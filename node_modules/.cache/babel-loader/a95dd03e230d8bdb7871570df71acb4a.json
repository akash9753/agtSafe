{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { TokenType, ScannerState } from '../htmlLanguageTypes.js';\nvar localize = nls.loadMessageBundle();\nvar MultiLineStream = /** @class */function () {\n  function MultiLineStream(source, position) {\n    this.source = source;\n    this.len = source.length;\n    this.position = position;\n  }\n  MultiLineStream.prototype.eos = function () {\n    return this.len <= this.position;\n  };\n  MultiLineStream.prototype.getSource = function () {\n    return this.source;\n  };\n  MultiLineStream.prototype.pos = function () {\n    return this.position;\n  };\n  MultiLineStream.prototype.goBackTo = function (pos) {\n    this.position = pos;\n  };\n  MultiLineStream.prototype.goBack = function (n) {\n    this.position -= n;\n  };\n  MultiLineStream.prototype.advance = function (n) {\n    this.position += n;\n  };\n  MultiLineStream.prototype.goToEnd = function () {\n    this.position = this.source.length;\n  };\n  MultiLineStream.prototype.nextChar = function () {\n    return this.source.charCodeAt(this.position++) || 0;\n  };\n  MultiLineStream.prototype.peekChar = function (n) {\n    if (n === void 0) {\n      n = 0;\n    }\n    return this.source.charCodeAt(this.position + n) || 0;\n  };\n  MultiLineStream.prototype.advanceIfChar = function (ch) {\n    if (ch === this.source.charCodeAt(this.position)) {\n      this.position++;\n      return true;\n    }\n    return false;\n  };\n  MultiLineStream.prototype.advanceIfChars = function (ch) {\n    var i;\n    if (this.position + ch.length > this.source.length) {\n      return false;\n    }\n    for (i = 0; i < ch.length; i++) {\n      if (this.source.charCodeAt(this.position + i) !== ch[i]) {\n        return false;\n      }\n    }\n    this.advance(i);\n    return true;\n  };\n  MultiLineStream.prototype.advanceIfRegExp = function (regex) {\n    var str = this.source.substr(this.position);\n    var match = str.match(regex);\n    if (match) {\n      this.position = this.position + match.index + match[0].length;\n      return match[0];\n    }\n    return '';\n  };\n  MultiLineStream.prototype.advanceUntilRegExp = function (regex) {\n    var str = this.source.substr(this.position);\n    var match = str.match(regex);\n    if (match) {\n      this.position = this.position + match.index;\n      return match[0];\n    } else {\n      this.goToEnd();\n    }\n    return '';\n  };\n  MultiLineStream.prototype.advanceUntilChar = function (ch) {\n    while (this.position < this.source.length) {\n      if (this.source.charCodeAt(this.position) === ch) {\n        return true;\n      }\n      this.advance(1);\n    }\n    return false;\n  };\n  MultiLineStream.prototype.advanceUntilChars = function (ch) {\n    while (this.position + ch.length <= this.source.length) {\n      var i = 0;\n      for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) {}\n      if (i === ch.length) {\n        return true;\n      }\n      this.advance(1);\n    }\n    this.goToEnd();\n    return false;\n  };\n  MultiLineStream.prototype.skipWhitespace = function () {\n    var n = this.advanceWhileChar(function (ch) {\n      return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;\n    });\n    return n > 0;\n  };\n  MultiLineStream.prototype.advanceWhileChar = function (condition) {\n    var posNow = this.position;\n    while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {\n      this.position++;\n    }\n    return this.position - posNow;\n  };\n  return MultiLineStream;\n}();\nvar _BNG = '!'.charCodeAt(0);\nvar _MIN = '-'.charCodeAt(0);\nvar _LAN = '<'.charCodeAt(0);\nvar _RAN = '>'.charCodeAt(0);\nvar _FSL = '/'.charCodeAt(0);\nvar _EQS = '='.charCodeAt(0);\nvar _DQO = '\"'.charCodeAt(0);\nvar _SQO = '\\''.charCodeAt(0);\nvar _NWL = '\\n'.charCodeAt(0);\nvar _CAR = '\\r'.charCodeAt(0);\nvar _LFD = '\\f'.charCodeAt(0);\nvar _WSP = ' '.charCodeAt(0);\nvar _TAB = '\\t'.charCodeAt(0);\nvar htmlScriptContents = {\n  'text/x-handlebars-template': true\n};\nexport function createScanner(input, initialOffset, initialState) {\n  if (initialOffset === void 0) {\n    initialOffset = 0;\n  }\n  if (initialState === void 0) {\n    initialState = ScannerState.WithinContent;\n  }\n  var stream = new MultiLineStream(input, initialOffset);\n  var state = initialState;\n  var tokenOffset = 0;\n  var tokenType = TokenType.Unknown;\n  var tokenError;\n  var hasSpaceAfterTag;\n  var lastTag;\n  var lastAttributeName;\n  var lastTypeValue;\n  function nextElementName() {\n    return stream.advanceIfRegExp(/^[_:\\w][_:\\w-.\\d]*/).toLowerCase();\n  }\n  function nextAttributeName() {\n    return stream.advanceIfRegExp(/^[^\\s\"'>/=\\x00-\\x0F\\x7F\\x80-\\x9F]*/).toLowerCase();\n  }\n  function finishToken(offset, type, errorMessage) {\n    tokenType = type;\n    tokenOffset = offset;\n    tokenError = errorMessage;\n    return type;\n  }\n  function scan() {\n    var offset = stream.pos();\n    var oldState = state;\n    var token = internalScan();\n    if (token !== TokenType.EOS && offset === stream.pos()) {\n      console.log('Scanner.scan has not advanced at offset ' + offset + ', state before: ' + oldState + ' after: ' + state);\n      stream.advance(1);\n      return finishToken(offset, TokenType.Unknown);\n    }\n    return token;\n  }\n  function internalScan() {\n    var offset = stream.pos();\n    if (stream.eos()) {\n      return finishToken(offset, TokenType.EOS);\n    }\n    var errorMessage;\n    switch (state) {\n      case ScannerState.WithinComment:\n        if (stream.advanceIfChars([_MIN, _MIN, _RAN])) {\n          // -->\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndCommentTag);\n        }\n        stream.advanceUntilChars([_MIN, _MIN, _RAN]); // -->\n        return finishToken(offset, TokenType.Comment);\n      case ScannerState.WithinDoctype:\n        if (stream.advanceIfChar(_RAN)) {\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndDoctypeTag);\n        }\n        stream.advanceUntilChar(_RAN); // >\n        return finishToken(offset, TokenType.Doctype);\n      case ScannerState.WithinContent:\n        if (stream.advanceIfChar(_LAN)) {\n          // <\n          if (!stream.eos() && stream.peekChar() === _BNG) {\n            // !\n            if (stream.advanceIfChars([_BNG, _MIN, _MIN])) {\n              // <!--\n              state = ScannerState.WithinComment;\n              return finishToken(offset, TokenType.StartCommentTag);\n            }\n            if (stream.advanceIfRegExp(/^!doctype/i)) {\n              state = ScannerState.WithinDoctype;\n              return finishToken(offset, TokenType.StartDoctypeTag);\n            }\n          }\n          if (stream.advanceIfChar(_FSL)) {\n            // /\n            state = ScannerState.AfterOpeningEndTag;\n            return finishToken(offset, TokenType.EndTagOpen);\n          }\n          state = ScannerState.AfterOpeningStartTag;\n          return finishToken(offset, TokenType.StartTagOpen);\n        }\n        stream.advanceUntilChar(_LAN);\n        return finishToken(offset, TokenType.Content);\n      case ScannerState.AfterOpeningEndTag:\n        var tagName = nextElementName();\n        if (tagName.length > 0) {\n          state = ScannerState.WithinEndTag;\n          return finishToken(offset, TokenType.EndTag);\n        }\n        if (stream.skipWhitespace()) {\n          // white space is not valid here\n          return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n        }\n        state = ScannerState.WithinEndTag;\n        stream.advanceUntilChar(_RAN);\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Unknown, localize('error.endTagNameExpected', 'End tag name expected.'));\n        }\n        return internalScan();\n      case ScannerState.WithinEndTag:\n        if (stream.skipWhitespace()) {\n          // white space is valid here\n          return finishToken(offset, TokenType.Whitespace);\n        }\n        if (stream.advanceIfChar(_RAN)) {\n          // >\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.EndTagClose);\n        }\n        errorMessage = localize('error.tagNameExpected', 'Closing bracket expected.');\n        break;\n      case ScannerState.AfterOpeningStartTag:\n        lastTag = nextElementName();\n        lastTypeValue = void 0;\n        lastAttributeName = void 0;\n        if (lastTag.length > 0) {\n          hasSpaceAfterTag = false;\n          state = ScannerState.WithinTag;\n          return finishToken(offset, TokenType.StartTag);\n        }\n        if (stream.skipWhitespace()) {\n          // white space is not valid here\n          return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n        }\n        state = ScannerState.WithinTag;\n        stream.advanceUntilChar(_RAN);\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Unknown, localize('error.startTagNameExpected', 'Start tag name expected.'));\n        }\n        return internalScan();\n      case ScannerState.WithinTag:\n        if (stream.skipWhitespace()) {\n          hasSpaceAfterTag = true; // remember that we have seen a whitespace\n          return finishToken(offset, TokenType.Whitespace);\n        }\n        if (hasSpaceAfterTag) {\n          lastAttributeName = nextAttributeName();\n          if (lastAttributeName.length > 0) {\n            state = ScannerState.AfterAttributeName;\n            hasSpaceAfterTag = false;\n            return finishToken(offset, TokenType.AttributeName);\n          }\n        }\n        if (stream.advanceIfChars([_FSL, _RAN])) {\n          // />\n          state = ScannerState.WithinContent;\n          return finishToken(offset, TokenType.StartTagSelfClose);\n        }\n        if (stream.advanceIfChar(_RAN)) {\n          // >\n          if (lastTag === 'script') {\n            if (lastTypeValue && htmlScriptContents[lastTypeValue]) {\n              // stay in html\n              state = ScannerState.WithinContent;\n            } else {\n              state = ScannerState.WithinScriptContent;\n            }\n          } else if (lastTag === 'style') {\n            state = ScannerState.WithinStyleContent;\n          } else {\n            state = ScannerState.WithinContent;\n          }\n          return finishToken(offset, TokenType.StartTagClose);\n        }\n        stream.advance(1);\n        return finishToken(offset, TokenType.Unknown, localize('error.unexpectedCharacterInTag', 'Unexpected character in tag.'));\n      case ScannerState.AfterAttributeName:\n        if (stream.skipWhitespace()) {\n          hasSpaceAfterTag = true;\n          return finishToken(offset, TokenType.Whitespace);\n        }\n        if (stream.advanceIfChar(_EQS)) {\n          state = ScannerState.BeforeAttributeValue;\n          return finishToken(offset, TokenType.DelimiterAssign);\n        }\n        state = ScannerState.WithinTag;\n        return internalScan();\n      // no advance yet - jump to WithinTag\n      case ScannerState.BeforeAttributeValue:\n        if (stream.skipWhitespace()) {\n          return finishToken(offset, TokenType.Whitespace);\n        }\n        var attributeValue = stream.advanceIfRegExp(/^[^\\s\"'`=<>]+/);\n        if (attributeValue.length > 0) {\n          if (stream.peekChar() === _RAN && stream.peekChar(-1) === _FSL) {\n            // <foo bar=http://foo/>\n            stream.goBack(1);\n            attributeValue = attributeValue.substr(0, attributeValue.length - 1);\n          }\n          if (lastAttributeName === 'type') {\n            lastTypeValue = attributeValue;\n          }\n          state = ScannerState.WithinTag;\n          hasSpaceAfterTag = false;\n          return finishToken(offset, TokenType.AttributeValue);\n        }\n        var ch = stream.peekChar();\n        if (ch === _SQO || ch === _DQO) {\n          stream.advance(1); // consume quote\n          if (stream.advanceUntilChar(ch)) {\n            stream.advance(1); // consume quote\n          }\n\n          if (lastAttributeName === 'type') {\n            lastTypeValue = stream.getSource().substring(offset + 1, stream.pos() - 1);\n          }\n          state = ScannerState.WithinTag;\n          hasSpaceAfterTag = false;\n          return finishToken(offset, TokenType.AttributeValue);\n        }\n        state = ScannerState.WithinTag;\n        hasSpaceAfterTag = false;\n        return internalScan();\n      // no advance yet - jump to WithinTag\n      case ScannerState.WithinScriptContent:\n        // see http://stackoverflow.com/questions/14574471/how-do-browsers-parse-a-script-tag-exactly\n        var sciptState = 1;\n        while (!stream.eos()) {\n          var match = stream.advanceIfRegExp(/<!--|-->|<\\/?script\\s*\\/?>?/i);\n          if (match.length === 0) {\n            stream.goToEnd();\n            return finishToken(offset, TokenType.Script);\n          } else if (match === '<!--') {\n            if (sciptState === 1) {\n              sciptState = 2;\n            }\n          } else if (match === '-->') {\n            sciptState = 1;\n          } else if (match[1] !== '/') {\n            // <script\n            if (sciptState === 2) {\n              sciptState = 3;\n            }\n          } else {\n            // </script\n            if (sciptState === 3) {\n              sciptState = 2;\n            } else {\n              stream.goBack(match.length); // to the beginning of the closing tag\n              break;\n            }\n          }\n        }\n        state = ScannerState.WithinContent;\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Script);\n        }\n        return internalScan();\n      // no advance yet - jump to content\n      case ScannerState.WithinStyleContent:\n        stream.advanceUntilRegExp(/<\\/style/i);\n        state = ScannerState.WithinContent;\n        if (offset < stream.pos()) {\n          return finishToken(offset, TokenType.Styles);\n        }\n        return internalScan();\n      // no advance yet - jump to content\n    }\n\n    stream.advance(1);\n    state = ScannerState.WithinContent;\n    return finishToken(offset, TokenType.Unknown, errorMessage);\n  }\n  return {\n    scan: scan,\n    getTokenType: function getTokenType() {\n      return tokenType;\n    },\n    getTokenOffset: function getTokenOffset() {\n      return tokenOffset;\n    },\n    getTokenLength: function getTokenLength() {\n      return stream.pos() - tokenOffset;\n    },\n    getTokenEnd: function getTokenEnd() {\n      return stream.pos();\n    },\n    getTokenText: function getTokenText() {\n      return stream.getSource().substring(tokenOffset, stream.pos());\n    },\n    getScannerState: function getScannerState() {\n      return state;\n    },\n    getTokenError: function getTokenError() {\n      return tokenError;\n    }\n  };\n}","map":{"version":3,"names":["nls","TokenType","ScannerState","localize","loadMessageBundle","MultiLineStream","source","position","len","length","prototype","eos","getSource","pos","goBackTo","goBack","n","advance","goToEnd","nextChar","charCodeAt","peekChar","advanceIfChar","ch","advanceIfChars","i","advanceIfRegExp","regex","str","substr","match","index","advanceUntilRegExp","advanceUntilChar","advanceUntilChars","skipWhitespace","advanceWhileChar","_WSP","_TAB","_NWL","_LFD","_CAR","condition","posNow","_BNG","_MIN","_LAN","_RAN","_FSL","_EQS","_DQO","_SQO","htmlScriptContents","createScanner","input","initialOffset","initialState","WithinContent","stream","state","tokenOffset","tokenType","Unknown","tokenError","hasSpaceAfterTag","lastTag","lastAttributeName","lastTypeValue","nextElementName","toLowerCase","nextAttributeName","finishToken","offset","type","errorMessage","scan","oldState","token","internalScan","EOS","console","log","WithinComment","EndCommentTag","Comment","WithinDoctype","EndDoctypeTag","Doctype","StartCommentTag","StartDoctypeTag","AfterOpeningEndTag","EndTagOpen","AfterOpeningStartTag","StartTagOpen","Content","tagName","WithinEndTag","EndTag","Whitespace","EndTagClose","WithinTag","StartTag","AfterAttributeName","AttributeName","StartTagSelfClose","WithinScriptContent","WithinStyleContent","StartTagClose","BeforeAttributeValue","DelimiterAssign","attributeValue","AttributeValue","substring","sciptState","Script","Styles","getTokenType","getTokenOffset","getTokenLength","getTokenEnd","getTokenText","getScannerState","getTokenError"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/parser/htmlScanner.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { TokenType, ScannerState } from '../htmlLanguageTypes.js';\nvar localize = nls.loadMessageBundle();\nvar MultiLineStream = /** @class */ (function () {\n    function MultiLineStream(source, position) {\n        this.source = source;\n        this.len = source.length;\n        this.position = position;\n    }\n    MultiLineStream.prototype.eos = function () {\n        return this.len <= this.position;\n    };\n    MultiLineStream.prototype.getSource = function () {\n        return this.source;\n    };\n    MultiLineStream.prototype.pos = function () {\n        return this.position;\n    };\n    MultiLineStream.prototype.goBackTo = function (pos) {\n        this.position = pos;\n    };\n    MultiLineStream.prototype.goBack = function (n) {\n        this.position -= n;\n    };\n    MultiLineStream.prototype.advance = function (n) {\n        this.position += n;\n    };\n    MultiLineStream.prototype.goToEnd = function () {\n        this.position = this.source.length;\n    };\n    MultiLineStream.prototype.nextChar = function () {\n        return this.source.charCodeAt(this.position++) || 0;\n    };\n    MultiLineStream.prototype.peekChar = function (n) {\n        if (n === void 0) { n = 0; }\n        return this.source.charCodeAt(this.position + n) || 0;\n    };\n    MultiLineStream.prototype.advanceIfChar = function (ch) {\n        if (ch === this.source.charCodeAt(this.position)) {\n            this.position++;\n            return true;\n        }\n        return false;\n    };\n    MultiLineStream.prototype.advanceIfChars = function (ch) {\n        var i;\n        if (this.position + ch.length > this.source.length) {\n            return false;\n        }\n        for (i = 0; i < ch.length; i++) {\n            if (this.source.charCodeAt(this.position + i) !== ch[i]) {\n                return false;\n            }\n        }\n        this.advance(i);\n        return true;\n    };\n    MultiLineStream.prototype.advanceIfRegExp = function (regex) {\n        var str = this.source.substr(this.position);\n        var match = str.match(regex);\n        if (match) {\n            this.position = this.position + match.index + match[0].length;\n            return match[0];\n        }\n        return '';\n    };\n    MultiLineStream.prototype.advanceUntilRegExp = function (regex) {\n        var str = this.source.substr(this.position);\n        var match = str.match(regex);\n        if (match) {\n            this.position = this.position + match.index;\n            return match[0];\n        }\n        else {\n            this.goToEnd();\n        }\n        return '';\n    };\n    MultiLineStream.prototype.advanceUntilChar = function (ch) {\n        while (this.position < this.source.length) {\n            if (this.source.charCodeAt(this.position) === ch) {\n                return true;\n            }\n            this.advance(1);\n        }\n        return false;\n    };\n    MultiLineStream.prototype.advanceUntilChars = function (ch) {\n        while (this.position + ch.length <= this.source.length) {\n            var i = 0;\n            for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) {\n            }\n            if (i === ch.length) {\n                return true;\n            }\n            this.advance(1);\n        }\n        this.goToEnd();\n        return false;\n    };\n    MultiLineStream.prototype.skipWhitespace = function () {\n        var n = this.advanceWhileChar(function (ch) {\n            return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;\n        });\n        return n > 0;\n    };\n    MultiLineStream.prototype.advanceWhileChar = function (condition) {\n        var posNow = this.position;\n        while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {\n            this.position++;\n        }\n        return this.position - posNow;\n    };\n    return MultiLineStream;\n}());\nvar _BNG = '!'.charCodeAt(0);\nvar _MIN = '-'.charCodeAt(0);\nvar _LAN = '<'.charCodeAt(0);\nvar _RAN = '>'.charCodeAt(0);\nvar _FSL = '/'.charCodeAt(0);\nvar _EQS = '='.charCodeAt(0);\nvar _DQO = '\"'.charCodeAt(0);\nvar _SQO = '\\''.charCodeAt(0);\nvar _NWL = '\\n'.charCodeAt(0);\nvar _CAR = '\\r'.charCodeAt(0);\nvar _LFD = '\\f'.charCodeAt(0);\nvar _WSP = ' '.charCodeAt(0);\nvar _TAB = '\\t'.charCodeAt(0);\nvar htmlScriptContents = {\n    'text/x-handlebars-template': true\n};\nexport function createScanner(input, initialOffset, initialState) {\n    if (initialOffset === void 0) { initialOffset = 0; }\n    if (initialState === void 0) { initialState = ScannerState.WithinContent; }\n    var stream = new MultiLineStream(input, initialOffset);\n    var state = initialState;\n    var tokenOffset = 0;\n    var tokenType = TokenType.Unknown;\n    var tokenError;\n    var hasSpaceAfterTag;\n    var lastTag;\n    var lastAttributeName;\n    var lastTypeValue;\n    function nextElementName() {\n        return stream.advanceIfRegExp(/^[_:\\w][_:\\w-.\\d]*/).toLowerCase();\n    }\n    function nextAttributeName() {\n        return stream.advanceIfRegExp(/^[^\\s\"'>/=\\x00-\\x0F\\x7F\\x80-\\x9F]*/).toLowerCase();\n    }\n    function finishToken(offset, type, errorMessage) {\n        tokenType = type;\n        tokenOffset = offset;\n        tokenError = errorMessage;\n        return type;\n    }\n    function scan() {\n        var offset = stream.pos();\n        var oldState = state;\n        var token = internalScan();\n        if (token !== TokenType.EOS && offset === stream.pos()) {\n            console.log('Scanner.scan has not advanced at offset ' + offset + ', state before: ' + oldState + ' after: ' + state);\n            stream.advance(1);\n            return finishToken(offset, TokenType.Unknown);\n        }\n        return token;\n    }\n    function internalScan() {\n        var offset = stream.pos();\n        if (stream.eos()) {\n            return finishToken(offset, TokenType.EOS);\n        }\n        var errorMessage;\n        switch (state) {\n            case ScannerState.WithinComment:\n                if (stream.advanceIfChars([_MIN, _MIN, _RAN])) { // -->\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.EndCommentTag);\n                }\n                stream.advanceUntilChars([_MIN, _MIN, _RAN]); // -->\n                return finishToken(offset, TokenType.Comment);\n            case ScannerState.WithinDoctype:\n                if (stream.advanceIfChar(_RAN)) {\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.EndDoctypeTag);\n                }\n                stream.advanceUntilChar(_RAN); // >\n                return finishToken(offset, TokenType.Doctype);\n            case ScannerState.WithinContent:\n                if (stream.advanceIfChar(_LAN)) { // <\n                    if (!stream.eos() && stream.peekChar() === _BNG) { // !\n                        if (stream.advanceIfChars([_BNG, _MIN, _MIN])) { // <!--\n                            state = ScannerState.WithinComment;\n                            return finishToken(offset, TokenType.StartCommentTag);\n                        }\n                        if (stream.advanceIfRegExp(/^!doctype/i)) {\n                            state = ScannerState.WithinDoctype;\n                            return finishToken(offset, TokenType.StartDoctypeTag);\n                        }\n                    }\n                    if (stream.advanceIfChar(_FSL)) { // /\n                        state = ScannerState.AfterOpeningEndTag;\n                        return finishToken(offset, TokenType.EndTagOpen);\n                    }\n                    state = ScannerState.AfterOpeningStartTag;\n                    return finishToken(offset, TokenType.StartTagOpen);\n                }\n                stream.advanceUntilChar(_LAN);\n                return finishToken(offset, TokenType.Content);\n            case ScannerState.AfterOpeningEndTag:\n                var tagName = nextElementName();\n                if (tagName.length > 0) {\n                    state = ScannerState.WithinEndTag;\n                    return finishToken(offset, TokenType.EndTag);\n                }\n                if (stream.skipWhitespace()) { // white space is not valid here\n                    return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n                }\n                state = ScannerState.WithinEndTag;\n                stream.advanceUntilChar(_RAN);\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Unknown, localize('error.endTagNameExpected', 'End tag name expected.'));\n                }\n                return internalScan();\n            case ScannerState.WithinEndTag:\n                if (stream.skipWhitespace()) { // white space is valid here\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                if (stream.advanceIfChar(_RAN)) { // >\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.EndTagClose);\n                }\n                errorMessage = localize('error.tagNameExpected', 'Closing bracket expected.');\n                break;\n            case ScannerState.AfterOpeningStartTag:\n                lastTag = nextElementName();\n                lastTypeValue = void 0;\n                lastAttributeName = void 0;\n                if (lastTag.length > 0) {\n                    hasSpaceAfterTag = false;\n                    state = ScannerState.WithinTag;\n                    return finishToken(offset, TokenType.StartTag);\n                }\n                if (stream.skipWhitespace()) { // white space is not valid here\n                    return finishToken(offset, TokenType.Whitespace, localize('error.unexpectedWhitespace', 'Tag name must directly follow the open bracket.'));\n                }\n                state = ScannerState.WithinTag;\n                stream.advanceUntilChar(_RAN);\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Unknown, localize('error.startTagNameExpected', 'Start tag name expected.'));\n                }\n                return internalScan();\n            case ScannerState.WithinTag:\n                if (stream.skipWhitespace()) {\n                    hasSpaceAfterTag = true; // remember that we have seen a whitespace\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                if (hasSpaceAfterTag) {\n                    lastAttributeName = nextAttributeName();\n                    if (lastAttributeName.length > 0) {\n                        state = ScannerState.AfterAttributeName;\n                        hasSpaceAfterTag = false;\n                        return finishToken(offset, TokenType.AttributeName);\n                    }\n                }\n                if (stream.advanceIfChars([_FSL, _RAN])) { // />\n                    state = ScannerState.WithinContent;\n                    return finishToken(offset, TokenType.StartTagSelfClose);\n                }\n                if (stream.advanceIfChar(_RAN)) { // >\n                    if (lastTag === 'script') {\n                        if (lastTypeValue && htmlScriptContents[lastTypeValue]) {\n                            // stay in html\n                            state = ScannerState.WithinContent;\n                        }\n                        else {\n                            state = ScannerState.WithinScriptContent;\n                        }\n                    }\n                    else if (lastTag === 'style') {\n                        state = ScannerState.WithinStyleContent;\n                    }\n                    else {\n                        state = ScannerState.WithinContent;\n                    }\n                    return finishToken(offset, TokenType.StartTagClose);\n                }\n                stream.advance(1);\n                return finishToken(offset, TokenType.Unknown, localize('error.unexpectedCharacterInTag', 'Unexpected character in tag.'));\n            case ScannerState.AfterAttributeName:\n                if (stream.skipWhitespace()) {\n                    hasSpaceAfterTag = true;\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                if (stream.advanceIfChar(_EQS)) {\n                    state = ScannerState.BeforeAttributeValue;\n                    return finishToken(offset, TokenType.DelimiterAssign);\n                }\n                state = ScannerState.WithinTag;\n                return internalScan(); // no advance yet - jump to WithinTag\n            case ScannerState.BeforeAttributeValue:\n                if (stream.skipWhitespace()) {\n                    return finishToken(offset, TokenType.Whitespace);\n                }\n                var attributeValue = stream.advanceIfRegExp(/^[^\\s\"'`=<>]+/);\n                if (attributeValue.length > 0) {\n                    if (stream.peekChar() === _RAN && stream.peekChar(-1) === _FSL) { // <foo bar=http://foo/>\n                        stream.goBack(1);\n                        attributeValue = attributeValue.substr(0, attributeValue.length - 1);\n                    }\n                    if (lastAttributeName === 'type') {\n                        lastTypeValue = attributeValue;\n                    }\n                    state = ScannerState.WithinTag;\n                    hasSpaceAfterTag = false;\n                    return finishToken(offset, TokenType.AttributeValue);\n                }\n                var ch = stream.peekChar();\n                if (ch === _SQO || ch === _DQO) {\n                    stream.advance(1); // consume quote\n                    if (stream.advanceUntilChar(ch)) {\n                        stream.advance(1); // consume quote\n                    }\n                    if (lastAttributeName === 'type') {\n                        lastTypeValue = stream.getSource().substring(offset + 1, stream.pos() - 1);\n                    }\n                    state = ScannerState.WithinTag;\n                    hasSpaceAfterTag = false;\n                    return finishToken(offset, TokenType.AttributeValue);\n                }\n                state = ScannerState.WithinTag;\n                hasSpaceAfterTag = false;\n                return internalScan(); // no advance yet - jump to WithinTag\n            case ScannerState.WithinScriptContent:\n                // see http://stackoverflow.com/questions/14574471/how-do-browsers-parse-a-script-tag-exactly\n                var sciptState = 1;\n                while (!stream.eos()) {\n                    var match = stream.advanceIfRegExp(/<!--|-->|<\\/?script\\s*\\/?>?/i);\n                    if (match.length === 0) {\n                        stream.goToEnd();\n                        return finishToken(offset, TokenType.Script);\n                    }\n                    else if (match === '<!--') {\n                        if (sciptState === 1) {\n                            sciptState = 2;\n                        }\n                    }\n                    else if (match === '-->') {\n                        sciptState = 1;\n                    }\n                    else if (match[1] !== '/') { // <script\n                        if (sciptState === 2) {\n                            sciptState = 3;\n                        }\n                    }\n                    else { // </script\n                        if (sciptState === 3) {\n                            sciptState = 2;\n                        }\n                        else {\n                            stream.goBack(match.length); // to the beginning of the closing tag\n                            break;\n                        }\n                    }\n                }\n                state = ScannerState.WithinContent;\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Script);\n                }\n                return internalScan(); // no advance yet - jump to content\n            case ScannerState.WithinStyleContent:\n                stream.advanceUntilRegExp(/<\\/style/i);\n                state = ScannerState.WithinContent;\n                if (offset < stream.pos()) {\n                    return finishToken(offset, TokenType.Styles);\n                }\n                return internalScan(); // no advance yet - jump to content\n        }\n        stream.advance(1);\n        state = ScannerState.WithinContent;\n        return finishToken(offset, TokenType.Unknown, errorMessage);\n    }\n    return {\n        scan: scan,\n        getTokenType: function () { return tokenType; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return stream.pos() - tokenOffset; },\n        getTokenEnd: function () { return stream.pos(); },\n        getTokenText: function () { return stream.getSource().substring(tokenOffset, stream.pos()); },\n        getScannerState: function () { return state; },\n        getTokenError: function () { return tokenError; }\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}