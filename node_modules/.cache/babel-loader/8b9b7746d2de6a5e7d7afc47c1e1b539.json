{"ast":null,"code":"// Fine Uploader 5.16.2 - MIT licensed. http://fineuploader.com\n(function (global) {\n  var qq = function qq(element) {\n    \"use strict\";\n\n    return {\n      hide: function hide() {\n        element.style.display = \"none\";\n        return this;\n      },\n      attach: function attach(type, fn) {\n        if (element.addEventListener) {\n          element.addEventListener(type, fn, false);\n        } else if (element.attachEvent) {\n          element.attachEvent(\"on\" + type, fn);\n        }\n        return function () {\n          qq(element).detach(type, fn);\n        };\n      },\n      detach: function detach(type, fn) {\n        if (element.removeEventListener) {\n          element.removeEventListener(type, fn, false);\n        } else if (element.attachEvent) {\n          element.detachEvent(\"on\" + type, fn);\n        }\n        return this;\n      },\n      contains: function contains(descendant) {\n        if (!descendant) {\n          return false;\n        }\n        if (element === descendant) {\n          return true;\n        }\n        if (element.contains) {\n          return element.contains(descendant);\n        } else {\n          return !!(descendant.compareDocumentPosition(element) & 8);\n        }\n      },\n      insertBefore: function insertBefore(elementB) {\n        elementB.parentNode.insertBefore(element, elementB);\n        return this;\n      },\n      remove: function remove() {\n        element.parentNode.removeChild(element);\n        return this;\n      },\n      css: function css(styles) {\n        if (element.style == null) {\n          throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n        }\n        if (styles.opacity != null) {\n          if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n            styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n          }\n        }\n        qq.extend(element.style, styles);\n        return this;\n      },\n      hasClass: function hasClass(name, considerParent) {\n        var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n        return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n      },\n      addClass: function addClass(name) {\n        if (!qq(element).hasClass(name)) {\n          element.className += \" \" + name;\n        }\n        return this;\n      },\n      removeClass: function removeClass(name) {\n        var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n        element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n        return this;\n      },\n      getByClass: function getByClass(className, first) {\n        var candidates,\n          result = [];\n        if (first && element.querySelector) {\n          return element.querySelector(\".\" + className);\n        } else if (element.querySelectorAll) {\n          return element.querySelectorAll(\".\" + className);\n        }\n        candidates = element.getElementsByTagName(\"*\");\n        qq.each(candidates, function (idx, val) {\n          if (qq(val).hasClass(className)) {\n            result.push(val);\n          }\n        });\n        return first ? result[0] : result;\n      },\n      getFirstByClass: function getFirstByClass(className) {\n        return qq(element).getByClass(className, true);\n      },\n      children: function children() {\n        var children = [],\n          child = element.firstChild;\n        while (child) {\n          if (child.nodeType === 1) {\n            children.push(child);\n          }\n          child = child.nextSibling;\n        }\n        return children;\n      },\n      setText: function setText(text) {\n        element.innerText = text;\n        element.textContent = text;\n        return this;\n      },\n      clearText: function clearText() {\n        return qq(element).setText(\"\");\n      },\n      hasAttribute: function hasAttribute(attrName) {\n        var attrVal;\n        if (element.hasAttribute) {\n          if (!element.hasAttribute(attrName)) {\n            return false;\n          }\n          return /^false$/i.exec(element.getAttribute(attrName)) == null;\n        } else {\n          attrVal = element[attrName];\n          if (attrVal === undefined) {\n            return false;\n          }\n          return /^false$/i.exec(attrVal) == null;\n        }\n      }\n    };\n  };\n  (function () {\n    \"use strict\";\n\n    qq.canvasToBlob = function (canvas, mime, quality) {\n      return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n    };\n    qq.dataUriToBlob = function (dataUri) {\n      var arrayBuffer,\n        byteString,\n        createBlob = function createBlob(data, mime) {\n          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,\n            blobBuilder = BlobBuilder && new BlobBuilder();\n          if (blobBuilder) {\n            blobBuilder.append(data);\n            return blobBuilder.getBlob(mime);\n          } else {\n            return new Blob([data], {\n              type: mime\n            });\n          }\n        },\n        intArray,\n        mimeString;\n      if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n        byteString = atob(dataUri.split(\",\")[1]);\n      } else {\n        byteString = decodeURI(dataUri.split(\",\")[1]);\n      }\n      mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n      arrayBuffer = new ArrayBuffer(byteString.length);\n      intArray = new Uint8Array(arrayBuffer);\n      qq.each(byteString, function (idx, character) {\n        intArray[idx] = character.charCodeAt(0);\n      });\n      return createBlob(arrayBuffer, mimeString);\n    };\n    qq.log = function (message, level) {\n      if (window.console) {\n        if (!level || level === \"info\") {\n          window.console.log(message);\n        } else {\n          if (window.console[level]) {\n            window.console[level](message);\n          } else {\n            window.console.log(\"<\" + level + \"> \" + message);\n          }\n        }\n      }\n    };\n    qq.isObject = function (variable) {\n      return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n    };\n    qq.isFunction = function (variable) {\n      return typeof variable === \"function\";\n    };\n    qq.isArray = function (value) {\n      return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n    };\n    qq.isItemList = function (maybeItemList) {\n      return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n    };\n    qq.isNodeList = function (maybeNodeList) {\n      return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n    };\n    qq.isString = function (maybeString) {\n      return Object.prototype.toString.call(maybeString) === \"[object String]\";\n    };\n    qq.trimStr = function (string) {\n      if (String.prototype.trim) {\n        return string.trim();\n      }\n      return string.replace(/^\\s+|\\s+$/g, \"\");\n    };\n    qq.format = function (str) {\n      var args = Array.prototype.slice.call(arguments, 1),\n        newStr = str,\n        nextIdxToReplace = newStr.indexOf(\"{}\");\n      qq.each(args, function (idx, val) {\n        var strBefore = newStr.substring(0, nextIdxToReplace),\n          strAfter = newStr.substring(nextIdxToReplace + 2);\n        newStr = strBefore + val + strAfter;\n        nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n        if (nextIdxToReplace < 0) {\n          return false;\n        }\n      });\n      return newStr;\n    };\n    qq.isFile = function (maybeFile) {\n      return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n    };\n    qq.isFileList = function (maybeFileList) {\n      return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n    };\n    qq.isFileOrInput = function (maybeFileOrInput) {\n      return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n    };\n    qq.isInput = function (maybeInput, notFile) {\n      var evaluateType = function evaluateType(type) {\n        var normalizedType = type.toLowerCase();\n        if (notFile) {\n          return normalizedType !== \"file\";\n        }\n        return normalizedType === \"file\";\n      };\n      if (window.HTMLInputElement) {\n        if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n          if (maybeInput.type && evaluateType(maybeInput.type)) {\n            return true;\n          }\n        }\n      }\n      if (maybeInput.tagName) {\n        if (maybeInput.tagName.toLowerCase() === \"input\") {\n          if (maybeInput.type && evaluateType(maybeInput.type)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    qq.isBlob = function (maybeBlob) {\n      if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n        return true;\n      }\n    };\n    qq.isXhrUploadSupported = function () {\n      var input = document.createElement(\"input\");\n      input.type = \"file\";\n      return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n    };\n    qq.createXhrInstance = function () {\n      if (window.XMLHttpRequest) {\n        return new XMLHttpRequest();\n      }\n      try {\n        return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n      } catch (error) {\n        qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n        return null;\n      }\n    };\n    qq.isFolderDropSupported = function (dataTransfer) {\n      return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n    };\n    qq.isFileChunkingSupported = function () {\n      return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n    };\n    qq.sliceBlob = function (fileOrBlob, start, end) {\n      var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n      return slicer.call(fileOrBlob, start, end);\n    };\n    qq.arrayBufferToHex = function (buffer) {\n      var bytesAsHex = \"\",\n        bytes = new Uint8Array(buffer);\n      qq.each(bytes, function (idx, byt) {\n        var byteAsHexStr = byt.toString(16);\n        if (byteAsHexStr.length < 2) {\n          byteAsHexStr = \"0\" + byteAsHexStr;\n        }\n        bytesAsHex += byteAsHexStr;\n      });\n      return bytesAsHex;\n    };\n    qq.readBlobToHex = function (blob, startOffset, length) {\n      var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length),\n        fileReader = new FileReader(),\n        promise = new qq.Promise();\n      fileReader.onload = function () {\n        promise.success(qq.arrayBufferToHex(fileReader.result));\n      };\n      fileReader.onerror = promise.failure;\n      fileReader.readAsArrayBuffer(initialBlob);\n      return promise;\n    };\n    qq.extend = function (first, second, extendNested) {\n      qq.each(second, function (prop, val) {\n        if (extendNested && qq.isObject(val)) {\n          if (first[prop] === undefined) {\n            first[prop] = {};\n          }\n          qq.extend(first[prop], val, true);\n        } else {\n          first[prop] = val;\n        }\n      });\n      return first;\n    };\n    qq.override = function (target, sourceFn) {\n      var super_ = {},\n        source = sourceFn(super_);\n      qq.each(source, function (srcPropName, srcPropVal) {\n        if (target[srcPropName] !== undefined) {\n          super_[srcPropName] = target[srcPropName];\n        }\n        target[srcPropName] = srcPropVal;\n      });\n      return target;\n    };\n    qq.indexOf = function (arr, elt, from) {\n      if (arr.indexOf) {\n        return arr.indexOf(elt, from);\n      }\n      from = from || 0;\n      var len = arr.length;\n      if (from < 0) {\n        from += len;\n      }\n      for (; from < len; from += 1) {\n        if (arr.hasOwnProperty(from) && arr[from] === elt) {\n          return from;\n        }\n      }\n      return -1;\n    };\n    qq.getUniqueId = function () {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n          v = c == \"x\" ? r : r & 3 | 8;\n        return v.toString(16);\n      });\n    };\n    qq.ie = function () {\n      return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n    };\n    qq.ie7 = function () {\n      return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n    };\n    qq.ie8 = function () {\n      return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n    };\n    qq.ie10 = function () {\n      return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n    };\n    qq.ie11 = function () {\n      return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n    };\n    qq.edge = function () {\n      return navigator.userAgent.indexOf(\"Edge\") >= 0;\n    };\n    qq.safari = function () {\n      return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n    };\n    qq.chrome = function () {\n      return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n    };\n    qq.opera = function () {\n      return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n    };\n    qq.firefox = function () {\n      return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n    };\n    qq.windows = function () {\n      return navigator.platform === \"Win32\";\n    };\n    qq.android = function () {\n      return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n    };\n    qq.androidStock = function () {\n      return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n    };\n    qq.ios6 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n    };\n    qq.ios7 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n    };\n    qq.ios8 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n    };\n    qq.ios800 = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n    };\n    qq.ios = function () {\n      return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n    };\n    qq.iosChrome = function () {\n      return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n    };\n    qq.iosSafari = function () {\n      return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n    };\n    qq.iosSafariWebView = function () {\n      return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n    };\n    qq.preventDefault = function (e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    };\n    qq.toElement = function () {\n      var div = document.createElement(\"div\");\n      return function (html) {\n        div.innerHTML = html;\n        var element = div.firstChild;\n        div.removeChild(element);\n        return element;\n      };\n    }();\n    qq.each = function (iterableItem, callback) {\n      var keyOrIndex, retVal;\n      if (iterableItem) {\n        if (window.Storage && iterableItem.constructor === window.Storage) {\n          for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n            retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n            if (retVal === false) {\n              break;\n            }\n          }\n        } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n          for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n            if (retVal === false) {\n              break;\n            }\n          }\n        } else if (qq.isString(iterableItem)) {\n          for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n            retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n            if (retVal === false) {\n              break;\n            }\n          }\n        } else {\n          for (keyOrIndex in iterableItem) {\n            if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n              retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n              if (retVal === false) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    };\n    qq.bind = function (oldFunc, context) {\n      if (qq.isFunction(oldFunc)) {\n        var args = Array.prototype.slice.call(arguments, 2);\n        return function () {\n          var newArgs = qq.extend([], args);\n          if (arguments.length) {\n            newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n          }\n          return oldFunc.apply(context, newArgs);\n        };\n      }\n      throw new Error(\"first parameter must be a function!\");\n    };\n    qq.obj2url = function (obj, temp, prefixDone) {\n      var uristrings = [],\n        prefix = \"&\",\n        add = function add(nextObj, i) {\n          var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n          if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n            uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n          }\n        };\n      if (!prefixDone && temp) {\n        prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n        uristrings.push(temp);\n        uristrings.push(qq.obj2url(obj));\n      } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n        qq.each(obj, function (idx, val) {\n          add(val, idx);\n        });\n      } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n        qq.each(obj, function (prop, val) {\n          add(val, prop);\n        });\n      } else {\n        uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n      }\n      if (temp) {\n        return uristrings.join(prefix);\n      } else {\n        return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n      }\n    };\n    qq.obj2FormData = function (obj, formData, arrayKeyName) {\n      if (!formData) {\n        formData = new FormData();\n      }\n      qq.each(obj, function (key, val) {\n        key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n        if (qq.isObject(val)) {\n          qq.obj2FormData(val, formData, key);\n        } else if (qq.isFunction(val)) {\n          formData.append(key, val());\n        } else {\n          formData.append(key, val);\n        }\n      });\n      return formData;\n    };\n    qq.obj2Inputs = function (obj, form) {\n      var input;\n      if (!form) {\n        form = document.createElement(\"form\");\n      }\n      qq.obj2FormData(obj, {\n        append: function append(key, val) {\n          input = document.createElement(\"input\");\n          input.setAttribute(\"name\", key);\n          input.setAttribute(\"value\", val);\n          form.appendChild(input);\n        }\n      });\n      return form;\n    };\n    qq.parseJson = function (json) {\n      if (window.JSON && qq.isFunction(JSON.parse)) {\n        return JSON.parse(json);\n      } else {\n        return eval(\"(\" + json + \")\");\n      }\n    };\n    qq.getExtension = function (filename) {\n      var extIdx = filename.lastIndexOf(\".\") + 1;\n      if (extIdx > 0) {\n        return filename.substr(extIdx, filename.length - extIdx);\n      }\n    };\n    qq.getFilename = function (blobOrFileInput) {\n      if (qq.isInput(blobOrFileInput)) {\n        return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n      } else if (qq.isFile(blobOrFileInput)) {\n        if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n          return blobOrFileInput.fileName;\n        }\n      }\n      return blobOrFileInput.name;\n    };\n    qq.DisposeSupport = function () {\n      var disposers = [];\n      return {\n        dispose: function dispose() {\n          var disposer;\n          do {\n            disposer = disposers.shift();\n            if (disposer) {\n              disposer();\n            }\n          } while (disposer);\n        },\n        attach: function attach() {\n          var args = arguments;\n          this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n        },\n        addDisposer: function addDisposer(disposeFunction) {\n          disposers.push(disposeFunction);\n        }\n      };\n    };\n  })();\n  (function () {\n    \"use strict\";\n\n    if (typeof define === \"function\" && define.amd) {\n      define(function () {\n        return qq;\n      });\n    } else if (typeof module !== \"undefined\" && module.exports) {\n      module.exports = qq;\n    } else {\n      global.qq = qq;\n    }\n  })();\n  (function () {\n    \"use strict\";\n\n    qq.Error = function (message) {\n      this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n    };\n    qq.Error.prototype = new Error();\n  })();\n  qq.version = \"5.16.2\";\n  qq.supportedFeatures = function () {\n    \"use strict\";\n\n    var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n    function testSupportsFileInputElement() {\n      var supported = true,\n        tempInput;\n      try {\n        tempInput = document.createElement(\"input\");\n        tempInput.type = \"file\";\n        qq(tempInput).hide();\n        if (tempInput.disabled) {\n          supported = false;\n        }\n      } catch (ex) {\n        supported = false;\n      }\n      return supported;\n    }\n    function isChrome14OrHigher() {\n      return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n    }\n    function isCrossOriginXhrSupported() {\n      if (window.XMLHttpRequest) {\n        var xhr = qq.createXhrInstance();\n        return xhr.withCredentials !== undefined;\n      }\n      return false;\n    }\n    function isXdrSupported() {\n      return window.XDomainRequest !== undefined;\n    }\n    function isCrossOriginAjaxSupported() {\n      if (isCrossOriginXhrSupported()) {\n        return true;\n      }\n      return isXdrSupported();\n    }\n    function isFolderSelectionSupported() {\n      return document.createElement(\"input\").webkitdirectory !== undefined;\n    }\n    function isLocalStorageSupported() {\n      try {\n        return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n      } catch (error) {\n        return false;\n      }\n    }\n    function isDragAndDropSupported() {\n      var span = document.createElement(\"span\");\n      return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n    }\n    supportsUploading = testSupportsFileInputElement();\n    supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n    supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n    supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n    supportsFolderDrop = supportsFileDrop && function () {\n      var input = document.createElement(\"input\");\n      input.type = \"file\";\n      return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n    }();\n    supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n    supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n    supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n    supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n    supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n    supportsDeleteFileXdr = isXdrSupported();\n    supportsDeleteFileCors = isCrossOriginAjaxSupported();\n    supportsFolderSelection = isFolderSelectionSupported();\n    supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n    supportsUploadProgress = function () {\n      if (supportsAjaxFileUploading) {\n        return !qq.androidStock() && !qq.iosChrome();\n      }\n      return false;\n    }();\n    return {\n      ajaxUploading: supportsAjaxFileUploading,\n      blobUploading: supportsUploadingBlobs,\n      canDetermineSize: supportsAjaxFileUploading,\n      chunking: supportsChunking,\n      deleteFileCors: supportsDeleteFileCors,\n      deleteFileCorsXdr: supportsDeleteFileXdr,\n      deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n      dialogElement: !!window.HTMLDialogElement,\n      fileDrop: supportsFileDrop,\n      folderDrop: supportsFolderDrop,\n      folderSelection: supportsFolderSelection,\n      imagePreviews: supportsImagePreviews,\n      imageValidation: supportsImagePreviews,\n      itemSizeValidation: supportsAjaxFileUploading,\n      pause: supportsChunking,\n      progressBar: supportsUploadProgress,\n      resume: supportsResume,\n      scaling: supportsImagePreviews && supportsUploadingBlobs,\n      tiffPreviews: qq.safari(),\n      unlimitedScaledImageSize: !qq.ios(),\n      uploading: supportsUploading,\n      uploadCors: supportsUploadCors,\n      uploadCustomHeaders: supportsAjaxFileUploading,\n      uploadNonMultipart: supportsAjaxFileUploading,\n      uploadViaPaste: supportsUploadViaPaste\n    };\n  }();\n  qq.isGenericPromise = function (maybePromise) {\n    \"use strict\";\n\n    return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n  };\n  qq.Promise = function () {\n    \"use strict\";\n\n    var successArgs,\n      failureArgs,\n      successCallbacks = [],\n      failureCallbacks = [],\n      doneCallbacks = [],\n      state = 0;\n    qq.extend(this, {\n      then: function then(onSuccess, onFailure) {\n        if (state === 0) {\n          if (onSuccess) {\n            successCallbacks.push(onSuccess);\n          }\n          if (onFailure) {\n            failureCallbacks.push(onFailure);\n          }\n        } else if (state === -1) {\n          onFailure && onFailure.apply(null, failureArgs);\n        } else if (onSuccess) {\n          onSuccess.apply(null, successArgs);\n        }\n        return this;\n      },\n      done: function done(callback) {\n        if (state === 0) {\n          doneCallbacks.push(callback);\n        } else {\n          callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n        }\n        return this;\n      },\n      success: function success() {\n        state = 1;\n        successArgs = arguments;\n        if (successCallbacks.length) {\n          qq.each(successCallbacks, function (idx, callback) {\n            callback.apply(null, successArgs);\n          });\n        }\n        if (doneCallbacks.length) {\n          qq.each(doneCallbacks, function (idx, callback) {\n            callback.apply(null, successArgs);\n          });\n        }\n        return this;\n      },\n      failure: function failure() {\n        state = -1;\n        failureArgs = arguments;\n        if (failureCallbacks.length) {\n          qq.each(failureCallbacks, function (idx, callback) {\n            callback.apply(null, failureArgs);\n          });\n        }\n        if (doneCallbacks.length) {\n          qq.each(doneCallbacks, function (idx, callback) {\n            callback.apply(null, failureArgs);\n          });\n        }\n        return this;\n      }\n    });\n  };\n  qq.BlobProxy = function (referenceBlob, onCreate) {\n    \"use strict\";\n\n    qq.extend(this, {\n      referenceBlob: referenceBlob,\n      create: function create() {\n        return onCreate(referenceBlob);\n      }\n    });\n  };\n  qq.UploadButton = function (o) {\n    \"use strict\";\n\n    var self = this,\n      disposeSupport = new qq.DisposeSupport(),\n      options = {\n        acceptFiles: null,\n        element: null,\n        focusClass: \"qq-upload-button-focus\",\n        folders: false,\n        hoverClass: \"qq-upload-button-hover\",\n        ios8BrowserCrashWorkaround: false,\n        multiple: false,\n        name: \"qqfile\",\n        onChange: function onChange(input) {},\n        title: null\n      },\n      input,\n      buttonId;\n    qq.extend(options, o);\n    buttonId = qq.getUniqueId();\n    function createInput() {\n      var input = document.createElement(\"input\");\n      input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n      input.setAttribute(\"title\", options.title);\n      self.setMultiple(options.multiple, input);\n      if (options.folders && qq.supportedFeatures.folderSelection) {\n        input.setAttribute(\"webkitdirectory\", \"\");\n      }\n      if (options.acceptFiles) {\n        input.setAttribute(\"accept\", options.acceptFiles);\n      }\n      input.setAttribute(\"type\", \"file\");\n      input.setAttribute(\"name\", options.name);\n      qq(input).css({\n        position: \"absolute\",\n        right: 0,\n        top: 0,\n        fontFamily: \"Arial\",\n        fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n        margin: 0,\n        padding: 0,\n        cursor: \"pointer\",\n        opacity: 0\n      });\n      !qq.ie7() && qq(input).css({\n        height: \"100%\"\n      });\n      options.element.appendChild(input);\n      disposeSupport.attach(input, \"change\", function () {\n        options.onChange(input);\n      });\n      disposeSupport.attach(input, \"mouseover\", function () {\n        qq(options.element).addClass(options.hoverClass);\n      });\n      disposeSupport.attach(input, \"mouseout\", function () {\n        qq(options.element).removeClass(options.hoverClass);\n      });\n      disposeSupport.attach(input, \"focus\", function () {\n        qq(options.element).addClass(options.focusClass);\n      });\n      disposeSupport.attach(input, \"blur\", function () {\n        qq(options.element).removeClass(options.focusClass);\n      });\n      return input;\n    }\n    qq(options.element).css({\n      position: \"relative\",\n      overflow: \"hidden\",\n      direction: \"ltr\"\n    });\n    qq.extend(this, {\n      getInput: function getInput() {\n        return input;\n      },\n      getButtonId: function getButtonId() {\n        return buttonId;\n      },\n      setMultiple: function setMultiple(isMultiple, optInput) {\n        var input = optInput || this.getInput();\n        if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n          input.setAttribute(\"multiple\", \"\");\n        } else {\n          if (isMultiple) {\n            input.setAttribute(\"multiple\", \"\");\n          } else {\n            input.removeAttribute(\"multiple\");\n          }\n        }\n      },\n      setAcceptFiles: function setAcceptFiles(acceptFiles) {\n        if (acceptFiles !== options.acceptFiles) {\n          input.setAttribute(\"accept\", acceptFiles);\n        }\n      },\n      reset: function reset() {\n        if (input.parentNode) {\n          qq(input).remove();\n        }\n        qq(options.element).removeClass(options.focusClass);\n        input = null;\n        input = createInput();\n      }\n    });\n    input = createInput();\n  };\n  qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n  qq.UploadData = function (uploaderProxy) {\n    \"use strict\";\n\n    var data = [],\n      byUuid = {},\n      byStatus = {},\n      byProxyGroupId = {},\n      byBatchId = {};\n    function getDataByIds(idOrIds) {\n      if (qq.isArray(idOrIds)) {\n        var entries = [];\n        qq.each(idOrIds, function (idx, id) {\n          entries.push(data[id]);\n        });\n        return entries;\n      }\n      return data[idOrIds];\n    }\n    function getDataByUuids(uuids) {\n      if (qq.isArray(uuids)) {\n        var entries = [];\n        qq.each(uuids, function (idx, uuid) {\n          entries.push(data[byUuid[uuid]]);\n        });\n        return entries;\n      }\n      return data[byUuid[uuids]];\n    }\n    function getDataByStatus(status) {\n      var statusResults = [],\n        statuses = [].concat(status);\n      qq.each(statuses, function (index, statusEnum) {\n        var statusResultIndexes = byStatus[statusEnum];\n        if (statusResultIndexes !== undefined) {\n          qq.each(statusResultIndexes, function (i, dataIndex) {\n            statusResults.push(data[dataIndex]);\n          });\n        }\n      });\n      return statusResults;\n    }\n    qq.extend(this, {\n      addFile: function addFile(spec) {\n        var status = spec.status || qq.status.SUBMITTING,\n          id = data.push({\n            name: spec.name,\n            originalName: spec.name,\n            uuid: spec.uuid,\n            size: spec.size == null ? -1 : spec.size,\n            status: status,\n            file: spec.file\n          }) - 1;\n        if (spec.batchId) {\n          data[id].batchId = spec.batchId;\n          if (byBatchId[spec.batchId] === undefined) {\n            byBatchId[spec.batchId] = [];\n          }\n          byBatchId[spec.batchId].push(id);\n        }\n        if (spec.proxyGroupId) {\n          data[id].proxyGroupId = spec.proxyGroupId;\n          if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n            byProxyGroupId[spec.proxyGroupId] = [];\n          }\n          byProxyGroupId[spec.proxyGroupId].push(id);\n        }\n        data[id].id = id;\n        byUuid[spec.uuid] = id;\n        if (byStatus[status] === undefined) {\n          byStatus[status] = [];\n        }\n        byStatus[status].push(id);\n        spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n        uploaderProxy.onStatusChange(id, null, status);\n        return id;\n      },\n      retrieve: function retrieve(optionalFilter) {\n        if (qq.isObject(optionalFilter) && data.length) {\n          if (optionalFilter.id !== undefined) {\n            return getDataByIds(optionalFilter.id);\n          } else if (optionalFilter.uuid !== undefined) {\n            return getDataByUuids(optionalFilter.uuid);\n          } else if (optionalFilter.status) {\n            return getDataByStatus(optionalFilter.status);\n          }\n        } else {\n          return qq.extend([], data, true);\n        }\n      },\n      removeFileRef: function removeFileRef(id) {\n        var record = getDataByIds(id);\n        if (record) {\n          delete record.file;\n        }\n      },\n      reset: function reset() {\n        data = [];\n        byUuid = {};\n        byStatus = {};\n        byBatchId = {};\n      },\n      setStatus: function setStatus(id, newStatus) {\n        var oldStatus = data[id].status,\n          byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n        byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n        data[id].status = newStatus;\n        if (byStatus[newStatus] === undefined) {\n          byStatus[newStatus] = [];\n        }\n        byStatus[newStatus].push(id);\n        uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n      },\n      uuidChanged: function uuidChanged(id, newUuid) {\n        var oldUuid = data[id].uuid;\n        data[id].uuid = newUuid;\n        byUuid[newUuid] = id;\n        delete byUuid[oldUuid];\n      },\n      updateName: function updateName(id, newName) {\n        data[id].name = newName;\n      },\n      updateSize: function updateSize(id, newSize) {\n        data[id].size = newSize;\n      },\n      setParentId: function setParentId(targetId, parentId) {\n        data[targetId].parentId = parentId;\n      },\n      getIdsInProxyGroup: function getIdsInProxyGroup(id) {\n        var proxyGroupId = data[id].proxyGroupId;\n        if (proxyGroupId) {\n          return byProxyGroupId[proxyGroupId];\n        }\n        return [];\n      },\n      getIdsInBatch: function getIdsInBatch(id) {\n        var batchId = data[id].batchId;\n        return byBatchId[batchId];\n      }\n    });\n  };\n  qq.status = {\n    SUBMITTING: \"submitting\",\n    SUBMITTED: \"submitted\",\n    REJECTED: \"rejected\",\n    QUEUED: \"queued\",\n    CANCELED: \"canceled\",\n    PAUSED: \"paused\",\n    UPLOADING: \"uploading\",\n    UPLOAD_FINALIZING: \"upload finalizing\",\n    UPLOAD_RETRYING: \"retrying upload\",\n    UPLOAD_SUCCESSFUL: \"upload successful\",\n    UPLOAD_FAILED: \"upload failed\",\n    DELETE_FAILED: \"delete failed\",\n    DELETING: \"deleting\",\n    DELETED: \"deleted\"\n  };\n  (function () {\n    \"use strict\";\n\n    qq.basePublicApi = {\n      addBlobs: function addBlobs(blobDataOrArray, params, endpoint) {\n        this.addFiles(blobDataOrArray, params, endpoint);\n      },\n      addInitialFiles: function addInitialFiles(cannedFileList) {\n        var self = this;\n        qq.each(cannedFileList, function (index, cannedFile) {\n          self._addCannedFile(cannedFile);\n        });\n      },\n      addFiles: function addFiles(data, params, endpoint) {\n        this._maybeHandleIos8SafariWorkaround();\n        var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId,\n          processBlob = qq.bind(function (blob) {\n            this._handleNewFile({\n              blob: blob,\n              name: this._options.blobs.defaultName\n            }, batchId, verifiedFiles);\n          }, this),\n          processBlobData = qq.bind(function (blobData) {\n            this._handleNewFile(blobData, batchId, verifiedFiles);\n          }, this),\n          processCanvas = qq.bind(function (canvas) {\n            var blob = qq.canvasToBlob(canvas);\n            this._handleNewFile({\n              blob: blob,\n              name: this._options.blobs.defaultName + \".png\"\n            }, batchId, verifiedFiles);\n          }, this),\n          processCanvasData = qq.bind(function (canvasData) {\n            var normalizedQuality = canvasData.quality && canvasData.quality / 100,\n              blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n            this._handleNewFile({\n              blob: blob,\n              name: canvasData.name\n            }, batchId, verifiedFiles);\n          }, this),\n          processFileOrInput = qq.bind(function (fileOrInput) {\n            if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n              var files = Array.prototype.slice.call(fileOrInput.files),\n                self = this;\n              qq.each(files, function (idx, file) {\n                self._handleNewFile(file, batchId, verifiedFiles);\n              });\n            } else {\n              this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n            }\n          }, this),\n          normalizeData = function normalizeData() {\n            if (qq.isFileList(data)) {\n              data = Array.prototype.slice.call(data);\n            }\n            data = [].concat(data);\n          },\n          self = this,\n          verifiedFiles = [];\n        this._currentBatchId = batchId;\n        if (data) {\n          normalizeData();\n          qq.each(data, function (idx, fileContainer) {\n            if (qq.isFileOrInput(fileContainer)) {\n              processFileOrInput(fileContainer);\n            } else if (qq.isBlob(fileContainer)) {\n              processBlob(fileContainer);\n            } else if (qq.isObject(fileContainer)) {\n              if (fileContainer.blob && fileContainer.name) {\n                processBlobData(fileContainer);\n              } else if (fileContainer.canvas && fileContainer.name) {\n                processCanvasData(fileContainer);\n              }\n            } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n              processCanvas(fileContainer);\n            } else {\n              self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n            }\n          });\n          this.log(\"Received \" + verifiedFiles.length + \" files.\");\n          this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n        }\n      },\n      cancel: function cancel(id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n        if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n          this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n        } else {\n          this._handler.cancel(id);\n        }\n      },\n      cancelAll: function cancelAll() {\n        var storedIdsCopy = [],\n          self = this;\n        qq.extend(storedIdsCopy, this._storedIds);\n        qq.each(storedIdsCopy, function (idx, storedFileId) {\n          self.cancel(storedFileId);\n        });\n        this._handler.cancelAll();\n      },\n      clearStoredFiles: function clearStoredFiles() {\n        this._storedIds = [];\n      },\n      continueUpload: function continueUpload(id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n        if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n          return false;\n        }\n        if (uploadData.status === qq.status.PAUSED) {\n          this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n          this._uploadFile(id);\n          return true;\n        } else {\n          this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n        }\n        return false;\n      },\n      deleteFile: function deleteFile(id) {\n        return this._onSubmitDelete(id);\n      },\n      doesExist: function doesExist(fileOrBlobId) {\n        return this._handler.isValid(fileOrBlobId);\n      },\n      drawThumbnail: function drawThumbnail(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n        var promiseToReturn = new qq.Promise(),\n          fileOrUrl,\n          options;\n        if (this._imageGenerator) {\n          fileOrUrl = this._thumbnailUrls[fileId];\n          options = {\n            customResizeFunction: customResizeFunction,\n            maxSize: maxSize > 0 ? maxSize : null,\n            scale: maxSize > 0\n          };\n          if (!fromServer && qq.supportedFeatures.imagePreviews) {\n            fileOrUrl = this.getFile(fileId);\n          }\n          if (fileOrUrl == null) {\n            promiseToReturn.failure({\n              container: imgOrCanvas,\n              error: \"File or URL not found.\"\n            });\n          } else {\n            this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n              promiseToReturn.success(modifiedContainer);\n            }, function failure(container, reason) {\n              promiseToReturn.failure({\n                container: container,\n                error: reason || \"Problem generating thumbnail\"\n              });\n            });\n          }\n        } else {\n          promiseToReturn.failure({\n            container: imgOrCanvas,\n            error: \"Missing image generator module\"\n          });\n        }\n        return promiseToReturn;\n      },\n      getButton: function getButton(fileId) {\n        return this._getButton(this._buttonIdsForFileIds[fileId]);\n      },\n      getEndpoint: function getEndpoint(fileId) {\n        return this._endpointStore.get(fileId);\n      },\n      getFile: function getFile(fileOrBlobId) {\n        var file = this._handler.getFile(fileOrBlobId);\n        var uploadDataRecord;\n        if (!file) {\n          uploadDataRecord = this._uploadData.retrieve({\n            id: fileOrBlobId\n          });\n          if (uploadDataRecord) {\n            file = uploadDataRecord.file;\n          }\n        }\n        return file || null;\n      },\n      getInProgress: function getInProgress() {\n        return this._uploadData.retrieve({\n          status: [qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED]\n        }).length;\n      },\n      getName: function getName(id) {\n        return this._uploadData.retrieve({\n          id: id\n        }).name;\n      },\n      getParentId: function getParentId(id) {\n        var uploadDataEntry = this.getUploads({\n            id: id\n          }),\n          parentId = null;\n        if (uploadDataEntry) {\n          if (uploadDataEntry.parentId !== undefined) {\n            parentId = uploadDataEntry.parentId;\n          }\n        }\n        return parentId;\n      },\n      getResumableFilesData: function getResumableFilesData() {\n        return this._handler.getResumableFilesData();\n      },\n      getSize: function getSize(id) {\n        return this._uploadData.retrieve({\n          id: id\n        }).size;\n      },\n      getNetUploads: function getNetUploads() {\n        return this._netUploaded;\n      },\n      getRemainingAllowedItems: function getRemainingAllowedItems() {\n        var allowedItems = this._currentItemLimit;\n        if (allowedItems > 0) {\n          return allowedItems - this._netUploadedOrQueued;\n        }\n        return null;\n      },\n      getUploads: function getUploads(optionalFilter) {\n        return this._uploadData.retrieve(optionalFilter);\n      },\n      getUuid: function getUuid(id) {\n        return this._uploadData.retrieve({\n          id: id\n        }).uuid;\n      },\n      isResumable: function isResumable(id) {\n        return this._handler.hasResumeRecord(id);\n      },\n      log: function log(str, level) {\n        if (this._options.debug && (!level || level === \"info\")) {\n          qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n        } else if (level && level !== \"info\") {\n          qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n        }\n      },\n      pauseUpload: function pauseUpload(id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n        if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n          return false;\n        }\n        if (qq.indexOf([qq.status.UPLOADING, qq.status.UPLOAD_RETRYING], uploadData.status) >= 0) {\n          if (this._handler.pause(id)) {\n            this._uploadData.setStatus(id, qq.status.PAUSED);\n            return true;\n          } else {\n            this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n          }\n        } else {\n          this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n        }\n        return false;\n      },\n      removeFileRef: function removeFileRef(id) {\n        this._handler.expunge(id);\n        this._uploadData.removeFileRef(id);\n      },\n      reset: function reset() {\n        this.log(\"Resetting uploader...\");\n        this._handler.reset();\n        this._storedIds = [];\n        this._autoRetries = [];\n        this._retryTimeouts = [];\n        this._preventRetries = [];\n        this._thumbnailUrls = [];\n        qq.each(this._buttons, function (idx, button) {\n          button.reset();\n        });\n        this._paramsStore.reset();\n        this._endpointStore.reset();\n        this._netUploadedOrQueued = 0;\n        this._netUploaded = 0;\n        this._uploadData.reset();\n        this._buttonIdsForFileIds = [];\n        this._pasteHandler && this._pasteHandler.reset();\n        this._options.session.refreshOnReset && this._refreshSessionData();\n        this._succeededSinceLastAllComplete = [];\n        this._failedSinceLastAllComplete = [];\n        this._totalProgress && this._totalProgress.reset();\n        this._customResumeDataStore.reset();\n      },\n      retry: function retry(id) {\n        return this._manualRetry(id);\n      },\n      scaleImage: function scaleImage(id, specs) {\n        var self = this;\n        return qq.Scaler.prototype.scaleImage(id, specs, {\n          log: qq.bind(self.log, self),\n          getFile: qq.bind(self.getFile, self),\n          uploadData: self._uploadData\n        });\n      },\n      setCustomHeaders: function setCustomHeaders(headers, id) {\n        this._customHeadersStore.set(headers, id);\n      },\n      setCustomResumeData: function setCustomResumeData(id, data) {\n        this._customResumeDataStore.set(data, id);\n      },\n      setDeleteFileCustomHeaders: function setDeleteFileCustomHeaders(headers, id) {\n        this._deleteFileCustomHeadersStore.set(headers, id);\n      },\n      setDeleteFileEndpoint: function setDeleteFileEndpoint(endpoint, id) {\n        this._deleteFileEndpointStore.set(endpoint, id);\n      },\n      setDeleteFileParams: function setDeleteFileParams(params, id) {\n        this._deleteFileParamsStore.set(params, id);\n      },\n      setEndpoint: function setEndpoint(endpoint, id) {\n        this._endpointStore.set(endpoint, id);\n      },\n      setForm: function setForm(elementOrId) {\n        this._updateFormSupportAndParams(elementOrId);\n      },\n      setItemLimit: function setItemLimit(newItemLimit) {\n        this._currentItemLimit = newItemLimit;\n      },\n      setName: function setName(id, newName) {\n        this._uploadData.updateName(id, newName);\n      },\n      setParams: function setParams(params, id) {\n        this._paramsStore.set(params, id);\n      },\n      setUuid: function setUuid(id, newUuid) {\n        return this._uploadData.uuidChanged(id, newUuid);\n      },\n      setStatus: function setStatus(id, newStatus) {\n        var fileRecord = this.getUploads({\n          id: id\n        });\n        if (!fileRecord) {\n          throw new qq.Error(id + \" is not a valid file ID.\");\n        }\n        switch (newStatus) {\n          case qq.status.DELETED:\n            this._onDeleteComplete(id, null, false);\n            break;\n          case qq.status.DELETE_FAILED:\n            this._onDeleteComplete(id, null, true);\n            break;\n          default:\n            var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n            this.log(errorMessage);\n            throw new qq.Error(errorMessage);\n        }\n      },\n      uploadStoredFiles: function uploadStoredFiles() {\n        if (this._storedIds.length === 0) {\n          this._itemError(\"noFilesError\");\n        } else {\n          this._uploadStoredFiles();\n        }\n      }\n    };\n    qq.basePrivateApi = {\n      _addCannedFile: function _addCannedFile(sessionData) {\n        var self = this;\n        return this._uploadData.addFile({\n          uuid: sessionData.uuid,\n          name: sessionData.name,\n          size: sessionData.size,\n          status: qq.status.UPLOAD_SUCCESSFUL,\n          onBeforeStatusChange: function onBeforeStatusChange(id) {\n            sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n            sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n            if (sessionData.thumbnailUrl) {\n              self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n            }\n            self._netUploaded++;\n            self._netUploadedOrQueued++;\n          }\n        });\n      },\n      _annotateWithButtonId: function _annotateWithButtonId(file, associatedInput) {\n        if (qq.isFile(file)) {\n          file.qqButtonId = this._getButtonId(associatedInput);\n        }\n      },\n      _batchError: function _batchError(message) {\n        this._options.callbacks.onError(null, null, message, undefined);\n      },\n      _createDeleteHandler: function _createDeleteHandler() {\n        var self = this;\n        return new qq.DeleteFileAjaxRequester({\n          method: this._options.deleteFile.method.toUpperCase(),\n          maxConnections: this._options.maxConnections,\n          uuidParamName: this._options.request.uuidName,\n          customHeaders: this._deleteFileCustomHeadersStore,\n          paramsStore: this._deleteFileParamsStore,\n          endpointStore: this._deleteFileEndpointStore,\n          cors: this._options.cors,\n          log: qq.bind(self.log, self),\n          onDelete: function onDelete(id) {\n            self._onDelete(id);\n            self._options.callbacks.onDelete(id);\n          },\n          onDeleteComplete: function onDeleteComplete(id, xhrOrXdr, isError) {\n            self._onDeleteComplete(id, xhrOrXdr, isError);\n            self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n          }\n        });\n      },\n      _createPasteHandler: function _createPasteHandler() {\n        var self = this;\n        return new qq.PasteSupport({\n          targetElement: this._options.paste.targetElement,\n          callbacks: {\n            log: qq.bind(self.log, self),\n            pasteReceived: function pasteReceived(blob) {\n              self._handleCheckedCallback({\n                name: \"onPasteReceived\",\n                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                identifier: \"pasted image\"\n              });\n            }\n          }\n        });\n      },\n      _createStore: function _createStore(initialValue, _readOnlyValues_) {\n        var store = {},\n          catchall = initialValue,\n          perIdReadOnlyValues = {},\n          readOnlyValues = _readOnlyValues_,\n          copy = function copy(orig) {\n            if (qq.isObject(orig)) {\n              return qq.extend({}, orig);\n            }\n            return orig;\n          },\n          getReadOnlyValues = function getReadOnlyValues() {\n            if (qq.isFunction(readOnlyValues)) {\n              return readOnlyValues();\n            }\n            return readOnlyValues;\n          },\n          includeReadOnlyValues = function includeReadOnlyValues(id, existing) {\n            if (readOnlyValues && qq.isObject(existing)) {\n              qq.extend(existing, getReadOnlyValues());\n            }\n            if (perIdReadOnlyValues[id]) {\n              qq.extend(existing, perIdReadOnlyValues[id]);\n            }\n          };\n        return {\n          set: function set(val, id) {\n            if (id == null) {\n              store = {};\n              catchall = copy(val);\n            } else {\n              store[id] = copy(val);\n            }\n          },\n          get: function get(id) {\n            var values;\n            if (id != null && store[id]) {\n              values = store[id];\n            } else {\n              values = copy(catchall);\n            }\n            includeReadOnlyValues(id, values);\n            return copy(values);\n          },\n          addReadOnly: function addReadOnly(id, values) {\n            if (qq.isObject(store)) {\n              if (id === null) {\n                if (qq.isFunction(values)) {\n                  readOnlyValues = values;\n                } else {\n                  readOnlyValues = readOnlyValues || {};\n                  qq.extend(readOnlyValues, values);\n                }\n              } else {\n                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                qq.extend(perIdReadOnlyValues[id], values);\n              }\n            }\n          },\n          remove: function remove(fileId) {\n            return delete store[fileId];\n          },\n          reset: function reset() {\n            store = {};\n            perIdReadOnlyValues = {};\n            catchall = initialValue;\n          }\n        };\n      },\n      _createUploadDataTracker: function _createUploadDataTracker() {\n        var self = this;\n        return new qq.UploadData({\n          getName: function getName(id) {\n            return self.getName(id);\n          },\n          getUuid: function getUuid(id) {\n            return self.getUuid(id);\n          },\n          getSize: function getSize(id) {\n            return self.getSize(id);\n          },\n          onStatusChange: function onStatusChange(id, oldStatus, newStatus) {\n            self._onUploadStatusChange(id, oldStatus, newStatus);\n            self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n            self._maybeAllComplete(id, newStatus);\n            if (self._totalProgress) {\n              setTimeout(function () {\n                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n              }, 0);\n            }\n          }\n        });\n      },\n      _createUploadButton: function _createUploadButton(spec) {\n        var self = this,\n          acceptFiles = spec.accept || this._options.validation.acceptFiles,\n          allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions,\n          button;\n        function allowMultiple() {\n          if (qq.supportedFeatures.ajaxUploading) {\n            if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n              return false;\n            }\n            if (spec.multiple === undefined) {\n              return self._options.multiple;\n            }\n            return spec.multiple;\n          }\n          return false;\n        }\n        button = new qq.UploadButton({\n          acceptFiles: acceptFiles,\n          element: spec.element,\n          focusClass: this._options.classes.buttonFocus,\n          folders: spec.folders,\n          hoverClass: this._options.classes.buttonHover,\n          ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n          multiple: allowMultiple(),\n          name: this._options.request.inputName,\n          onChange: function onChange(input) {\n            self._onInputChange(input);\n          },\n          title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n        });\n        this._disposeSupport.addDisposer(function () {\n          button.dispose();\n        });\n        self._buttons.push(button);\n        return button;\n      },\n      _createUploadHandler: function _createUploadHandler(additionalOptions, namespace) {\n        var self = this,\n          lastOnProgress = {},\n          options = {\n            debug: this._options.debug,\n            maxConnections: this._options.maxConnections,\n            cors: this._options.cors,\n            paramsStore: this._paramsStore,\n            endpointStore: this._endpointStore,\n            chunking: this._options.chunking,\n            resume: this._options.resume,\n            blobs: this._options.blobs,\n            log: qq.bind(self.log, self),\n            preventRetryParam: this._options.retry.preventRetryResponseProperty,\n            onProgress: function onProgress(id, name, loaded, total) {\n              if (loaded < 0 || total < 0) {\n                return;\n              }\n              if (lastOnProgress[id]) {\n                if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                  self._onProgress(id, name, loaded, total);\n                  self._options.callbacks.onProgress(id, name, loaded, total);\n                }\n              } else {\n                self._onProgress(id, name, loaded, total);\n                self._options.callbacks.onProgress(id, name, loaded, total);\n              }\n              lastOnProgress[id] = {\n                loaded: loaded,\n                total: total\n              };\n            },\n            onComplete: function onComplete(id, name, result, xhr) {\n              delete lastOnProgress[id];\n              var status = self.getUploads({\n                  id: id\n                }).status,\n                retVal;\n              if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                return;\n              }\n              retVal = self._onComplete(id, name, result, xhr);\n              if (retVal instanceof qq.Promise) {\n                retVal.done(function () {\n                  self._options.callbacks.onComplete(id, name, result, xhr);\n                });\n              } else {\n                self._options.callbacks.onComplete(id, name, result, xhr);\n              }\n            },\n            onCancel: function onCancel(id, name, cancelFinalizationEffort) {\n              var promise = new qq.Promise();\n              self._handleCheckedCallback({\n                name: \"onCancel\",\n                callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                onFailure: promise.failure,\n                onSuccess: function onSuccess() {\n                  cancelFinalizationEffort.then(function () {\n                    self._onCancel(id, name);\n                  });\n                  promise.success();\n                },\n                identifier: id\n              });\n              return promise;\n            },\n            onUploadPrep: qq.bind(this._onUploadPrep, this),\n            onUpload: function onUpload(id, name) {\n              self._onUpload(id, name);\n              var onUploadResult = self._options.callbacks.onUpload(id, name);\n              if (qq.isGenericPromise(onUploadResult)) {\n                self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n                return onUploadResult;\n              }\n              return new qq.Promise().success();\n            },\n            onUploadChunk: function onUploadChunk(id, name, chunkData) {\n              self._onUploadChunk(id, chunkData);\n              var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n              if (qq.isGenericPromise(onUploadChunkResult)) {\n                self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n                return onUploadChunkResult;\n              }\n              return new qq.Promise().success();\n            },\n            onUploadChunkSuccess: function onUploadChunkSuccess(id, chunkData, result, xhr) {\n              self._onUploadChunkSuccess(id, chunkData);\n              self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n            },\n            onResume: function onResume(id, name, chunkData, customResumeData) {\n              return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n            },\n            onAutoRetry: function onAutoRetry(id, name, responseJSON, xhr) {\n              return self._onAutoRetry.apply(self, arguments);\n            },\n            onUuidChanged: function onUuidChanged(id, newUuid) {\n              self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n              self.setUuid(id, newUuid);\n            },\n            getName: qq.bind(self.getName, self),\n            getUuid: qq.bind(self.getUuid, self),\n            getSize: qq.bind(self.getSize, self),\n            setSize: qq.bind(self._setSize, self),\n            getDataByUuid: function getDataByUuid(uuid) {\n              return self.getUploads({\n                uuid: uuid\n              });\n            },\n            isQueued: function isQueued(id) {\n              var status = self.getUploads({\n                id: id\n              }).status;\n              return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n            },\n            getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n            getIdsInBatch: self._uploadData.getIdsInBatch,\n            isInProgress: function isInProgress(id) {\n              return self.getUploads({\n                id: id\n              }).status === qq.status.UPLOADING;\n            },\n            getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n            setStatus: function setStatus(id, status) {\n              self._uploadData.setStatus(id, status);\n            }\n          };\n        qq.each(this._options.request, function (prop, val) {\n          options[prop] = val;\n        });\n        options.customHeaders = this._customHeadersStore;\n        if (additionalOptions) {\n          qq.each(additionalOptions, function (key, val) {\n            options[key] = val;\n          });\n        }\n        return new qq.UploadHandlerController(options, namespace);\n      },\n      _fileOrBlobRejected: function _fileOrBlobRejected(id) {\n        this._netUploadedOrQueued--;\n        this._uploadData.setStatus(id, qq.status.REJECTED);\n      },\n      _formatSize: function _formatSize(bytes) {\n        if (bytes === 0) {\n          return bytes + this._options.text.sizeSymbols[0];\n        }\n        var i = -1;\n        do {\n          bytes = bytes / 1e3;\n          i++;\n        } while (bytes > 999);\n        return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n      },\n      _generateExtraButtonSpecs: function _generateExtraButtonSpecs() {\n        var self = this;\n        this._extraButtonSpecs = {};\n        qq.each(this._options.extraButtons, function (idx, extraButtonOptionEntry) {\n          var multiple = extraButtonOptionEntry.multiple,\n            validation = qq.extend({}, self._options.validation, true),\n            extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n          if (multiple === undefined) {\n            multiple = self._options.multiple;\n          }\n          if (extraButtonSpec.validation) {\n            qq.extend(validation, extraButtonOptionEntry.validation, true);\n          }\n          qq.extend(extraButtonSpec, {\n            multiple: multiple,\n            validation: validation\n          }, true);\n          self._initExtraButton(extraButtonSpec);\n        });\n      },\n      _getButton: function _getButton(buttonId) {\n        var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n        if (extraButtonsSpec) {\n          return extraButtonsSpec.element;\n        } else if (buttonId === this._defaultButtonId) {\n          return this._options.button;\n        }\n      },\n      _getButtonId: function _getButtonId(buttonOrFileInputOrFile) {\n        var inputs,\n          fileInput,\n          fileBlobOrInput = buttonOrFileInputOrFile;\n        if (fileBlobOrInput instanceof qq.BlobProxy) {\n          fileBlobOrInput = fileBlobOrInput.referenceBlob;\n        }\n        if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n          if (qq.isFile(fileBlobOrInput)) {\n            return fileBlobOrInput.qqButtonId;\n          } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n            return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n          }\n          inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n          qq.each(inputs, function (idx, input) {\n            if (input.getAttribute(\"type\") === \"file\") {\n              fileInput = input;\n              return false;\n            }\n          });\n          if (fileInput) {\n            return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n          }\n        }\n      },\n      _getCustomResumeData: function _getCustomResumeData(fileId) {\n        return this._customResumeDataStore.get(fileId);\n      },\n      _getNotFinished: function _getNotFinished() {\n        return this._uploadData.retrieve({\n          status: [qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED]\n        }).length;\n      },\n      _getValidationBase: function _getValidationBase(buttonId) {\n        var extraButtonSpec = this._extraButtonSpecs[buttonId];\n        return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n      },\n      _getValidationDescriptor: function _getValidationDescriptor(fileWrapper) {\n        if (fileWrapper.file instanceof qq.BlobProxy) {\n          return {\n            name: qq.getFilename(fileWrapper.file.referenceBlob),\n            size: fileWrapper.file.referenceBlob.size\n          };\n        }\n        return {\n          name: this.getUploads({\n            id: fileWrapper.id\n          }).name,\n          size: this.getUploads({\n            id: fileWrapper.id\n          }).size\n        };\n      },\n      _getValidationDescriptors: function _getValidationDescriptors(fileWrappers) {\n        var self = this,\n          fileDescriptors = [];\n        qq.each(fileWrappers, function (idx, fileWrapper) {\n          fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n        });\n        return fileDescriptors;\n      },\n      _handleCameraAccess: function _handleCameraAccess() {\n        if (this._options.camera.ios && qq.ios()) {\n          var acceptIosCamera = \"image/*;capture=camera\",\n            button = this._options.camera.button,\n            buttonId = button ? this._getButtonId(button) : this._defaultButtonId,\n            optionRoot = this._options;\n          if (buttonId && buttonId !== this._defaultButtonId) {\n            optionRoot = this._extraButtonSpecs[buttonId];\n          }\n          optionRoot.multiple = false;\n          if (optionRoot.validation.acceptFiles === null) {\n            optionRoot.validation.acceptFiles = acceptIosCamera;\n          } else {\n            optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n          }\n          qq.each(this._buttons, function (idx, button) {\n            if (button.getButtonId() === buttonId) {\n              button.setMultiple(optionRoot.multiple);\n              button.setAcceptFiles(optionRoot.acceptFiles);\n              return false;\n            }\n          });\n        }\n      },\n      _handleCheckedCallback: function _handleCheckedCallback(details) {\n        var self = this,\n          callbackRetVal = details.callback();\n        if (qq.isGenericPromise(callbackRetVal)) {\n          this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n          return callbackRetVal.then(function (successParam) {\n            self.log(details.name + \" promise success for \" + details.identifier);\n            details.onSuccess(successParam);\n          }, function () {\n            if (details.onFailure) {\n              self.log(details.name + \" promise failure for \" + details.identifier);\n              details.onFailure();\n            } else {\n              self.log(details.name + \" promise failure for \" + details.identifier);\n            }\n          });\n        }\n        if (callbackRetVal !== false) {\n          details.onSuccess(callbackRetVal);\n        } else {\n          if (details.onFailure) {\n            this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n            details.onFailure();\n          } else {\n            this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n          }\n        }\n        return callbackRetVal;\n      },\n      _handleNewFile: function _handleNewFile(file, batchId, newFileWrapperList) {\n        var self = this,\n          uuid = qq.getUniqueId(),\n          size = -1,\n          name = qq.getFilename(file),\n          actualFile = file.blob || file,\n          handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n        if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n          size = actualFile.size;\n        }\n        handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n          uploadData: self._uploadData,\n          paramsStore: self._paramsStore,\n          addFileToHandler: function addFileToHandler(id, file) {\n            self._handler.add(id, file);\n            self._netUploadedOrQueued++;\n            self._trackButton(id);\n          }\n        });\n      },\n      _handleNewFileGeneric: function _handleNewFileGeneric(file, name, uuid, size, fileList, batchId) {\n        var id = this._uploadData.addFile({\n          uuid: uuid,\n          name: name,\n          size: size,\n          batchId: batchId,\n          file: file\n        });\n        this._handler.add(id, file);\n        this._trackButton(id);\n        this._netUploadedOrQueued++;\n        fileList.push({\n          id: id,\n          file: file\n        });\n      },\n      _handlePasteSuccess: function _handlePasteSuccess(blob, extSuppliedName) {\n        var extension = blob.type.split(\"/\")[1],\n          name = extSuppliedName;\n        if (name == null) {\n          name = this._options.paste.defaultName;\n        }\n        name += \".\" + extension;\n        this.addFiles({\n          name: name,\n          blob: blob\n        });\n      },\n      _handleDeleteSuccess: function _handleDeleteSuccess(id) {\n        if (this.getUploads({\n          id: id\n        }).status !== qq.status.DELETED) {\n          var name = this.getName(id);\n          this._netUploadedOrQueued--;\n          this._netUploaded--;\n          this._handler.expunge(id);\n          this._uploadData.setStatus(id, qq.status.DELETED);\n          this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n        }\n      },\n      _handleDeleteFailed: function _handleDeleteFailed(id, xhrOrXdr) {\n        var name = this.getName(id);\n        this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n        this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n        if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n          this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n        } else {\n          this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n        }\n      },\n      _initExtraButton: function _initExtraButton(spec) {\n        var button = this._createUploadButton({\n          accept: spec.validation.acceptFiles,\n          allowedExtensions: spec.validation.allowedExtensions,\n          element: spec.element,\n          folders: spec.folders,\n          multiple: spec.multiple,\n          title: spec.fileInputTitle\n        });\n        this._extraButtonSpecs[button.getButtonId()] = spec;\n      },\n      _initFormSupportAndParams: function _initFormSupportAndParams() {\n        this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n        if (this._formSupport && this._formSupport.attachedToForm) {\n          this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n          this._options.autoUpload = this._formSupport.newAutoUpload;\n          if (this._formSupport.newEndpoint) {\n            this._options.request.endpoint = this._formSupport.newEndpoint;\n          }\n        } else {\n          this._paramsStore = this._createStore(this._options.request.params);\n        }\n      },\n      _isDeletePossible: function _isDeletePossible() {\n        if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n          return false;\n        }\n        if (this._options.cors.expected) {\n          if (qq.supportedFeatures.deleteFileCorsXhr) {\n            return true;\n          }\n          if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n            return true;\n          }\n          return false;\n        }\n        return true;\n      },\n      _isAllowedExtension: function _isAllowedExtension(allowed, fileName) {\n        var valid = false;\n        if (!allowed.length) {\n          return true;\n        }\n        qq.each(allowed, function (idx, allowedExt) {\n          if (qq.isString(allowedExt)) {\n            var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n            if (fileName.match(extRegex) != null) {\n              valid = true;\n              return false;\n            }\n          }\n        });\n        return valid;\n      },\n      _itemError: function _itemError(code, maybeNameOrNames, item) {\n        var message = this._options.messages[code],\n          allowedExtensions = [],\n          names = [].concat(maybeNameOrNames),\n          name = names[0],\n          buttonId = this._getButtonId(item),\n          validationBase = this._getValidationBase(buttonId),\n          extensionsForMessage,\n          placeholderMatch;\n        function r(name, replacement) {\n          message = message.replace(name, replacement);\n        }\n        qq.each(validationBase.allowedExtensions, function (idx, allowedExtension) {\n          if (qq.isString(allowedExtension)) {\n            allowedExtensions.push(allowedExtension);\n          }\n        });\n        extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n        r(\"{file}\", this._options.formatFileName(name));\n        r(\"{extensions}\", extensionsForMessage);\n        r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n        r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n        placeholderMatch = message.match(/(\\{\\w+\\})/g);\n        if (placeholderMatch !== null) {\n          qq.each(placeholderMatch, function (idx, placeholder) {\n            r(placeholder, names[idx]);\n          });\n        }\n        this._options.callbacks.onError(null, name, message, undefined);\n        return message;\n      },\n      _manualRetry: function _manualRetry(id, callback) {\n        if (this._onBeforeManualRetry(id)) {\n          this._netUploadedOrQueued++;\n          this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n          if (callback) {\n            callback(id);\n          } else {\n            this._handler.retry(id);\n          }\n          return true;\n        }\n      },\n      _maybeAllComplete: function _maybeAllComplete(id, status) {\n        var self = this,\n          notFinished = this._getNotFinished();\n        if (status === qq.status.UPLOAD_SUCCESSFUL) {\n          this._succeededSinceLastAllComplete.push(id);\n        } else if (status === qq.status.UPLOAD_FAILED) {\n          this._failedSinceLastAllComplete.push(id);\n        }\n        if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n          setTimeout(function () {\n            self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n          }, 0);\n        }\n      },\n      _maybeHandleIos8SafariWorkaround: function _maybeHandleIos8SafariWorkaround() {\n        var self = this;\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n          setTimeout(function () {\n            window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n          }, 0);\n          throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n        }\n      },\n      _maybeParseAndSendUploadError: function _maybeParseAndSendUploadError(id, name, response, xhr) {\n        if (!response.success) {\n          if (xhr && xhr.status !== 200 && !response.error) {\n            this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n          } else {\n            var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n            this._options.callbacks.onError(id, name, errorReason, xhr);\n          }\n        }\n      },\n      _maybeProcessNextItemAfterOnValidateCallback: function _maybeProcessNextItemAfterOnValidateCallback(validItem, items, index, params, endpoint) {\n        var self = this;\n        if (items.length > index) {\n          if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n            setTimeout(function () {\n              var validationDescriptor = self._getValidationDescriptor(items[index]),\n                buttonId = self._getButtonId(items[index].file),\n                button = self._getButton(buttonId);\n              self._handleCheckedCallback({\n                name: \"onValidate\",\n                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n              });\n            }, 0);\n          } else if (!validItem) {\n            for (; index < items.length; index++) {\n              self._fileOrBlobRejected(items[index].id);\n            }\n          }\n        }\n      },\n      _onAllComplete: function _onAllComplete(successful, failed) {\n        this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n        this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n        this._succeededSinceLastAllComplete = [];\n        this._failedSinceLastAllComplete = [];\n      },\n      _onAutoRetry: function _onAutoRetry(id, name, responseJSON, xhr, callback) {\n        var self = this;\n        self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n        if (self._shouldAutoRetry(id)) {\n          var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n          self._maybeParseAndSendUploadError.apply(self, arguments);\n          self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n          self._onBeforeAutoRetry(id, name);\n          self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n          self._retryTimeouts[id] = setTimeout(function () {\n            self.log(\"Starting retry for \" + name + \"...\");\n            if (callback) {\n              callback(id);\n            } else {\n              self._handler.retry(id);\n            }\n          }, retryWaitPeriod);\n          return true;\n        }\n      },\n      _onBeforeAutoRetry: function _onBeforeAutoRetry(id, name) {\n        this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n      },\n      _onBeforeManualRetry: function _onBeforeManualRetry(id) {\n        var itemLimit = this._currentItemLimit,\n          fileName;\n        if (this._preventRetries[id]) {\n          this.log(\"Retries are forbidden for id \" + id, \"warn\");\n          return false;\n        } else if (this._handler.isValid(id)) {\n          fileName = this.getName(id);\n          if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n            return false;\n          }\n          if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n            this._itemError(\"retryFailTooManyItems\");\n            return false;\n          }\n          this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n          return true;\n        } else {\n          this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n          return false;\n        }\n      },\n      _onCancel: function _onCancel(id, name) {\n        this._netUploadedOrQueued--;\n        clearTimeout(this._retryTimeouts[id]);\n        var storedItemIndex = qq.indexOf(this._storedIds, id);\n        if (!this._options.autoUpload && storedItemIndex >= 0) {\n          this._storedIds.splice(storedItemIndex, 1);\n        }\n        this._uploadData.setStatus(id, qq.status.CANCELED);\n      },\n      _onComplete: function _onComplete(id, name, result, xhr) {\n        if (!result.success) {\n          this._netUploadedOrQueued--;\n          this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n          if (result[this._options.retry.preventRetryResponseProperty] === true) {\n            this._preventRetries[id] = true;\n          }\n        } else {\n          if (result.thumbnailUrl) {\n            this._thumbnailUrls[id] = result.thumbnailUrl;\n          }\n          this._netUploaded++;\n          this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n        }\n        this._maybeParseAndSendUploadError(id, name, result, xhr);\n        return result.success ? true : false;\n      },\n      _onDelete: function _onDelete(id) {\n        this._uploadData.setStatus(id, qq.status.DELETING);\n      },\n      _onDeleteComplete: function _onDeleteComplete(id, xhrOrXdr, isError) {\n        var name = this.getName(id);\n        if (isError) {\n          this._handleDeleteFailed(id, xhrOrXdr);\n        } else {\n          this._handleDeleteSuccess(id);\n        }\n      },\n      _onInputChange: function _onInputChange(input) {\n        var fileIndex;\n        if (qq.supportedFeatures.ajaxUploading) {\n          for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n            this._annotateWithButtonId(input.files[fileIndex], input);\n          }\n          this.addFiles(input.files);\n        } else if (input.value.length > 0) {\n          this.addFiles(input);\n        }\n        qq.each(this._buttons, function (idx, button) {\n          button.reset();\n        });\n      },\n      _onProgress: function _onProgress(id, name, loaded, total) {\n        this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n      },\n      _onSubmit: function _onSubmit(id, name) {},\n      _onSubmitCallbackSuccess: function _onSubmitCallbackSuccess(id, name) {\n        this._onSubmit.apply(this, arguments);\n        this._uploadData.setStatus(id, qq.status.SUBMITTED);\n        this._onSubmitted.apply(this, arguments);\n        if (this._options.autoUpload) {\n          this._options.callbacks.onSubmitted.apply(this, arguments);\n          this._uploadFile(id);\n        } else {\n          this._storeForLater(id);\n          this._options.callbacks.onSubmitted.apply(this, arguments);\n        }\n      },\n      _onSubmitDelete: function _onSubmitDelete(id, onSuccessCallback, additionalMandatedParams) {\n        var uuid = this.getUuid(id),\n          adjustedOnSuccessCallback;\n        if (onSuccessCallback) {\n          adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n        }\n        if (this._isDeletePossible()) {\n          this._handleCheckedCallback({\n            name: \"onSubmitDelete\",\n            callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n            onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n            identifier: id\n          });\n          return true;\n        } else {\n          this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n          return false;\n        }\n      },\n      _onSubmitted: function _onSubmitted(id) {},\n      _onTotalProgress: function _onTotalProgress(loaded, total) {\n        this._options.callbacks.onTotalProgress(loaded, total);\n      },\n      _onUploadPrep: function _onUploadPrep(id) {},\n      _onUpload: function _onUpload(id, name) {\n        this._uploadData.setStatus(id, qq.status.UPLOADING);\n      },\n      _onUploadChunk: function _onUploadChunk(id, chunkData) {},\n      _onUploadChunkSuccess: function _onUploadChunkSuccess(id, chunkData) {\n        if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n          this._autoRetries[id] = 0;\n        }\n      },\n      _onUploadStatusChange: function _onUploadStatusChange(id, oldStatus, newStatus) {\n        if (newStatus === qq.status.PAUSED) {\n          clearTimeout(this._retryTimeouts[id]);\n        }\n      },\n      _onValidateBatchCallbackFailure: function _onValidateBatchCallbackFailure(fileWrappers) {\n        var self = this;\n        qq.each(fileWrappers, function (idx, fileWrapper) {\n          self._fileOrBlobRejected(fileWrapper.id);\n        });\n      },\n      _onValidateBatchCallbackSuccess: function _onValidateBatchCallbackSuccess(validationDescriptors, items, params, endpoint, button) {\n        var errorMessage,\n          itemLimit = this._currentItemLimit,\n          proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n        if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n          if (items.length > 0) {\n            this._handleCheckedCallback({\n              name: \"onValidate\",\n              callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n              onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n              onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n              identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n            });\n          } else {\n            this._itemError(\"noFilesError\");\n          }\n        } else {\n          this._onValidateBatchCallbackFailure(items);\n          errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n          this._batchError(errorMessage);\n        }\n      },\n      _onValidateCallbackFailure: function _onValidateCallbackFailure(items, index, params, endpoint) {\n        var nextIndex = index + 1;\n        this._fileOrBlobRejected(items[index].id, items[index].file.name);\n        this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n      },\n      _onValidateCallbackSuccess: function _onValidateCallbackSuccess(items, index, params, endpoint) {\n        var self = this,\n          nextIndex = index + 1,\n          validationDescriptor = this._getValidationDescriptor(items[index]);\n        this._validateFileOrBlobData(items[index], validationDescriptor).then(function () {\n          self._upload(items[index].id, params, endpoint);\n          self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n        }, function () {\n          self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n        });\n      },\n      _prepareItemsForUpload: function _prepareItemsForUpload(items, params, endpoint) {\n        if (items.length === 0) {\n          this._itemError(\"noFilesError\");\n          return;\n        }\n        var validationDescriptors = this._getValidationDescriptors(items),\n          buttonId = this._getButtonId(items[0].file),\n          button = this._getButton(buttonId);\n        this._handleCheckedCallback({\n          name: \"onValidateBatch\",\n          callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n          onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n          onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n          identifier: \"batch validation\"\n        });\n      },\n      _preventLeaveInProgress: function _preventLeaveInProgress() {\n        var self = this;\n        this._disposeSupport.attach(window, \"beforeunload\", function (e) {\n          if (self.getInProgress()) {\n            e = e || window.event;\n            e.returnValue = self._options.messages.onLeave;\n            return self._options.messages.onLeave;\n          }\n        });\n      },\n      _refreshSessionData: function _refreshSessionData() {\n        var self = this,\n          options = this._options.session;\n        if (qq.Session && this._options.session.endpoint != null) {\n          if (!this._session) {\n            qq.extend(options, {\n              cors: this._options.cors\n            });\n            options.log = qq.bind(this.log, this);\n            options.addFileRecord = qq.bind(this._addCannedFile, this);\n            this._session = new qq.Session(options);\n          }\n          setTimeout(function () {\n            self._session.refresh().then(function (response, xhrOrXdr) {\n              self._sessionRequestComplete();\n              self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n            }, function (response, xhrOrXdr) {\n              self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n            });\n          }, 0);\n        }\n      },\n      _sessionRequestComplete: function _sessionRequestComplete() {},\n      _setSize: function _setSize(id, newSize) {\n        this._uploadData.updateSize(id, newSize);\n        this._totalProgress && this._totalProgress.onNewSize(id);\n      },\n      _shouldAutoRetry: function _shouldAutoRetry(id) {\n        var uploadData = this._uploadData.retrieve({\n          id: id\n        });\n        if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n          if (this._autoRetries[id] === undefined) {\n            this._autoRetries[id] = 0;\n          }\n          if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n            this._autoRetries[id] += 1;\n            return true;\n          }\n        }\n        return false;\n      },\n      _storeForLater: function _storeForLater(id) {\n        this._storedIds.push(id);\n      },\n      _trackButton: function _trackButton(id) {\n        var buttonId;\n        if (qq.supportedFeatures.ajaxUploading) {\n          buttonId = this._handler.getFile(id).qqButtonId;\n        } else {\n          buttonId = this._getButtonId(this._handler.getInput(id));\n        }\n        if (buttonId) {\n          this._buttonIdsForFileIds[id] = buttonId;\n        }\n      },\n      _updateFormSupportAndParams: function _updateFormSupportAndParams(formElementOrId) {\n        this._options.form.element = formElementOrId;\n        this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n        if (this._formSupport && this._formSupport.attachedToForm) {\n          this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n          this._options.autoUpload = this._formSupport.newAutoUpload;\n          if (this._formSupport.newEndpoint) {\n            this.setEndpoint(this._formSupport.newEndpoint);\n          }\n        }\n      },\n      _upload: function _upload(id, params, endpoint) {\n        var name = this.getName(id);\n        if (params) {\n          this.setParams(params, id);\n        }\n        if (endpoint) {\n          this.setEndpoint(endpoint, id);\n        }\n        this._handleCheckedCallback({\n          name: \"onSubmit\",\n          callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n          onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n          onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n          identifier: id\n        });\n      },\n      _uploadFile: function _uploadFile(id) {\n        if (!this._handler.upload(id)) {\n          this._uploadData.setStatus(id, qq.status.QUEUED);\n        }\n      },\n      _uploadStoredFiles: function _uploadStoredFiles() {\n        var idToUpload,\n          stillSubmitting,\n          self = this;\n        while (this._storedIds.length) {\n          idToUpload = this._storedIds.shift();\n          this._uploadFile(idToUpload);\n        }\n        stillSubmitting = this.getUploads({\n          status: qq.status.SUBMITTING\n        }).length;\n        if (stillSubmitting) {\n          qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n          setTimeout(function () {\n            self._uploadStoredFiles();\n          }, 1e3);\n        }\n      },\n      _validateFileOrBlobData: function _validateFileOrBlobData(fileWrapper, validationDescriptor) {\n        var self = this,\n          file = function () {\n            if (fileWrapper.file instanceof qq.BlobProxy) {\n              return fileWrapper.file.referenceBlob;\n            }\n            return fileWrapper.file;\n          }(),\n          name = validationDescriptor.name,\n          size = validationDescriptor.size,\n          buttonId = this._getButtonId(fileWrapper.file),\n          validationBase = this._getValidationBase(buttonId),\n          validityChecker = new qq.Promise();\n        validityChecker.then(function () {}, function () {\n          self._fileOrBlobRejected(fileWrapper.id, name);\n        });\n        if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n          this._itemError(\"typeError\", name, file);\n          return validityChecker.failure();\n        }\n        if (!this._options.validation.allowEmpty && size === 0) {\n          this._itemError(\"emptyError\", name, file);\n          return validityChecker.failure();\n        }\n        if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n          this._itemError(\"sizeError\", name, file);\n          return validityChecker.failure();\n        }\n        if (size > 0 && size < validationBase.minSizeLimit) {\n          this._itemError(\"minSizeError\", name, file);\n          return validityChecker.failure();\n        }\n        if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n          new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function (errorCode) {\n            self._itemError(errorCode + \"ImageError\", name, file);\n            validityChecker.failure();\n          });\n        } else {\n          validityChecker.success();\n        }\n        return validityChecker;\n      },\n      _wrapCallbacks: function _wrapCallbacks() {\n        var self, safeCallback, prop;\n        self = this;\n        safeCallback = function safeCallback(name, callback, args) {\n          var errorMsg;\n          try {\n            return callback.apply(self, args);\n          } catch (exception) {\n            errorMsg = exception.message || exception.toString();\n            self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n          }\n        };\n        for (prop in this._options.callbacks) {\n          (function () {\n            var callbackName, callbackFunc;\n            callbackName = prop;\n            callbackFunc = self._options.callbacks[callbackName];\n            self._options.callbacks[callbackName] = function () {\n              return safeCallback(callbackName, callbackFunc, arguments);\n            };\n          })();\n        }\n      }\n    };\n  })();\n  (function () {\n    \"use strict\";\n\n    qq.FineUploaderBasic = function (o) {\n      var self = this;\n      this._options = {\n        debug: false,\n        button: null,\n        multiple: true,\n        maxConnections: 3,\n        disableCancelForFormUploads: false,\n        autoUpload: true,\n        warnBeforeUnload: true,\n        request: {\n          customHeaders: {},\n          endpoint: \"/server/upload\",\n          filenameParam: \"qqfilename\",\n          forceMultipart: true,\n          inputName: \"qqfile\",\n          method: \"POST\",\n          omitDefaultParams: false,\n          params: {},\n          paramsInBody: true,\n          requireSuccessJson: true,\n          totalFileSizeName: \"qqtotalfilesize\",\n          uuidName: \"qquuid\"\n        },\n        validation: {\n          allowedExtensions: [],\n          sizeLimit: 0,\n          minSizeLimit: 0,\n          itemLimit: 0,\n          stopOnFirstInvalidFile: true,\n          acceptFiles: null,\n          image: {\n            maxHeight: 0,\n            maxWidth: 0,\n            minHeight: 0,\n            minWidth: 0\n          },\n          allowEmpty: false\n        },\n        callbacks: {\n          onSubmit: function onSubmit(id, name) {},\n          onSubmitted: function onSubmitted(id, name) {},\n          onComplete: function onComplete(id, name, responseJSON, maybeXhr) {},\n          onAllComplete: function onAllComplete(successful, failed) {},\n          onCancel: function onCancel(id, name) {},\n          onUpload: function onUpload(id, name) {},\n          onUploadChunk: function onUploadChunk(id, name, chunkData) {},\n          onUploadChunkSuccess: function onUploadChunkSuccess(id, chunkData, responseJSON, xhr) {},\n          onResume: function onResume(id, fileName, chunkData, customResumeData) {},\n          onProgress: function onProgress(id, name, loaded, total) {},\n          onTotalProgress: function onTotalProgress(loaded, total) {},\n          onError: function onError(id, name, reason, maybeXhrOrXdr) {},\n          onAutoRetry: function onAutoRetry(id, name, attemptNumber) {},\n          onManualRetry: function onManualRetry(id, name) {},\n          onValidateBatch: function onValidateBatch(fileOrBlobData) {},\n          onValidate: function onValidate(fileOrBlobData) {},\n          onSubmitDelete: function onSubmitDelete(id) {},\n          onDelete: function onDelete(id) {},\n          onDeleteComplete: function onDeleteComplete(id, xhrOrXdr, isError) {},\n          onPasteReceived: function onPasteReceived(blob) {},\n          onStatusChange: function onStatusChange(id, oldStatus, newStatus) {},\n          onSessionRequestComplete: function onSessionRequestComplete(response, success, xhrOrXdr) {}\n        },\n        messages: {\n          typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n          sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n          minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n          emptyError: \"{file} is empty, please select files again without it.\",\n          noFilesError: \"No files to upload.\",\n          tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n          maxHeightImageError: \"Image is too tall.\",\n          maxWidthImageError: \"Image is too wide.\",\n          minHeightImageError: \"Image is not tall enough.\",\n          minWidthImageError: \"Image is not wide enough.\",\n          retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n          onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n          unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n        },\n        retry: {\n          enableAuto: false,\n          maxAutoAttempts: 3,\n          autoAttemptDelay: 5,\n          preventRetryResponseProperty: \"preventRetry\"\n        },\n        classes: {\n          buttonHover: \"qq-upload-button-hover\",\n          buttonFocus: \"qq-upload-button-focus\"\n        },\n        chunking: {\n          enabled: false,\n          concurrent: {\n            enabled: false\n          },\n          mandatory: false,\n          paramNames: {\n            partIndex: \"qqpartindex\",\n            partByteOffset: \"qqpartbyteoffset\",\n            chunkSize: \"qqchunksize\",\n            totalFileSize: \"qqtotalfilesize\",\n            totalParts: \"qqtotalparts\"\n          },\n          partSize: function partSize(id) {\n            return 2e6;\n          },\n          success: {\n            endpoint: null,\n            headers: function headers(id) {\n              return null;\n            },\n            jsonPayload: false,\n            method: \"POST\",\n            params: function params(id) {\n              return null;\n            },\n            resetOnStatus: []\n          }\n        },\n        resume: {\n          enabled: false,\n          recordsExpireIn: 7,\n          paramNames: {\n            resuming: \"qqresume\"\n          },\n          customKeys: function customKeys(fileId) {\n            return [];\n          }\n        },\n        formatFileName: function formatFileName(fileOrBlobName) {\n          return fileOrBlobName;\n        },\n        text: {\n          defaultResponseError: \"Upload failure reason unknown\",\n          fileInputTitle: \"file input\",\n          sizeSymbols: [\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"]\n        },\n        deleteFile: {\n          enabled: false,\n          method: \"DELETE\",\n          endpoint: \"/server/upload\",\n          customHeaders: {},\n          params: {}\n        },\n        cors: {\n          expected: false,\n          sendCredentials: false,\n          allowXdr: false\n        },\n        blobs: {\n          defaultName: \"misc_data\"\n        },\n        paste: {\n          targetElement: null,\n          defaultName: \"pasted_image\"\n        },\n        camera: {\n          ios: false,\n          button: null\n        },\n        extraButtons: [],\n        session: {\n          endpoint: null,\n          params: {},\n          customHeaders: {},\n          refreshOnReset: true\n        },\n        form: {\n          element: \"qq-form\",\n          autoUpload: false,\n          interceptSubmit: true\n        },\n        scaling: {\n          customResizer: null,\n          sendOriginal: true,\n          orient: true,\n          defaultType: null,\n          defaultQuality: 80,\n          failureText: \"Failed to scale\",\n          includeExif: false,\n          sizes: []\n        },\n        workarounds: {\n          iosEmptyVideos: true,\n          ios8SafariUploads: true,\n          ios8BrowserCrash: false\n        }\n      };\n      qq.extend(this._options, o, true);\n      this._buttons = [];\n      this._extraButtonSpecs = {};\n      this._buttonIdsForFileIds = [];\n      this._wrapCallbacks();\n      this._disposeSupport = new qq.DisposeSupport();\n      this._storedIds = [];\n      this._autoRetries = [];\n      this._retryTimeouts = [];\n      this._preventRetries = [];\n      this._thumbnailUrls = [];\n      this._netUploadedOrQueued = 0;\n      this._netUploaded = 0;\n      this._uploadData = this._createUploadDataTracker();\n      this._initFormSupportAndParams();\n      this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n      this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n      this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n      this._endpointStore = this._createStore(this._options.request.endpoint);\n      this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n      this._handler = this._createUploadHandler();\n      this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n      if (this._options.button) {\n        this._defaultButtonId = this._createUploadButton({\n          element: this._options.button,\n          title: this._options.text.fileInputTitle\n        }).getButtonId();\n      }\n      this._generateExtraButtonSpecs();\n      this._handleCameraAccess();\n      if (this._options.paste.targetElement) {\n        if (qq.PasteSupport) {\n          this._pasteHandler = this._createPasteHandler();\n        } else {\n          this.log(\"Paste support module not found\", \"error\");\n        }\n      }\n      this._options.warnBeforeUnload && this._preventLeaveInProgress();\n      this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n      this._refreshSessionData();\n      this._succeededSinceLastAllComplete = [];\n      this._failedSinceLastAllComplete = [];\n      this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n      if (this._scaler.enabled) {\n        this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n      }\n      if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n        this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function (id) {\n          var entry = self._uploadData.retrieve({\n            id: id\n          });\n          return entry && entry.size || 0;\n        });\n      }\n      this._currentItemLimit = this._options.validation.itemLimit;\n      this._customResumeDataStore = this._createStore();\n    };\n    qq.FineUploaderBasic.prototype = qq.basePublicApi;\n    qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n  })();\n  qq.AjaxRequester = function (o) {\n    \"use strict\";\n\n    var log,\n      shouldParamsBeInQueryString,\n      queue = [],\n      requestData = {},\n      options = {\n        acceptHeader: null,\n        validMethods: [\"PATCH\", \"POST\", \"PUT\"],\n        method: \"POST\",\n        contentType: \"application/x-www-form-urlencoded\",\n        maxConnections: 3,\n        customHeaders: {},\n        endpointStore: {},\n        paramsStore: {},\n        mandatedParams: {},\n        allowXRequestedWithAndCacheControl: true,\n        successfulResponseCodes: {\n          DELETE: [200, 202, 204],\n          PATCH: [200, 201, 202, 203, 204],\n          POST: [200, 201, 202, 203, 204],\n          PUT: [200, 201, 202, 203, 204],\n          GET: [200]\n        },\n        cors: {\n          expected: false,\n          sendCredentials: false\n        },\n        log: function log(str, level) {},\n        onSend: function onSend(id) {},\n        onComplete: function onComplete(id, xhrOrXdr, isError) {},\n        onProgress: null\n      };\n    qq.extend(options, o);\n    log = options.log;\n    if (qq.indexOf(options.validMethods, options.method) < 0) {\n      throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n    }\n    function isSimpleMethod() {\n      return qq.indexOf([\"GET\", \"POST\", \"HEAD\"], options.method) >= 0;\n    }\n    function containsNonSimpleHeaders(headers) {\n      var containsNonSimple = false;\n      qq.each(containsNonSimple, function (idx, header) {\n        if (qq.indexOf([\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\"], header) < 0) {\n          containsNonSimple = true;\n          return false;\n        }\n      });\n      return containsNonSimple;\n    }\n    function isXdr(xhr) {\n      return options.cors.expected && xhr.withCredentials === undefined;\n    }\n    function getCorsAjaxTransport() {\n      var xhrOrXdr;\n      if (window.XMLHttpRequest || window.ActiveXObject) {\n        xhrOrXdr = qq.createXhrInstance();\n        if (xhrOrXdr.withCredentials === undefined) {\n          xhrOrXdr = new XDomainRequest();\n          xhrOrXdr.onload = function () {};\n          xhrOrXdr.onerror = function () {};\n          xhrOrXdr.ontimeout = function () {};\n          xhrOrXdr.onprogress = function () {};\n        }\n      }\n      return xhrOrXdr;\n    }\n    function getXhrOrXdr(id, suppliedXhr) {\n      var xhrOrXdr = requestData[id] && requestData[id].xhr;\n      if (!xhrOrXdr) {\n        if (suppliedXhr) {\n          xhrOrXdr = suppliedXhr;\n        } else {\n          if (options.cors.expected) {\n            xhrOrXdr = getCorsAjaxTransport();\n          } else {\n            xhrOrXdr = qq.createXhrInstance();\n          }\n        }\n        requestData[id].xhr = xhrOrXdr;\n      }\n      return xhrOrXdr;\n    }\n    function dequeue(id) {\n      var i = qq.indexOf(queue, id),\n        max = options.maxConnections,\n        nextId;\n      delete requestData[id];\n      queue.splice(i, 1);\n      if (queue.length >= max && i < max) {\n        nextId = queue[max - 1];\n        sendRequest(nextId);\n      }\n    }\n    function onComplete(id, xdrError) {\n      var xhr = getXhrOrXdr(id),\n        method = options.method,\n        isError = xdrError === true;\n      dequeue(id);\n      if (isError) {\n        log(method + \" request for \" + id + \" has failed\", \"error\");\n      } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n        isError = true;\n        log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n      }\n      options.onComplete(id, xhr, isError);\n    }\n    function getParams(id) {\n      var onDemandParams = requestData[id].additionalParams,\n        mandatedParams = options.mandatedParams,\n        params;\n      if (options.paramsStore.get) {\n        params = options.paramsStore.get(id);\n      }\n      if (onDemandParams) {\n        qq.each(onDemandParams, function (name, val) {\n          params = params || {};\n          params[name] = val;\n        });\n      }\n      if (mandatedParams) {\n        qq.each(mandatedParams, function (name, val) {\n          params = params || {};\n          params[name] = val;\n        });\n      }\n      return params;\n    }\n    function sendRequest(id, optXhr) {\n      var xhr = getXhrOrXdr(id, optXhr),\n        method = options.method,\n        params = getParams(id),\n        payload = requestData[id].payload,\n        url;\n      options.onSend(id);\n      url = createUrl(id, params, requestData[id].additionalQueryParams);\n      if (isXdr(xhr)) {\n        xhr.onload = getXdrLoadHandler(id);\n        xhr.onerror = getXdrErrorHandler(id);\n      } else {\n        xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n      }\n      registerForUploadProgress(id);\n      xhr.open(method, url, true);\n      if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n        xhr.withCredentials = true;\n      }\n      setHeaders(id);\n      log(\"Sending \" + method + \" request for \" + id);\n      if (payload) {\n        xhr.send(payload);\n      } else if (shouldParamsBeInQueryString || !params) {\n        xhr.send();\n      } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n        xhr.send(qq.obj2url(params, \"\"));\n      } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n        xhr.send(JSON.stringify(params));\n      } else {\n        xhr.send(params);\n      }\n      return xhr;\n    }\n    function createUrl(id, params, additionalQueryParams) {\n      var endpoint = options.endpointStore.get(id),\n        addToPath = requestData[id].addToPath;\n      if (addToPath != undefined) {\n        endpoint += \"/\" + addToPath;\n      }\n      if (shouldParamsBeInQueryString && params) {\n        endpoint = qq.obj2url(params, endpoint);\n      }\n      if (additionalQueryParams) {\n        endpoint = qq.obj2url(additionalQueryParams, endpoint);\n      }\n      return endpoint;\n    }\n    function getXhrReadyStateChangeHandler(id) {\n      return function () {\n        if (getXhrOrXdr(id).readyState === 4) {\n          onComplete(id);\n        }\n      };\n    }\n    function registerForUploadProgress(id) {\n      var onProgress = options.onProgress;\n      if (onProgress) {\n        getXhrOrXdr(id).upload.onprogress = function (e) {\n          if (e.lengthComputable) {\n            onProgress(id, e.loaded, e.total);\n          }\n        };\n      }\n    }\n    function getXdrLoadHandler(id) {\n      return function () {\n        onComplete(id);\n      };\n    }\n    function getXdrErrorHandler(id) {\n      return function () {\n        onComplete(id, true);\n      };\n    }\n    function setHeaders(id) {\n      var xhr = getXhrOrXdr(id),\n        customHeaders = options.customHeaders,\n        onDemandHeaders = requestData[id].additionalHeaders || {},\n        method = options.method,\n        allHeaders = {};\n      if (!isXdr(xhr)) {\n        options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n        if (options.allowXRequestedWithAndCacheControl) {\n          if (!options.cors.expected || !isSimpleMethod() || containsNonSimpleHeaders(customHeaders)) {\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n          }\n        }\n        if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n          xhr.setRequestHeader(\"Content-Type\", options.contentType);\n        }\n        qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n        qq.extend(allHeaders, onDemandHeaders);\n        qq.each(allHeaders, function (name, val) {\n          xhr.setRequestHeader(name, val);\n        });\n      }\n    }\n    function isResponseSuccessful(responseCode) {\n      return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n    }\n    function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n      requestData[id] = {\n        addToPath: addToPath,\n        additionalParams: additionalParams,\n        additionalQueryParams: additionalQueryParams,\n        additionalHeaders: additionalHeaders,\n        payload: payload\n      };\n      var len = queue.push(id);\n      if (len <= options.maxConnections) {\n        return sendRequest(id, optXhr);\n      }\n    }\n    shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n    qq.extend(this, {\n      initTransport: function initTransport(id) {\n        var path, params, headers, payload, cacheBuster, additionalQueryParams;\n        return {\n          withPath: function withPath(appendToPath) {\n            path = appendToPath;\n            return this;\n          },\n          withParams: function withParams(additionalParams) {\n            params = additionalParams;\n            return this;\n          },\n          withQueryParams: function withQueryParams(_additionalQueryParams_) {\n            additionalQueryParams = _additionalQueryParams_;\n            return this;\n          },\n          withHeaders: function withHeaders(additionalHeaders) {\n            headers = additionalHeaders;\n            return this;\n          },\n          withPayload: function withPayload(thePayload) {\n            payload = thePayload;\n            return this;\n          },\n          withCacheBuster: function withCacheBuster() {\n            cacheBuster = true;\n            return this;\n          },\n          send: function send(optXhr) {\n            if (cacheBuster && qq.indexOf([\"GET\", \"DELETE\"], options.method) >= 0) {\n              params.qqtimestamp = new Date().getTime();\n            }\n            return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n          }\n        };\n      },\n      canceled: function canceled(id) {\n        dequeue(id);\n      }\n    });\n  };\n  qq.UploadHandler = function (spec) {\n    \"use strict\";\n\n    var proxy = spec.proxy,\n      fileState = {},\n      onCancel = proxy.onCancel,\n      getName = proxy.getName;\n    qq.extend(this, {\n      add: function add(id, fileItem) {\n        fileState[id] = fileItem;\n        fileState[id].temp = {};\n      },\n      cancel: function cancel(id) {\n        var self = this,\n          cancelFinalizationEffort = new qq.Promise(),\n          onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n        onCancelRetVal.then(function () {\n          if (self.isValid(id)) {\n            fileState[id].canceled = true;\n            self.expunge(id);\n          }\n          cancelFinalizationEffort.success();\n        });\n      },\n      expunge: function expunge(id) {\n        delete fileState[id];\n      },\n      getThirdPartyFileId: function getThirdPartyFileId(id) {\n        return fileState[id].key;\n      },\n      isValid: function isValid(id) {\n        return fileState[id] !== undefined;\n      },\n      reset: function reset() {\n        fileState = {};\n      },\n      _getFileState: function _getFileState(id) {\n        return fileState[id];\n      },\n      _setThirdPartyFileId: function _setThirdPartyFileId(id, thirdPartyFileId) {\n        fileState[id].key = thirdPartyFileId;\n      },\n      _wasCanceled: function _wasCanceled(id) {\n        return !!fileState[id].canceled;\n      }\n    });\n  };\n  qq.UploadHandlerController = function (o, namespace) {\n    \"use strict\";\n\n    var controller = this,\n      chunkingPossible = false,\n      concurrentChunkingPossible = false,\n      chunking,\n      preventRetryResponse,\n      log,\n      handler,\n      options = {\n        paramsStore: {},\n        maxConnections: 3,\n        chunking: {\n          enabled: false,\n          multiple: {\n            enabled: false\n          }\n        },\n        log: function log(str, level) {},\n        onProgress: function onProgress(id, fileName, loaded, total) {},\n        onComplete: function onComplete(id, fileName, response, xhr) {},\n        onCancel: function onCancel(id, fileName) {},\n        onUploadPrep: function onUploadPrep(id) {},\n        onUpload: function onUpload(id, fileName) {},\n        onUploadChunk: function onUploadChunk(id, fileName, chunkData) {},\n        onUploadChunkSuccess: function onUploadChunkSuccess(id, chunkData, response, xhr) {},\n        onAutoRetry: function onAutoRetry(id, fileName, response, xhr) {},\n        onResume: function onResume(id, fileName, chunkData, customResumeData) {},\n        onUuidChanged: function onUuidChanged(id, newUuid) {},\n        getName: function getName(id) {},\n        setSize: function setSize(id, newSize) {},\n        isQueued: function isQueued(id) {},\n        getIdsInProxyGroup: function getIdsInProxyGroup(id) {},\n        getIdsInBatch: function getIdsInBatch(id) {},\n        isInProgress: function isInProgress(id) {}\n      },\n      chunked = {\n        done: function done(id, chunkIdx, response, xhr) {\n          var chunkData = handler._getChunkData(id, chunkIdx);\n          handler._getFileState(id).attemptingResume = false;\n          delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n          handler._getFileState(id).loaded += chunkData.size;\n          options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n        },\n        finalize: function finalize(id) {\n          var size = options.getSize(id),\n            name = options.getName(id);\n          log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n          handler.finalizeChunks(id).then(function (response, xhr) {\n            log(\"Finalize successful for \" + id);\n            var normaizedResponse = _upload2.normalizeResponse(response, true);\n            options.onProgress(id, name, size, size);\n            handler._maybeDeletePersistedChunkData(id);\n            _upload2.cleanup(id, normaizedResponse, xhr);\n          }, function (response, xhr) {\n            var normalizedResponse = _upload2.normalizeResponse(response, false);\n            log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n            if (normalizedResponse.reset || xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0) {\n              chunked.reset(id);\n            }\n            if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n              _upload2.cleanup(id, normalizedResponse, xhr);\n            }\n          });\n        },\n        handleFailure: function handleFailure(chunkIdx, id, response, xhr) {\n          var name = options.getName(id);\n          log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n          handler.clearCachedChunk(id, chunkIdx);\n          var responseToReport = _upload2.normalizeResponse(response, false),\n            inProgressIdx;\n          if (responseToReport.reset) {\n            chunked.reset(id);\n          } else {\n            var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n            inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n            if (inProgressIdx >= 0) {\n              handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n              handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n            }\n          }\n          if (!handler._getFileState(id).temp.ignoreFailure) {\n            if (concurrentChunkingPossible) {\n              handler._getFileState(id).temp.ignoreFailure = true;\n              log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n              qq.each(handler._getXhrs(id), function (ckid, ckXhr) {\n                log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                ckXhr.abort();\n                ckXhr._cancelled = true;\n              });\n              handler.moveInProgressToRemaining(id);\n              connectionManager.free(id, true);\n            }\n            if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n              _upload2.cleanup(id, responseToReport, xhr);\n            }\n          }\n        },\n        hasMoreParts: function hasMoreParts(id) {\n          return !!handler._getFileState(id).chunking.remaining.length;\n        },\n        nextPart: function nextPart(id) {\n          var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n          if (nextIdx >= handler._getTotalChunks(id)) {\n            nextIdx = null;\n          }\n          return nextIdx;\n        },\n        reset: function reset(id) {\n          log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n          handler._maybeDeletePersistedChunkData(id);\n          handler.reevaluateChunking(id);\n          handler._getFileState(id).loaded = 0;\n          handler._getFileState(id).attemptingResume = false;\n        },\n        sendNext: function sendNext(id) {\n          var size = options.getSize(id),\n            name = options.getName(id),\n            chunkIdx = chunked.nextPart(id),\n            chunkData = handler._getChunkData(id, chunkIdx),\n            fileState = handler._getFileState(id),\n            resuming = fileState.attemptingResume,\n            inProgressChunks = fileState.chunking.inProgress || [];\n          if (fileState.loaded == null) {\n            fileState.loaded = 0;\n          }\n          if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n            chunked.reset(id);\n            chunkIdx = chunked.nextPart(id);\n            chunkData = handler._getChunkData(id, chunkIdx);\n            resuming = false;\n          }\n          if (chunkIdx == null && inProgressChunks.length === 0) {\n            chunked.finalize(id);\n          } else {\n            inProgressChunks.push(chunkIdx);\n            handler._getFileState(id).chunking.inProgress = inProgressChunks;\n            if (concurrentChunkingPossible) {\n              connectionManager.open(id, chunkIdx);\n            }\n            if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n              chunked.sendNext(id);\n            }\n            if (chunkData.blob.size === 0) {\n              log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n              chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n            }\n            var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n            onUploadChunkPromise.then(function (requestOverrides) {\n              if (!options.isInProgress(id)) {\n                log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n              } else {\n                log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n                var uploadChunkData = {\n                  chunkIdx: chunkIdx,\n                  id: id,\n                  overrides: requestOverrides,\n                  resuming: resuming\n                };\n                handler.uploadChunk(uploadChunkData).then(function success(response, xhr) {\n                  log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                  handler.clearCachedChunk(id, chunkIdx);\n                  var inProgressChunks = handler._getFileState(id).chunking.inProgress || [],\n                    responseToReport = _upload2.normalizeResponse(response, true),\n                    inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                  log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                  chunked.done(id, chunkIdx, responseToReport, xhr);\n                  if (inProgressChunkIdx >= 0) {\n                    inProgressChunks.splice(inProgressChunkIdx, 1);\n                  }\n                  handler._maybePersistChunkedState(id);\n                  if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                    chunked.finalize(id);\n                  } else if (chunked.hasMoreParts(id)) {\n                    chunked.sendNext(id);\n                  } else {\n                    log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                  }\n                }, function failure(response, xhr) {\n                  chunked.handleFailure(chunkIdx, id, response, xhr);\n                }).done(function () {\n                  handler.clearXhr(id, chunkIdx);\n                });\n              }\n            }, function (error) {\n              chunked.handleFailure(chunkIdx, id, error, null);\n            });\n          }\n        }\n      },\n      connectionManager = {\n        _open: [],\n        _openChunks: {},\n        _waiting: [],\n        available: function available() {\n          var max = options.maxConnections,\n            openChunkEntriesCount = 0,\n            openChunksCount = 0;\n          qq.each(connectionManager._openChunks, function (fileId, openChunkIndexes) {\n            openChunkEntriesCount++;\n            openChunksCount += openChunkIndexes.length;\n          });\n          return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n        },\n        free: function free(id, dontAllowNext) {\n          var allowNext = !dontAllowNext,\n            waitingIndex = qq.indexOf(connectionManager._waiting, id),\n            connectionsIndex = qq.indexOf(connectionManager._open, id),\n            nextId;\n          delete connectionManager._openChunks[id];\n          if (_upload2.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n            log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n            delete handler._getFileState(id).file;\n          }\n          if (waitingIndex >= 0) {\n            connectionManager._waiting.splice(waitingIndex, 1);\n          } else if (allowNext && connectionsIndex >= 0) {\n            connectionManager._open.splice(connectionsIndex, 1);\n            nextId = connectionManager._waiting.shift();\n            if (nextId >= 0) {\n              connectionManager._open.push(nextId);\n              _upload2.start(nextId);\n            }\n          }\n        },\n        getWaitingOrConnected: function getWaitingOrConnected() {\n          var waitingOrConnected = [];\n          qq.each(connectionManager._openChunks, function (fileId, chunks) {\n            if (chunks && chunks.length) {\n              waitingOrConnected.push(parseInt(fileId));\n            }\n          });\n          qq.each(connectionManager._open, function (idx, fileId) {\n            if (!connectionManager._openChunks[fileId]) {\n              waitingOrConnected.push(parseInt(fileId));\n            }\n          });\n          waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n          return waitingOrConnected;\n        },\n        isUsingConnection: function isUsingConnection(id) {\n          return qq.indexOf(connectionManager._open, id) >= 0;\n        },\n        open: function open(id, chunkIdx) {\n          if (chunkIdx == null) {\n            connectionManager._waiting.push(id);\n          }\n          if (connectionManager.available()) {\n            if (chunkIdx == null) {\n              connectionManager._waiting.pop();\n              connectionManager._open.push(id);\n            } else {\n              (function () {\n                var openChunksEntry = connectionManager._openChunks[id] || [];\n                openChunksEntry.push(chunkIdx);\n                connectionManager._openChunks[id] = openChunksEntry;\n              })();\n            }\n            return true;\n          }\n          return false;\n        },\n        reset: function reset() {\n          connectionManager._waiting = [];\n          connectionManager._open = [];\n        }\n      },\n      simple = {\n        send: function send(id, name) {\n          var fileState = handler._getFileState(id);\n          if (!fileState) {\n            log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n            return;\n          }\n          fileState.loaded = 0;\n          log(\"Sending simple upload request for \" + id);\n          handler.uploadFile(id).then(function (response, optXhr) {\n            log(\"Simple upload request succeeded for \" + id);\n            var responseToReport = _upload2.normalizeResponse(response, true),\n              size = options.getSize(id);\n            options.onProgress(id, name, size, size);\n            _upload2.maybeNewUuid(id, responseToReport);\n            _upload2.cleanup(id, responseToReport, optXhr);\n          }, function (response, optXhr) {\n            log(\"Simple upload request failed for \" + id);\n            var responseToReport = _upload2.normalizeResponse(response, false);\n            if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n              _upload2.cleanup(id, responseToReport, optXhr);\n            }\n          });\n        }\n      },\n      _upload2 = {\n        cancel: function cancel(id) {\n          log(\"Cancelling \" + id);\n          options.paramsStore.remove(id);\n          connectionManager.free(id);\n        },\n        cleanup: function cleanup(id, response, optXhr) {\n          var name = options.getName(id);\n          options.onComplete(id, name, response, optXhr);\n          if (handler._getFileState(id)) {\n            handler._clearXhrs && handler._clearXhrs(id);\n          }\n          connectionManager.free(id);\n        },\n        getProxyOrBlob: function getProxyOrBlob(id) {\n          return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n        },\n        initHandler: function initHandler() {\n          var handlerType = namespace ? qq[namespace] : qq.traditional,\n            handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n          handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n            getCustomResumeData: options.getCustomResumeData,\n            getDataByUuid: options.getDataByUuid,\n            getName: options.getName,\n            getSize: options.getSize,\n            getUuid: options.getUuid,\n            log: log,\n            onCancel: options.onCancel,\n            onProgress: options.onProgress,\n            onUuidChanged: options.onUuidChanged,\n            onFinalizing: function onFinalizing(id) {\n              options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n            }\n          });\n          if (handler._removeExpiredChunkingRecords) {\n            handler._removeExpiredChunkingRecords();\n          }\n        },\n        isDeferredEligibleForUpload: function isDeferredEligibleForUpload(id) {\n          return options.isQueued(id);\n        },\n        maybeDefer: function maybeDefer(id, blob) {\n          if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n            options.onUploadPrep(id);\n            log(\"Attempting to generate a blob on-demand for \" + id);\n            blob.create().then(function (generatedBlob) {\n              log(\"Generated an on-demand blob for \" + id);\n              handler.updateBlob(id, generatedBlob);\n              options.setSize(id, generatedBlob.size);\n              handler.reevaluateChunking(id);\n              _upload2.maybeSendDeferredFiles(id);\n            }, function (errorMessage) {\n              var errorResponse = {};\n              if (errorMessage) {\n                errorResponse.error = errorMessage;\n              }\n              log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n              options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n              _upload2.maybeSendDeferredFiles(id);\n              connectionManager.free(id);\n            });\n          } else {\n            return _upload2.maybeSendDeferredFiles(id);\n          }\n          return false;\n        },\n        maybeSendDeferredFiles: function maybeSendDeferredFiles(id) {\n          var idsInGroup = options.getIdsInProxyGroup(id),\n            uploadedThisId = false;\n          if (idsInGroup && idsInGroup.length) {\n            log(\"Maybe ready to upload proxy group file \" + id);\n            qq.each(idsInGroup, function (idx, idInGroup) {\n              if (_upload2.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                uploadedThisId = idInGroup === id;\n                _upload2.now(idInGroup);\n              } else if (_upload2.isDeferredEligibleForUpload(idInGroup)) {\n                return false;\n              }\n            });\n          } else {\n            uploadedThisId = true;\n            _upload2.now(id);\n          }\n          return uploadedThisId;\n        },\n        maybeNewUuid: function maybeNewUuid(id, response) {\n          if (response.newUuid !== undefined) {\n            options.onUuidChanged(id, response.newUuid);\n          }\n        },\n        normalizeResponse: function normalizeResponse(originalResponse, successful) {\n          var response = originalResponse;\n          if (!qq.isObject(originalResponse)) {\n            response = {};\n            if (qq.isString(originalResponse) && !successful) {\n              response.error = originalResponse;\n            }\n          }\n          response.success = successful;\n          return response;\n        },\n        now: function now(id) {\n          var name = options.getName(id);\n          if (!controller.isValid(id)) {\n            throw new qq.Error(id + \" is not a valid file ID to upload!\");\n          }\n          options.onUpload(id, name).then(function (response) {\n            if (response && response.pause) {\n              options.setStatus(id, qq.status.PAUSED);\n              handler.pause(id);\n              connectionManager.free(id);\n            } else {\n              if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                chunked.sendNext(id);\n              } else {\n                simple.send(id, name);\n              }\n            }\n          }, function (error) {\n            error = error || {};\n            log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n            if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n              var response = _upload2.normalizeResponse(error.responseJSON, false);\n              _upload2.cleanup(id, response);\n            }\n          });\n        },\n        start: function start(id) {\n          var blobToUpload = _upload2.getProxyOrBlob(id);\n          if (blobToUpload) {\n            return _upload2.maybeDefer(id, blobToUpload);\n          } else {\n            _upload2.now(id);\n            return true;\n          }\n        }\n      };\n    qq.extend(this, {\n      add: function add(id, file) {\n        handler.add.apply(this, arguments);\n      },\n      upload: function upload(id) {\n        if (connectionManager.open(id)) {\n          return _upload2.start(id);\n        }\n        return false;\n      },\n      retry: function retry(id) {\n        if (concurrentChunkingPossible) {\n          handler._getFileState(id).temp.ignoreFailure = false;\n        }\n        if (connectionManager.isUsingConnection(id)) {\n          return _upload2.start(id);\n        } else {\n          return controller.upload(id);\n        }\n      },\n      cancel: function cancel(id) {\n        var cancelRetVal = handler.cancel(id);\n        if (qq.isGenericPromise(cancelRetVal)) {\n          cancelRetVal.then(function () {\n            _upload2.cancel(id);\n          });\n        } else if (cancelRetVal !== false) {\n          _upload2.cancel(id);\n        }\n      },\n      cancelAll: function cancelAll() {\n        var waitingOrConnected = connectionManager.getWaitingOrConnected(),\n          i;\n        if (waitingOrConnected.length) {\n          for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n            controller.cancel(waitingOrConnected[i]);\n          }\n        }\n        connectionManager.reset();\n      },\n      getFile: function getFile(id) {\n        if (handler.getProxy && handler.getProxy(id)) {\n          return handler.getProxy(id).referenceBlob;\n        }\n        return handler.getFile && handler.getFile(id);\n      },\n      isProxied: function isProxied(id) {\n        return !!(handler.getProxy && handler.getProxy(id));\n      },\n      getInput: function getInput(id) {\n        if (handler.getInput) {\n          return handler.getInput(id);\n        }\n      },\n      reset: function reset() {\n        log(\"Resetting upload handler\");\n        controller.cancelAll();\n        connectionManager.reset();\n        handler.reset();\n      },\n      expunge: function expunge(id) {\n        if (controller.isValid(id)) {\n          return handler.expunge(id);\n        }\n      },\n      isValid: function isValid(id) {\n        return handler.isValid(id);\n      },\n      hasResumeRecord: function hasResumeRecord(id) {\n        var key = handler.isValid(id) && handler._getLocalStorageId && handler._getLocalStorageId(id);\n        if (key) {\n          return !!localStorage.getItem(key);\n        }\n        return false;\n      },\n      getResumableFilesData: function getResumableFilesData() {\n        if (handler.getResumableFilesData) {\n          return handler.getResumableFilesData();\n        }\n        return [];\n      },\n      getThirdPartyFileId: function getThirdPartyFileId(id) {\n        if (controller.isValid(id)) {\n          return handler.getThirdPartyFileId(id);\n        }\n      },\n      pause: function pause(id) {\n        if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n          connectionManager.free(id);\n          handler.moveInProgressToRemaining(id);\n          return true;\n        }\n        return false;\n      },\n      isAttemptingResume: function isAttemptingResume(id) {\n        return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n      },\n      isResumable: function isResumable(id) {\n        return !!handler.isResumable && handler.isResumable(id);\n      }\n    });\n    qq.extend(options, o);\n    log = options.log;\n    chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n    concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n    preventRetryResponse = function () {\n      var response = {};\n      response[options.preventRetryParam] = true;\n      return response;\n    }();\n    _upload2.initHandler();\n  };\n  qq.WindowReceiveMessage = function (o) {\n    \"use strict\";\n\n    var options = {\n        log: function log(message, level) {}\n      },\n      callbackWrapperDetachers = {};\n    qq.extend(options, o);\n    qq.extend(this, {\n      receiveMessage: function receiveMessage(id, callback) {\n        var onMessageCallbackWrapper = function onMessageCallbackWrapper(event) {\n          callback(event.data);\n        };\n        if (window.postMessage) {\n          callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n        } else {\n          log(\"iframe message passing not supported in this browser!\", \"error\");\n        }\n      },\n      stopReceivingMessages: function stopReceivingMessages(id) {\n        if (window.postMessage) {\n          var detacher = callbackWrapperDetachers[id];\n          if (detacher) {\n            detacher();\n          }\n        }\n      }\n    });\n  };\n  qq.FormUploadHandler = function (spec) {\n    \"use strict\";\n\n    var options = spec.options,\n      handler = this,\n      proxy = spec.proxy,\n      formHandlerInstanceId = qq.getUniqueId(),\n      onloadCallbacks = {},\n      detachLoadEvents = {},\n      postMessageCallbackTimers = {},\n      isCors = options.isCors,\n      inputName = options.inputName,\n      getUuid = proxy.getUuid,\n      log = proxy.log,\n      corsMessageReceiver = new qq.WindowReceiveMessage({\n        log: log\n      });\n    function expungeFile(id) {\n      delete detachLoadEvents[id];\n      if (isCors) {\n        clearTimeout(postMessageCallbackTimers[id]);\n        delete postMessageCallbackTimers[id];\n        corsMessageReceiver.stopReceivingMessages(id);\n      }\n      var iframe = document.getElementById(handler._getIframeName(id));\n      if (iframe) {\n        iframe.setAttribute(\"src\", \"javascript:false;\");\n        qq(iframe).remove();\n      }\n    }\n    function getFileIdForIframeName(iframeName) {\n      return iframeName.split(\"_\")[0];\n    }\n    function initIframeForUpload(name) {\n      var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n      iframe.setAttribute(\"id\", name);\n      iframe.style.display = \"none\";\n      document.body.appendChild(iframe);\n      return iframe;\n    }\n    function registerPostMessageCallback(iframe, callback) {\n      var iframeName = iframe.id,\n        fileId = getFileIdForIframeName(iframeName),\n        uuid = getUuid(fileId);\n      onloadCallbacks[uuid] = callback;\n      detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function () {\n        if (handler.getInput(fileId)) {\n          log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n          postMessageCallbackTimers[iframeName] = setTimeout(function () {\n            var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n            log(errorMessage, \"error\");\n            callback({\n              error: errorMessage\n            });\n          }, 1e3);\n        }\n      });\n      corsMessageReceiver.receiveMessage(iframeName, function (message) {\n        log(\"Received the following window message: '\" + message + \"'\");\n        var fileId = getFileIdForIframeName(iframeName),\n          response = handler._parseJsonResponse(message),\n          uuid = response.uuid,\n          onloadCallback;\n        if (uuid && onloadCallbacks[uuid]) {\n          log(\"Handling response for iframe name \" + iframeName);\n          clearTimeout(postMessageCallbackTimers[iframeName]);\n          delete postMessageCallbackTimers[iframeName];\n          handler._detachLoadEvent(iframeName);\n          onloadCallback = onloadCallbacks[uuid];\n          delete onloadCallbacks[uuid];\n          corsMessageReceiver.stopReceivingMessages(iframeName);\n          onloadCallback(response);\n        } else if (!uuid) {\n          log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n        }\n      });\n    }\n    qq.extend(this, new qq.UploadHandler(spec));\n    qq.override(this, function (super_) {\n      return {\n        add: function add(id, fileInput) {\n          super_.add(id, {\n            input: fileInput\n          });\n          fileInput.setAttribute(\"name\", inputName);\n          if (fileInput.parentNode) {\n            qq(fileInput).remove();\n          }\n        },\n        expunge: function expunge(id) {\n          expungeFile(id);\n          super_.expunge(id);\n        },\n        isValid: function isValid(id) {\n          return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n        }\n      };\n    });\n    qq.extend(this, {\n      getInput: function getInput(id) {\n        return handler._getFileState(id).input;\n      },\n      _attachLoadEvent: function _attachLoadEvent(iframe, callback) {\n        var responseDescriptor;\n        if (isCors) {\n          registerPostMessageCallback(iframe, callback);\n        } else {\n          detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function () {\n            log(\"Received response for \" + iframe.id);\n            if (!iframe.parentNode) {\n              return;\n            }\n            try {\n              if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                return;\n              }\n            } catch (error) {\n              log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n              responseDescriptor = {\n                success: false\n              };\n            }\n            callback(responseDescriptor);\n          });\n        }\n      },\n      _createIframe: function _createIframe(id) {\n        var iframeName = handler._getIframeName(id);\n        return initIframeForUpload(iframeName);\n      },\n      _detachLoadEvent: function _detachLoadEvent(id) {\n        if (detachLoadEvents[id] !== undefined) {\n          detachLoadEvents[id]();\n          delete detachLoadEvents[id];\n        }\n      },\n      _getIframeName: function _getIframeName(fileId) {\n        return fileId + \"_\" + formHandlerInstanceId;\n      },\n      _initFormForUpload: function _initFormForUpload(spec) {\n        var method = spec.method,\n          endpoint = spec.endpoint,\n          params = spec.params,\n          paramsInBody = spec.paramsInBody,\n          targetName = spec.targetName,\n          form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"),\n          url = endpoint;\n        if (paramsInBody) {\n          qq.obj2Inputs(params, form);\n        } else {\n          url = qq.obj2url(params, endpoint);\n        }\n        form.setAttribute(\"action\", url);\n        form.setAttribute(\"target\", targetName);\n        form.style.display = \"none\";\n        document.body.appendChild(form);\n        return form;\n      },\n      _parseJsonResponse: function _parseJsonResponse(innerHtmlOrMessage) {\n        var response = {};\n        try {\n          response = qq.parseJson(innerHtmlOrMessage);\n        } catch (error) {\n          log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n        }\n        return response;\n      }\n    });\n  };\n  qq.XhrUploadHandler = function (spec) {\n    \"use strict\";\n\n    var handler = this,\n      namespace = spec.options.namespace,\n      proxy = spec.proxy,\n      chunking = spec.options.chunking,\n      getChunkSize = function getChunkSize(id) {\n        var fileState = handler._getFileState(id);\n        if (fileState.chunkSize) {\n          return fileState.chunkSize;\n        } else {\n          var chunkSize = chunking.partSize;\n          if (qq.isFunction(chunkSize)) {\n            chunkSize = chunkSize(id, getSize(id));\n          }\n          fileState.chunkSize = chunkSize;\n          return chunkSize;\n        }\n      },\n      resume = spec.options.resume,\n      chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking,\n      resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume,\n      getName = proxy.getName,\n      getSize = proxy.getSize,\n      getUuid = proxy.getUuid,\n      getEndpoint = proxy.getEndpoint,\n      getDataByUuid = proxy.getDataByUuid,\n      onUuidChanged = proxy.onUuidChanged,\n      onProgress = proxy.onProgress,\n      log = proxy.log,\n      getCustomResumeData = proxy.getCustomResumeData;\n    function abort(id) {\n      qq.each(handler._getXhrs(id), function (xhrId, xhr) {\n        var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n        xhr.onreadystatechange = null;\n        xhr.upload.onprogress = null;\n        xhr.abort();\n        ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n      });\n    }\n    qq.extend(this, new qq.UploadHandler(spec));\n    qq.override(this, function (super_) {\n      return {\n        add: function add(id, blobOrProxy) {\n          if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n            super_.add(id, {\n              file: blobOrProxy\n            });\n          } else if (blobOrProxy instanceof qq.BlobProxy) {\n            super_.add(id, {\n              proxy: blobOrProxy\n            });\n          } else {\n            throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n          }\n          handler._initTempState(id);\n          resumeEnabled && handler._maybePrepareForResume(id);\n        },\n        expunge: function expunge(id) {\n          abort(id);\n          handler._maybeDeletePersistedChunkData(id);\n          handler._clearXhrs(id);\n          super_.expunge(id);\n        }\n      };\n    });\n    qq.extend(this, {\n      clearCachedChunk: function clearCachedChunk(id, chunkIdx) {\n        var fileState = handler._getFileState(id);\n        if (fileState) {\n          delete fileState.temp.cachedChunks[chunkIdx];\n        }\n      },\n      clearXhr: function clearXhr(id, chunkIdx) {\n        var tempState = handler._getFileState(id).temp;\n        if (tempState.xhrs) {\n          delete tempState.xhrs[chunkIdx];\n        }\n        if (tempState.ajaxRequesters) {\n          delete tempState.ajaxRequesters[chunkIdx];\n        }\n      },\n      finalizeChunks: function finalizeChunks(id, responseParser) {\n        var lastChunkIdx = handler._getTotalChunks(id) - 1,\n          xhr = handler._getXhr(id, lastChunkIdx);\n        if (responseParser) {\n          return new qq.Promise().success(responseParser(xhr), xhr);\n        }\n        return new qq.Promise().success({}, xhr);\n      },\n      getFile: function getFile(id) {\n        return handler.isValid(id) && handler._getFileState(id).file;\n      },\n      getProxy: function getProxy(id) {\n        return handler.isValid(id) && handler._getFileState(id).proxy;\n      },\n      getResumableFilesData: function getResumableFilesData() {\n        var resumableFilesData = [];\n        handler._iterateResumeRecords(function (key, uploadData) {\n          handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n          var data = {\n            name: uploadData.name,\n            remaining: uploadData.chunking.remaining,\n            size: uploadData.size,\n            uuid: uploadData.uuid\n          };\n          if (uploadData.key) {\n            data.key = uploadData.key;\n          }\n          if (uploadData.customResumeData) {\n            data.customResumeData = uploadData.customResumeData;\n          }\n          resumableFilesData.push(data);\n        });\n        return resumableFilesData;\n      },\n      isAttemptingResume: function isAttemptingResume(id) {\n        return handler._getFileState(id).attemptingResume;\n      },\n      isResumable: function isResumable(id) {\n        return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n      },\n      moveInProgressToRemaining: function moveInProgressToRemaining(id, optInProgress, optRemaining) {\n        var fileState = handler._getFileState(id) || {},\n          chunkingState = fileState.chunking || {},\n          inProgress = optInProgress || chunkingState.inProgress,\n          remaining = optRemaining || chunkingState.remaining;\n        if (inProgress) {\n          log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n          inProgress.reverse();\n          qq.each(inProgress, function (idx, chunkIdx) {\n            remaining.unshift(chunkIdx);\n          });\n          inProgress.length = 0;\n        }\n      },\n      pause: function pause(id) {\n        if (handler.isValid(id)) {\n          log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n          handler._getFileState(id).paused = true;\n          abort(id);\n          return true;\n        }\n      },\n      reevaluateChunking: function reevaluateChunking(id) {\n        if (chunking && handler.isValid(id)) {\n          var state = handler._getFileState(id),\n            totalChunks,\n            i;\n          delete state.chunking;\n          state.chunking = {};\n          totalChunks = handler._getTotalChunks(id);\n          if (totalChunks > 1 || chunking.mandatory) {\n            state.chunking.enabled = true;\n            state.chunking.parts = totalChunks;\n            state.chunking.remaining = [];\n            for (i = 0; i < totalChunks; i++) {\n              state.chunking.remaining.push(i);\n            }\n            handler._initTempState(id);\n          } else {\n            state.chunking.enabled = false;\n          }\n        }\n      },\n      updateBlob: function updateBlob(id, newBlob) {\n        if (handler.isValid(id)) {\n          handler._getFileState(id).file = newBlob;\n        }\n      },\n      _clearXhrs: function _clearXhrs(id) {\n        var tempState = handler._getFileState(id).temp;\n        qq.each(tempState.ajaxRequesters, function (chunkId) {\n          delete tempState.ajaxRequesters[chunkId];\n        });\n        qq.each(tempState.xhrs, function (chunkId) {\n          delete tempState.xhrs[chunkId];\n        });\n      },\n      _createXhr: function _createXhr(id, optChunkIdx) {\n        return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n      },\n      _getAjaxRequester: function _getAjaxRequester(id, optChunkIdx) {\n        var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n        return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n      },\n      _getChunkData: function _getChunkData(id, chunkIndex) {\n        var chunkSize = getChunkSize(id),\n          fileSize = getSize(id),\n          fileOrBlob = handler.getFile(id),\n          startBytes = chunkSize * chunkIndex,\n          endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize,\n          totalChunks = handler._getTotalChunks(id),\n          cachedChunks = this._getFileState(id).temp.cachedChunks,\n          blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n        cachedChunks[chunkIndex] = blob;\n        return {\n          part: chunkIndex,\n          start: startBytes,\n          end: endBytes,\n          count: totalChunks,\n          blob: blob,\n          size: endBytes - startBytes\n        };\n      },\n      _getChunkDataForCallback: function _getChunkDataForCallback(chunkData) {\n        return {\n          partIndex: chunkData.part,\n          startByte: chunkData.start + 1,\n          endByte: chunkData.end,\n          totalParts: chunkData.count\n        };\n      },\n      _getLocalStorageId: function _getLocalStorageId(id) {\n        var formatVersion = \"5.0\",\n          name = getName(id),\n          size = getSize(id),\n          chunkSize = getChunkSize(id),\n          endpoint = getEndpoint(id),\n          customKeys = resume.customKeys(id),\n          localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n        customKeys.forEach(function (key) {\n          localStorageId += \"-\" + key;\n        });\n        return localStorageId;\n      },\n      _getMimeType: function _getMimeType(id) {\n        return handler.getFile(id).type;\n      },\n      _getPersistableData: function _getPersistableData(id) {\n        return handler._getFileState(id).chunking;\n      },\n      _getTotalChunks: function _getTotalChunks(id) {\n        if (chunking) {\n          var fileSize = getSize(id),\n            chunkSize = getChunkSize(id);\n          return Math.ceil(fileSize / chunkSize);\n        }\n      },\n      _getXhr: function _getXhr(id, optChunkIdx) {\n        var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n        return handler._getFileState(id).temp.xhrs[chunkIdx];\n      },\n      _getXhrs: function _getXhrs(id) {\n        return handler._getFileState(id).temp.xhrs;\n      },\n      _iterateResumeRecords: function _iterateResumeRecords(callback) {\n        if (resumeEnabled) {\n          qq.each(localStorage, function (key, item) {\n            if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n              var uploadData = JSON.parse(item);\n              callback(key, uploadData);\n            }\n          });\n        }\n      },\n      _initTempState: function _initTempState(id) {\n        handler._getFileState(id).temp = {\n          ajaxRequesters: {},\n          chunkProgress: {},\n          xhrs: {},\n          cachedChunks: {}\n        };\n      },\n      _markNotResumable: function _markNotResumable(id) {\n        handler._getFileState(id).notResumable = true;\n      },\n      _maybeDeletePersistedChunkData: function _maybeDeletePersistedChunkData(id) {\n        var localStorageId;\n        if (resumeEnabled && handler.isResumable(id)) {\n          localStorageId = handler._getLocalStorageId(id);\n          if (localStorageId && localStorage.getItem(localStorageId)) {\n            localStorage.removeItem(localStorageId);\n            return true;\n          }\n        }\n        return false;\n      },\n      _maybePrepareForResume: function _maybePrepareForResume(id) {\n        var state = handler._getFileState(id),\n          localStorageId,\n          persistedData;\n        if (resumeEnabled && state.key === undefined) {\n          localStorageId = handler._getLocalStorageId(id);\n          persistedData = localStorage.getItem(localStorageId);\n          if (persistedData) {\n            persistedData = JSON.parse(persistedData);\n            if (getDataByUuid(persistedData.uuid)) {\n              handler._markNotResumable(id);\n            } else {\n              log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n              onUuidChanged(id, persistedData.uuid);\n              state.key = persistedData.key;\n              state.chunking = persistedData.chunking;\n              state.loaded = persistedData.loaded;\n              state.customResumeData = persistedData.customResumeData;\n              state.attemptingResume = true;\n              handler.moveInProgressToRemaining(id);\n            }\n          }\n        }\n      },\n      _maybePersistChunkedState: function _maybePersistChunkedState(id) {\n        var state = handler._getFileState(id),\n          localStorageId,\n          persistedData;\n        if (resumeEnabled && handler.isResumable(id)) {\n          var customResumeData = getCustomResumeData(id);\n          localStorageId = handler._getLocalStorageId(id);\n          persistedData = {\n            name: getName(id),\n            size: getSize(id),\n            uuid: getUuid(id),\n            key: state.key,\n            chunking: state.chunking,\n            loaded: state.loaded,\n            lastUpdated: Date.now()\n          };\n          if (customResumeData) {\n            persistedData.customResumeData = customResumeData;\n          }\n          try {\n            localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n          } catch (error) {\n            log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n          }\n        }\n      },\n      _registerProgressHandler: function _registerProgressHandler(id, chunkIdx, chunkSize) {\n        var xhr = handler._getXhr(id, chunkIdx),\n          name = getName(id),\n          progressCalculator = {\n            simple: function simple(loaded, total) {\n              var fileSize = getSize(id);\n              if (loaded === total) {\n                onProgress(id, name, fileSize, fileSize);\n              } else {\n                onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n              }\n            },\n            chunked: function chunked(loaded, total) {\n              var chunkProgress = handler._getFileState(id).temp.chunkProgress,\n                totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded,\n                loadedForRequest = loaded,\n                totalForRequest = total,\n                totalFileSize = getSize(id),\n                estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize),\n                totalLoadedForFile = totalSuccessfullyLoadedForFile;\n              chunkProgress[chunkIdx] = estActualChunkLoaded;\n              qq.each(chunkProgress, function (chunkIdx, chunkLoaded) {\n                totalLoadedForFile += chunkLoaded;\n              });\n              onProgress(id, name, totalLoadedForFile, totalFileSize);\n            }\n          };\n        xhr.upload.onprogress = function (e) {\n          if (e.lengthComputable) {\n            var type = chunkSize == null ? \"simple\" : \"chunked\";\n            progressCalculator[type](e.loaded, e.total);\n          }\n        };\n      },\n      _registerXhr: function _registerXhr(id, optChunkIdx, xhr, optAjaxRequester) {\n        var xhrsId = optChunkIdx == null ? -1 : optChunkIdx,\n          tempState = handler._getFileState(id).temp;\n        tempState.xhrs = tempState.xhrs || {};\n        tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n        tempState.xhrs[xhrsId] = xhr;\n        if (optAjaxRequester) {\n          tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n        }\n        return xhr;\n      },\n      _removeExpiredChunkingRecords: function _removeExpiredChunkingRecords() {\n        var expirationDays = resume.recordsExpireIn;\n        handler._iterateResumeRecords(function (key, uploadData) {\n          var expirationDate = new Date(uploadData.lastUpdated);\n          expirationDate.setDate(expirationDate.getDate() + expirationDays);\n          if (expirationDate.getTime() <= Date.now()) {\n            log(\"Removing expired resume record with key \" + key);\n            localStorage.removeItem(key);\n          }\n        });\n      },\n      _shouldChunkThisFile: function _shouldChunkThisFile(id) {\n        var state = handler._getFileState(id);\n        if (state) {\n          if (!state.chunking) {\n            handler.reevaluateChunking(id);\n          }\n          return state.chunking.enabled;\n        }\n      }\n    });\n  };\n  qq.DeleteFileAjaxRequester = function (o) {\n    \"use strict\";\n\n    var requester,\n      options = {\n        method: \"DELETE\",\n        uuidParamName: \"qquuid\",\n        endpointStore: {},\n        maxConnections: 3,\n        customHeaders: function customHeaders(id) {\n          return {};\n        },\n        paramsStore: {},\n        cors: {\n          expected: false,\n          sendCredentials: false\n        },\n        log: function log(str, level) {},\n        onDelete: function onDelete(id) {},\n        onDeleteComplete: function onDeleteComplete(id, xhrOrXdr, isError) {}\n      };\n    qq.extend(options, o);\n    function getMandatedParams() {\n      if (options.method.toUpperCase() === \"POST\") {\n        return {\n          _method: \"DELETE\"\n        };\n      }\n      return {};\n    }\n    requester = qq.extend(this, new qq.AjaxRequester({\n      acceptHeader: \"application/json\",\n      validMethods: [\"POST\", \"DELETE\"],\n      method: options.method,\n      endpointStore: options.endpointStore,\n      paramsStore: options.paramsStore,\n      mandatedParams: getMandatedParams(),\n      maxConnections: options.maxConnections,\n      customHeaders: function customHeaders(id) {\n        return options.customHeaders.get(id);\n      },\n      log: options.log,\n      onSend: options.onDelete,\n      onComplete: options.onDeleteComplete,\n      cors: options.cors\n    }));\n    qq.extend(this, {\n      sendDelete: function sendDelete(id, uuid, additionalMandatedParams) {\n        var additionalOptions = additionalMandatedParams || {};\n        options.log(\"Submitting delete file request for \" + id);\n        if (options.method === \"DELETE\") {\n          requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n        } else {\n          additionalOptions[options.uuidParamName] = uuid;\n          requester.initTransport(id).withParams(additionalOptions).send();\n        }\n      }\n    });\n  };\n  (function () {\n    function detectSubsampling(img) {\n      var iw = img.naturalWidth,\n        ih = img.naturalHeight,\n        canvas = document.createElement(\"canvas\"),\n        ctx;\n      if (iw * ih > 1024 * 1024) {\n        canvas.width = canvas.height = 1;\n        ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, -iw + 1, 0);\n        return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n      } else {\n        return false;\n      }\n    }\n    function detectVerticalSquash(img, iw, ih) {\n      var canvas = document.createElement(\"canvas\"),\n        sy = 0,\n        ey = ih,\n        py = ih,\n        ctx,\n        data,\n        alpha,\n        ratio;\n      canvas.width = 1;\n      canvas.height = ih;\n      ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(img, 0, 0);\n      data = ctx.getImageData(0, 0, 1, ih).data;\n      while (py > sy) {\n        alpha = data[(py - 1) * 4 + 3];\n        if (alpha === 0) {\n          ey = py;\n        } else {\n          sy = py;\n        }\n        py = ey + sy >> 1;\n      }\n      ratio = py / ih;\n      return ratio === 0 ? 1 : ratio;\n    }\n    function renderImageToDataURL(img, blob, options, doSquash) {\n      var canvas = document.createElement(\"canvas\"),\n        mime = options.mime || \"image/jpeg\",\n        promise = new qq.Promise();\n      renderImageToCanvas(img, blob, canvas, options, doSquash).then(function () {\n        promise.success(canvas.toDataURL(mime, options.quality || .8));\n      });\n      return promise;\n    }\n    function maybeCalculateDownsampledDimensions(spec) {\n      var maxPixels = 5241e3;\n      if (!qq.ios()) {\n        throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n      }\n      if (spec.origHeight * spec.origWidth > maxPixels) {\n        return {\n          newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n          newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n        };\n      }\n    }\n    function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n      var iw = img.naturalWidth,\n        ih = img.naturalHeight,\n        width = options.width,\n        height = options.height,\n        ctx = canvas.getContext(\"2d\"),\n        promise = new qq.Promise(),\n        modifiedDimensions;\n      ctx.save();\n      if (options.resize) {\n        return renderImageToCanvasWithCustomResizer({\n          blob: blob,\n          canvas: canvas,\n          image: img,\n          imageHeight: ih,\n          imageWidth: iw,\n          orientation: options.orientation,\n          resize: options.resize,\n          targetHeight: height,\n          targetWidth: width\n        });\n      }\n      if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n        modifiedDimensions = maybeCalculateDownsampledDimensions({\n          origWidth: width,\n          origHeight: height\n        });\n        if (modifiedDimensions) {\n          qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n          width = modifiedDimensions.newWidth;\n          height = modifiedDimensions.newHeight;\n        }\n      }\n      transformCoordinate(canvas, width, height, options.orientation);\n      if (qq.ios()) {\n        (function () {\n          if (detectSubsampling(img)) {\n            iw /= 2;\n            ih /= 2;\n          }\n          var d = 1024,\n            tmpCanvas = document.createElement(\"canvas\"),\n            vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1,\n            dw = Math.ceil(d * width / iw),\n            dh = Math.ceil(d * height / ih / vertSquashRatio),\n            sy = 0,\n            dy = 0,\n            tmpCtx,\n            sx,\n            dx;\n          tmpCanvas.width = tmpCanvas.height = d;\n          tmpCtx = tmpCanvas.getContext(\"2d\");\n          while (sy < ih) {\n            sx = 0;\n            dx = 0;\n            while (sx < iw) {\n              tmpCtx.clearRect(0, 0, d, d);\n              tmpCtx.drawImage(img, -sx, -sy);\n              ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n              sx += d;\n              dx += dw;\n            }\n            sy += d;\n            dy += dh;\n          }\n          ctx.restore();\n          tmpCanvas = tmpCtx = null;\n        })();\n      } else {\n        ctx.drawImage(img, 0, 0, width, height);\n      }\n      canvas.qqImageRendered && canvas.qqImageRendered();\n      promise.success();\n      return promise;\n    }\n    function renderImageToCanvasWithCustomResizer(resizeInfo) {\n      var blob = resizeInfo.blob,\n        image = resizeInfo.image,\n        imageHeight = resizeInfo.imageHeight,\n        imageWidth = resizeInfo.imageWidth,\n        orientation = resizeInfo.orientation,\n        promise = new qq.Promise(),\n        resize = resizeInfo.resize,\n        sourceCanvas = document.createElement(\"canvas\"),\n        sourceCanvasContext = sourceCanvas.getContext(\"2d\"),\n        targetCanvas = resizeInfo.canvas,\n        targetHeight = resizeInfo.targetHeight,\n        targetWidth = resizeInfo.targetWidth;\n      transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n      targetCanvas.height = targetHeight;\n      targetCanvas.width = targetWidth;\n      sourceCanvasContext.drawImage(image, 0, 0);\n      resize({\n        blob: blob,\n        height: targetHeight,\n        image: image,\n        sourceCanvas: sourceCanvas,\n        targetCanvas: targetCanvas,\n        width: targetWidth\n      }).then(function success() {\n        targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n        promise.success();\n      }, promise.failure);\n      return promise;\n    }\n    function transformCoordinate(canvas, width, height, orientation) {\n      switch (orientation) {\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n          canvas.width = height;\n          canvas.height = width;\n          break;\n        default:\n          canvas.width = width;\n          canvas.height = height;\n      }\n      var ctx = canvas.getContext(\"2d\");\n      switch (orientation) {\n        case 2:\n          ctx.translate(width, 0);\n          ctx.scale(-1, 1);\n          break;\n        case 3:\n          ctx.translate(width, height);\n          ctx.rotate(Math.PI);\n          break;\n        case 4:\n          ctx.translate(0, height);\n          ctx.scale(1, -1);\n          break;\n        case 5:\n          ctx.rotate(.5 * Math.PI);\n          ctx.scale(1, -1);\n          break;\n        case 6:\n          ctx.rotate(.5 * Math.PI);\n          ctx.translate(0, -height);\n          break;\n        case 7:\n          ctx.rotate(.5 * Math.PI);\n          ctx.translate(width, -height);\n          ctx.scale(-1, 1);\n          break;\n        case 8:\n          ctx.rotate(-.5 * Math.PI);\n          ctx.translate(-width, 0);\n          break;\n        default:\n          break;\n      }\n    }\n    function MegaPixImage(srcImage, errorCallback) {\n      var self = this;\n      if (window.Blob && srcImage instanceof Blob) {\n        (function () {\n          var img = new Image(),\n            URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n          if (!URL) {\n            throw Error(\"No createObjectURL function found to create blob url\");\n          }\n          img.src = URL.createObjectURL(srcImage);\n          self.blob = srcImage;\n          srcImage = img;\n        })();\n      }\n      if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n        srcImage.onload = function () {\n          var listeners = self.imageLoadListeners;\n          if (listeners) {\n            self.imageLoadListeners = null;\n            setTimeout(function () {\n              for (var i = 0, len = listeners.length; i < len; i++) {\n                listeners[i]();\n              }\n            }, 0);\n          }\n        };\n        srcImage.onerror = errorCallback;\n        this.imageLoadListeners = [];\n      }\n      this.srcImage = srcImage;\n    }\n    MegaPixImage.prototype.render = function (target, options) {\n      options = options || {};\n      var self = this,\n        imgWidth = this.srcImage.naturalWidth,\n        imgHeight = this.srcImage.naturalHeight,\n        width = options.width,\n        height = options.height,\n        maxWidth = options.maxWidth,\n        maxHeight = options.maxHeight,\n        doSquash = !this.blob || this.blob.type === \"image/jpeg\",\n        tagName = target.tagName.toLowerCase(),\n        opt;\n      if (this.imageLoadListeners) {\n        this.imageLoadListeners.push(function () {\n          self.render(target, options);\n        });\n        return;\n      }\n      if (width && !height) {\n        height = imgHeight * width / imgWidth << 0;\n      } else if (height && !width) {\n        width = imgWidth * height / imgHeight << 0;\n      } else {\n        width = imgWidth;\n        height = imgHeight;\n      }\n      if (maxWidth && width > maxWidth) {\n        width = maxWidth;\n        height = imgHeight * width / imgWidth << 0;\n      }\n      if (maxHeight && height > maxHeight) {\n        height = maxHeight;\n        width = imgWidth * height / imgHeight << 0;\n      }\n      opt = {\n        width: width,\n        height: height\n      }, qq.each(options, function (optionsKey, optionsValue) {\n        opt[optionsKey] = optionsValue;\n      });\n      if (tagName === \"img\") {\n        (function () {\n          var oldTargetSrc = target.src;\n          renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function (dataUri) {\n            target.src = dataUri;\n            oldTargetSrc === target.src && target.onload();\n          });\n        })();\n      } else if (tagName === \"canvas\") {\n        renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n      }\n      if (typeof this.onrender === \"function\") {\n        this.onrender(target);\n      }\n    };\n    qq.MegaPixImage = MegaPixImage;\n  })();\n  qq.ImageGenerator = function (log) {\n    \"use strict\";\n\n    function isImg(el) {\n      return el.tagName.toLowerCase() === \"img\";\n    }\n    function isCanvas(el) {\n      return el.tagName.toLowerCase() === \"canvas\";\n    }\n    function isImgCorsSupported() {\n      return new Image().crossOrigin !== undefined;\n    }\n    function isCanvasSupported() {\n      var canvas = document.createElement(\"canvas\");\n      return canvas.getContext && canvas.getContext(\"2d\");\n    }\n    function determineMimeOfFileName(nameWithPath) {\n      var pathSegments = nameWithPath.split(\"/\"),\n        name = pathSegments[pathSegments.length - 1].split(\"?\")[0],\n        extension = qq.getExtension(name);\n      extension = extension && extension.toLowerCase();\n      switch (extension) {\n        case \"jpeg\":\n        case \"jpg\":\n          return \"image/jpeg\";\n        case \"png\":\n          return \"image/png\";\n        case \"bmp\":\n          return \"image/bmp\";\n        case \"gif\":\n          return \"image/gif\";\n        case \"tiff\":\n        case \"tif\":\n          return \"image/tiff\";\n      }\n    }\n    function isCrossOrigin(url) {\n      var targetAnchor = document.createElement(\"a\"),\n        targetProtocol,\n        targetHostname,\n        targetPort;\n      targetAnchor.href = url;\n      targetProtocol = targetAnchor.protocol;\n      targetPort = targetAnchor.port;\n      targetHostname = targetAnchor.hostname;\n      if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n        return true;\n      }\n      if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n        return true;\n      }\n      if (targetPort !== window.location.port && !qq.ie()) {\n        return true;\n      }\n      return false;\n    }\n    function registerImgLoadListeners(img, promise) {\n      img.onload = function () {\n        img.onload = null;\n        img.onerror = null;\n        promise.success(img);\n      };\n      img.onerror = function () {\n        img.onload = null;\n        img.onerror = null;\n        log(\"Problem drawing thumbnail!\", \"error\");\n        promise.failure(img, \"Problem drawing thumbnail!\");\n      };\n    }\n    function registerCanvasDrawImageListener(canvas, promise) {\n      canvas.qqImageRendered = function () {\n        promise.success(canvas);\n      };\n    }\n    function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n      var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n      if (isImg(imgOrCanvas)) {\n        registerImgLoadListeners(imgOrCanvas, promise);\n      } else if (isCanvas(imgOrCanvas)) {\n        registerCanvasDrawImageListener(imgOrCanvas, promise);\n      } else {\n        promise.failure(imgOrCanvas);\n        log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n      }\n      return registered;\n    }\n    function draw(fileOrBlob, container, options) {\n      var drawPreview = new qq.Promise(),\n        identifier = new qq.Identify(fileOrBlob, log),\n        maxSize = options.maxSize,\n        orient = options.orient == null ? true : options.orient,\n        megapixErrorHandler = function megapixErrorHandler() {\n          container.onerror = null;\n          container.onload = null;\n          log(\"Could not render preview, file may be too large!\", \"error\");\n          drawPreview.failure(container, \"Browser cannot render image!\");\n        };\n      identifier.isPreviewable().then(function (mime) {\n        var dummyExif = {\n            parse: function parse() {\n              return new qq.Promise().success();\n            }\n          },\n          exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif,\n          mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n        if (registerThumbnailRenderedListener(container, drawPreview)) {\n          exif.parse().then(function (exif) {\n            var orientation = exif && exif.Orientation;\n            mpImg.render(container, {\n              maxWidth: maxSize,\n              maxHeight: maxSize,\n              orientation: orientation,\n              mime: mime,\n              resize: options.customResizeFunction\n            });\n          }, function (failureMsg) {\n            log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n            mpImg.render(container, {\n              maxWidth: maxSize,\n              maxHeight: maxSize,\n              mime: mime,\n              resize: options.customResizeFunction\n            });\n          });\n        }\n      }, function () {\n        log(\"Not previewable\");\n        drawPreview.failure(container, \"Not previewable\");\n      });\n      return drawPreview;\n    }\n    function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n      var tempImg = new Image(),\n        tempImgRender = new qq.Promise();\n      registerThumbnailRenderedListener(tempImg, tempImgRender);\n      if (isCrossOrigin(url)) {\n        tempImg.crossOrigin = \"anonymous\";\n      }\n      tempImg.src = url;\n      tempImgRender.then(function rendered() {\n        registerThumbnailRenderedListener(canvasOrImg, draw);\n        var mpImg = new qq.MegaPixImage(tempImg);\n        mpImg.render(canvasOrImg, {\n          maxWidth: maxSize,\n          maxHeight: maxSize,\n          mime: determineMimeOfFileName(url),\n          resize: customResizeFunction\n        });\n      }, draw.failure);\n    }\n    function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n      registerThumbnailRenderedListener(img, draw);\n      qq(img).css({\n        maxWidth: maxSize + \"px\",\n        maxHeight: maxSize + \"px\"\n      });\n      img.src = url;\n    }\n    function drawFromUrl(url, container, options) {\n      var draw = new qq.Promise(),\n        scale = options.scale,\n        maxSize = scale ? options.maxSize : null;\n      if (scale && isImg(container)) {\n        if (isCanvasSupported()) {\n          if (isCrossOrigin(url) && !isImgCorsSupported()) {\n            drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n          } else {\n            drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n          }\n        } else {\n          drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n        }\n      } else if (isCanvas(container)) {\n        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n      } else if (registerThumbnailRenderedListener(container, draw)) {\n        container.src = url;\n      }\n      return draw;\n    }\n    qq.extend(this, {\n      generate: function generate(fileBlobOrUrl, container, options) {\n        if (qq.isString(fileBlobOrUrl)) {\n          log(\"Attempting to update thumbnail based on server response.\");\n          return drawFromUrl(fileBlobOrUrl, container, options || {});\n        } else {\n          log(\"Attempting to draw client-side image preview.\");\n          return draw(fileBlobOrUrl, container, options || {});\n        }\n      }\n    });\n    this._testing = {};\n    this._testing.isImg = isImg;\n    this._testing.isCanvas = isCanvas;\n    this._testing.isCrossOrigin = isCrossOrigin;\n    this._testing.determineMimeOfFileName = determineMimeOfFileName;\n  };\n  qq.Exif = function (fileOrBlob, log) {\n    \"use strict\";\n\n    var TAG_IDS = [274],\n      TAG_INFO = {\n        274: {\n          name: \"Orientation\",\n          bytes: 2\n        }\n      };\n    function parseLittleEndian(hex) {\n      var result = 0,\n        pow = 0;\n      while (hex.length > 0) {\n        result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n        hex = hex.substring(2, hex.length);\n        pow += 8;\n      }\n      return result;\n    }\n    function seekToApp1(offset, promise) {\n      var theOffset = offset,\n        thePromise = promise;\n      if (theOffset === undefined) {\n        theOffset = 2;\n        thePromise = new qq.Promise();\n      }\n      qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function (hex) {\n        var match = /^ffe([0-9])/.exec(hex),\n          segmentLength;\n        if (match) {\n          if (match[1] !== \"1\") {\n            segmentLength = parseInt(hex.slice(4, 8), 16);\n            seekToApp1(theOffset + segmentLength + 2, thePromise);\n          } else {\n            thePromise.success(theOffset);\n          }\n        } else {\n          thePromise.failure(\"No EXIF header to be found!\");\n        }\n      });\n      return thePromise;\n    }\n    function getApp1Offset() {\n      var promise = new qq.Promise();\n      qq.readBlobToHex(fileOrBlob, 0, 6).then(function (hex) {\n        if (hex.indexOf(\"ffd8\") !== 0) {\n          promise.failure(\"Not a valid JPEG!\");\n        } else {\n          seekToApp1().then(function (offset) {\n            promise.success(offset);\n          }, function (error) {\n            promise.failure(error);\n          });\n        }\n      });\n      return promise;\n    }\n    function isLittleEndian(app1Start) {\n      var promise = new qq.Promise();\n      qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function (hex) {\n        promise.success(hex === \"4949\");\n      });\n      return promise;\n    }\n    function getDirEntryCount(app1Start, littleEndian) {\n      var promise = new qq.Promise();\n      qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function (hex) {\n        if (littleEndian) {\n          return promise.success(parseLittleEndian(hex));\n        } else {\n          promise.success(parseInt(hex, 16));\n        }\n      });\n      return promise;\n    }\n    function getIfd(app1Start, dirEntries) {\n      var offset = app1Start + 20,\n        bytes = dirEntries * 12;\n      return qq.readBlobToHex(fileOrBlob, offset, bytes);\n    }\n    function getDirEntries(ifdHex) {\n      var entries = [],\n        offset = 0;\n      while (offset + 24 <= ifdHex.length) {\n        entries.push(ifdHex.slice(offset, offset + 24));\n        offset += 24;\n      }\n      return entries;\n    }\n    function getTagValues(littleEndian, dirEntries) {\n      var TAG_VAL_OFFSET = 16,\n        tagsToFind = qq.extend([], TAG_IDS),\n        vals = {};\n      qq.each(dirEntries, function (idx, entry) {\n        var idHex = entry.slice(0, 4),\n          id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16),\n          tagsToFindIdx = tagsToFind.indexOf(id),\n          tagValHex,\n          tagName,\n          tagValLength;\n        if (tagsToFindIdx >= 0) {\n          tagName = TAG_INFO[id].name;\n          tagValLength = TAG_INFO[id].bytes;\n          tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n          vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n          tagsToFind.splice(tagsToFindIdx, 1);\n        }\n        if (tagsToFind.length === 0) {\n          return false;\n        }\n      });\n      return vals;\n    }\n    qq.extend(this, {\n      parse: function parse() {\n        var parser = new qq.Promise(),\n          onParseFailure = function onParseFailure(message) {\n            log(qq.format(\"EXIF header parse failed: '{}' \", message));\n            parser.failure(message);\n          };\n        getApp1Offset().then(function (app1Offset) {\n          log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n          isLittleEndian(app1Offset).then(function (littleEndian) {\n            log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n            getDirEntryCount(app1Offset, littleEndian).then(function (dirEntryCount) {\n              log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n              getIfd(app1Offset, dirEntryCount).then(function (ifdHex) {\n                var dirEntries = getDirEntries(ifdHex),\n                  tagValues = getTagValues(littleEndian, dirEntries);\n                log(\"Successfully parsed some EXIF tags\");\n                parser.success(tagValues);\n              }, onParseFailure);\n            }, onParseFailure);\n          }, onParseFailure);\n        }, onParseFailure);\n        return parser;\n      }\n    });\n    this._testing = {};\n    this._testing.parseLittleEndian = parseLittleEndian;\n  };\n  qq.Identify = function (fileOrBlob, log) {\n    \"use strict\";\n\n    function isIdentifiable(magicBytes, questionableBytes) {\n      var identifiable = false,\n        magicBytesEntries = [].concat(magicBytes);\n      qq.each(magicBytesEntries, function (idx, magicBytesArrayEntry) {\n        if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n          identifiable = true;\n          return false;\n        }\n      });\n      return identifiable;\n    }\n    qq.extend(this, {\n      isPreviewable: function isPreviewable() {\n        var self = this,\n          identifier = new qq.Promise(),\n          previewable = false,\n          name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n        log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n        log(\"First pass: check type attribute of blob object.\");\n        if (this.isPreviewableSync()) {\n          log(\"Second pass: check for magic bytes in file header.\");\n          qq.readBlobToHex(fileOrBlob, 0, 4).then(function (hex) {\n            qq.each(self.PREVIEWABLE_MIME_TYPES, function (mime, bytes) {\n              if (isIdentifiable(bytes, hex)) {\n                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                  previewable = true;\n                  identifier.success(mime);\n                }\n                return false;\n              }\n            });\n            log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n            if (!previewable) {\n              identifier.failure();\n            }\n          }, function () {\n            log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n            identifier.failure();\n          });\n        } else {\n          identifier.failure();\n        }\n        return identifier;\n      },\n      isPreviewableSync: function isPreviewableSync() {\n        var fileMime = fileOrBlob.type,\n          isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0,\n          previewable = false,\n          name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n        if (isRecognizedImage) {\n          if (fileMime === \"image/tiff\") {\n            previewable = qq.supportedFeatures.tiffPreviews;\n          } else {\n            previewable = true;\n          }\n        }\n        !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n        return previewable;\n      }\n    });\n  };\n  qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n    \"image/jpeg\": \"ffd8ff\",\n    \"image/gif\": \"474946\",\n    \"image/png\": \"89504e\",\n    \"image/bmp\": \"424d\",\n    \"image/tiff\": [\"49492a00\", \"4d4d002a\"]\n  };\n  qq.ImageValidation = function (blob, log) {\n    \"use strict\";\n\n    function hasNonZeroLimits(limits) {\n      var atLeastOne = false;\n      qq.each(limits, function (limit, value) {\n        if (value > 0) {\n          atLeastOne = true;\n          return false;\n        }\n      });\n      return atLeastOne;\n    }\n    function getWidthHeight() {\n      var sizeDetermination = new qq.Promise();\n      new qq.Identify(blob, log).isPreviewable().then(function () {\n        var image = new Image(),\n          url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n        if (url) {\n          image.onerror = function () {\n            log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n            sizeDetermination.failure();\n          };\n          image.onload = function () {\n            sizeDetermination.success({\n              width: this.width,\n              height: this.height\n            });\n          };\n          image.src = url.createObjectURL(blob);\n        } else {\n          log(\"No createObjectURL function available to generate image URL!\", \"error\");\n          sizeDetermination.failure();\n        }\n      }, sizeDetermination.failure);\n      return sizeDetermination;\n    }\n    function getFailingLimit(limits, dimensions) {\n      var failingLimit;\n      qq.each(limits, function (limitName, limitValue) {\n        if (limitValue > 0) {\n          var limitMatcher = /(max|min)(Width|Height)/.exec(limitName),\n            dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1),\n            actualValue = dimensions[dimensionPropName];\n          switch (limitMatcher[1]) {\n            case \"min\":\n              if (actualValue < limitValue) {\n                failingLimit = limitName;\n                return false;\n              }\n              break;\n            case \"max\":\n              if (actualValue > limitValue) {\n                failingLimit = limitName;\n                return false;\n              }\n              break;\n          }\n        }\n      });\n      return failingLimit;\n    }\n    this.validate = function (limits) {\n      var validationEffort = new qq.Promise();\n      log(\"Attempting to validate image.\");\n      if (hasNonZeroLimits(limits)) {\n        getWidthHeight().then(function (dimensions) {\n          var failingLimit = getFailingLimit(limits, dimensions);\n          if (failingLimit) {\n            validationEffort.failure(failingLimit);\n          } else {\n            validationEffort.success();\n          }\n        }, validationEffort.success);\n      } else {\n        validationEffort.success();\n      }\n      return validationEffort;\n    };\n  };\n  qq.Session = function (spec) {\n    \"use strict\";\n\n    var options = {\n      endpoint: null,\n      params: {},\n      customHeaders: {},\n      cors: {},\n      addFileRecord: function addFileRecord(sessionData) {},\n      log: function log(message, level) {}\n    };\n    qq.extend(options, spec, true);\n    function isJsonResponseValid(response) {\n      if (qq.isArray(response)) {\n        return true;\n      }\n      options.log(\"Session response is not an array.\", \"error\");\n    }\n    function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n      var someItemsIgnored = false;\n      success = success && isJsonResponseValid(fileItems);\n      if (success) {\n        qq.each(fileItems, function (idx, fileItem) {\n          if (fileItem.uuid == null) {\n            someItemsIgnored = true;\n            options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n          } else if (fileItem.name == null) {\n            someItemsIgnored = true;\n            options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n          } else {\n            try {\n              options.addFileRecord(fileItem);\n              return true;\n            } catch (err) {\n              someItemsIgnored = true;\n              options.log(err.message, \"error\");\n            }\n          }\n          return false;\n        });\n      }\n      promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n    }\n    this.refresh = function () {\n      var refreshEffort = new qq.Promise(),\n        refreshCompleteCallback = function refreshCompleteCallback(response, success, xhrOrXdr) {\n          handleFileItems(response, success, xhrOrXdr, refreshEffort);\n        },\n        requesterOptions = qq.extend({}, options),\n        requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n          onComplete: refreshCompleteCallback\n        }));\n      requester.queryServer();\n      return refreshEffort;\n    };\n  };\n  qq.SessionAjaxRequester = function (spec) {\n    \"use strict\";\n\n    var requester,\n      options = {\n        endpoint: null,\n        customHeaders: {},\n        params: {},\n        cors: {\n          expected: false,\n          sendCredentials: false\n        },\n        onComplete: function onComplete(response, success, xhrOrXdr) {},\n        log: function log(str, level) {}\n      };\n    qq.extend(options, spec);\n    function onComplete(id, xhrOrXdr, isError) {\n      var response = null;\n      if (xhrOrXdr.responseText != null) {\n        try {\n          response = qq.parseJson(xhrOrXdr.responseText);\n        } catch (err) {\n          options.log(\"Problem parsing session response: \" + err.message, \"error\");\n          isError = true;\n        }\n      }\n      options.onComplete(response, !isError, xhrOrXdr);\n    }\n    requester = qq.extend(this, new qq.AjaxRequester({\n      acceptHeader: \"application/json\",\n      validMethods: [\"GET\"],\n      method: \"GET\",\n      endpointStore: {\n        get: function get() {\n          return options.endpoint;\n        }\n      },\n      customHeaders: options.customHeaders,\n      log: options.log,\n      onComplete: onComplete,\n      cors: options.cors\n    }));\n    qq.extend(this, {\n      queryServer: function queryServer() {\n        var params = qq.extend({}, options.params);\n        options.log(\"Session query request.\");\n        requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n      }\n    });\n  };\n  qq.Scaler = function (spec, log) {\n    \"use strict\";\n\n    var self = this,\n      customResizeFunction = spec.customResizer,\n      includeOriginal = spec.sendOriginal,\n      orient = spec.orient,\n      defaultType = spec.defaultType,\n      defaultQuality = spec.defaultQuality / 100,\n      failedToScaleText = spec.failureText,\n      includeExif = spec.includeExif,\n      sizes = this._getSortedSizes(spec.sizes);\n    qq.extend(this, {\n      enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n      getFileRecords: function getFileRecords(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n        var self = this,\n          records = [],\n          originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData,\n          identifier = new qq.Identify(originalBlob, log);\n        if (identifier.isPreviewableSync()) {\n          qq.each(sizes, function (idx, sizeRecord) {\n            var outputType = self._determineOutputType({\n              defaultType: defaultType,\n              requestedType: sizeRecord.type,\n              refType: originalBlob.type\n            });\n            records.push({\n              uuid: qq.getUniqueId(),\n              name: self._getName(originalFileName, {\n                name: sizeRecord.name,\n                type: outputType,\n                refType: originalBlob.type\n              }),\n              blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                customResizeFunction: customResizeFunction,\n                maxSize: sizeRecord.maxSize,\n                orient: orient,\n                type: outputType,\n                quality: defaultQuality,\n                failedText: failedToScaleText,\n                includeExif: includeExif,\n                log: log\n              }))\n            });\n          });\n          records.push({\n            uuid: originalFileUuid,\n            name: originalFileName,\n            size: originalBlob.size,\n            blob: includeOriginal ? originalBlob : null\n          });\n        } else {\n          records.push({\n            uuid: originalFileUuid,\n            name: originalFileName,\n            size: originalBlob.size,\n            blob: originalBlob\n          });\n        }\n        return records;\n      },\n      handleNewFile: function handleNewFile(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n        var self = this,\n          buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId,\n          scaledIds = [],\n          originalId = null,\n          addFileToHandler = api.addFileToHandler,\n          uploadData = api.uploadData,\n          paramsStore = api.paramsStore,\n          proxyGroupId = qq.getUniqueId();\n        qq.each(self.getFileRecords(uuid, name, file), function (idx, record) {\n          var blobSize = record.size,\n            id;\n          if (record.blob instanceof qq.BlobProxy) {\n            blobSize = -1;\n          }\n          id = uploadData.addFile({\n            uuid: record.uuid,\n            name: record.name,\n            size: blobSize,\n            batchId: batchId,\n            proxyGroupId: proxyGroupId\n          });\n          if (record.blob instanceof qq.BlobProxy) {\n            scaledIds.push(id);\n          } else {\n            originalId = id;\n          }\n          if (record.blob) {\n            addFileToHandler(id, record.blob);\n            fileList.push({\n              id: id,\n              file: record.blob\n            });\n          } else {\n            uploadData.setStatus(id, qq.status.REJECTED);\n          }\n        });\n        if (originalId !== null) {\n          qq.each(scaledIds, function (idx, scaledId) {\n            var params = {\n              qqparentuuid: uploadData.retrieve({\n                id: originalId\n              }).uuid,\n              qqparentsize: uploadData.retrieve({\n                id: originalId\n              }).size\n            };\n            params[uuidParamName] = uploadData.retrieve({\n              id: scaledId\n            }).uuid;\n            uploadData.setParentId(scaledId, originalId);\n            paramsStore.addReadOnly(scaledId, params);\n          });\n          if (scaledIds.length) {\n            (function () {\n              var param = {};\n              param[uuidParamName] = uploadData.retrieve({\n                id: originalId\n              }).uuid;\n              paramsStore.addReadOnly(originalId, param);\n            })();\n          }\n        }\n      }\n    });\n  };\n  qq.extend(qq.Scaler.prototype, {\n    scaleImage: function scaleImage(id, specs, api) {\n      \"use strict\";\n\n      if (!qq.supportedFeatures.scaling) {\n        throw new qq.Error(\"Scaling is not supported in this browser!\");\n      }\n      var scalingEffort = new qq.Promise(),\n        log = api.log,\n        file = api.getFile(id),\n        uploadData = api.uploadData.retrieve({\n          id: id\n        }),\n        name = uploadData && uploadData.name,\n        uuid = uploadData && uploadData.uuid,\n        scalingOptions = {\n          customResizer: specs.customResizer,\n          sendOriginal: false,\n          orient: specs.orient,\n          defaultType: specs.type || null,\n          defaultQuality: specs.quality,\n          failedToScaleText: \"Unable to scale\",\n          sizes: [{\n            name: \"\",\n            maxSize: specs.maxSize\n          }]\n        },\n        scaler = new qq.Scaler(scalingOptions, log);\n      if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n        scalingEffort.failure();\n        log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n      } else {\n        qq.bind(function () {\n          var record = scaler.getFileRecords(uuid, name, file)[0];\n          if (record && record.blob instanceof qq.BlobProxy) {\n            record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n          } else {\n            log(id + \" is not a scalable image!\", \"error\");\n            scalingEffort.failure();\n          }\n        }, this)();\n      }\n      return scalingEffort;\n    },\n    _determineOutputType: function _determineOutputType(spec) {\n      \"use strict\";\n\n      var requestedType = spec.requestedType,\n        defaultType = spec.defaultType,\n        referenceType = spec.refType;\n      if (!defaultType && !requestedType) {\n        if (referenceType !== \"image/jpeg\") {\n          return \"image/png\";\n        }\n        return referenceType;\n      }\n      if (!requestedType) {\n        return defaultType;\n      }\n      if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n        if (requestedType === \"image/tiff\") {\n          return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n        }\n        return requestedType;\n      }\n      return defaultType;\n    },\n    _getName: function _getName(originalName, scaledVersionProperties) {\n      \"use strict\";\n\n      var startOfExt = originalName.lastIndexOf(\".\"),\n        versionType = scaledVersionProperties.type || \"image/png\",\n        referenceType = scaledVersionProperties.refType,\n        scaledName = \"\",\n        scaledExt = qq.getExtension(originalName),\n        nameAppendage = \"\";\n      if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n        nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n      }\n      if (startOfExt >= 0) {\n        scaledName = originalName.substr(0, startOfExt);\n        if (referenceType !== versionType) {\n          scaledExt = versionType.split(\"/\")[1];\n        }\n        scaledName += nameAppendage + \".\" + scaledExt;\n      } else {\n        scaledName = originalName + nameAppendage;\n      }\n      return scaledName;\n    },\n    _getSortedSizes: function _getSortedSizes(sizes) {\n      \"use strict\";\n\n      sizes = qq.extend([], sizes);\n      return sizes.sort(function (a, b) {\n        if (a.maxSize > b.maxSize) {\n          return 1;\n        }\n        if (a.maxSize < b.maxSize) {\n          return -1;\n        }\n        return 0;\n      });\n    },\n    _generateScaledImage: function _generateScaledImage(spec, sourceFile) {\n      \"use strict\";\n\n      var self = this,\n        customResizeFunction = spec.customResizeFunction,\n        log = spec.log,\n        maxSize = spec.maxSize,\n        orient = spec.orient,\n        type = spec.type,\n        quality = spec.quality,\n        failedText = spec.failedText,\n        includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\",\n        scalingEffort = new qq.Promise(),\n        imageGenerator = new qq.ImageGenerator(log),\n        canvas = document.createElement(\"canvas\");\n      log(\"Attempting to generate scaled version for \" + sourceFile.name);\n      imageGenerator.generate(sourceFile, canvas, {\n        maxSize: maxSize,\n        orient: orient,\n        customResizeFunction: customResizeFunction\n      }).then(function () {\n        var scaledImageDataUri = canvas.toDataURL(type, quality),\n          signalSuccess = function signalSuccess() {\n            log(\"Success generating scaled version for \" + sourceFile.name);\n            var blob = qq.dataUriToBlob(scaledImageDataUri);\n            scalingEffort.success(blob);\n          };\n        if (includeExif) {\n          self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function (scaledImageDataUriWithExif) {\n            scaledImageDataUri = scaledImageDataUriWithExif;\n            signalSuccess();\n          }, function () {\n            log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n            signalSuccess();\n          });\n        } else {\n          signalSuccess();\n        }\n      }, function () {\n        log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n        scalingEffort.failure(failedText);\n      });\n      return scalingEffort;\n    },\n    _insertExifHeader: function _insertExifHeader(originalImage, scaledImageDataUri, log) {\n      \"use strict\";\n\n      var reader = new FileReader(),\n        insertionEffort = new qq.Promise(),\n        originalImageDataUri = \"\";\n      reader.onload = function () {\n        originalImageDataUri = reader.result;\n        insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n      };\n      reader.onerror = function () {\n        log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n        insertionEffort.failure();\n      };\n      reader.readAsDataURL(originalImage);\n      return insertionEffort;\n    },\n    _dataUriToBlob: function _dataUriToBlob(dataUri) {\n      \"use strict\";\n\n      var byteString, mimeString, arrayBuffer, intArray;\n      if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n        byteString = atob(dataUri.split(\",\")[1]);\n      } else {\n        byteString = decodeURI(dataUri.split(\",\")[1]);\n      }\n      mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n      arrayBuffer = new ArrayBuffer(byteString.length);\n      intArray = new Uint8Array(arrayBuffer);\n      qq.each(byteString, function (idx, character) {\n        intArray[idx] = character.charCodeAt(0);\n      });\n      return this._createBlob(arrayBuffer, mimeString);\n    },\n    _createBlob: function _createBlob(data, mime) {\n      \"use strict\";\n\n      var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,\n        blobBuilder = BlobBuilder && new BlobBuilder();\n      if (blobBuilder) {\n        blobBuilder.append(data);\n        return blobBuilder.getBlob(mime);\n      } else {\n        return new Blob([data], {\n          type: mime\n        });\n      }\n    }\n  });\n  qq.ExifRestorer = function () {\n    var ExifRestorer = {};\n    ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n    ExifRestorer.encode64 = function (input) {\n      var output = \"\",\n        chr1,\n        chr2,\n        chr3 = \"\",\n        enc1,\n        enc2,\n        enc3,\n        enc4 = \"\",\n        i = 0;\n      do {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = \"\";\n        enc1 = enc2 = enc3 = enc4 = \"\";\n      } while (i < input.length);\n      return output;\n    };\n    ExifRestorer.restore = function (origFileBase64, resizedFileBase64) {\n      var expectedBase64Header = \"data:image/jpeg;base64,\";\n      if (!origFileBase64.match(expectedBase64Header)) {\n        return resizedFileBase64;\n      }\n      var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n      var segments = this.slice2Segments(rawImage);\n      var image = this.exifManipulation(resizedFileBase64, segments);\n      return expectedBase64Header + this.encode64(image);\n    };\n    ExifRestorer.exifManipulation = function (resizedFileBase64, segments) {\n      var exifArray = this.getExifArray(segments),\n        newImageArray = this.insertExif(resizedFileBase64, exifArray),\n        aBuffer = new Uint8Array(newImageArray);\n      return aBuffer;\n    };\n    ExifRestorer.getExifArray = function (segments) {\n      var seg;\n      for (var x = 0; x < segments.length; x++) {\n        seg = segments[x];\n        if (seg[0] == 255 & seg[1] == 225) {\n          return seg;\n        }\n      }\n      return [];\n    };\n    ExifRestorer.insertExif = function (resizedFileBase64, exifArray) {\n      var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"),\n        buf = this.decode64(imageData),\n        separatePoint = buf.indexOf(255, 3),\n        mae = buf.slice(0, separatePoint),\n        ato = buf.slice(separatePoint),\n        array = mae;\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    };\n    ExifRestorer.slice2Segments = function (rawImageArray) {\n      var head = 0,\n        segments = [];\n      while (1) {\n        if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n          break;\n        }\n        if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n          head += 2;\n        } else {\n          var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],\n            endPoint = head + length + 2,\n            seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n      return segments;\n    };\n    ExifRestorer.decode64 = function (input) {\n      var output = \"\",\n        chr1,\n        chr2,\n        chr3 = \"\",\n        enc1,\n        enc2,\n        enc3,\n        enc4 = \"\",\n        i = 0,\n        buf = [];\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n      if (base64test.exec(input)) {\n        throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n      }\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n      do {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        buf.push(chr1);\n        if (enc3 != 64) {\n          buf.push(chr2);\n        }\n        if (enc4 != 64) {\n          buf.push(chr3);\n        }\n        chr1 = chr2 = chr3 = \"\";\n        enc1 = enc2 = enc3 = enc4 = \"\";\n      } while (i < input.length);\n      return buf;\n    };\n    return ExifRestorer;\n  }();\n  qq.TotalProgress = function (callback, getSize) {\n    \"use strict\";\n\n    var perFileProgress = {},\n      totalLoaded = 0,\n      totalSize = 0,\n      lastLoadedSent = -1,\n      lastTotalSent = -1,\n      callbackProxy = function callbackProxy(loaded, total) {\n        if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n          callback(loaded, total);\n        }\n        lastLoadedSent = loaded;\n        lastTotalSent = total;\n      },\n      noRetryableFiles = function noRetryableFiles(failed, retryable) {\n        var none = true;\n        qq.each(failed, function (idx, failedId) {\n          if (qq.indexOf(retryable, failedId) >= 0) {\n            none = false;\n            return false;\n          }\n        });\n        return none;\n      },\n      onCancel = function onCancel(id) {\n        updateTotalProgress(id, -1, -1);\n        delete perFileProgress[id];\n      },\n      onAllComplete = function onAllComplete(successful, failed, retryable) {\n        if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n          callbackProxy(totalSize, totalSize);\n          this.reset();\n        }\n      },\n      onNew = function onNew(id) {\n        var size = getSize(id);\n        if (size > 0) {\n          updateTotalProgress(id, 0, size);\n          perFileProgress[id] = {\n            loaded: 0,\n            total: size\n          };\n        }\n      },\n      updateTotalProgress = function updateTotalProgress(id, newLoaded, newTotal) {\n        var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0,\n          oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n        if (newLoaded === -1 && newTotal === -1) {\n          totalLoaded -= oldLoaded;\n          totalSize -= oldTotal;\n        } else {\n          if (newLoaded) {\n            totalLoaded += newLoaded - oldLoaded;\n          }\n          if (newTotal) {\n            totalSize += newTotal - oldTotal;\n          }\n        }\n        callbackProxy(totalLoaded, totalSize);\n      };\n    qq.extend(this, {\n      onAllComplete: onAllComplete,\n      onStatusChange: function onStatusChange(id, oldStatus, newStatus) {\n        if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n          onCancel(id);\n        } else if (newStatus === qq.status.SUBMITTING) {\n          onNew(id);\n        }\n      },\n      onIndividualProgress: function onIndividualProgress(id, loaded, total) {\n        updateTotalProgress(id, loaded, total);\n        perFileProgress[id] = {\n          loaded: loaded,\n          total: total\n        };\n      },\n      onNewSize: function onNewSize(id) {\n        onNew(id);\n      },\n      reset: function reset() {\n        perFileProgress = {};\n        totalLoaded = 0;\n        totalSize = 0;\n      }\n    });\n  };\n  qq.PasteSupport = function (o) {\n    \"use strict\";\n\n    var options, detachPasteHandler;\n    options = {\n      targetElement: null,\n      callbacks: {\n        log: function log(message, level) {},\n        pasteReceived: function pasteReceived(blob) {}\n      }\n    };\n    function isImage(item) {\n      return item.type && item.type.indexOf(\"image/\") === 0;\n    }\n    function registerPasteHandler() {\n      detachPasteHandler = qq(options.targetElement).attach(\"paste\", function (event) {\n        var clipboardData = event.clipboardData;\n        if (clipboardData) {\n          qq.each(clipboardData.items, function (idx, item) {\n            if (isImage(item)) {\n              var blob = item.getAsFile();\n              options.callbacks.pasteReceived(blob);\n            }\n          });\n        }\n      });\n    }\n    function unregisterPasteHandler() {\n      if (detachPasteHandler) {\n        detachPasteHandler();\n      }\n    }\n    qq.extend(options, o);\n    registerPasteHandler();\n    qq.extend(this, {\n      reset: function reset() {\n        unregisterPasteHandler();\n      }\n    });\n  };\n  qq.FormSupport = function (options, startUpload, log) {\n    \"use strict\";\n\n    var self = this,\n      interceptSubmit = options.interceptSubmit,\n      formEl = options.element,\n      autoUpload = options.autoUpload;\n    qq.extend(this, {\n      newEndpoint: null,\n      newAutoUpload: autoUpload,\n      attachedToForm: false,\n      getFormInputsAsObject: function getFormInputsAsObject() {\n        if (formEl == null) {\n          return null;\n        }\n        return self._form2Obj(formEl);\n      }\n    });\n    function determineNewEndpoint(formEl) {\n      if (formEl.getAttribute(\"action\")) {\n        self.newEndpoint = formEl.getAttribute(\"action\");\n      }\n    }\n    function validateForm(formEl, nativeSubmit) {\n      if (formEl.checkValidity && !formEl.checkValidity()) {\n        log(\"Form did not pass validation checks - will not upload.\", \"error\");\n        nativeSubmit();\n      } else {\n        return true;\n      }\n    }\n    function maybeUploadOnSubmit(formEl) {\n      var nativeSubmit = formEl.submit;\n      qq(formEl).attach(\"submit\", function (event) {\n        event = event || window.event;\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else {\n          event.returnValue = false;\n        }\n        validateForm(formEl, nativeSubmit) && startUpload();\n      });\n      formEl.submit = function () {\n        validateForm(formEl, nativeSubmit) && startUpload();\n      };\n    }\n    function determineFormEl(formEl) {\n      if (formEl) {\n        if (qq.isString(formEl)) {\n          formEl = document.getElementById(formEl);\n        }\n        if (formEl) {\n          log(\"Attaching to form element.\");\n          determineNewEndpoint(formEl);\n          interceptSubmit && maybeUploadOnSubmit(formEl);\n        }\n      }\n      return formEl;\n    }\n    formEl = determineFormEl(formEl);\n    this.attachedToForm = !!formEl;\n  };\n  qq.extend(qq.FormSupport.prototype, {\n    _form2Obj: function _form2Obj(form) {\n      \"use strict\";\n\n      var obj = {},\n        notIrrelevantType = function notIrrelevantType(type) {\n          var irrelevantTypes = [\"button\", \"image\", \"reset\", \"submit\"];\n          return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n        },\n        radioOrCheckbox = function radioOrCheckbox(type) {\n          return qq.indexOf([\"checkbox\", \"radio\"], type.toLowerCase()) >= 0;\n        },\n        ignoreValue = function ignoreValue(el) {\n          if (radioOrCheckbox(el.type) && !el.checked) {\n            return true;\n          }\n          return el.disabled && el.type.toLowerCase() !== \"hidden\";\n        },\n        selectValue = function selectValue(select) {\n          var value = null;\n          qq.each(qq(select).children(), function (idx, child) {\n            if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n              value = child.value;\n              return false;\n            }\n          });\n          return value;\n        };\n      qq.each(form.elements, function (idx, el) {\n        if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n          obj[el.name] = el.value;\n        } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n          var value = selectValue(el);\n          if (value !== null) {\n            obj[el.name] = value;\n          }\n        }\n      });\n      return obj;\n    }\n  });\n  qq.traditional = qq.traditional || {};\n  qq.traditional.FormUploadHandler = function (options, proxy) {\n    \"use strict\";\n\n    var handler = this,\n      getName = proxy.getName,\n      getUuid = proxy.getUuid,\n      log = proxy.log;\n    function getIframeContentJson(id, iframe) {\n      var response, doc, innerHtml;\n      try {\n        doc = iframe.contentDocument || iframe.contentWindow.document;\n        innerHtml = doc.body.innerHTML;\n        log(\"converting iframe's innerHTML to JSON\");\n        log(\"innerHTML = \" + innerHtml);\n        if (innerHtml && innerHtml.match(/^<pre/i)) {\n          innerHtml = doc.body.firstChild.firstChild.nodeValue;\n        }\n        response = handler._parseJsonResponse(innerHtml);\n      } catch (error) {\n        log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n        response = {\n          success: false\n        };\n      }\n      return response;\n    }\n    function createForm(id, iframe) {\n      var params = options.paramsStore.get(id),\n        method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\",\n        endpoint = options.endpointStore.get(id),\n        name = getName(id);\n      params[options.uuidName] = getUuid(id);\n      params[options.filenameParam] = name;\n      return handler._initFormForUpload({\n        method: method,\n        endpoint: endpoint,\n        params: params,\n        paramsInBody: options.paramsInBody,\n        targetName: iframe.name\n      });\n    }\n    this.uploadFile = function (id) {\n      var input = handler.getInput(id),\n        iframe = handler._createIframe(id),\n        promise = new qq.Promise(),\n        form;\n      form = createForm(id, iframe);\n      form.appendChild(input);\n      handler._attachLoadEvent(iframe, function (responseFromMessage) {\n        log(\"iframe loaded\");\n        var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n        handler._detachLoadEvent(id);\n        if (!options.cors.expected) {\n          qq(iframe).remove();\n        }\n        if (response.success) {\n          promise.success(response);\n        } else {\n          promise.failure(response);\n        }\n      });\n      log(\"Sending upload request for \" + id);\n      form.submit();\n      qq(form).remove();\n      return promise;\n    };\n    qq.extend(this, new qq.FormUploadHandler({\n      options: {\n        isCors: options.cors.expected,\n        inputName: options.inputName\n      },\n      proxy: {\n        onCancel: options.onCancel,\n        getName: getName,\n        getUuid: getUuid,\n        log: log\n      }\n    }));\n  };\n  qq.traditional = qq.traditional || {};\n  qq.traditional.XhrUploadHandler = function (spec, proxy) {\n    \"use strict\";\n\n    var handler = this,\n      getName = proxy.getName,\n      getSize = proxy.getSize,\n      getUuid = proxy.getUuid,\n      log = proxy.log,\n      multipart = spec.forceMultipart || spec.paramsInBody,\n      addChunkingSpecificParams = function addChunkingSpecificParams(id, params, chunkData) {\n        var size = getSize(id),\n          name = getName(id);\n        if (!spec.omitDefaultParams) {\n          params[spec.chunking.paramNames.partIndex] = chunkData.part;\n          params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n          params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n          params[spec.chunking.paramNames.totalParts] = chunkData.count;\n          params[spec.totalFileSizeName] = size;\n        }\n        if (multipart && !spec.omitDefaultParams) {\n          params[spec.filenameParam] = name;\n        }\n      },\n      allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n        cors: spec.cors,\n        endpoint: spec.chunking.success.endpoint,\n        headers: spec.chunking.success.headers,\n        jsonPayload: spec.chunking.success.jsonPayload,\n        log: log,\n        method: spec.chunking.success.method,\n        params: spec.chunking.success.params\n      }),\n      createReadyStateChangedHandler = function createReadyStateChangedHandler(id, xhr) {\n        var promise = new qq.Promise();\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState === 4) {\n            var result = onUploadOrChunkComplete(id, xhr);\n            if (result.success) {\n              promise.success(result.response, xhr);\n            } else {\n              promise.failure(result.response, xhr);\n            }\n          }\n        };\n        return promise;\n      },\n      getChunksCompleteParams = function getChunksCompleteParams(id) {\n        var params = spec.paramsStore.get(id),\n          name = getName(id),\n          size = getSize(id);\n        params[spec.uuidName] = getUuid(id);\n        params[spec.filenameParam] = name;\n        params[spec.totalFileSizeName] = size;\n        params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n        return params;\n      },\n      isErrorUploadResponse = function isErrorUploadResponse(xhr, response) {\n        return qq.indexOf([200, 201, 202, 203, 204], xhr.status) < 0 || spec.requireSuccessJson && !response.success || response.reset;\n      },\n      onUploadOrChunkComplete = function onUploadOrChunkComplete(id, xhr) {\n        var response;\n        log(\"xhr - server response received for \" + id);\n        log(\"responseText = \" + xhr.responseText);\n        response = parseResponse(true, xhr);\n        return {\n          success: !isErrorUploadResponse(xhr, response),\n          response: response\n        };\n      },\n      parseResponse = function parseResponse(upload, xhr) {\n        var response = {};\n        try {\n          log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n          response = qq.parseJson(xhr.responseText);\n        } catch (error) {\n          upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n        }\n        return response;\n      },\n      sendChunksCompleteRequest = function sendChunksCompleteRequest(id) {\n        var promise = new qq.Promise();\n        allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function (xhr) {\n          promise.success(parseResponse(false, xhr), xhr);\n        }, function (xhr) {\n          promise.failure(parseResponse(false, xhr), xhr);\n        });\n        return promise;\n      },\n      setParamsAndGetEntityToSend = function setParamsAndGetEntityToSend(entityToSendParams) {\n        var fileOrBlob = entityToSendParams.fileOrBlob;\n        var id = entityToSendParams.id;\n        var xhr = entityToSendParams.xhr;\n        var xhrOverrides = entityToSendParams.xhrOverrides || {};\n        var customParams = entityToSendParams.customParams || {};\n        var defaultParams = entityToSendParams.params || {};\n        var xhrOverrideParams = xhrOverrides.params || {};\n        var params;\n        var formData = multipart ? new FormData() : null,\n          method = xhrOverrides.method || spec.method,\n          endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id),\n          name = getName(id),\n          size = getSize(id);\n        if (spec.omitDefaultParams) {\n          params = qq.extend({}, customParams);\n          qq.extend(params, xhrOverrideParams);\n        } else {\n          params = qq.extend({}, customParams);\n          qq.extend(params, xhrOverrideParams);\n          qq.extend(params, defaultParams);\n          params[spec.uuidName] = getUuid(id);\n          params[spec.filenameParam] = name;\n          if (multipart) {\n            params[spec.totalFileSizeName] = size;\n          } else if (!spec.paramsInBody) {\n            params[spec.inputName] = name;\n          }\n        }\n        if (!spec.paramsInBody) {\n          endpoint = qq.obj2url(params, endpoint);\n        }\n        xhr.open(method, endpoint, true);\n        if (spec.cors.expected && spec.cors.sendCredentials) {\n          xhr.withCredentials = true;\n        }\n        if (multipart) {\n          if (spec.paramsInBody) {\n            qq.obj2FormData(params, formData);\n          }\n          formData.append(spec.inputName, fileOrBlob);\n          return formData;\n        }\n        return fileOrBlob;\n      },\n      setUploadHeaders = function setUploadHeaders(headersOptions) {\n        var headerOverrides = headersOptions.headerOverrides;\n        var id = headersOptions.id;\n        var xhr = headersOptions.xhr;\n        if (headerOverrides) {\n          qq.each(headerOverrides, function (headerName, headerValue) {\n            xhr.setRequestHeader(headerName, headerValue);\n          });\n        } else {\n          var extraHeaders = spec.customHeaders.get(id),\n            fileOrBlob = handler.getFile(id);\n          xhr.setRequestHeader(\"Accept\", \"application/json\");\n          xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n          xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n          if (!multipart) {\n            xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n            xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n          }\n          qq.each(extraHeaders, function (name, val) {\n            xhr.setRequestHeader(name, val);\n          });\n        }\n      };\n    qq.extend(this, {\n      uploadChunk: function uploadChunk(uploadChunkParams) {\n        var id = uploadChunkParams.id;\n        var chunkIdx = uploadChunkParams.chunkIdx;\n        var overrides = uploadChunkParams.overrides || {};\n        var resuming = uploadChunkParams.resuming;\n        var chunkData = handler._getChunkData(id, chunkIdx),\n          xhr = handler._createXhr(id, chunkIdx),\n          promise,\n          toSend,\n          customParams,\n          params = {};\n        promise = createReadyStateChangedHandler(id, xhr);\n        handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n        customParams = spec.paramsStore.get(id);\n        addChunkingSpecificParams(id, params, chunkData);\n        if (resuming) {\n          params[spec.resume.paramNames.resuming] = true;\n        }\n        toSend = setParamsAndGetEntityToSend({\n          fileOrBlob: chunkData.blob,\n          id: id,\n          customParams: customParams,\n          params: params,\n          xhr: xhr,\n          xhrOverrides: overrides\n        });\n        setUploadHeaders({\n          headerOverrides: overrides.headers,\n          id: id,\n          xhr: xhr\n        });\n        xhr.send(toSend);\n        return promise;\n      },\n      uploadFile: function uploadFile(id) {\n        var fileOrBlob = handler.getFile(id),\n          promise,\n          xhr,\n          customParams,\n          toSend;\n        xhr = handler._createXhr(id);\n        handler._registerProgressHandler(id);\n        promise = createReadyStateChangedHandler(id, xhr);\n        customParams = spec.paramsStore.get(id);\n        toSend = setParamsAndGetEntityToSend({\n          fileOrBlob: fileOrBlob,\n          id: id,\n          customParams: customParams,\n          xhr: xhr\n        });\n        setUploadHeaders({\n          id: id,\n          xhr: xhr\n        });\n        xhr.send(toSend);\n        return promise;\n      }\n    });\n    qq.extend(this, new qq.XhrUploadHandler({\n      options: qq.extend({\n        namespace: \"traditional\"\n      }, spec),\n      proxy: qq.extend({\n        getEndpoint: spec.endpointStore.get\n      }, proxy)\n    }));\n    qq.override(this, function (super_) {\n      return {\n        finalizeChunks: function finalizeChunks(id) {\n          proxy.onFinalizing(id);\n          if (spec.chunking.success.endpoint) {\n            return sendChunksCompleteRequest(id);\n          } else {\n            return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n          }\n        }\n      };\n    });\n  };\n  qq.traditional.AllChunksDoneAjaxRequester = function (o) {\n    \"use strict\";\n\n    var requester,\n      options = {\n        cors: {\n          allowXdr: false,\n          expected: false,\n          sendCredentials: false\n        },\n        endpoint: null,\n        log: function log(str, level) {},\n        method: \"POST\"\n      },\n      promises = {},\n      endpointHandler = {\n        get: function get(id) {\n          if (qq.isFunction(options.endpoint)) {\n            return options.endpoint(id);\n          }\n          return options.endpoint;\n        }\n      };\n    qq.extend(options, o);\n    requester = qq.extend(this, new qq.AjaxRequester({\n      acceptHeader: \"application/json\",\n      contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n      validMethods: [options.method],\n      method: options.method,\n      endpointStore: endpointHandler,\n      allowXRequestedWithAndCacheControl: false,\n      cors: options.cors,\n      log: options.log,\n      onComplete: function onComplete(id, xhr, isError) {\n        var promise = promises[id];\n        delete promises[id];\n        if (isError) {\n          promise.failure(xhr);\n        } else {\n          promise.success(xhr);\n        }\n      }\n    }));\n    qq.extend(this, {\n      complete: function complete(id, xhr, params, headers) {\n        var promise = new qq.Promise();\n        options.log(\"Submitting All Chunks Done request for \" + id);\n        promises[id] = promise;\n        requester.initTransport(id).withParams(options.params(id) || params).withHeaders(options.headers(id) || headers).send(xhr);\n        return promise;\n      }\n    });\n  };\n})(window);","map":{"version":3,"sources":["?","../client/js/util.js","../client/js/export.js","../client/js/error/error.js","../client/js/version.js","../client/js/features.js","../client/js/promise.js","../client/js/blob-proxy.js","../client/js/button.js","../client/js/upload-data.js","../client/js/uploader.basic.api.js","../client/js/uploader.basic.js","../client/js/ajax.requester.js","../client/js/upload-handler/upload.handler.js","../client/js/upload-handler/upload.handler.controller.js","../client/js/window.receive.message.js","../client/js/upload-handler/form.upload.handler.js","../client/js/upload-handler/xhr.upload.handler.js","../client/js/deletefile.ajax.requester.js","../client/js/image-support/megapix-image.js","../client/js/image-support/image.js","../client/js/image-support/exif.js","../client/js/identify.js","../client/js/image-support/validation.image.js","../client/js/session.js","../client/js/session.ajax.requester.js","../client/js/image-support/scaler.js","../client/js/third-party/ExifRestorer.js","../client/js/total-progress.js","../client/js/paste.js","../client/js/form-support.js","../client/js/traditional/traditional.form.upload.handler.js","../client/js/traditional/traditional.xhr.upload.handler.js","../client/js/traditional/all-chunks-done.ajax.requester.js"],"names":["global","window","qq","element","hide","style","display","this","attach","type","fn","addEventListener","attachEvent","detach","removeEventListener","detachEvent","contains","descendant","compareDocumentPosition","insertBefore","elementB","parentNode","remove","removeChild","css","styles","Error","opacity","filter","Math","round","extend","hasClass","name","considerParent","re","RegExp","test","className","addClass","removeClass","replace","getByClass","first","candidates","result","querySelector","querySelectorAll","getElementsByTagName","each","idx","val","push","getFirstByClass","children","child","firstChild","nodeType","nextSibling","setText","text","innerText","textContent","clearText","hasAttribute","attrName","attrVal","exec","getAttribute","undefined","canvasToBlob","canvas","mime","quality","dataUriToBlob","toDataURL","dataUri","arrayBuffer","byteString","createBlob","data","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","blobBuilder","append","getBlob","Blob","intArray","mimeString","split","indexOf","atob","decodeURI","ArrayBuffer","length","Uint8Array","character","charCodeAt","log","message","level","console","isObject","variable","Object","prototype","toString","call","isFunction","isArray","value","buffer","constructor","isItemList","maybeItemList","isNodeList","maybeNodeList","item","namedItem","isString","maybeString","trimStr","string","String","trim","format","str","args","Array","slice","arguments","newStr","nextIdxToReplace","strBefore","substring","strAfter","isFile","maybeFile","File","isFileList","maybeFileList","FileList","isFileOrInput","maybeFileOrInput","isInput","maybeInput","notFile","evaluateType","normalizedType","toLowerCase","HTMLInputElement","tagName","isBlob","maybeBlob","isXhrUploadSupported","input","document","createElement","multiple","FormData","createXhrInstance","upload","XMLHttpRequest","ActiveXObject","error","isFolderDropSupported","dataTransfer","items","webkitGetAsEntry","isFileChunkingSupported","androidStock","webkitSlice","mozSlice","sliceBlob","fileOrBlob","start","end","slicer","arrayBufferToHex","bytesAsHex","bytes","byt","byteAsHexStr","readBlobToHex","blob","startOffset","initialBlob","fileReader","FileReader","promise","Promise","onload","success","onerror","failure","readAsArrayBuffer","second","extendNested","prop","override","target","sourceFn","super_","source","srcPropName","srcPropVal","arr","elt","from","len","hasOwnProperty","getUniqueId","c","r","random","v","ie","navigator","userAgent","ie7","ie8","ie10","ie11","edge","safari","vendor","chrome","opera","firefox","windows","platform","android","ios6","ios","ios7","ios8","ios800","iosChrome","iosSafari","iosSafariWebView","preventDefault","e","returnValue","toElement","div","html","innerHTML","iterableItem","callback","keyOrIndex","retVal","Storage","key","getItem","charAt","bind","oldFunc","context","newArgs","concat","apply","obj2url","obj","temp","prefixDone","uristrings","prefix","add","nextObj","i","nextTemp","encodeURIComponent","join","obj2FormData","formData","arrayKeyName","obj2Inputs","form","setAttribute","appendChild","parseJson","json","JSON","parse","eval","getExtension","filename","extIdx","lastIndexOf","substr","getFilename","blobOrFileInput","fileName","DisposeSupport","disposers","dispose","disposer","shift","addDisposer","disposeFunction","define","amd","module","exports","version","supportedFeatures","supportsUploading","supportsUploadingBlobs","supportsFileDrop","supportsAjaxFileUploading","supportsFolderDrop","supportsChunking","supportsResume","supportsUploadViaPaste","supportsUploadCors","supportsDeleteFileXdr","supportsDeleteFileCorsXhr","supportsDeleteFileCors","supportsFolderSelection","supportsImagePreviews","supportsUploadProgress","testSupportsFileInputElement","supported","tempInput","disabled","ex","isChrome14OrHigher","match","isCrossOriginXhrSupported","xhr","withCredentials","isXdrSupported","XDomainRequest","isCrossOriginAjaxSupported","isFolderSelectionSupported","webkitdirectory","isLocalStorageSupported","localStorage","setItem","isDragAndDropSupported","span","postMessage","ajaxUploading","blobUploading","canDetermineSize","chunking","deleteFileCors","deleteFileCorsXdr","deleteFileCorsXhr","dialogElement","HTMLDialogElement","fileDrop","folderDrop","folderSelection","imagePreviews","imageValidation","itemSizeValidation","pause","progressBar","resume","scaling","tiffPreviews","unlimitedScaledImageSize","uploading","uploadCors","uploadCustomHeaders","uploadNonMultipart","uploadViaPaste","isGenericPromise","maybePromise","then","successArgs","failureArgs","successCallbacks","failureCallbacks","doneCallbacks","state","onSuccess","onFailure","done","BlobProxy","referenceBlob","onCreate","create","UploadButton","o","self","disposeSupport","options","acceptFiles","focusClass","folders","hoverClass","ios8BrowserCrashWorkaround","onChange","title","buttonId","createInput","BUTTON_ID_ATTR_NAME","setMultiple","position","right","top","fontFamily","fontSize","margin","padding","cursor","height","overflow","direction","getInput","getButtonId","isMultiple","optInput","removeAttribute","setAcceptFiles","reset","UploadData","uploaderProxy","byUuid","byStatus","byProxyGroupId","byBatchId","getDataByIds","idOrIds","entries","id","getDataByUuids","uuids","uuid","getDataByStatus","status","statusResults","statuses","index","statusEnum","statusResultIndexes","dataIndex","addFile","spec","SUBMITTING","originalName","size","file","batchId","proxyGroupId","onBeforeStatusChange","onStatusChange","retrieve","optionalFilter","removeFileRef","record","setStatus","newStatus","oldStatus","byStatusOldStatusIndex","splice","uuidChanged","newUuid","oldUuid","updateName","newName","updateSize","newSize","setParentId","targetId","parentId","getIdsInProxyGroup","getIdsInBatch","SUBMITTED","REJECTED","QUEUED","CANCELED","PAUSED","UPLOADING","UPLOAD_FINALIZING","UPLOAD_RETRYING","UPLOAD_SUCCESSFUL","UPLOAD_FAILED","DELETE_FAILED","DELETING","DELETED","basePublicApi","addBlobs","blobDataOrArray","params","endpoint","addFiles","addInitialFiles","cannedFileList","cannedFile","_addCannedFile","_maybeHandleIos8SafariWorkaround","_storedIds","_currentBatchId","processBlob","_handleNewFile","_options","blobs","defaultName","verifiedFiles","processBlobData","blobData","processCanvas","processCanvasData","canvasData","normalizedQuality","processFileOrInput","fileOrInput","files","normalizeData","fileContainer","_prepareItemsForUpload","cancel","uploadData","_uploadData","getName","_handler","cancelAll","storedIdsCopy","storedFileId","clearStoredFiles","continueUpload","enabled","_uploadFile","deleteFile","_onSubmitDelete","doesExist","fileOrBlobId","isValid","drawThumbnail","fileId","imgOrCanvas","maxSize","fromServer","customResizeFunction","promiseToReturn","fileOrUrl","_imageGenerator","_thumbnailUrls","scale","getFile","container","generate","modifiedContainer","reason","getButton","_getButton","_buttonIdsForFileIds","getEndpoint","_endpointStore","get","uploadDataRecord","getInProgress","getParentId","uploadDataEntry","getUploads","getResumableFilesData","getSize","getNetUploads","_netUploaded","getRemainingAllowedItems","allowedItems","_currentItemLimit","_netUploadedOrQueued","getUuid","isResumable","hasResumeRecord","debug","pauseUpload","expunge","_autoRetries","_retryTimeouts","_preventRetries","_buttons","button","_paramsStore","_pasteHandler","session","refreshOnReset","_refreshSessionData","_succeededSinceLastAllComplete","_failedSinceLastAllComplete","_totalProgress","_customResumeDataStore","retry","_manualRetry","scaleImage","specs","Scaler","setCustomHeaders","headers","_customHeadersStore","set","setCustomResumeData","setDeleteFileCustomHeaders","_deleteFileCustomHeadersStore","setDeleteFileEndpoint","_deleteFileEndpointStore","setDeleteFileParams","_deleteFileParamsStore","setEndpoint","setForm","elementOrId","_updateFormSupportAndParams","setItemLimit","newItemLimit","setName","setParams","setUuid","fileRecord","_onDeleteComplete","errorMessage","uploadStoredFiles","_itemError","_uploadStoredFiles","basePrivateApi","sessionData","deleteFileEndpoint","deleteFileParams","thumbnailUrl","_annotateWithButtonId","associatedInput","qqButtonId","_getButtonId","_batchError","callbacks","onError","_createDeleteHandler","DeleteFileAjaxRequester","method","toUpperCase","maxConnections","uuidParamName","request","uuidName","customHeaders","paramsStore","endpointStore","cors","onDelete","_onDelete","onDeleteComplete","xhrOrXdr","isError","_createPasteHandler","PasteSupport","targetElement","paste","pasteReceived","_handleCheckedCallback","onPasteReceived","_handlePasteSuccess","identifier","_createStore","initialValue","_readOnlyValues_","store","catchall","perIdReadOnlyValues","readOnlyValues","copy","orig","getReadOnlyValues","includeReadOnlyValues","existing","values","addReadOnly","_createUploadDataTracker","_onUploadStatusChange","_maybeAllComplete","setTimeout","_createUploadButton","accept","validation","allowedExtensions","allowMultiple","workarounds","iosEmptyVideos","_isAllowedExtension","classes","buttonFocus","buttonHover","ios8BrowserCrash","inputName","_onInputChange","fileInputTitle","_disposeSupport","_createUploadHandler","additionalOptions","namespace","lastOnProgress","preventRetryParam","preventRetryResponseProperty","onProgress","loaded","total","_onProgress","onComplete","_onComplete","onCancel","cancelFinalizationEffort","_onCancel","onUploadPrep","_onUploadPrep","onUpload","_onUpload","onUploadResult","onUploadChunk","chunkData","_onUploadChunk","onUploadChunkResult","partIndex","onUploadChunkSuccess","_onUploadChunkSuccess","onResume","customResumeData","onAutoRetry","responseJSON","_onAutoRetry","onUuidChanged","setSize","_setSize","getDataByUuid","isQueued","isInProgress","getCustomResumeData","_getCustomResumeData","UploadHandlerController","_fileOrBlobRejected","_formatSize","sizeSymbols","max","toFixed","_generateExtraButtonSpecs","_extraButtonSpecs","extraButtons","extraButtonOptionEntry","extraButtonSpec","_initExtraButton","extraButtonsSpec","_defaultButtonId","buttonOrFileInputOrFile","inputs","fileInput","fileBlobOrInput","_getNotFinished","_getValidationBase","_getValidationDescriptor","fileWrapper","_getValidationDescriptors","fileWrappers","fileDescriptors","_handleCameraAccess","camera","acceptIosCamera","optionRoot","details","callbackRetVal","successParam","newFileWrapperList","actualFile","handler","_customNewFileHandler","_handleNewFileGeneric","addFileToHandler","_trackButton","fileList","extSuppliedName","extension","_handleDeleteSuccess","_handleDeleteFailed","_initFormSupportAndParams","_formSupport","FormSupport","attachedToForm","getFormInputsAsObject","autoUpload","newAutoUpload","newEndpoint","_isDeletePossible","expected","allowXdr","allowed","valid","allowedExt","extRegex","code","maybeNameOrNames","messages","names","validationBase","extensionsForMessage","placeholderMatch","replacement","allowedExtension","formatFileName","sizeLimit","minSizeLimit","placeholder","_onBeforeManualRetry","notFinished","_onAllComplete","ios8SafariUploads","alert","unsupportedBrowserIos8Safari","_maybeParseAndSendUploadError","response","errorReason","defaultResponseError","_maybeProcessNextItemAfterOnValidateCallback","validItem","stopOnFirstInvalidFile","validationDescriptor","onValidate","_onValidateCallbackSuccess","_onValidateCallbackFailure","successful","failed","onAllComplete","_shouldAutoRetry","retryWaitPeriod","autoAttemptDelay","_onBeforeAutoRetry","itemLimit","onManualRetry","clearTimeout","storedItemIndex","fileIndex","onIndividualProgress","_onSubmit","_onSubmitCallbackSuccess","_onSubmitted","onSubmitted","_storeForLater","onSuccessCallback","additionalMandatedParams","adjustedOnSuccessCallback","onSubmitDelete","_deleteHandler","sendDelete","_onTotalProgress","onTotalProgress","enableAuto","_onValidateBatchCallbackFailure","_onValidateBatchCallbackSuccess","validationDescriptors","proposedNetFilesUploadedOrQueued","tooManyItemsError","nextIndex","_validateFileOrBlobData","_upload","onValidateBatch","_preventLeaveInProgress","event","onLeave","Session","_session","addFileRecord","refresh","_sessionRequestComplete","onSessionRequestComplete","onNewSize","maxAutoAttempts","formElementOrId","onSubmit","idToUpload","stillSubmitting","validityChecker","allowEmpty","ImageValidation","validate","image","errorCode","_wrapCallbacks","safeCallback","errorMsg","exception","callbackName","callbackFunc","FineUploaderBasic","disableCancelForFormUploads","warnBeforeUnload","filenameParam","forceMultipart","omitDefaultParams","paramsInBody","requireSuccessJson","totalFileSizeName","maxHeight","maxWidth","minHeight","minWidth","maybeXhr","maybeXhrOrXdr","attemptNumber","fileOrBlobData","typeError","sizeError","minSizeError","emptyError","noFilesError","maxHeightImageError","maxWidthImageError","minHeightImageError","minWidthImageError","retryFailTooManyItems","concurrent","mandatory","paramNames","partByteOffset","chunkSize","totalFileSize","totalParts","partSize","jsonPayload","resetOnStatus","recordsExpireIn","resuming","customKeys","fileOrBlobName","sendCredentials","interceptSubmit","customResizer","sendOriginal","orient","defaultType","defaultQuality","failureText","includeExif","sizes","ImageGenerator","_scaler","handleNewFile","TotalProgress","entry","AjaxRequester","shouldParamsBeInQueryString","queue","requestData","acceptHeader","validMethods","contentType","mandatedParams","allowXRequestedWithAndCacheControl","successfulResponseCodes","DELETE","PATCH","POST","PUT","GET","onSend","isSimpleMethod","containsNonSimpleHeaders","containsNonSimple","header","isXdr","getCorsAjaxTransport","ontimeout","onprogress","getXhrOrXdr","suppliedXhr","dequeue","nextId","sendRequest","xdrError","isResponseSuccessful","getParams","onDemandParams","additionalParams","optXhr","payload","url","createUrl","additionalQueryParams","getXdrLoadHandler","getXdrErrorHandler","onreadystatechange","getXhrReadyStateChangeHandler","registerForUploadProgress","open","setHeaders","send","stringify","addToPath","readyState","lengthComputable","onDemandHeaders","additionalHeaders","allHeaders","setRequestHeader","responseCode","prepareToSend","initTransport","path","cacheBuster","withPath","appendToPath","withParams","withQueryParams","_additionalQueryParams_","withHeaders","withPayload","thePayload","withCacheBuster","qqtimestamp","Date","getTime","canceled","UploadHandler","proxy","fileState","fileItem","onCancelRetVal","getThirdPartyFileId","_getFileState","_setThirdPartyFileId","thirdPartyFileId","_wasCanceled","controller","chunkingPossible","concurrentChunkingPossible","preventRetryResponse","chunked","chunkIdx","_getChunkData","attemptingResume","chunkProgress","_getChunkDataForCallback","finalize","finalizeChunks","normaizedResponse","normalizeResponse","_maybeDeletePersistedChunkData","cleanup","normalizedResponse","handleFailure","clearCachedChunk","responseToReport","inProgressIdx","inProgressChunksArray","inProgress","remaining","unshift","ignoreFailure","keys","_getXhrs","ckid","ckXhr","abort","_cancelled","moveInProgressToRemaining","connectionManager","free","hasMoreParts","nextPart","nextIdx","_getTotalChunks","reevaluateChunking","sendNext","inProgressChunks","available","onUploadChunkPromise","requestOverrides","uploadChunkData","overrides","uploadChunk","inProgressChunkIdx","_maybePersistChunkedState","clearXhr","_open","_openChunks","_waiting","openChunkEntriesCount","openChunksCount","openChunkIndexes","dontAllowNext","allowNext","waitingIndex","connectionsIndex","getProxyOrBlob","getWaitingOrConnected","waitingOrConnected","chunks","parseInt","isUsingConnection","pop","openChunksEntry","simple","uploadFile","maybeNewUuid","_clearXhrs","getProxy","initHandler","handlerType","traditional","handlerModuleSubtype","onFinalizing","_removeExpiredChunkingRecords","isDeferredEligibleForUpload","maybeDefer","generatedBlob","updateBlob","maybeSendDeferredFiles","errorResponse","idsInGroup","uploadedThisId","idInGroup","now","originalResponse","_shouldChunkThisFile","blobToUpload","cancelRetVal","isProxied","_getLocalStorageId","isAttemptingResume","WindowReceiveMessage","callbackWrapperDetachers","receiveMessage","onMessageCallbackWrapper","stopReceivingMessages","detacher","FormUploadHandler","formHandlerInstanceId","onloadCallbacks","detachLoadEvents","postMessageCallbackTimers","isCors","corsMessageReceiver","expungeFile","iframe","getElementById","_getIframeName","getFileIdForIframeName","iframeName","initIframeForUpload","body","registerPostMessageCallback","_parseJsonResponse","onloadCallback","_detachLoadEvent","_attachLoadEvent","responseDescriptor","contentDocument","_createIframe","_initFormForUpload","targetName","innerHtmlOrMessage","XhrUploadHandler","getChunkSize","chunkFiles","resumeEnabled","xhrId","ajaxRequester","_getAjaxRequester","blobOrProxy","_initTempState","_maybePrepareForResume","cachedChunks","tempState","xhrs","ajaxRequesters","responseParser","lastChunkIdx","_getXhr","resumableFilesData","_iterateResumeRecords","notResumable","optInProgress","optRemaining","chunkingState","reverse","paused","totalChunks","parts","newBlob","chunkId","_createXhr","optChunkIdx","_registerXhr","chunkIndex","fileSize","startBytes","endBytes","part","count","startByte","endByte","formatVersion","localStorageId","forEach","_getMimeType","_getPersistableData","ceil","_markNotResumable","removeItem","persistedData","lastUpdated","_registerProgressHandler","progressCalculator","totalSuccessfullyLoadedForFile","loadedForRequest","totalForRequest","estActualChunkLoaded","totalLoadedForFile","chunkLoaded","optAjaxRequester","xhrsId","expirationDays","expirationDate","setDate","getDate","requester","getMandatedParams","_method","detectSubsampling","img","iw","naturalWidth","ih","naturalHeight","ctx","width","getContext","drawImage","getImageData","detectVerticalSquash","sy","ey","py","alpha","ratio","renderImageToDataURL","doSquash","renderImageToCanvas","maybeCalculateDownsampledDimensions","maxPixels","origHeight","origWidth","newHeight","sqrt","newWidth","modifiedDimensions","save","resize","renderImageToCanvasWithCustomResizer","imageHeight","imageWidth","orientation","targetHeight","targetWidth","transformCoordinate","d","tmpCanvas","vertSquashRatio","dw","dh","dy","tmpCtx","sx","dx","clearRect","restore","qqImageRendered","resizeInfo","sourceCanvas","sourceCanvasContext","targetCanvas","translate","rotate","PI","MegaPixImage","srcImage","errorCallback","Image","URL","createObjectURL","webkitURL","src","listeners","imageLoadListeners","render","imgWidth","imgHeight","opt","optionsKey","optionsValue","oldTargetSrc","onrender","isImg","el","isCanvas","isImgCorsSupported","crossOrigin","isCanvasSupported","determineMimeOfFileName","nameWithPath","pathSegments","isCrossOrigin","targetAnchor","targetProtocol","targetHostname","targetPort","href","protocol","port","hostname","location","registerImgLoadListeners","registerCanvasDrawImageListener","registerThumbnailRenderedListener","registered","draw","drawPreview","Identify","megapixErrorHandler","isPreviewable","dummyExif","exif","Exif","mpImg","Orientation","failureMsg","drawOnCanvasOrImgFromUrl","canvasOrImg","tempImg","tempImgRender","rendered","drawOnImgFromUrlWithCssScaling","drawFromUrl","fileBlobOrUrl","_testing","TAG_IDS","TAG_INFO","274","parseLittleEndian","hex","pow","seekToApp1","offset","theOffset","thePromise","segmentLength","getApp1Offset","isLittleEndian","app1Start","getDirEntryCount","littleEndian","getIfd","dirEntries","getDirEntries","ifdHex","getTagValues","TAG_VAL_OFFSET","tagsToFind","vals","idHex","tagsToFindIdx","tagValHex","tagValLength","parser","onParseFailure","app1Offset","dirEntryCount","tagValues","isIdentifiable","magicBytes","questionableBytes","identifiable","magicBytesEntries","magicBytesArrayEntry","previewable","isPreviewableSync","PREVIEWABLE_MIME_TYPES","fileMime","isRecognizedImage","image/jpeg","image/gif","image/png","image/bmp","image/tiff","hasNonZeroLimits","limits","atLeastOne","limit","getWidthHeight","sizeDetermination","getFailingLimit","dimensions","failingLimit","limitName","limitValue","limitMatcher","dimensionPropName","actualValue","validationEffort","isJsonResponseValid","handleFileItems","fileItems","someItemsIgnored","err","refreshEffort","refreshCompleteCallback","requesterOptions","SessionAjaxRequester","queryServer","responseText","includeOriginal","failedToScaleText","_getSortedSizes","getFileRecords","originalFileUuid","originalFileName","originalBlobOrBlobData","records","originalBlob","sizeRecord","outputType","_determineOutputType","requestedType","refType","_getName","_generateScaledImage","failedText","api","scaledIds","originalId","blobSize","scaledId","qqparentuuid","qqparentsize","param","scalingEffort","scalingOptions","scaler","referenceType","scaledVersionProperties","startOfExt","versionType","scaledName","scaledExt","nameAppendage","sort","a","b","sourceFile","imageGenerator","scaledImageDataUri","signalSuccess","_insertExifHeader","scaledImageDataUriWithExif","originalImage","reader","insertionEffort","originalImageDataUri","ExifRestorer","readAsDataURL","_dataUriToBlob","_createBlob","KEY_STR","encode64","output","chr1","chr2","chr3","enc1","enc2","enc3","enc4","isNaN","origFileBase64","resizedFileBase64","expectedBase64Header","rawImage","decode64","segments","slice2Segments","exifManipulation","exifArray","getExifArray","newImageArray","insertExif","aBuffer","seg","x","imageData","buf","separatePoint","mae","ato","array","rawImageArray","head","endPoint","base64test","perFileProgress","totalLoaded","totalSize","lastLoadedSent","lastTotalSent","callbackProxy","noRetryableFiles","retryable","none","failedId","updateTotalProgress","onNew","newLoaded","newTotal","oldLoaded","oldTotal","detachPasteHandler","isImage","registerPasteHandler","clipboardData","getAsFile","unregisterPasteHandler","startUpload","formEl","_form2Obj","determineNewEndpoint","validateForm","nativeSubmit","checkValidity","maybeUploadOnSubmit","submit","determineFormEl","notIrrelevantType","irrelevantTypes","radioOrCheckbox","ignoreValue","checked","selectValue","select","selected","elements","getIframeContentJson","doc","innerHtml","contentWindow","nodeValue","createForm","responseFromMessage","multipart","addChunkingSpecificParams","allChunksDoneRequester","AllChunksDoneAjaxRequester","createReadyStateChangedHandler","onUploadOrChunkComplete","getChunksCompleteParams","isErrorUploadResponse","parseResponse","sendChunksCompleteRequest","complete","setParamsAndGetEntityToSend","entityToSendParams","xhrOverrides","customParams","defaultParams","xhrOverrideParams","setUploadHeaders","headersOptions","headerOverrides","headerName","headerValue","extraHeaders","uploadChunkParams","toSend","promises","endpointHandler"],"mappings":"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","sourcesContent":[null,"/*globals window, navigator, document, FormData, File, HTMLInputElement, XMLHttpRequest, Blob, Storage, ActiveXObject */\n/* jshint -W079 */\nvar qq = function(element) {\n    \"use strict\";\n\n    return {\n        hide: function() {\n            element.style.display = \"none\";\n            return this;\n        },\n\n        /** Returns the function which detaches attached event */\n        attach: function(type, fn) {\n            if (element.addEventListener) {\n                element.addEventListener(type, fn, false);\n            } else if (element.attachEvent) {\n                element.attachEvent(\"on\" + type, fn);\n            }\n            return function() {\n                qq(element).detach(type, fn);\n            };\n        },\n\n        detach: function(type, fn) {\n            if (element.removeEventListener) {\n                element.removeEventListener(type, fn, false);\n            } else if (element.attachEvent) {\n                element.detachEvent(\"on\" + type, fn);\n            }\n            return this;\n        },\n\n        contains: function(descendant) {\n            // The [W3C spec](http://www.w3.org/TR/domcore/#dom-node-contains)\n            // says a `null` (or ostensibly `undefined`) parameter\n            // passed into `Node.contains` should result in a false return value.\n            // IE7 throws an exception if the parameter is `undefined` though.\n            if (!descendant) {\n                return false;\n            }\n\n            // compareposition returns false in this case\n            if (element === descendant) {\n                return true;\n            }\n\n            if (element.contains) {\n                return element.contains(descendant);\n            } else {\n                /*jslint bitwise: true*/\n                return !!(descendant.compareDocumentPosition(element) & 8);\n            }\n        },\n\n        /**\n         * Insert this element before elementB.\n         */\n        insertBefore: function(elementB) {\n            elementB.parentNode.insertBefore(element, elementB);\n            return this;\n        },\n\n        remove: function() {\n            element.parentNode.removeChild(element);\n            return this;\n        },\n\n        /**\n         * Sets styles for an element.\n         * Fixes opacity in IE6-8.\n         */\n        css: function(styles) {\n            /*jshint eqnull: true*/\n            if (element.style == null) {\n                throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n            }\n\n            /*jshint -W116*/\n            if (styles.opacity != null) {\n                if (typeof element.style.opacity !== \"string\" && typeof (element.filters) !== \"undefined\") {\n                    styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                }\n            }\n            qq.extend(element.style, styles);\n\n            return this;\n        },\n\n        hasClass: function(name, considerParent) {\n            var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n            return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n        },\n\n        addClass: function(name) {\n            if (!qq(element).hasClass(name)) {\n                element.className += \" \" + name;\n            }\n            return this;\n        },\n\n        removeClass: function(name) {\n            var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n            element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n            return this;\n        },\n\n        getByClass: function(className, first) {\n            var candidates,\n                result = [];\n\n            if (first && element.querySelector) {\n                return element.querySelector(\".\" + className);\n            }\n            else if (element.querySelectorAll) {\n                return element.querySelectorAll(\".\" + className);\n            }\n\n            candidates = element.getElementsByTagName(\"*\");\n\n            qq.each(candidates, function(idx, val) {\n                if (qq(val).hasClass(className)) {\n                    result.push(val);\n                }\n            });\n            return first ? result[0] : result;\n        },\n\n        getFirstByClass: function(className) {\n            return qq(element).getByClass(className, true);\n        },\n\n        children: function() {\n            var children = [],\n                child = element.firstChild;\n\n            while (child) {\n                if (child.nodeType === 1) {\n                    children.push(child);\n                }\n                child = child.nextSibling;\n            }\n\n            return children;\n        },\n\n        setText: function(text) {\n            element.innerText = text;\n            element.textContent = text;\n            return this;\n        },\n\n        clearText: function() {\n            return qq(element).setText(\"\");\n        },\n\n        // Returns true if the attribute exists on the element\n        // AND the value of the attribute is NOT \"false\" (case-insensitive)\n        hasAttribute: function(attrName) {\n            var attrVal;\n\n            if (element.hasAttribute) {\n\n                if (!element.hasAttribute(attrName)) {\n                    return false;\n                }\n\n                /*jshint -W116*/\n                return (/^false$/i).exec(element.getAttribute(attrName)) == null;\n            }\n            else {\n                attrVal = element[attrName];\n\n                if (attrVal === undefined) {\n                    return false;\n                }\n\n                /*jshint -W116*/\n                return (/^false$/i).exec(attrVal) == null;\n            }\n        }\n    };\n};\n\n(function() {\n    \"use strict\";\n\n    qq.canvasToBlob = function(canvas, mime, quality) {\n        return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n    };\n\n    qq.dataUriToBlob = function(dataUri) {\n        var arrayBuffer, byteString,\n            createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder ||\n                        window.WebKitBlobBuilder ||\n                        window.MozBlobBuilder ||\n                        window.MSBlobBuilder,\n                    blobBuilder = BlobBuilder && new BlobBuilder();\n\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                }\n                else {\n                    return new Blob([data], {type: mime});\n                }\n            },\n            intArray, mimeString;\n\n        // convert base64 to raw binary data held in a string\n        if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n            byteString = atob(dataUri.split(\",\")[1]);\n        }\n        else {\n            byteString = decodeURI(dataUri.split(\",\")[1]);\n        }\n\n        // extract the MIME\n        mimeString = dataUri.split(\",\")[0]\n            .split(\":\")[1]\n            .split(\";\")[0];\n\n        // write the bytes of the binary string to an ArrayBuffer\n        arrayBuffer = new ArrayBuffer(byteString.length);\n        intArray = new Uint8Array(arrayBuffer);\n        qq.each(byteString, function(idx, character) {\n            intArray[idx] = character.charCodeAt(0);\n        });\n\n        return createBlob(arrayBuffer, mimeString);\n    };\n\n    qq.log = function(message, level) {\n        if (window.console) {\n            if (!level || level === \"info\") {\n                window.console.log(message);\n            }\n            else\n            {\n                if (window.console[level]) {\n                    window.console[level](message);\n                }\n                else {\n                    window.console.log(\"<\" + level + \"> \" + message);\n                }\n            }\n        }\n    };\n\n    qq.isObject = function(variable) {\n        return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n    };\n\n    qq.isFunction = function(variable) {\n        return typeof (variable) === \"function\";\n    };\n\n    /**\n     * Check the type of a value.  Is it an \"array\"?\n     *\n     * @param value value to test.\n     * @returns true if the value is an array or associated with an `ArrayBuffer`\n     */\n    qq.isArray = function(value) {\n        return Object.prototype.toString.call(value) === \"[object Array]\" ||\n            (value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer);\n    };\n\n    // Looks for an object on a `DataTransfer` object that is associated with drop events when utilizing the Filesystem API.\n    qq.isItemList = function(maybeItemList) {\n        return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n    };\n\n    // Looks for an object on a `NodeList` or an `HTMLCollection`|`HTMLFormElement`|`HTMLSelectElement`\n    // object that is associated with collections of Nodes.\n    qq.isNodeList = function(maybeNodeList) {\n        return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" ||\n            // If `HTMLCollection` is the actual type of the object, we must determine this\n            // by checking for expected properties/methods on the object\n            (maybeNodeList.item && maybeNodeList.namedItem);\n    };\n\n    qq.isString = function(maybeString) {\n        return Object.prototype.toString.call(maybeString) === \"[object String]\";\n    };\n\n    qq.trimStr = function(string) {\n        if (String.prototype.trim) {\n            return string.trim();\n        }\n\n        return string.replace(/^\\s+|\\s+$/g, \"\");\n    };\n\n    /**\n     * @param str String to format.\n     * @returns {string} A string, swapping argument values with the associated occurrence of {} in the passed string.\n     */\n    qq.format = function(str) {\n\n        var args =  Array.prototype.slice.call(arguments, 1),\n            newStr = str,\n            nextIdxToReplace = newStr.indexOf(\"{}\");\n\n        qq.each(args, function(idx, val) {\n            var strBefore = newStr.substring(0, nextIdxToReplace),\n                strAfter = newStr.substring(nextIdxToReplace + 2);\n\n            newStr = strBefore + val + strAfter;\n            nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n\n            // End the loop if we have run out of tokens (when the arguments exceed the # of tokens)\n            if (nextIdxToReplace < 0) {\n                return false;\n            }\n        });\n\n        return newStr;\n    };\n\n    qq.isFile = function(maybeFile) {\n        return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n    };\n\n    qq.isFileList = function(maybeFileList) {\n        return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n    };\n\n    qq.isFileOrInput = function(maybeFileOrInput) {\n        return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n    };\n\n    qq.isInput = function(maybeInput, notFile) {\n        var evaluateType = function(type) {\n            var normalizedType = type.toLowerCase();\n\n            if (notFile) {\n                return normalizedType !== \"file\";\n            }\n\n            return normalizedType === \"file\";\n        };\n\n        if (window.HTMLInputElement) {\n            if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                if (maybeInput.type && evaluateType(maybeInput.type)) {\n                    return true;\n                }\n            }\n        }\n        if (maybeInput.tagName) {\n            if (maybeInput.tagName.toLowerCase() === \"input\") {\n                if (maybeInput.type && evaluateType(maybeInput.type)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    qq.isBlob = function(maybeBlob) {\n        if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n            return true;\n        }\n    };\n\n    qq.isXhrUploadSupported = function() {\n        var input = document.createElement(\"input\");\n        input.type = \"file\";\n\n        return (\n            input.multiple !== undefined &&\n                typeof File !== \"undefined\" &&\n                typeof FormData !== \"undefined\" &&\n                typeof (qq.createXhrInstance()).upload !== \"undefined\");\n    };\n\n    // Fall back to ActiveX is native XHR is disabled (possible in any version of IE).\n    qq.createXhrInstance = function() {\n        if (window.XMLHttpRequest) {\n            return new XMLHttpRequest();\n        }\n\n        try {\n            return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n        }\n        catch (error) {\n            qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n            return null;\n        }\n    };\n\n    qq.isFolderDropSupported = function(dataTransfer) {\n        return dataTransfer.items &&\n            dataTransfer.items.length > 0 &&\n            dataTransfer.items[0].webkitGetAsEntry;\n    };\n\n    qq.isFileChunkingSupported = function() {\n        return !qq.androidStock() && //Android's stock browser cannot upload Blobs correctly\n            qq.isXhrUploadSupported() &&\n            (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n    };\n\n    qq.sliceBlob = function(fileOrBlob, start, end) {\n        var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n\n        return slicer.call(fileOrBlob, start, end);\n    };\n\n    qq.arrayBufferToHex = function(buffer) {\n        var bytesAsHex = \"\",\n            bytes = new Uint8Array(buffer);\n\n        qq.each(bytes, function(idx, byt) {\n            var byteAsHexStr = byt.toString(16);\n\n            if (byteAsHexStr.length < 2) {\n                byteAsHexStr = \"0\" + byteAsHexStr;\n            }\n\n            bytesAsHex += byteAsHexStr;\n        });\n\n        return bytesAsHex;\n    };\n\n    qq.readBlobToHex = function(blob, startOffset, length) {\n        var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length),\n            fileReader = new FileReader(),\n            promise = new qq.Promise();\n\n        fileReader.onload = function() {\n            promise.success(qq.arrayBufferToHex(fileReader.result));\n        };\n\n        fileReader.onerror = promise.failure;\n\n        fileReader.readAsArrayBuffer(initialBlob);\n\n        return promise;\n    };\n\n    qq.extend = function(first, second, extendNested) {\n        qq.each(second, function(prop, val) {\n            if (extendNested && qq.isObject(val)) {\n                if (first[prop] === undefined) {\n                    first[prop] = {};\n                }\n                qq.extend(first[prop], val, true);\n            }\n            else {\n                first[prop] = val;\n            }\n        });\n\n        return first;\n    };\n\n    /**\n     * Allow properties in one object to override properties in another,\n     * keeping track of the original values from the target object.\n     *\n     * Note that the pre-overriden properties to be overriden by the source will be passed into the `sourceFn` when it is invoked.\n     *\n     * @param target Update properties in this object from some source\n     * @param sourceFn A function that, when invoked, will return properties that will replace properties with the same name in the target.\n     * @returns {object} The target object\n     */\n    qq.override = function(target, sourceFn) {\n        var super_ = {},\n            source = sourceFn(super_);\n\n        qq.each(source, function(srcPropName, srcPropVal) {\n            if (target[srcPropName] !== undefined) {\n                super_[srcPropName] = target[srcPropName];\n            }\n\n            target[srcPropName] = srcPropVal;\n        });\n\n        return target;\n    };\n\n    /**\n     * Searches for a given element (elt) in the array, returns -1 if it is not present.\n     */\n    qq.indexOf = function(arr, elt, from) {\n        if (arr.indexOf) {\n            return arr.indexOf(elt, from);\n        }\n\n        from = from || 0;\n        var len = arr.length;\n\n        if (from < 0) {\n            from += len;\n        }\n\n        for (; from < len; from += 1) {\n            if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n\n    //this is a version 4 UUID\n    qq.getUniqueId = function() {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n            /*jslint eqeq: true, bitwise: true*/\n            var r = Math.random() * 16 | 0, v = c == \"x\" ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    };\n\n    //\n    // Browsers and platforms detection\n    qq.ie = function() {\n        return navigator.userAgent.indexOf(\"MSIE\") !== -1 ||\n            navigator.userAgent.indexOf(\"Trident\") !== -1;\n    };\n\n    qq.ie7 = function() {\n        return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n    };\n\n    qq.ie8 = function() {\n        return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n    };\n\n    qq.ie10 = function() {\n        return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n    };\n\n    qq.ie11 = function() {\n        return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n    };\n\n    qq.edge = function() {\n        return navigator.userAgent.indexOf(\"Edge\") >= 0;\n    };\n\n    qq.safari = function() {\n        return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n    };\n\n    qq.chrome = function() {\n        return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n    };\n\n    qq.opera = function() {\n        return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n    };\n\n    qq.firefox = function() {\n        return (!qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\");\n    };\n\n    qq.windows = function() {\n        return navigator.platform === \"Win32\";\n    };\n\n    qq.android = function() {\n        return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n    };\n\n    // We need to identify the Android stock browser via the UA string to work around various bugs in this browser,\n    // such as the one that prevents a `Blob` from being uploaded.\n    qq.androidStock = function() {\n        return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n    };\n\n    qq.ios6 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n    };\n\n    qq.ios7 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n    };\n\n    qq.ios8 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n    };\n\n    // iOS 8.0.0\n    qq.ios800 = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n    };\n\n    qq.ios = function() {\n        /*jshint -W014 */\n        return navigator.userAgent.indexOf(\"iPad\") !== -1\n            || navigator.userAgent.indexOf(\"iPod\") !== -1\n            || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n    };\n\n    qq.iosChrome = function() {\n        return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n    };\n\n    qq.iosSafari = function() {\n        return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n    };\n\n    qq.iosSafariWebView = function() {\n        return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n    };\n\n    //\n    // Events\n\n    qq.preventDefault = function(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n    };\n\n    /**\n     * Creates and returns element from html string\n     * Uses innerHTML to create an element\n     */\n    qq.toElement = (function() {\n        var div = document.createElement(\"div\");\n        return function(html) {\n            div.innerHTML = html;\n            var element = div.firstChild;\n            div.removeChild(element);\n            return element;\n        };\n    }());\n\n    //key and value are passed to callback for each entry in the iterable item\n    qq.each = function(iterableItem, callback) {\n        var keyOrIndex, retVal;\n\n        if (iterableItem) {\n            // Iterate through [`Storage`](http://www.w3.org/TR/webstorage/#the-storage-interface) items\n            if (window.Storage && iterableItem.constructor === window.Storage) {\n                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                    retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                    if (retVal === false) {\n                        break;\n                    }\n                }\n            }\n            // `DataTransferItemList` & `NodeList` objects are array-like and should be treated as arrays\n            // when iterating over items inside the object.\n            else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                    retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                    if (retVal === false) {\n                        break;\n                    }\n                }\n            }\n            else if (qq.isString(iterableItem)) {\n                for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                    retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                    if (retVal === false) {\n                        break;\n                    }\n                }\n            }\n            else {\n                for (keyOrIndex in iterableItem) {\n                    if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    //include any args that should be passed to the new function after the context arg\n    qq.bind = function(oldFunc, context) {\n        if (qq.isFunction(oldFunc)) {\n            var args =  Array.prototype.slice.call(arguments, 2);\n\n            return function() {\n                var newArgs = qq.extend([], args);\n                if (arguments.length) {\n                    newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                }\n                return oldFunc.apply(context, newArgs);\n            };\n        }\n\n        throw new Error(\"first parameter must be a function!\");\n    };\n\n    /**\n     * obj2url() takes a json-object as argument and generates\n     * a querystring. pretty much like jQuery.param()\n     *\n     * how to use:\n     *\n     *    `qq.obj2url({a:'b',c:'d'},'http://any.url/upload?otherParam=value');`\n     *\n     * will result in:\n     *\n     *    `http://any.url/upload?otherParam=value&a=b&c=d`\n     *\n     * @param  Object JSON-Object\n     * @param  String current querystring-part\n     * @return String encoded querystring\n     */\n    qq.obj2url = function(obj, temp, prefixDone) {\n        /*jshint laxbreak: true*/\n        var uristrings = [],\n            prefix = \"&\",\n            add = function(nextObj, i) {\n                var nextTemp = temp\n                    ? (/\\[\\]$/.test(temp)) // prevent double-encoding\n                    ? temp\n                    : temp + \"[\" + i + \"]\"\n                    : i;\n                if ((nextTemp !== \"undefined\") && (i !== \"undefined\")) {\n                    uristrings.push(\n                        (typeof nextObj === \"object\")\n                            ? qq.obj2url(nextObj, nextTemp, true)\n                            : (Object.prototype.toString.call(nextObj) === \"[object Function]\")\n                            ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj())\n                            : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj)\n                    );\n                }\n            };\n\n        if (!prefixDone && temp) {\n            prefix = (/\\?/.test(temp)) ? (/\\?$/.test(temp)) ? \"\" : \"&\" : \"?\";\n            uristrings.push(temp);\n            uristrings.push(qq.obj2url(obj));\n        } else if ((Object.prototype.toString.call(obj) === \"[object Array]\") && (typeof obj !== \"undefined\")) {\n            qq.each(obj, function(idx, val) {\n                add(val, idx);\n            });\n        } else if ((typeof obj !== \"undefined\") && (obj !== null) && (typeof obj === \"object\")) {\n            qq.each(obj, function(prop, val) {\n                add(val, prop);\n            });\n        } else {\n            uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n        }\n\n        if (temp) {\n            return uristrings.join(prefix);\n        } else {\n            return uristrings.join(prefix)\n                .replace(/^&/, \"\")\n                .replace(/%20/g, \"+\");\n        }\n    };\n\n    qq.obj2FormData = function(obj, formData, arrayKeyName) {\n        if (!formData) {\n            formData = new FormData();\n        }\n\n        qq.each(obj, function(key, val) {\n            key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n\n            if (qq.isObject(val)) {\n                qq.obj2FormData(val, formData, key);\n            }\n            else if (qq.isFunction(val)) {\n                formData.append(key, val());\n            }\n            else {\n                formData.append(key, val);\n            }\n        });\n\n        return formData;\n    };\n\n    qq.obj2Inputs = function(obj, form) {\n        var input;\n\n        if (!form) {\n            form = document.createElement(\"form\");\n        }\n\n        qq.obj2FormData(obj, {\n            append: function(key, val) {\n                input = document.createElement(\"input\");\n                input.setAttribute(\"name\", key);\n                input.setAttribute(\"value\", val);\n                form.appendChild(input);\n            }\n        });\n\n        return form;\n    };\n\n    /**\n     * Not recommended for use outside of Fine Uploader since this falls back to an unchecked eval if JSON.parse is not\n     * implemented.  For a more secure JSON.parse polyfill, use Douglas Crockford's json2.js.\n     */\n    qq.parseJson = function(json) {\n        /*jshint evil: true*/\n        if (window.JSON && qq.isFunction(JSON.parse)) {\n            return JSON.parse(json);\n        } else {\n            return eval(\"(\" + json + \")\");\n        }\n    };\n\n    /**\n     * Retrieve the extension of a file, if it exists.\n     *\n     * @param filename\n     * @returns {string || undefined}\n     */\n    qq.getExtension = function(filename) {\n        var extIdx = filename.lastIndexOf(\".\") + 1;\n\n        if (extIdx > 0) {\n            return filename.substr(extIdx, filename.length - extIdx);\n        }\n    };\n\n    qq.getFilename = function(blobOrFileInput) {\n        /*jslint regexp: true*/\n\n        if (qq.isInput(blobOrFileInput)) {\n            // get input value and remove path to normalize\n            return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n        }\n        else if (qq.isFile(blobOrFileInput)) {\n            if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                return blobOrFileInput.fileName;\n            }\n        }\n\n        return blobOrFileInput.name;\n    };\n\n    /**\n     * A generic module which supports object disposing in dispose() method.\n     * */\n    qq.DisposeSupport = function() {\n        var disposers = [];\n\n        return {\n            /** Run all registered disposers */\n            dispose: function() {\n                var disposer;\n                do {\n                    disposer = disposers.shift();\n                    if (disposer) {\n                        disposer();\n                    }\n                }\n                while (disposer);\n            },\n\n            /** Attach event handler and register de-attacher as a disposer */\n            attach: function() {\n                var args = arguments;\n                /*jslint undef:true*/\n                this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n            },\n\n            /** Add disposer to the collection */\n            addDisposer: function(disposeFunction) {\n                disposers.push(disposeFunction);\n            }\n        };\n    };\n}());\n","/* globals define, module, global, qq */\n(function() {\n    \"use strict\";\n    if (typeof define === \"function\" && define.amd) {\n        define(function() {\n            return qq;\n        });\n    }\n    else if (typeof module !== \"undefined\" && module.exports) {\n        module.exports = qq;\n    }\n    else {\n        global.qq = qq;\n    }\n}());\n","/* globals qq */\n/**\n * Fine Uploader top-level Error container.  Inherits from `Error`.\n */\n(function() {\n    \"use strict\";\n\n    qq.Error = function(message) {\n        this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n    };\n\n    qq.Error.prototype = new Error();\n}());\n","/*global qq */\nqq.version = \"5.16.2\";\n","/* globals qq */\nqq.supportedFeatures = (function() {\n    \"use strict\";\n\n    var supportsUploading,\n        supportsUploadingBlobs,\n        supportsFileDrop,\n        supportsAjaxFileUploading,\n        supportsFolderDrop,\n        supportsChunking,\n        supportsResume,\n        supportsUploadViaPaste,\n        supportsUploadCors,\n        supportsDeleteFileXdr,\n        supportsDeleteFileCorsXhr,\n        supportsDeleteFileCors,\n        supportsFolderSelection,\n        supportsImagePreviews,\n        supportsUploadProgress;\n\n    function testSupportsFileInputElement() {\n        var supported = true,\n            tempInput;\n\n        try {\n            tempInput = document.createElement(\"input\");\n            tempInput.type = \"file\";\n            qq(tempInput).hide();\n\n            if (tempInput.disabled) {\n                supported = false;\n            }\n        }\n        catch (ex) {\n            supported = false;\n        }\n\n        return supported;\n    }\n\n    //only way to test for complete Clipboard API support at this time\n    function isChrome14OrHigher() {\n        return (qq.chrome() || qq.opera()) &&\n            navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n    }\n\n    //Ensure we can send cross-origin `XMLHttpRequest`s\n    function isCrossOriginXhrSupported() {\n        if (window.XMLHttpRequest) {\n            var xhr = qq.createXhrInstance();\n\n            //Commonly accepted test for XHR CORS support.\n            return xhr.withCredentials !== undefined;\n        }\n\n        return false;\n    }\n\n    //Test for (terrible) cross-origin ajax transport fallback for IE9 and IE8\n    function isXdrSupported() {\n        return window.XDomainRequest !== undefined;\n    }\n\n    // CORS Ajax requests are supported if it is either possible to send credentialed `XMLHttpRequest`s,\n    // or if `XDomainRequest` is an available alternative.\n    function isCrossOriginAjaxSupported() {\n        if (isCrossOriginXhrSupported()) {\n            return true;\n        }\n\n        return isXdrSupported();\n    }\n\n    function isFolderSelectionSupported() {\n        // We know that folder selection is only supported in Chrome via this proprietary attribute for now\n        return document.createElement(\"input\").webkitdirectory !== undefined;\n    }\n\n    function isLocalStorageSupported() {\n        try {\n            return !!window.localStorage &&\n                // unpatched versions of IE10/11 have buggy impls of localStorage where setItem is a string\n                qq.isFunction(window.localStorage.setItem);\n        }\n        catch (error) {\n            // probably caught a security exception, so no localStorage for you\n            return false;\n        }\n    }\n\n    function isDragAndDropSupported() {\n        var span = document.createElement(\"span\");\n\n        return (\"draggable\" in span || (\"ondragstart\" in span && \"ondrop\" in span)) &&\n            !qq.android() && !qq.ios();\n    }\n\n    supportsUploading = testSupportsFileInputElement();\n\n    supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n\n    supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n\n    supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n\n    // adapted from https://stackoverflow.com/a/23278460/486979\n    supportsFolderDrop = supportsFileDrop && (function() {\n        var input = document.createElement(\"input\");\n\n        input.type = \"file\";\n        return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n    }());\n\n    supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n\n    supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n\n    supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n\n    supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n\n    supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n\n    supportsDeleteFileXdr = isXdrSupported();\n\n    supportsDeleteFileCors = isCrossOriginAjaxSupported();\n\n    supportsFolderSelection = isFolderSelectionSupported();\n\n    supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n\n    supportsUploadProgress = (function() {\n        if (supportsAjaxFileUploading) {\n            return !qq.androidStock() && !qq.iosChrome();\n        }\n        return false;\n    }());\n\n    return {\n        ajaxUploading: supportsAjaxFileUploading,\n        blobUploading: supportsUploadingBlobs,\n        canDetermineSize: supportsAjaxFileUploading,\n        chunking: supportsChunking,\n        deleteFileCors: supportsDeleteFileCors,\n        deleteFileCorsXdr: supportsDeleteFileXdr, //NOTE: will also return true in IE10, where XDR is also supported\n        deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n        dialogElement: !!window.HTMLDialogElement,\n        fileDrop: supportsFileDrop,\n        folderDrop: supportsFolderDrop,\n        folderSelection: supportsFolderSelection,\n        imagePreviews: supportsImagePreviews,\n        imageValidation: supportsImagePreviews,\n        itemSizeValidation: supportsAjaxFileUploading,\n        pause: supportsChunking,\n        progressBar: supportsUploadProgress,\n        resume: supportsResume,\n        scaling: supportsImagePreviews && supportsUploadingBlobs,\n        tiffPreviews: qq.safari(), // Not the best solution, but simple and probably accurate enough (for now)\n        unlimitedScaledImageSize: !qq.ios(), // false simply indicates that there is some known limit\n        uploading: supportsUploading,\n        uploadCors: supportsUploadCors,\n        uploadCustomHeaders: supportsAjaxFileUploading,\n        uploadNonMultipart: supportsAjaxFileUploading,\n        uploadViaPaste: supportsUploadViaPaste\n    };\n\n}());\n","/*globals qq*/\n\n// Is the passed object a promise instance?\nqq.isGenericPromise = function(maybePromise) {\n    \"use strict\";\n    return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n};\n\nqq.Promise = function() {\n    \"use strict\";\n\n    var successArgs, failureArgs,\n        successCallbacks = [],\n        failureCallbacks = [],\n        doneCallbacks = [],\n        state = 0;\n\n    qq.extend(this, {\n        then: function(onSuccess, onFailure) {\n            if (state === 0) {\n                if (onSuccess) {\n                    successCallbacks.push(onSuccess);\n                }\n                if (onFailure) {\n                    failureCallbacks.push(onFailure);\n                }\n            }\n            else if (state === -1) {\n                onFailure && onFailure.apply(null, failureArgs);\n            }\n            else if (onSuccess) {\n                onSuccess.apply(null, successArgs);\n            }\n\n            return this;\n        },\n\n        done: function(callback) {\n            if (state === 0) {\n                doneCallbacks.push(callback);\n            }\n            else {\n                callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n            }\n\n            return this;\n        },\n\n        success: function() {\n            state = 1;\n            successArgs = arguments;\n\n            if (successCallbacks.length) {\n                qq.each(successCallbacks, function(idx, callback) {\n                    callback.apply(null, successArgs);\n                });\n            }\n\n            if (doneCallbacks.length) {\n                qq.each(doneCallbacks, function(idx, callback) {\n                    callback.apply(null, successArgs);\n                });\n            }\n\n            return this;\n        },\n\n        failure: function() {\n            state = -1;\n            failureArgs = arguments;\n\n            if (failureCallbacks.length) {\n                qq.each(failureCallbacks, function(idx, callback) {\n                    callback.apply(null, failureArgs);\n                });\n            }\n\n            if (doneCallbacks.length) {\n                qq.each(doneCallbacks, function(idx, callback) {\n                    callback.apply(null, failureArgs);\n                });\n            }\n\n            return this;\n        }\n    });\n};\n","/* globals qq */\n/**\n * Placeholder for a Blob that will be generated on-demand.\n *\n * @param referenceBlob Parent of the generated blob\n * @param onCreate Function to invoke when the blob must be created.  Must be promissory.\n * @constructor\n */\nqq.BlobProxy = function(referenceBlob, onCreate) {\n    \"use strict\";\n\n    qq.extend(this, {\n        referenceBlob: referenceBlob,\n\n        create: function() {\n            return onCreate(referenceBlob);\n        }\n    });\n};\n","/*globals qq*/\n\n/**\n * This module represents an upload or \"Select File(s)\" button.  It's job is to embed an opaque `<input type=\"file\">`\n * element as a child of a provided \"container\" element.  This \"container\" element (`options.element`) is used to provide\n * a custom style for the `<input type=\"file\">` element.  The ability to change the style of the container element is also\n * provided here by adding CSS classes to the container on hover/focus.\n *\n * TODO Eliminate the mouseover and mouseout event handlers since the :hover CSS pseudo-class should now be\n * available on all supported browsers.\n *\n * @param o Options to override the default values\n */\nqq.UploadButton = function(o) {\n    \"use strict\";\n\n    var self = this,\n\n        disposeSupport = new qq.DisposeSupport(),\n\n        options = {\n            // Corresponds to the `accept` attribute on the associated `<input type=\"file\">`\n            acceptFiles: null,\n\n            // \"Container\" element\n            element: null,\n\n            focusClass: \"qq-upload-button-focus\",\n\n            // A true value allows folders to be selected, if supported by the UA\n            folders: false,\n\n            // **This option will be removed** in the future as the :hover CSS pseudo-class is available on all supported browsers\n            hoverClass: \"qq-upload-button-hover\",\n\n            ios8BrowserCrashWorkaround: false,\n\n            // If true adds `multiple` attribute to `<input type=\"file\">`\n            multiple: false,\n\n            // `name` attribute of `<input type=\"file\">`\n            name: \"qqfile\",\n\n            // Called when the browser invokes the onchange handler on the `<input type=\"file\">`\n            onChange: function(input) {},\n\n            title: null\n        },\n        input, buttonId;\n\n    // Overrides any of the default option values with any option values passed in during construction.\n    qq.extend(options, o);\n\n    buttonId = qq.getUniqueId();\n\n    // Embed an opaque `<input type=\"file\">` element as a child of `options.element`.\n    function createInput() {\n        var input = document.createElement(\"input\");\n\n        input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n        input.setAttribute(\"title\", options.title);\n\n        self.setMultiple(options.multiple, input);\n\n        if (options.folders && qq.supportedFeatures.folderSelection) {\n            // selecting directories is only possible in Chrome now, via a vendor-specific prefixed attribute\n            input.setAttribute(\"webkitdirectory\", \"\");\n        }\n\n        if (options.acceptFiles) {\n            input.setAttribute(\"accept\", options.acceptFiles);\n        }\n\n        input.setAttribute(\"type\", \"file\");\n        input.setAttribute(\"name\", options.name);\n\n        qq(input).css({\n            position: \"absolute\",\n            // in Opera only 'browse' button\n            // is clickable and it is located at\n            // the right side of the input\n            right: 0,\n            top: 0,\n            fontFamily: \"Arial\",\n            // It's especially important to make this an arbitrarily large value\n            // to ensure the rendered input button in IE takes up the entire\n            // space of the container element.  Otherwise, the left side of the\n            // button will require a double-click to invoke the file chooser.\n            // In other browsers, this might cause other issues, so a large font-size\n            // is only used in IE.  There is a bug in IE8 where the opacity style is  ignored\n            // in some cases when the font-size is large.  So, this workaround is not applied\n            // to IE8.\n            fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n            margin: 0,\n            padding: 0,\n            cursor: \"pointer\",\n            opacity: 0\n        });\n\n        // Setting the file input's height to 100% in IE7 causes\n        // most of the visible button to be unclickable.\n        !qq.ie7() && qq(input).css({height: \"100%\"});\n\n        options.element.appendChild(input);\n\n        disposeSupport.attach(input, \"change\", function() {\n            options.onChange(input);\n        });\n\n        // **These event handlers will be removed** in the future as the :hover CSS pseudo-class is available on all supported browsers\n        disposeSupport.attach(input, \"mouseover\", function() {\n            qq(options.element).addClass(options.hoverClass);\n        });\n        disposeSupport.attach(input, \"mouseout\", function() {\n            qq(options.element).removeClass(options.hoverClass);\n        });\n\n        disposeSupport.attach(input, \"focus\", function() {\n            qq(options.element).addClass(options.focusClass);\n        });\n        disposeSupport.attach(input, \"blur\", function() {\n            qq(options.element).removeClass(options.focusClass);\n        });\n\n        return input;\n    }\n\n    // Make button suitable container for input\n    qq(options.element).css({\n        position: \"relative\",\n        overflow: \"hidden\",\n        // Make sure browse button is in the right side in Internet Explorer\n        direction: \"ltr\"\n    });\n\n    // Exposed API\n    qq.extend(this, {\n        getInput: function() {\n            return input;\n        },\n\n        getButtonId: function() {\n            return buttonId;\n        },\n\n        setMultiple: function(isMultiple, optInput) {\n            var input = optInput || this.getInput();\n\n            // Temporary workaround for bug in in iOS8 UIWebView that causes the browser to crash\n            // before the file chooser appears if the file input doesn't contain a multiple attribute.\n            // See #1283.\n            if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                input.setAttribute(\"multiple\", \"\");\n            }\n\n            else {\n                if (isMultiple) {\n                    input.setAttribute(\"multiple\", \"\");\n                }\n                else {\n                    input.removeAttribute(\"multiple\");\n                }\n            }\n        },\n\n        setAcceptFiles: function(acceptFiles) {\n            if (acceptFiles !== options.acceptFiles) {\n                input.setAttribute(\"accept\", acceptFiles);\n            }\n        },\n\n        reset: function() {\n            if (input.parentNode) {\n                qq(input).remove();\n            }\n\n            qq(options.element).removeClass(options.focusClass);\n            input = null;\n            input = createInput();\n        }\n    });\n\n    input = createInput();\n};\n\nqq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n","/*globals qq */\nqq.UploadData = function(uploaderProxy) {\n    \"use strict\";\n\n    var data = [],\n        byUuid = {},\n        byStatus = {},\n        byProxyGroupId = {},\n        byBatchId = {};\n\n    function getDataByIds(idOrIds) {\n        if (qq.isArray(idOrIds)) {\n            var entries = [];\n\n            qq.each(idOrIds, function(idx, id) {\n                entries.push(data[id]);\n            });\n\n            return entries;\n        }\n\n        return data[idOrIds];\n    }\n\n    function getDataByUuids(uuids) {\n        if (qq.isArray(uuids)) {\n            var entries = [];\n\n            qq.each(uuids, function(idx, uuid) {\n                entries.push(data[byUuid[uuid]]);\n            });\n\n            return entries;\n        }\n\n        return data[byUuid[uuids]];\n    }\n\n    function getDataByStatus(status) {\n        var statusResults = [],\n            statuses = [].concat(status);\n\n        qq.each(statuses, function(index, statusEnum) {\n            var statusResultIndexes = byStatus[statusEnum];\n\n            if (statusResultIndexes !== undefined) {\n                qq.each(statusResultIndexes, function(i, dataIndex) {\n                    statusResults.push(data[dataIndex]);\n                });\n            }\n        });\n\n        return statusResults;\n    }\n\n    qq.extend(this, {\n        /**\n         * Adds a new file to the data cache for tracking purposes.\n         *\n         * @param spec Data that describes this file.  Possible properties are:\n         *\n         * - uuid: Initial UUID for this file.\n         * - name: Initial name of this file.\n         * - size: Size of this file, omit if this cannot be determined\n         * - status: Initial `qq.status` for this file.  Omit for `qq.status.SUBMITTING`.\n         * - batchId: ID of the batch this file belongs to\n         * - proxyGroupId: ID of the proxy group associated with this file\n         * - onBeforeStatusChange(fileId): callback that is executed before the status change is broadcast\n         *\n         * @returns {number} Internal ID for this file.\n         */\n        addFile: function(spec) {\n            var status = spec.status || qq.status.SUBMITTING,\n                id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status,\n                    file: spec.file\n                }) - 1;\n\n            if (spec.batchId) {\n                data[id].batchId = spec.batchId;\n\n                if (byBatchId[spec.batchId] === undefined) {\n                    byBatchId[spec.batchId] = [];\n                }\n                byBatchId[spec.batchId].push(id);\n            }\n\n            if (spec.proxyGroupId) {\n                data[id].proxyGroupId = spec.proxyGroupId;\n\n                if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                    byProxyGroupId[spec.proxyGroupId] = [];\n                }\n                byProxyGroupId[spec.proxyGroupId].push(id);\n            }\n\n            data[id].id = id;\n            byUuid[spec.uuid] = id;\n\n            if (byStatus[status] === undefined) {\n                byStatus[status] = [];\n            }\n            byStatus[status].push(id);\n\n            spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n            uploaderProxy.onStatusChange(id, null, status);\n\n            return id;\n        },\n\n        retrieve: function(optionalFilter) {\n            if (qq.isObject(optionalFilter) && data.length)  {\n                if (optionalFilter.id !== undefined) {\n                    return getDataByIds(optionalFilter.id);\n                }\n\n                else if (optionalFilter.uuid !== undefined) {\n                    return getDataByUuids(optionalFilter.uuid);\n                }\n\n                else if (optionalFilter.status) {\n                    return getDataByStatus(optionalFilter.status);\n                }\n            }\n            else {\n                return qq.extend([], data, true);\n            }\n        },\n\n        removeFileRef: function(id) {\n            var record = getDataByIds(id);\n\n            if (record) {\n                delete record.file;\n            }\n        },\n\n        reset: function() {\n            data = [];\n            byUuid = {};\n            byStatus = {};\n            byBatchId = {};\n        },\n\n        setStatus: function(id, newStatus) {\n            var oldStatus = data[id].status,\n                byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n\n            byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n\n            data[id].status = newStatus;\n\n            if (byStatus[newStatus] === undefined) {\n                byStatus[newStatus] = [];\n            }\n            byStatus[newStatus].push(id);\n\n            uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n        },\n\n        uuidChanged: function(id, newUuid) {\n            var oldUuid = data[id].uuid;\n\n            data[id].uuid = newUuid;\n            byUuid[newUuid] = id;\n            delete byUuid[oldUuid];\n        },\n\n        updateName: function(id, newName) {\n            data[id].name = newName;\n        },\n\n        updateSize: function(id, newSize) {\n            data[id].size = newSize;\n        },\n\n        // Only applicable if this file has a parent that we may want to reference later.\n        setParentId: function(targetId, parentId) {\n            data[targetId].parentId = parentId;\n        },\n\n        getIdsInProxyGroup: function(id) {\n            var proxyGroupId = data[id].proxyGroupId;\n\n            if (proxyGroupId) {\n                return byProxyGroupId[proxyGroupId];\n            }\n            return [];\n        },\n\n        getIdsInBatch: function(id) {\n            var batchId = data[id].batchId;\n\n            return byBatchId[batchId];\n        }\n    });\n};\n\nqq.status = {\n    SUBMITTING: \"submitting\",\n    SUBMITTED: \"submitted\",\n    REJECTED: \"rejected\",\n    QUEUED: \"queued\",\n    CANCELED: \"canceled\",\n    PAUSED: \"paused\",\n    UPLOADING: \"uploading\",\n    UPLOAD_FINALIZING: \"upload finalizing\",\n    UPLOAD_RETRYING: \"retrying upload\",\n    UPLOAD_SUCCESSFUL: \"upload successful\",\n    UPLOAD_FAILED: \"upload failed\",\n    DELETE_FAILED: \"delete failed\",\n    DELETING: \"deleting\",\n    DELETED: \"deleted\"\n};\n","/*globals qq*/\n/**\n * Defines the public API for FineUploaderBasic mode.\n */\n(function() {\n    \"use strict\";\n\n    qq.basePublicApi = {\n        // DEPRECATED - TODO REMOVE IN NEXT MAJOR RELEASE (replaced by addFiles)\n        addBlobs: function(blobDataOrArray, params, endpoint) {\n            this.addFiles(blobDataOrArray, params, endpoint);\n        },\n\n        addInitialFiles: function(cannedFileList) {\n            var self = this;\n\n            qq.each(cannedFileList, function(index, cannedFile) {\n                self._addCannedFile(cannedFile);\n            });\n        },\n\n        addFiles: function(data, params, endpoint) {\n            this._maybeHandleIos8SafariWorkaround();\n\n            var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId,\n\n                processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this),\n\n                processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this),\n\n                processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this),\n\n                processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100,\n                        blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this),\n\n                processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files),\n                            self = this;\n\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    }\n                    else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this),\n\n                normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                },\n\n                self = this,\n                verifiedFiles = [];\n\n            this._currentBatchId = batchId;\n\n            if (data) {\n                normalizeData();\n\n                qq.each(data, function(idx, fileContainer) {\n                    if (qq.isFileOrInput(fileContainer)) {\n                        processFileOrInput(fileContainer);\n                    }\n                    else if (qq.isBlob(fileContainer)) {\n                        processBlob(fileContainer);\n                    }\n                    else if (qq.isObject(fileContainer)) {\n                        if (fileContainer.blob && fileContainer.name) {\n                            processBlobData(fileContainer);\n                        }\n                        else if (fileContainer.canvas && fileContainer.name) {\n                            processCanvasData(fileContainer);\n                        }\n                    }\n                    else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                        processCanvas(fileContainer);\n                    }\n                    else {\n                        self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                    }\n                });\n\n                this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n            }\n        },\n\n        cancel: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n                this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n            }\n            else {\n                this._handler.cancel(id);\n            }\n        },\n\n        cancelAll: function() {\n            var storedIdsCopy = [],\n                self = this;\n\n            qq.extend(storedIdsCopy, this._storedIds);\n            qq.each(storedIdsCopy, function(idx, storedFileId) {\n                self.cancel(storedFileId);\n            });\n\n            this._handler.cancelAll();\n        },\n\n        clearStoredFiles: function() {\n            this._storedIds = [];\n        },\n\n        continueUpload: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                return false;\n            }\n\n            if (uploadData.status === qq.status.PAUSED) {\n                this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                this._uploadFile(id);\n                return true;\n            }\n            else {\n                this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n            }\n\n            return false;\n        },\n\n        deleteFile: function(id) {\n            return this._onSubmitDelete(id);\n        },\n\n        // TODO document?\n        doesExist: function(fileOrBlobId) {\n            return this._handler.isValid(fileOrBlobId);\n        },\n\n        // Generate a variable size thumbnail on an img or canvas,\n        // returning a promise that is fulfilled when the attempt completes.\n        // Thumbnail can either be based off of a URL for an image returned\n        // by the server in the upload response, or the associated `Blob`.\n        drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n            var promiseToReturn = new qq.Promise(),\n                fileOrUrl, options;\n\n            if (this._imageGenerator) {\n                fileOrUrl = this._thumbnailUrls[fileId];\n                options = {\n                    customResizeFunction: customResizeFunction,\n                    maxSize: maxSize > 0 ? maxSize : null,\n                    scale: maxSize > 0\n                };\n\n                // If client-side preview generation is possible\n                // and we are not specifically looking for the image URl returned by the server...\n                if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                    fileOrUrl = this.getFile(fileId);\n                }\n\n                /* jshint eqeqeq:false,eqnull:true */\n                if (fileOrUrl == null) {\n                    promiseToReturn.failure({container: imgOrCanvas, error: \"File or URL not found.\"});\n                }\n                else {\n                    this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(\n                        function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        },\n\n                        function failure(container, reason) {\n                            promiseToReturn.failure({container: container, error: reason || \"Problem generating thumbnail\"});\n                        }\n                    );\n                }\n            }\n            else {\n                promiseToReturn.failure({container: imgOrCanvas, error: \"Missing image generator module\"});\n            }\n\n            return promiseToReturn;\n        },\n\n        getButton: function(fileId) {\n            return this._getButton(this._buttonIdsForFileIds[fileId]);\n        },\n\n        getEndpoint: function(fileId) {\n            return this._endpointStore.get(fileId);\n        },\n\n        getFile: function(fileOrBlobId) {\n            var file = this._handler.getFile(fileOrBlobId);\n            var uploadDataRecord;\n\n            if (!file) {\n                uploadDataRecord = this._uploadData.retrieve({id: fileOrBlobId});\n\n                if (uploadDataRecord) {\n                    file = uploadDataRecord.file;\n                }\n            }\n\n            return file || null;\n        },\n\n        getInProgress: function() {\n            return this._uploadData.retrieve({\n                status: [\n                    qq.status.UPLOADING,\n                    qq.status.UPLOAD_RETRYING,\n                    qq.status.QUEUED\n                ]\n            }).length;\n        },\n\n        getName: function(id) {\n            return this._uploadData.retrieve({id: id}).name;\n        },\n\n        // Parent ID for a specific file, or null if this is the parent, or if it has no parent.\n        getParentId: function(id) {\n            var uploadDataEntry = this.getUploads({id: id}),\n                parentId = null;\n\n            if (uploadDataEntry) {\n                if (uploadDataEntry.parentId !== undefined) {\n                    parentId = uploadDataEntry.parentId;\n                }\n            }\n\n            return parentId;\n        },\n\n        getResumableFilesData: function() {\n            return this._handler.getResumableFilesData();\n        },\n\n        getSize: function(id) {\n            return this._uploadData.retrieve({id: id}).size;\n        },\n\n        getNetUploads: function() {\n            return this._netUploaded;\n        },\n\n        getRemainingAllowedItems: function() {\n            var allowedItems = this._currentItemLimit;\n\n            if (allowedItems > 0) {\n                return allowedItems - this._netUploadedOrQueued;\n            }\n\n            return null;\n        },\n\n        getUploads: function(optionalFilter) {\n            return this._uploadData.retrieve(optionalFilter);\n        },\n\n        getUuid: function(id) {\n            return this._uploadData.retrieve({id: id}).uuid;\n        },\n\n        isResumable: function(id) {\n            return this._handler.hasResumeRecord(id);\n        },\n\n        log: function(str, level) {\n            if (this._options.debug && (!level || level === \"info\")) {\n                qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n            }\n            else if (level && level !== \"info\") {\n                qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n\n            }\n        },\n\n        pauseUpload: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                return false;\n            }\n\n            // Pause only really makes sense if the file is uploading or retrying\n            if (qq.indexOf([qq.status.UPLOADING, qq.status.UPLOAD_RETRYING], uploadData.status) >= 0) {\n                if (this._handler.pause(id)) {\n                    this._uploadData.setStatus(id, qq.status.PAUSED);\n                    return true;\n                }\n                else {\n                    this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                }\n            }\n            else {\n                this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n            }\n\n            return false;\n        },\n\n        removeFileRef: function(id) {\n            this._handler.expunge(id);\n            this._uploadData.removeFileRef(id);\n        },\n\n        reset: function() {\n            this.log(\"Resetting uploader...\");\n\n            this._handler.reset();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n\n            qq.each(this._buttons, function(idx, button) {\n                button.reset();\n            });\n\n            this._paramsStore.reset();\n            this._endpointStore.reset();\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData.reset();\n            this._buttonIdsForFileIds = [];\n\n            this._pasteHandler && this._pasteHandler.reset();\n            this._options.session.refreshOnReset && this._refreshSessionData();\n\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n\n            this._totalProgress && this._totalProgress.reset();\n\n            this._customResumeDataStore.reset();\n        },\n\n        retry: function(id) {\n            return this._manualRetry(id);\n        },\n\n        scaleImage: function(id, specs) {\n            var self = this;\n\n            return qq.Scaler.prototype.scaleImage(id, specs, {\n                log: qq.bind(self.log, self),\n                getFile: qq.bind(self.getFile, self),\n                uploadData: self._uploadData\n            });\n        },\n\n        setCustomHeaders: function(headers, id) {\n            this._customHeadersStore.set(headers, id);\n        },\n\n        setCustomResumeData: function(id, data) {\n            this._customResumeDataStore.set(data, id);\n        },\n\n        setDeleteFileCustomHeaders: function(headers, id) {\n            this._deleteFileCustomHeadersStore.set(headers, id);\n        },\n\n        setDeleteFileEndpoint: function(endpoint, id) {\n            this._deleteFileEndpointStore.set(endpoint, id);\n        },\n\n        setDeleteFileParams: function(params, id) {\n            this._deleteFileParamsStore.set(params, id);\n        },\n\n        // Re-sets the default endpoint, an endpoint for a specific file, or an endpoint for a specific button\n        setEndpoint: function(endpoint, id) {\n            this._endpointStore.set(endpoint, id);\n        },\n\n        setForm: function(elementOrId) {\n            this._updateFormSupportAndParams(elementOrId);\n        },\n\n        setItemLimit: function(newItemLimit) {\n            this._currentItemLimit = newItemLimit;\n        },\n\n        setName: function(id, newName) {\n            this._uploadData.updateName(id, newName);\n        },\n\n        setParams: function(params, id) {\n            this._paramsStore.set(params, id);\n        },\n\n        setUuid: function(id, newUuid) {\n            return this._uploadData.uuidChanged(id, newUuid);\n        },\n\n        /**\n         * Expose the internal status of a file id to the public api for manual state changes\n         * @public\n         *\n         * @param {Number} id,\n         * @param {String} newStatus\n         *\n         * @todo Implement the remaining methods\n         */\n        setStatus: function(id, newStatus) {\n            var fileRecord = this.getUploads({id: id});\n            if (!fileRecord) {\n                throw new qq.Error(id + \" is not a valid file ID.\");\n            }\n\n            switch (newStatus) {\n                case qq.status.DELETED:\n                    this._onDeleteComplete(id, null, false);\n                    break;\n                case qq.status.DELETE_FAILED:\n                    this._onDeleteComplete(id, null, true);\n                    break;\n                default:\n                    var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n                    this.log(errorMessage);\n                    throw new qq.Error(errorMessage);\n            }\n        },\n\n        uploadStoredFiles: function() {\n            if (this._storedIds.length === 0) {\n                this._itemError(\"noFilesError\");\n            }\n            else {\n                this._uploadStoredFiles();\n            }\n        }\n    };\n\n    /**\n     * Defines the private (internal) API for FineUploaderBasic mode.\n     */\n    qq.basePrivateApi = {\n        // Updates internal state with a file record (not backed by a live file).  Returns the assigned ID.\n        _addCannedFile: function(sessionData) {\n            var self = this;\n\n            return this._uploadData.addFile({\n                uuid: sessionData.uuid,\n                name: sessionData.name,\n                size: sessionData.size,\n                status: qq.status.UPLOAD_SUCCESSFUL,\n                onBeforeStatusChange: function(id) {\n                    sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                    sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n\n                    if (sessionData.thumbnailUrl) {\n                        self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                    }\n\n                    self._netUploaded++;\n                    self._netUploadedOrQueued++;\n                }\n            });\n        },\n\n        _annotateWithButtonId: function(file, associatedInput) {\n            if (qq.isFile(file)) {\n                file.qqButtonId = this._getButtonId(associatedInput);\n            }\n        },\n\n        _batchError: function(message) {\n            this._options.callbacks.onError(null, null, message, undefined);\n        },\n\n        _createDeleteHandler: function() {\n            var self = this;\n\n            return new qq.DeleteFileAjaxRequester({\n                method: this._options.deleteFile.method.toUpperCase(),\n                maxConnections: this._options.maxConnections,\n                uuidParamName: this._options.request.uuidName,\n                customHeaders: this._deleteFileCustomHeadersStore,\n                paramsStore: this._deleteFileParamsStore,\n                endpointStore: this._deleteFileEndpointStore,\n                cors: this._options.cors,\n                log: qq.bind(self.log, self),\n                onDelete: function(id) {\n                    self._onDelete(id);\n                    self._options.callbacks.onDelete(id);\n                },\n                onDeleteComplete: function(id, xhrOrXdr, isError) {\n                    self._onDeleteComplete(id, xhrOrXdr, isError);\n                    self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                }\n\n            });\n        },\n\n        _createPasteHandler: function() {\n            var self = this;\n\n            return new qq.PasteSupport({\n                targetElement: this._options.paste.targetElement,\n                callbacks: {\n                    log: qq.bind(self.log, self),\n                    pasteReceived: function(blob) {\n                        self._handleCheckedCallback({\n                            name: \"onPasteReceived\",\n                            callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                            onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                            identifier: \"pasted image\"\n                        });\n                    }\n                }\n            });\n        },\n\n        _createStore: function(initialValue, _readOnlyValues_) {\n            var store = {},\n                catchall = initialValue,\n                perIdReadOnlyValues = {},\n                readOnlyValues = _readOnlyValues_,\n                copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                },\n                getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                },\n                includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n\n            return {\n                set: function(val, id) {\n                    /*jshint eqeqeq: true, eqnull: true*/\n                    if (id == null) {\n                        store = {};\n                        catchall = copy(val);\n                    }\n                    else {\n                        store[id] = copy(val);\n                    }\n                },\n\n                get: function(id) {\n                    var values;\n\n                    /*jshint eqeqeq: true, eqnull: true*/\n                    if (id != null && store[id]) {\n                        values = store[id];\n                    }\n                    else {\n                        values = copy(catchall);\n                    }\n\n                    includeReadOnlyValues(id, values);\n\n                    return copy(values);\n                },\n\n                addReadOnly: function(id, values) {\n                    // Only applicable to Object stores\n                    if (qq.isObject(store)) {\n                        // If null ID, apply readonly values to all files\n                        if (id === null) {\n                            if (qq.isFunction(values)) {\n                                readOnlyValues = values;\n                            }\n                            else {\n                                readOnlyValues = readOnlyValues || {};\n                                qq.extend(readOnlyValues, values);\n                            }\n                        }\n                        else {\n                            perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                            qq.extend(perIdReadOnlyValues[id], values);\n                        }\n                    }\n                },\n\n                remove: function(fileId) {\n                    return delete store[fileId];\n                },\n\n                reset: function() {\n                    store = {};\n                    perIdReadOnlyValues = {};\n                    catchall = initialValue;\n                }\n            };\n        },\n\n        _createUploadDataTracker: function() {\n            var self = this;\n\n            return new qq.UploadData({\n                getName: function(id) {\n                    return self.getName(id);\n                },\n                getUuid: function(id) {\n                    return self.getUuid(id);\n                },\n                getSize: function(id) {\n                    return self.getSize(id);\n                },\n                onStatusChange: function(id, oldStatus, newStatus) {\n                    self._onUploadStatusChange(id, oldStatus, newStatus);\n                    self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                    self._maybeAllComplete(id, newStatus);\n\n                    if (self._totalProgress) {\n                        setTimeout(function() {\n                            self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                        }, 0);\n                    }\n                }\n            });\n        },\n\n        /**\n         * Generate a tracked upload button.\n         *\n         * @param spec Object containing a required `element` property\n         * along with optional `multiple`, `accept`, and `folders`.\n         * @returns {qq.UploadButton}\n         * @private\n         */\n        _createUploadButton: function(spec) {\n            var self = this,\n                acceptFiles = spec.accept || this._options.validation.acceptFiles,\n                allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions,\n                button;\n\n            function allowMultiple() {\n                if (qq.supportedFeatures.ajaxUploading) {\n                    // Workaround for bug in iOS7+ (see #1039)\n                    if (self._options.workarounds.iosEmptyVideos &&\n                        qq.ios() &&\n                        !qq.ios6() &&\n                        self._isAllowedExtension(allowedExtensions, \".mov\")) {\n\n                        return false;\n                    }\n\n                    if (spec.multiple === undefined) {\n                        return self._options.multiple;\n                    }\n\n                    return spec.multiple;\n                }\n\n                return false;\n            }\n\n            button = new qq.UploadButton({\n                acceptFiles: acceptFiles,\n                element: spec.element,\n                focusClass: this._options.classes.buttonFocus,\n                folders: spec.folders,\n                hoverClass: this._options.classes.buttonHover,\n                ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                multiple: allowMultiple(),\n                name: this._options.request.inputName,\n                onChange: function(input) {\n                    self._onInputChange(input);\n                },\n                title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n            });\n\n            this._disposeSupport.addDisposer(function() {\n                button.dispose();\n            });\n\n            self._buttons.push(button);\n\n            return button;\n        },\n\n        _createUploadHandler: function(additionalOptions, namespace) {\n            var self = this,\n                lastOnProgress = {},\n                options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        }\n                        else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n\n                        lastOnProgress[id] = {loaded: loaded, total: total};\n\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n\n                        var status = self.getUploads({id: id}).status,\n                            retVal;\n\n                        // This is to deal with some observed cases where the XHR readyStateChange handler is\n                        // invoked by the browser multiple times for the same XHR instance with the same state\n                        // readyState value.  Higher level: don't invoke complete-related code if we've already\n                        // done this.\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n\n                        retVal = self._onComplete(id, name, result, xhr);\n\n                        // If the internal `_onComplete` handler returns a promise, don't invoke the `onComplete` callback\n                        // until the promise has been fulfilled.\n                        if (retVal instanceof  qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        }\n                        else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        var onUploadResult = self._options.callbacks.onUpload(id, name);\n\n                        if (qq.isGenericPromise(onUploadResult)) {\n                            self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n                            return onUploadResult;\n                        }\n\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n\n                        if (qq.isGenericPromise(onUploadChunkResult)) {\n                            self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n                            return onUploadChunkResult;\n                        }\n\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._onUploadChunkSuccess(id, chunkData);\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData, customResumeData) {\n                        return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({uuid: uuid});\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({id: id}).status;\n                        return status === qq.status.QUEUED ||\n                            status === qq.status.SUBMITTED ||\n                            status === qq.status.UPLOAD_RETRYING ||\n                            status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch,\n                    isInProgress: function(id) {\n                        return self.getUploads({id: id}).status === qq.status.UPLOADING;\n                    },\n                    getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n                    setStatus: function(id, status) {\n                        self._uploadData.setStatus(id, status);\n                    }\n                };\n\n            qq.each(this._options.request, function(prop, val) {\n                options[prop] = val;\n            });\n\n            options.customHeaders = this._customHeadersStore;\n\n            if (additionalOptions) {\n                qq.each(additionalOptions, function(key, val) {\n                    options[key] = val;\n                });\n            }\n\n            return new qq.UploadHandlerController(options, namespace);\n        },\n\n        _fileOrBlobRejected: function(id) {\n            this._netUploadedOrQueued--;\n            this._uploadData.setStatus(id, qq.status.REJECTED);\n        },\n\n        _formatSize: function(bytes) {\n            if (bytes === 0) {\n                return bytes + this._options.text.sizeSymbols[0];\n            }\n            var i = -1;\n            do {\n                bytes = bytes / 1000;\n                i++;\n            } while (bytes > 999);\n\n            return Math.max(bytes, 0.1).toFixed(1) + this._options.text.sizeSymbols[i];\n        },\n\n        // Creates an internal object that tracks various properties of each extra button,\n        // and then actually creates the extra button.\n        _generateExtraButtonSpecs: function() {\n            var self = this;\n\n            this._extraButtonSpecs = {};\n\n            qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                var multiple = extraButtonOptionEntry.multiple,\n                    validation = qq.extend({}, self._options.validation, true),\n                    extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n\n                if (multiple === undefined) {\n                    multiple = self._options.multiple;\n                }\n\n                if (extraButtonSpec.validation) {\n                    qq.extend(validation, extraButtonOptionEntry.validation, true);\n                }\n\n                qq.extend(extraButtonSpec, {\n                    multiple: multiple,\n                    validation: validation\n                }, true);\n\n                self._initExtraButton(extraButtonSpec);\n            });\n        },\n\n        _getButton: function(buttonId) {\n            var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n\n            if (extraButtonsSpec) {\n                return extraButtonsSpec.element;\n            }\n            else if (buttonId === this._defaultButtonId) {\n                return this._options.button;\n            }\n        },\n\n        /**\n         * Gets the internally used tracking ID for a button.\n         *\n         * @param buttonOrFileInputOrFile `File`, `<input type=\"file\">`, or a button container element\n         * @returns {*} The button's ID, or undefined if no ID is recoverable\n         * @private\n         */\n        _getButtonId: function(buttonOrFileInputOrFile) {\n            var inputs, fileInput,\n                fileBlobOrInput = buttonOrFileInputOrFile;\n\n            // We want the reference file/blob here if this is a proxy (a file that will be generated on-demand later)\n            if (fileBlobOrInput instanceof qq.BlobProxy) {\n                fileBlobOrInput = fileBlobOrInput.referenceBlob;\n            }\n\n            // If the item is a `Blob` it will never be associated with a button or drop zone.\n            if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                if (qq.isFile(fileBlobOrInput)) {\n                    return fileBlobOrInput.qqButtonId;\n                }\n                else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" &&\n                    fileBlobOrInput.type.toLowerCase() === \"file\") {\n\n                    return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                }\n\n                inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n\n                qq.each(inputs, function(idx, input) {\n                    if (input.getAttribute(\"type\") === \"file\") {\n                        fileInput = input;\n                        return false;\n                    }\n                });\n\n                if (fileInput) {\n                    return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                }\n            }\n        },\n\n        _getCustomResumeData: function(fileId) {\n            return this._customResumeDataStore.get(fileId);\n        },\n\n        _getNotFinished: function() {\n            return this._uploadData.retrieve({\n                status: [\n                    qq.status.UPLOADING,\n                    qq.status.UPLOAD_RETRYING,\n                    qq.status.QUEUED,\n                    qq.status.SUBMITTING,\n                    qq.status.SUBMITTED,\n                    qq.status.PAUSED\n                ]\n            }).length;\n        },\n\n        // Get the validation options for this button.  Could be the default validation option\n        // or a specific one assigned to this particular button.\n        _getValidationBase: function(buttonId) {\n            var extraButtonSpec = this._extraButtonSpecs[buttonId];\n\n            return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n        },\n\n        _getValidationDescriptor: function(fileWrapper) {\n            if (fileWrapper.file instanceof qq.BlobProxy) {\n                return {\n                    name: qq.getFilename(fileWrapper.file.referenceBlob),\n                    size: fileWrapper.file.referenceBlob.size\n                };\n            }\n\n            return {\n                name: this.getUploads({id: fileWrapper.id}).name,\n                size: this.getUploads({id: fileWrapper.id}).size\n            };\n        },\n\n        _getValidationDescriptors: function(fileWrappers) {\n            var self = this,\n                fileDescriptors = [];\n\n            qq.each(fileWrappers, function(idx, fileWrapper) {\n                fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n            });\n\n            return fileDescriptors;\n        },\n\n        // Allows camera access on either the default or an extra button for iOS devices.\n        _handleCameraAccess: function() {\n            if (this._options.camera.ios && qq.ios()) {\n                var acceptIosCamera = \"image/*;capture=camera\",\n                    button = this._options.camera.button,\n                    buttonId = button ? this._getButtonId(button) : this._defaultButtonId,\n                    optionRoot = this._options;\n\n                // If we are not targeting the default button, it is an \"extra\" button\n                if (buttonId && buttonId !== this._defaultButtonId) {\n                    optionRoot = this._extraButtonSpecs[buttonId];\n                }\n\n                // Camera access won't work in iOS if the `multiple` attribute is present on the file input\n                optionRoot.multiple = false;\n\n                // update the options\n                if (optionRoot.validation.acceptFiles === null) {\n                    optionRoot.validation.acceptFiles = acceptIosCamera;\n                }\n                else {\n                    optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                }\n\n                // update the already-created button\n                qq.each(this._buttons, function(idx, button) {\n                    if (button.getButtonId() === buttonId) {\n                        button.setMultiple(optionRoot.multiple);\n                        button.setAcceptFiles(optionRoot.acceptFiles);\n\n                        return false;\n                    }\n                });\n            }\n        },\n\n        _handleCheckedCallback: function(details) {\n            var self = this,\n                callbackRetVal = details.callback();\n\n            if (qq.isGenericPromise(callbackRetVal)) {\n                this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                return callbackRetVal.then(\n                    function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    },\n                    function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        }\n                        else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n            }\n\n            if (callbackRetVal !== false) {\n                details.onSuccess(callbackRetVal);\n            }\n            else {\n                if (details.onFailure) {\n                    this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                    details.onFailure();\n                }\n                else {\n                    this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                }\n            }\n\n            return callbackRetVal;\n        },\n\n        // Updates internal state when a new file has been received, and adds it along with its ID to a passed array.\n        _handleNewFile: function(file, batchId, newFileWrapperList) {\n            var self = this,\n                uuid = qq.getUniqueId(),\n                size = -1,\n                name = qq.getFilename(file),\n                actualFile = file.blob || file,\n                handler = this._customNewFileHandler ?\n                    this._customNewFileHandler :\n                    qq.bind(self._handleNewFileGeneric, self);\n\n            if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                size = actualFile.size;\n            }\n\n            handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                uploadData: self._uploadData,\n                paramsStore: self._paramsStore,\n                addFileToHandler: function(id, file) {\n                    self._handler.add(id, file);\n                    self._netUploadedOrQueued++;\n                    self._trackButton(id);\n                }\n            });\n        },\n\n        _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n            var id = this._uploadData.addFile({\n                uuid: uuid,\n                name: name,\n                size: size,\n                batchId: batchId,\n                file: file\n            });\n\n            this._handler.add(id, file);\n\n            this._trackButton(id);\n\n            this._netUploadedOrQueued++;\n\n            fileList.push({id: id, file: file});\n        },\n\n        _handlePasteSuccess: function(blob, extSuppliedName) {\n            var extension = blob.type.split(\"/\")[1],\n                name = extSuppliedName;\n\n            /*jshint eqeqeq: true, eqnull: true*/\n            if (name == null) {\n                name = this._options.paste.defaultName;\n            }\n\n            name += \".\" + extension;\n\n            this.addFiles({\n                name: name,\n                blob: blob\n            });\n        },\n\n        _handleDeleteSuccess: function(id) {\n            if (this.getUploads({id: id}).status !== qq.status.DELETED) {\n                var name = this.getName(id);\n\n                this._netUploadedOrQueued--;\n                this._netUploaded--;\n                this._handler.expunge(id);\n                this._uploadData.setStatus(id, qq.status.DELETED);\n                this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n            }\n        },\n\n        _handleDeleteFailed: function(id, xhrOrXdr) {\n            var name = this.getName(id);\n\n            this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n            this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n\n            // Check first if xhrOrXdr is actually passed or valid\n            // For error reporting, we only have access to the response status if this is not\n            // an `XDomainRequest`.\n            if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n                this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n            }\n            else {\n                this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n            }\n        },\n\n        // Creates an extra button element\n        _initExtraButton: function(spec) {\n            var button = this._createUploadButton({\n                accept: spec.validation.acceptFiles,\n                allowedExtensions: spec.validation.allowedExtensions,\n                element: spec.element,\n                folders: spec.folders,\n                multiple: spec.multiple,\n                title: spec.fileInputTitle\n            });\n\n            this._extraButtonSpecs[button.getButtonId()] = spec;\n        },\n\n        _initFormSupportAndParams: function() {\n            this._formSupport = qq.FormSupport && new qq.FormSupport(\n                this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this)\n            );\n\n            if (this._formSupport && this._formSupport.attachedToForm) {\n                this._paramsStore = this._createStore(\n                    this._options.request.params,  this._formSupport.getFormInputsAsObject\n                );\n\n                this._options.autoUpload = this._formSupport.newAutoUpload;\n                if (this._formSupport.newEndpoint) {\n                    this._options.request.endpoint = this._formSupport.newEndpoint;\n                }\n            }\n            else {\n                this._paramsStore = this._createStore(this._options.request.params);\n            }\n        },\n\n        _isDeletePossible: function() {\n            if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                return false;\n            }\n\n            if (this._options.cors.expected) {\n                if (qq.supportedFeatures.deleteFileCorsXhr) {\n                    return true;\n                }\n\n                if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            return true;\n        },\n\n        _isAllowedExtension: function(allowed, fileName) {\n            var valid = false;\n\n            if (!allowed.length) {\n                return true;\n            }\n\n            qq.each(allowed, function(idx, allowedExt) {\n                /**\n                 * If an argument is not a string, ignore it.  Added when a possible issue with MooTools hijacking the\n                 * `allowedExtensions` array was discovered.  See case #735 in the issue tracker for more details.\n                 */\n                if (qq.isString(allowedExt)) {\n                    /*jshint eqeqeq: true, eqnull: true*/\n                    var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n\n                    if (fileName.match(extRegex) != null) {\n                        valid = true;\n                        return false;\n                    }\n                }\n            });\n\n            return valid;\n        },\n\n        /**\n         * Constructs and returns a message that describes an item/file error.  Also calls `onError` callback.\n         *\n         * @param code REQUIRED - a code that corresponds to a stock message describing this type of error\n         * @param maybeNameOrNames names of the items that have failed, if applicable\n         * @param item `File`, `Blob`, or `<input type=\"file\">`\n         * @private\n         */\n        _itemError: function(code, maybeNameOrNames, item) {\n            var message = this._options.messages[code],\n                allowedExtensions = [],\n                names = [].concat(maybeNameOrNames),\n                name = names[0],\n                buttonId = this._getButtonId(item),\n                validationBase = this._getValidationBase(buttonId),\n                extensionsForMessage, placeholderMatch;\n\n            function r(name, replacement) { message = message.replace(name, replacement); }\n\n            qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                /**\n                 * If an argument is not a string, ignore it.  Added when a possible issue with MooTools hijacking the\n                 * `allowedExtensions` array was discovered.  See case #735 in the issue tracker for more details.\n                 */\n                if (qq.isString(allowedExtension)) {\n                    allowedExtensions.push(allowedExtension);\n                }\n            });\n\n            extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n\n            r(\"{file}\", this._options.formatFileName(name));\n            r(\"{extensions}\", extensionsForMessage);\n            r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n            r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n\n            placeholderMatch = message.match(/(\\{\\w+\\})/g);\n            if (placeholderMatch !== null) {\n                qq.each(placeholderMatch, function(idx, placeholder) {\n                    r(placeholder, names[idx]);\n                });\n            }\n\n            this._options.callbacks.onError(null, name, message, undefined);\n\n            return message;\n        },\n\n        /**\n         * Conditionally orders a manual retry of a failed upload.\n         *\n         * @param id File ID of the failed upload\n         * @param callback Optional callback to invoke if a retry is prudent.\n         * In lieu of asking the upload handler to retry.\n         * @returns {boolean} true if a manual retry will occur\n         * @private\n         */\n        _manualRetry: function(id, callback) {\n            if (this._onBeforeManualRetry(id)) {\n                this._netUploadedOrQueued++;\n                this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n\n                if (callback) {\n                    callback(id);\n                }\n                else {\n                    this._handler.retry(id);\n                }\n\n                return true;\n            }\n        },\n\n        _maybeAllComplete: function(id, status) {\n            var self = this,\n                notFinished = this._getNotFinished();\n\n            if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                this._succeededSinceLastAllComplete.push(id);\n            }\n            else if (status === qq.status.UPLOAD_FAILED) {\n                this._failedSinceLastAllComplete.push(id);\n            }\n\n            if (notFinished === 0 &&\n                (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                // Attempt to ensure onAllComplete is not invoked before other callbacks, such as onCancel & onComplete\n                setTimeout(function() {\n                    self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                }, 0);\n            }\n        },\n\n        _maybeHandleIos8SafariWorkaround: function() {\n            var self = this;\n\n            if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                setTimeout(function() {\n                    window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                }, 0);\n                throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n            }\n        },\n\n        _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n            // Assuming no one will actually set the response code to something other than 200\n            // and still set 'success' to true...\n            if (!response.success) {\n                if (xhr && xhr.status !== 200 && !response.error) {\n                    this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                }\n                else {\n                    var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                    this._options.callbacks.onError(id, name, errorReason, xhr);\n                }\n            }\n        },\n\n        _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n            var self = this;\n\n            if (items.length > index) {\n                if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                    //use setTimeout to prevent a stack overflow with a large number of files in the batch & non-promissory callbacks\n                    setTimeout(function() {\n                        var validationDescriptor = self._getValidationDescriptor(items[index]),\n                            buttonId = self._getButtonId(items[index].file),\n                            button = self._getButton(buttonId);\n\n                        self._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                            onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                            onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                            identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                        });\n                    }, 0);\n                }\n                else if (!validItem) {\n                    for (; index < items.length; index++) {\n                        self._fileOrBlobRejected(items[index].id);\n                    }\n                }\n            }\n        },\n\n        _onAllComplete: function(successful, failed) {\n            this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n\n            this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n        },\n\n        /**\n         * Attempt to automatically retry a failed upload.\n         *\n         * @param id The file ID of the failed upload\n         * @param name The name of the file associated with the failed upload\n         * @param responseJSON Response from the server, parsed into a javascript object\n         * @param xhr Ajax transport used to send the failed request\n         * @param callback Optional callback to be invoked if a retry is prudent.\n         * Invoked in lieu of asking the upload handler to retry.\n         * @returns {boolean} true if an auto-retry will occur\n         * @private\n         */\n        _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n            var self = this;\n\n            self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n\n            if (self._shouldAutoRetry(id)) {\n                var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1000;\n\n                self._maybeParseAndSendUploadError.apply(self, arguments);\n                self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                self._onBeforeAutoRetry(id, name);\n\n                self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                self._retryTimeouts[id] = setTimeout(function() {\n                    self.log(\"Starting retry for \" + name + \"...\");\n\n                    if (callback) {\n                        callback(id);\n                    }\n                    else {\n                        self._handler.retry(id);\n                    }\n                }, retryWaitPeriod);\n\n                return true;\n            }\n        },\n\n        _onBeforeAutoRetry: function(id, name) {\n            this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n        },\n\n        //return false if we should not attempt the requested retry\n        _onBeforeManualRetry: function(id) {\n            var itemLimit = this._currentItemLimit,\n                fileName;\n\n            if (this._preventRetries[id]) {\n                this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                return false;\n            }\n            else if (this._handler.isValid(id)) {\n                fileName = this.getName(id);\n\n                if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                    return false;\n                }\n\n                if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                    this._itemError(\"retryFailTooManyItems\");\n                    return false;\n                }\n\n                this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                return true;\n            }\n            else {\n                this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                return false;\n            }\n        },\n\n        _onCancel: function(id, name) {\n            this._netUploadedOrQueued--;\n\n            clearTimeout(this._retryTimeouts[id]);\n\n            var storedItemIndex = qq.indexOf(this._storedIds, id);\n            if (!this._options.autoUpload && storedItemIndex >= 0) {\n                this._storedIds.splice(storedItemIndex, 1);\n            }\n\n            this._uploadData.setStatus(id, qq.status.CANCELED);\n        },\n\n        _onComplete: function(id, name, result, xhr) {\n            if (!result.success) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n\n                if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                    this._preventRetries[id] = true;\n                }\n            }\n            else {\n                if (result.thumbnailUrl) {\n                    this._thumbnailUrls[id] = result.thumbnailUrl;\n                }\n\n                this._netUploaded++;\n                this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n            }\n\n            this._maybeParseAndSendUploadError(id, name, result, xhr);\n\n            return result.success ? true : false;\n        },\n\n        _onDelete: function(id) {\n            this._uploadData.setStatus(id, qq.status.DELETING);\n        },\n\n        _onDeleteComplete: function(id, xhrOrXdr, isError) {\n            var name = this.getName(id);\n\n            if (isError) {\n                this._handleDeleteFailed(id, xhrOrXdr);\n            }\n            else {\n                this._handleDeleteSuccess(id);\n            }\n        },\n\n        _onInputChange: function(input) {\n            var fileIndex;\n\n            if (qq.supportedFeatures.ajaxUploading) {\n                for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                    this._annotateWithButtonId(input.files[fileIndex], input);\n                }\n\n                this.addFiles(input.files);\n            }\n            // Android 2.3.x will fire `onchange` even if no file has been selected\n            else if (input.value.length > 0) {\n                this.addFiles(input);\n            }\n\n            qq.each(this._buttons, function(idx, button) {\n                button.reset();\n            });\n        },\n\n        _onProgress: function(id, name, loaded, total) {\n            this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n        },\n\n        _onSubmit: function(id, name) {\n            //nothing to do yet in core uploader\n        },\n\n        _onSubmitCallbackSuccess: function(id, name) {\n            this._onSubmit.apply(this, arguments);\n            this._uploadData.setStatus(id, qq.status.SUBMITTED);\n            this._onSubmitted.apply(this, arguments);\n\n            if (this._options.autoUpload) {\n                this._options.callbacks.onSubmitted.apply(this, arguments);\n                this._uploadFile(id);\n            }\n            else {\n                this._storeForLater(id);\n                this._options.callbacks.onSubmitted.apply(this, arguments);\n            }\n        },\n\n        _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n            var uuid = this.getUuid(id),\n                adjustedOnSuccessCallback;\n\n            if (onSuccessCallback) {\n                adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n            }\n\n            if (this._isDeletePossible()) {\n                this._handleCheckedCallback({\n                    name: \"onSubmitDelete\",\n                    callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                    onSuccess: adjustedOnSuccessCallback ||\n                        qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                    identifier: id\n                });\n                return true;\n            }\n            else {\n                this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" +\n                    \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                return false;\n            }\n        },\n\n        _onSubmitted: function(id) {\n            //nothing to do in the base uploader\n        },\n\n        _onTotalProgress: function(loaded, total) {\n            this._options.callbacks.onTotalProgress(loaded, total);\n        },\n\n        _onUploadPrep: function(id) {\n            // nothing to do in the core uploader for now\n        },\n\n        _onUpload: function(id, name) {\n            this._uploadData.setStatus(id, qq.status.UPLOADING);\n        },\n\n        _onUploadChunk: function(id, chunkData) {\n            //nothing to do in the base uploader\n        },\n\n        _onUploadChunkSuccess: function(id, chunkData) {\n            if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n                this._autoRetries[id] = 0;\n            }\n        },\n\n        _onUploadStatusChange: function(id, oldStatus, newStatus) {\n            // Make sure a \"queued\" retry attempt is canceled if the upload has been paused\n            if (newStatus === qq.status.PAUSED) {\n                clearTimeout(this._retryTimeouts[id]);\n            }\n        },\n\n        _onValidateBatchCallbackFailure: function(fileWrappers) {\n            var self = this;\n\n            qq.each(fileWrappers, function(idx, fileWrapper) {\n                self._fileOrBlobRejected(fileWrapper.id);\n            });\n        },\n\n        _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n            var errorMessage,\n                itemLimit = this._currentItemLimit,\n                proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n\n            if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                if (items.length > 0) {\n                    this._handleCheckedCallback({\n                        name: \"onValidate\",\n                        callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                        onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                        onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                        identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                    });\n                }\n                else {\n                    this._itemError(\"noFilesError\");\n                }\n            }\n            else {\n                this._onValidateBatchCallbackFailure(items);\n                errorMessage = this._options.messages.tooManyItemsError\n                    .replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued)\n                    .replace(/\\{itemLimit\\}/g, itemLimit);\n                this._batchError(errorMessage);\n            }\n        },\n\n        _onValidateCallbackFailure: function(items, index, params, endpoint) {\n            var nextIndex = index + 1;\n\n            this._fileOrBlobRejected(items[index].id, items[index].file.name);\n\n            this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n        },\n\n        _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n            var self = this,\n                nextIndex = index + 1,\n                validationDescriptor = this._getValidationDescriptor(items[index]);\n\n            this._validateFileOrBlobData(items[index], validationDescriptor)\n                .then(\n                function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                },\n                function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                }\n            );\n        },\n\n        _prepareItemsForUpload: function(items, params, endpoint) {\n            if (items.length === 0) {\n                this._itemError(\"noFilesError\");\n                return;\n            }\n\n            var validationDescriptors = this._getValidationDescriptors(items),\n                buttonId = this._getButtonId(items[0].file),\n                button = this._getButton(buttonId);\n\n            this._handleCheckedCallback({\n                name: \"onValidateBatch\",\n                callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                identifier: \"batch validation\"\n            });\n        },\n\n        _preventLeaveInProgress: function() {\n            var self = this;\n\n            this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                if (self.getInProgress()) {\n                    e = e || window.event;\n                    // for ie, ff\n                    e.returnValue = self._options.messages.onLeave;\n                    // for webkit\n                    return self._options.messages.onLeave;\n                }\n            });\n        },\n\n        // Attempts to refresh session data only if the `qq.Session` module exists\n        // and a session endpoint has been specified.  The `onSessionRequestComplete`\n        // callback will be invoked once the refresh is complete.\n        _refreshSessionData: function() {\n            var self = this,\n                options = this._options.session;\n\n            /* jshint eqnull:true */\n            if (qq.Session && this._options.session.endpoint != null) {\n                if (!this._session) {\n                    qq.extend(options, {cors: this._options.cors});\n\n                    options.log = qq.bind(this.log, this);\n                    options.addFileRecord = qq.bind(this._addCannedFile, this);\n\n                    this._session = new qq.Session(options);\n                }\n\n                setTimeout(function() {\n                    self._session.refresh().then(function(response, xhrOrXdr) {\n                        self._sessionRequestComplete();\n                        self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n\n                    }, function(response, xhrOrXdr) {\n\n                        self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                    });\n                }, 0);\n            }\n        },\n\n        _sessionRequestComplete: function() {},\n\n        _setSize: function(id, newSize) {\n            this._uploadData.updateSize(id, newSize);\n            this._totalProgress && this._totalProgress.onNewSize(id);\n        },\n\n        _shouldAutoRetry: function(id) {\n            var uploadData = this._uploadData.retrieve({id: id});\n\n            /*jshint laxbreak: true */\n            if (!this._preventRetries[id]\n                && this._options.retry.enableAuto\n                && uploadData.status !== qq.status.PAUSED) {\n\n                if (this._autoRetries[id] === undefined) {\n                    this._autoRetries[id] = 0;\n                }\n\n                if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                    this._autoRetries[id] += 1;\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        _storeForLater: function(id) {\n            this._storedIds.push(id);\n        },\n\n        // Maps a file with the button that was used to select it.\n        _trackButton: function(id) {\n            var buttonId;\n\n            if (qq.supportedFeatures.ajaxUploading) {\n                buttonId = this._handler.getFile(id).qqButtonId;\n            }\n            else {\n                buttonId = this._getButtonId(this._handler.getInput(id));\n            }\n\n            if (buttonId) {\n                this._buttonIdsForFileIds[id] = buttonId;\n            }\n        },\n\n        _updateFormSupportAndParams: function(formElementOrId) {\n            this._options.form.element = formElementOrId;\n\n            this._formSupport = qq.FormSupport && new qq.FormSupport(\n                    this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this)\n                );\n\n            if (this._formSupport && this._formSupport.attachedToForm) {\n                this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n\n                this._options.autoUpload = this._formSupport.newAutoUpload;\n                if (this._formSupport.newEndpoint) {\n                    this.setEndpoint(this._formSupport.newEndpoint);\n                }\n            }\n        },\n\n        _upload: function(id, params, endpoint) {\n            var name = this.getName(id);\n\n            if (params) {\n                this.setParams(params, id);\n            }\n\n            if (endpoint) {\n                this.setEndpoint(endpoint, id);\n            }\n\n            this._handleCheckedCallback({\n                name: \"onSubmit\",\n                callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                identifier: id\n            });\n        },\n\n        _uploadFile: function(id) {\n            if (!this._handler.upload(id)) {\n                this._uploadData.setStatus(id, qq.status.QUEUED);\n            }\n        },\n\n        _uploadStoredFiles: function() {\n            var idToUpload, stillSubmitting,\n                self = this;\n\n            while (this._storedIds.length) {\n                idToUpload = this._storedIds.shift();\n                this._uploadFile(idToUpload);\n            }\n\n            // If we are still waiting for some files to clear validation, attempt to upload these again in a bit\n            stillSubmitting = this.getUploads({status: qq.status.SUBMITTING}).length;\n            if (stillSubmitting) {\n                qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                setTimeout(function() {\n                    self._uploadStoredFiles();\n                }, 1000);\n            }\n        },\n\n        /**\n         * Performs some internal validation checks on an item, defined in the `validation` option.\n         *\n         * @param fileWrapper Wrapper containing a `file` along with an `id`\n         * @param validationDescriptor Normalized information about the item (`size`, `name`).\n         * @returns qq.Promise with appropriate callbacks invoked depending on the validity of the file\n         * @private\n         */\n        _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n            var self = this,\n                file = (function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }()),\n                name = validationDescriptor.name,\n                size = validationDescriptor.size,\n                buttonId = this._getButtonId(fileWrapper.file),\n                validationBase = this._getValidationBase(buttonId),\n                validityChecker = new qq.Promise();\n\n            validityChecker.then(\n                function() {},\n                function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n\n            if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                this._itemError(\"typeError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (!this._options.validation.allowEmpty && size === 0) {\n                this._itemError(\"emptyError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                this._itemError(\"sizeError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (size > 0 && size < validationBase.minSizeLimit) {\n                this._itemError(\"minSizeError\", name, file);\n                return validityChecker.failure();\n            }\n\n            if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(\n                    validityChecker.success,\n                    function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    }\n                );\n            }\n            else {\n                validityChecker.success();\n            }\n\n            return validityChecker;\n        },\n\n        _wrapCallbacks: function() {\n            var self, safeCallback, prop;\n\n            self = this;\n\n            safeCallback = function(name, callback, args) {\n                var errorMsg;\n\n                try {\n                    return callback.apply(self, args);\n                }\n                catch (exception) {\n                    errorMsg = exception.message || exception.toString();\n                    self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                }\n            };\n\n            /* jshint forin: false, loopfunc: true */\n            for (prop in this._options.callbacks) {\n                (function() {\n                    var callbackName, callbackFunc;\n                    callbackName = prop;\n                    callbackFunc = self._options.callbacks[callbackName];\n                    self._options.callbacks[callbackName] = function() {\n                        return safeCallback(callbackName, callbackFunc, arguments);\n                    };\n                }());\n            }\n        }\n    };\n}());\n","/*globals qq*/\n(function() {\n    \"use strict\";\n\n    qq.FineUploaderBasic = function(o) {\n        var self = this;\n\n        // These options define FineUploaderBasic mode.\n        this._options = {\n            debug: false,\n            button: null,\n            multiple: true,\n            maxConnections: 3,\n            disableCancelForFormUploads: false,\n            autoUpload: true,\n            warnBeforeUnload: true,\n\n            request: {\n                customHeaders: {},\n                endpoint: \"/server/upload\",\n                filenameParam: \"qqfilename\",\n                forceMultipart: true,\n                inputName: \"qqfile\",\n                method: \"POST\",\n                omitDefaultParams: false,\n                params: {},\n                paramsInBody: true,\n                requireSuccessJson: true,\n                totalFileSizeName: \"qqtotalfilesize\",\n                uuidName: \"qquuid\"\n            },\n\n            validation: {\n                allowedExtensions: [],\n                sizeLimit: 0,\n                minSizeLimit: 0,\n                itemLimit: 0,\n                stopOnFirstInvalidFile: true,\n                acceptFiles: null,\n                image: {\n                    maxHeight: 0,\n                    maxWidth: 0,\n                    minHeight: 0,\n                    minWidth: 0\n                },\n                allowEmpty: false\n            },\n\n            callbacks: {\n                onSubmit: function(id, name) {},\n                onSubmitted: function(id, name) {},\n                onComplete: function(id, name, responseJSON, maybeXhr) {},\n                onAllComplete: function(successful, failed) {},\n                onCancel: function(id, name) {},\n                onUpload: function(id, name) {},\n                onUploadChunk: function(id, name, chunkData) {},\n                onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                onResume: function(id, fileName, chunkData, customResumeData) {},\n                onProgress: function(id, name, loaded, total) {},\n                onTotalProgress: function(loaded, total) {},\n                onError: function(id, name, reason, maybeXhrOrXdr) {},\n                onAutoRetry: function(id, name, attemptNumber) {},\n                onManualRetry: function(id, name) {},\n                onValidateBatch: function(fileOrBlobData) {},\n                onValidate: function(fileOrBlobData) {},\n                onSubmitDelete: function(id) {},\n                onDelete: function(id) {},\n                onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                onPasteReceived: function(blob) {},\n                onStatusChange: function(id, oldStatus, newStatus) {},\n                onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n            },\n\n            messages: {\n                typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                emptyError: \"{file} is empty, please select files again without it.\",\n                noFilesError: \"No files to upload.\",\n                tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                maxHeightImageError: \"Image is too tall.\",\n                maxWidthImageError: \"Image is too wide.\",\n                minHeightImageError: \"Image is not tall enough.\",\n                minWidthImageError: \"Image is not wide enough.\",\n                retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n            },\n\n            retry: {\n                enableAuto: false,\n                maxAutoAttempts: 3,\n                autoAttemptDelay: 5,\n                preventRetryResponseProperty: \"preventRetry\"\n            },\n\n            classes: {\n                buttonHover: \"qq-upload-button-hover\",\n                buttonFocus: \"qq-upload-button-focus\"\n            },\n\n            chunking: {\n                enabled: false,\n                concurrent: {\n                    enabled: false\n                },\n                mandatory: false,\n                paramNames: {\n                    partIndex: \"qqpartindex\",\n                    partByteOffset: \"qqpartbyteoffset\",\n                    chunkSize: \"qqchunksize\",\n                    totalFileSize: \"qqtotalfilesize\",\n                    totalParts: \"qqtotalparts\"\n                },\n                partSize: function(id) {\n                    return 2000000;\n                },\n                // only relevant for traditional endpoints, only required when concurrent.enabled === true\n                success: {\n                    endpoint: null,\n\n                    headers: function(id) {\n                        return null;\n                    },\n\n                    jsonPayload: false,\n\n                    method: \"POST\",\n\n                    params: function(id) {\n                        return null;\n                    },\n\n                    resetOnStatus: []\n                }\n            },\n\n            resume: {\n                enabled: false,\n                recordsExpireIn: 7, //days\n                paramNames: {\n                    resuming: \"qqresume\"\n                },\n                customKeys: function(fileId) {\n                    return [];\n                }\n            },\n\n            formatFileName: function(fileOrBlobName) {\n                return fileOrBlobName;\n            },\n\n            text: {\n                defaultResponseError: \"Upload failure reason unknown\",\n                fileInputTitle: \"file input\",\n                sizeSymbols: [\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"]\n            },\n\n            deleteFile: {\n                enabled: false,\n                method: \"DELETE\",\n                endpoint: \"/server/upload\",\n                customHeaders: {},\n                params: {}\n            },\n\n            cors: {\n                expected: false,\n                sendCredentials: false,\n                allowXdr: false\n            },\n\n            blobs: {\n                defaultName: \"misc_data\"\n            },\n\n            paste: {\n                targetElement: null,\n                defaultName: \"pasted_image\"\n            },\n\n            camera: {\n                ios: false,\n\n                // if ios is true: button is null means target the default button, otherwise target the button specified\n                button: null\n            },\n\n            // This refers to additional upload buttons to be handled by Fine Uploader.\n            // Each element is an object, containing `element` as the only required\n            // property.  The `element` must be a container that will ultimately\n            // contain an invisible `<input type=\"file\">` created by Fine Uploader.\n            // Optional properties of each object include `multiple`, `validation`,\n            // and `folders`.\n            extraButtons: [],\n\n            // Depends on the session module.  Used to query the server for an initial file list\n            // during initialization and optionally after a `reset`.\n            session: {\n                endpoint: null,\n                params: {},\n                customHeaders: {},\n                refreshOnReset: true\n            },\n\n            // Send parameters associated with an existing form along with the files\n            form: {\n                // Element ID, HTMLElement, or null\n                element: \"qq-form\",\n\n                // Overrides the base `autoUpload`, unless `element` is null.\n                autoUpload: false,\n\n                // true = upload files on form submission (and squelch submit event)\n                interceptSubmit: true\n            },\n\n            // scale images client side, upload a new file for each scaled version\n            scaling: {\n                customResizer: null,\n\n                // send the original file as well\n                sendOriginal: true,\n\n                // fox orientation for scaled images\n                orient: true,\n\n                // If null, scaled image type will match reference image type.  This value will be referred to\n                // for any size record that does not specific a type.\n                defaultType: null,\n\n                defaultQuality: 80,\n\n                failureText: \"Failed to scale\",\n\n                includeExif: false,\n\n                // metadata about each requested scaled version\n                sizes: []\n            },\n\n            workarounds: {\n                iosEmptyVideos: true,\n                ios8SafariUploads: true,\n                ios8BrowserCrash: false\n            }\n        };\n\n        // Replace any default options with user defined ones\n        qq.extend(this._options, o, true);\n\n        this._buttons = [];\n        this._extraButtonSpecs = {};\n        this._buttonIdsForFileIds = [];\n\n        this._wrapCallbacks();\n        this._disposeSupport =  new qq.DisposeSupport();\n\n        this._storedIds = [];\n        this._autoRetries = [];\n        this._retryTimeouts = [];\n        this._preventRetries = [];\n        this._thumbnailUrls = [];\n\n        this._netUploadedOrQueued = 0;\n        this._netUploaded = 0;\n        this._uploadData = this._createUploadDataTracker();\n\n        this._initFormSupportAndParams();\n\n        this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n        this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n\n        this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n\n        this._endpointStore = this._createStore(this._options.request.endpoint);\n        this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n\n        this._handler = this._createUploadHandler();\n\n        this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n\n        if (this._options.button) {\n            this._defaultButtonId = this._createUploadButton({\n                element: this._options.button,\n                title: this._options.text.fileInputTitle\n            }).getButtonId();\n        }\n\n        this._generateExtraButtonSpecs();\n\n        this._handleCameraAccess();\n\n        if (this._options.paste.targetElement) {\n            if (qq.PasteSupport) {\n                this._pasteHandler = this._createPasteHandler();\n            }\n            else {\n                this.log(\"Paste support module not found\", \"error\");\n            }\n        }\n\n        this._options.warnBeforeUnload && this._preventLeaveInProgress();\n\n        this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n        this._refreshSessionData();\n\n        this._succeededSinceLastAllComplete = [];\n        this._failedSinceLastAllComplete = [];\n\n        this._scaler = (qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this))) || {};\n        if (this._scaler.enabled) {\n            this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n        }\n\n        if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n            this._totalProgress = new qq.TotalProgress(\n                qq.bind(this._onTotalProgress, this),\n\n                function(id) {\n                    var entry = self._uploadData.retrieve({id: id});\n                    return (entry && entry.size) || 0;\n                }\n            );\n        }\n\n        this._currentItemLimit = this._options.validation.itemLimit;\n\n        this._customResumeDataStore = this._createStore();\n    };\n\n    // Define the private & public API methods.\n    qq.FineUploaderBasic.prototype = qq.basePublicApi;\n    qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n}());\n","/*globals qq, XDomainRequest*/\n/** Generic class for sending non-upload ajax requests and handling the associated responses **/\nqq.AjaxRequester = function(o) {\n    \"use strict\";\n\n    var log, shouldParamsBeInQueryString,\n        queue = [],\n        requestData = {},\n        options = {\n            acceptHeader: null,\n            validMethods: [\"PATCH\", \"POST\", \"PUT\"],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [200, 202, 204],\n                PATCH: [200, 201, 202, 203, 204],\n                POST: [200, 201, 202, 203, 204],\n                PUT: [200, 201, 202, 203, 204],\n                GET: [200]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n\n    qq.extend(options, o);\n    log = options.log;\n\n    if (qq.indexOf(options.validMethods, options.method) < 0) {\n        throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n    }\n\n    // [Simple methods](http://www.w3.org/TR/cors/#simple-method)\n    // are defined by the W3C in the CORS spec as a list of methods that, in part,\n    // make a CORS request eligible to be exempt from preflighting.\n    function isSimpleMethod() {\n        return qq.indexOf([\"GET\", \"POST\", \"HEAD\"], options.method) >= 0;\n    }\n\n    // [Simple headers](http://www.w3.org/TR/cors/#simple-header)\n    // are defined by the W3C in the CORS spec as a list of headers that, in part,\n    // make a CORS request eligible to be exempt from preflighting.\n    function containsNonSimpleHeaders(headers) {\n        var containsNonSimple = false;\n\n        qq.each(containsNonSimple, function(idx, header) {\n            if (qq.indexOf([\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\"], header) < 0) {\n                containsNonSimple = true;\n                return false;\n            }\n        });\n\n        return containsNonSimple;\n    }\n\n    function isXdr(xhr) {\n        //The `withCredentials` test is a commonly accepted way to determine if XHR supports CORS.\n        return options.cors.expected && xhr.withCredentials === undefined;\n    }\n\n    // Returns either a new `XMLHttpRequest` or `XDomainRequest` instance.\n    function getCorsAjaxTransport() {\n        var xhrOrXdr;\n\n        if (window.XMLHttpRequest || window.ActiveXObject) {\n            xhrOrXdr = qq.createXhrInstance();\n\n            if (xhrOrXdr.withCredentials === undefined) {\n                xhrOrXdr = new XDomainRequest();\n                // Workaround for XDR bug in IE9 - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment\n                xhrOrXdr.onload = function() {};\n                xhrOrXdr.onerror = function() {};\n                xhrOrXdr.ontimeout = function() {};\n                xhrOrXdr.onprogress = function() {};\n            }\n        }\n\n        return xhrOrXdr;\n    }\n\n    // Returns either a new XHR/XDR instance, or an existing one for the associated `File` or `Blob`.\n    function getXhrOrXdr(id, suppliedXhr) {\n        var xhrOrXdr = requestData[id] && requestData[id].xhr;\n\n        if (!xhrOrXdr) {\n            if (suppliedXhr) {\n                xhrOrXdr = suppliedXhr;\n            }\n            else {\n                if (options.cors.expected) {\n                    xhrOrXdr = getCorsAjaxTransport();\n                }\n                else {\n                    xhrOrXdr = qq.createXhrInstance();\n                }\n            }\n\n            requestData[id].xhr = xhrOrXdr;\n        }\n\n        return xhrOrXdr;\n    }\n\n    // Removes element from queue, sends next request\n    function dequeue(id) {\n        var i = qq.indexOf(queue, id),\n            max = options.maxConnections,\n            nextId;\n\n        delete requestData[id];\n        queue.splice(i, 1);\n\n        if (queue.length >= max && i < max) {\n            nextId = queue[max - 1];\n            sendRequest(nextId);\n        }\n    }\n\n    function onComplete(id, xdrError) {\n        var xhr = getXhrOrXdr(id),\n            method = options.method,\n            isError = xdrError === true;\n\n        dequeue(id);\n\n        if (isError) {\n            log(method + \" request for \" + id + \" has failed\", \"error\");\n        }\n        else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n            isError = true;\n            log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n        }\n\n        options.onComplete(id, xhr, isError);\n    }\n\n    function getParams(id) {\n        var onDemandParams = requestData[id].additionalParams,\n            mandatedParams = options.mandatedParams,\n            params;\n\n        if (options.paramsStore.get) {\n            params = options.paramsStore.get(id);\n        }\n\n        if (onDemandParams) {\n            qq.each(onDemandParams, function(name, val) {\n                params = params || {};\n                params[name] = val;\n            });\n        }\n\n        if (mandatedParams) {\n            qq.each(mandatedParams, function(name, val) {\n                params = params || {};\n                params[name] = val;\n            });\n        }\n\n        return params;\n    }\n\n    function sendRequest(id, optXhr) {\n        var xhr = getXhrOrXdr(id, optXhr),\n            method = options.method,\n            params = getParams(id),\n            payload = requestData[id].payload,\n            url;\n\n        options.onSend(id);\n\n        url = createUrl(id, params, requestData[id].additionalQueryParams);\n\n        // XDR and XHR status detection APIs differ a bit.\n        if (isXdr(xhr)) {\n            xhr.onload = getXdrLoadHandler(id);\n            xhr.onerror = getXdrErrorHandler(id);\n        }\n        else {\n            xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n        }\n\n        registerForUploadProgress(id);\n\n        // The last parameter is assumed to be ignored if we are actually using `XDomainRequest`.\n        xhr.open(method, url, true);\n\n        // Instruct the transport to send cookies along with the CORS request,\n        // unless we are using `XDomainRequest`, which is not capable of this.\n        if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n            xhr.withCredentials = true;\n        }\n\n        setHeaders(id);\n\n        log(\"Sending \" + method + \" request for \" + id);\n\n        if (payload) {\n            xhr.send(payload);\n        }\n        else if (shouldParamsBeInQueryString || !params) {\n            xhr.send();\n        }\n        else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n            xhr.send(qq.obj2url(params, \"\"));\n        }\n        else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n            xhr.send(JSON.stringify(params));\n        }\n        else {\n            xhr.send(params);\n        }\n\n        return xhr;\n    }\n\n    function createUrl(id, params, additionalQueryParams) {\n        var endpoint = options.endpointStore.get(id),\n            addToPath = requestData[id].addToPath;\n\n        /*jshint -W116,-W041 */\n        if (addToPath != undefined) {\n            endpoint += \"/\" + addToPath;\n        }\n\n        if (shouldParamsBeInQueryString && params) {\n            endpoint = qq.obj2url(params, endpoint);\n        }\n\n        if (additionalQueryParams) {\n            endpoint = qq.obj2url(additionalQueryParams, endpoint);\n        }\n\n        return endpoint;\n    }\n\n    // Invoked by the UA to indicate a number of possible states that describe\n    // a live `XMLHttpRequest` transport.\n    function getXhrReadyStateChangeHandler(id) {\n        return function() {\n            if (getXhrOrXdr(id).readyState === 4) {\n                onComplete(id);\n            }\n        };\n    }\n\n    function registerForUploadProgress(id) {\n        var onProgress = options.onProgress;\n\n        if (onProgress) {\n            getXhrOrXdr(id).upload.onprogress = function(e) {\n                if (e.lengthComputable) {\n                    onProgress(id, e.loaded, e.total);\n                }\n            };\n        }\n    }\n\n    // This will be called by IE to indicate **success** for an associated\n    // `XDomainRequest` transported request.\n    function getXdrLoadHandler(id) {\n        return function() {\n            onComplete(id);\n        };\n    }\n\n    // This will be called by IE to indicate **failure** for an associated\n    // `XDomainRequest` transported request.\n    function getXdrErrorHandler(id) {\n        return function() {\n            onComplete(id, true);\n        };\n    }\n\n    function setHeaders(id) {\n        var xhr = getXhrOrXdr(id),\n            customHeaders = options.customHeaders,\n            onDemandHeaders = requestData[id].additionalHeaders || {},\n            method = options.method,\n            allHeaders = {};\n\n        // If XDomainRequest is being used, we can't set headers, so just ignore this block.\n        if (!isXdr(xhr)) {\n            options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n\n            // Only attempt to add X-Requested-With & Cache-Control if permitted\n            if (options.allowXRequestedWithAndCacheControl) {\n                // Do not add X-Requested-With & Cache-Control if this is a cross-origin request\n                // OR the cross-origin request contains a non-simple method or header.\n                // This is done to ensure a preflight is not triggered exclusively based on the\n                // addition of these 2 non-simple headers.\n                if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                    xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                    xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                }\n            }\n\n            if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                xhr.setRequestHeader(\"Content-Type\", options.contentType);\n            }\n\n            qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n            qq.extend(allHeaders, onDemandHeaders);\n\n            qq.each(allHeaders, function(name, val) {\n                xhr.setRequestHeader(name, val);\n            });\n        }\n    }\n\n    function isResponseSuccessful(responseCode) {\n        return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n    }\n\n    function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n        requestData[id] = {\n            addToPath: addToPath,\n            additionalParams: additionalParams,\n            additionalQueryParams: additionalQueryParams,\n            additionalHeaders: additionalHeaders,\n            payload: payload\n        };\n\n        var len = queue.push(id);\n\n        // if too many active connections, wait...\n        if (len <= options.maxConnections) {\n            return sendRequest(id, optXhr);\n        }\n    }\n\n    shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n\n    qq.extend(this, {\n        // Start the process of sending the request.  The ID refers to the file associated with the request.\n        initTransport: function(id) {\n            var path, params, headers, payload, cacheBuster, additionalQueryParams;\n\n            return {\n                // Optionally specify the end of the endpoint path for the request.\n                withPath: function(appendToPath) {\n                    path = appendToPath;\n                    return this;\n                },\n\n                // Optionally specify additional parameters to send along with the request.\n                // These will be added to the query string for GET/DELETE requests or the payload\n                // for POST/PUT requests.  The Content-Type of the request will be used to determine\n                // how these parameters should be formatted as well.\n                withParams: function(additionalParams) {\n                    params = additionalParams;\n                    return this;\n                },\n\n                withQueryParams: function(_additionalQueryParams_) {\n                    additionalQueryParams = _additionalQueryParams_;\n                    return this;\n                },\n\n                // Optionally specify additional headers to send along with the request.\n                withHeaders: function(additionalHeaders) {\n                    headers = additionalHeaders;\n                    return this;\n                },\n\n                // Optionally specify a payload/body for the request.\n                withPayload: function(thePayload) {\n                    payload = thePayload;\n                    return this;\n                },\n\n                // Appends a cache buster (timestamp) to the request URL as a query parameter (only if GET or DELETE)\n                withCacheBuster: function() {\n                    cacheBuster = true;\n                    return this;\n                },\n\n                // Send the constructed request.\n                send: function(optXhr) {\n                    if (cacheBuster && qq.indexOf([\"GET\", \"DELETE\"], options.method) >= 0) {\n                        params.qqtimestamp = new Date().getTime();\n                    }\n\n                    return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                }\n            };\n        },\n\n        canceled: function(id) {\n            dequeue(id);\n        }\n    });\n};\n","/* globals qq */\n/**\n * Common upload handler functions.\n *\n * @constructor\n */\nqq.UploadHandler = function(spec) {\n    \"use strict\";\n\n    var proxy = spec.proxy,\n        fileState = {},\n        onCancel = proxy.onCancel,\n        getName = proxy.getName;\n\n    qq.extend(this, {\n        add: function(id, fileItem) {\n            fileState[id] = fileItem;\n            fileState[id].temp = {};\n        },\n\n        cancel: function(id) {\n            var self = this,\n                cancelFinalizationEffort = new qq.Promise(),\n                onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n\n            onCancelRetVal.then(function() {\n                if (self.isValid(id)) {\n                    fileState[id].canceled = true;\n                    self.expunge(id);\n                }\n                cancelFinalizationEffort.success();\n            });\n        },\n\n        expunge: function(id) {\n            delete fileState[id];\n        },\n\n        getThirdPartyFileId: function(id) {\n            return fileState[id].key;\n        },\n\n        isValid: function(id) {\n            return fileState[id] !== undefined;\n        },\n\n        reset: function() {\n            fileState = {};\n        },\n\n        _getFileState: function(id) {\n            return fileState[id];\n        },\n\n        _setThirdPartyFileId: function(id, thirdPartyFileId) {\n            fileState[id].key = thirdPartyFileId;\n        },\n\n        _wasCanceled: function(id) {\n            return !!fileState[id].canceled;\n        }\n    });\n};\n","/*globals qq*/\n/**\n * Base upload handler module.  Controls more specific handlers.\n *\n * @param o Options.  Passed along to the specific handler submodule as well.\n * @param namespace [optional] Namespace for the specific handler.\n */\nqq.UploadHandlerController = function(o, namespace) {\n    \"use strict\";\n\n    var controller = this,\n        chunkingPossible = false,\n        concurrentChunkingPossible = false,\n        chunking, preventRetryResponse, log, handler,\n\n    options = {\n        paramsStore: {},\n        maxConnections: 3, // maximum number of concurrent uploads\n        chunking: {\n            enabled: false,\n            multiple: {\n                enabled: false\n            }\n        },\n        log: function(str, level) {},\n        onProgress: function(id, fileName, loaded, total) {},\n        onComplete: function(id, fileName, response, xhr) {},\n        onCancel: function(id, fileName) {},\n        onUploadPrep: function(id) {}, // Called if non-trivial operations will be performed before onUpload\n        onUpload: function(id, fileName) {},\n        onUploadChunk: function(id, fileName, chunkData) {},\n        onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n        onAutoRetry: function(id, fileName, response, xhr) {},\n        onResume: function(id, fileName, chunkData, customResumeData) {},\n        onUuidChanged: function(id, newUuid) {},\n        getName: function(id) {},\n        setSize: function(id, newSize) {},\n        isQueued: function(id) {},\n        getIdsInProxyGroup: function(id) {},\n        getIdsInBatch: function(id) {},\n        isInProgress: function(id) {}\n    },\n\n    chunked = {\n        // Called when each chunk has uploaded successfully\n        done: function(id, chunkIdx, response, xhr) {\n            var chunkData = handler._getChunkData(id, chunkIdx);\n\n            handler._getFileState(id).attemptingResume = false;\n\n            delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n            handler._getFileState(id).loaded += chunkData.size;\n\n            options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n        },\n\n        // Called when all chunks have been successfully uploaded and we want to ask the handler to perform any\n        // logic associated with closing out the file, such as combining the chunks.\n        finalize: function(id) {\n            var size = options.getSize(id),\n                name = options.getName(id);\n\n            log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n            handler.finalizeChunks(id).then(\n                function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                },\n                function(response, xhr) {\n                    var normalizedResponse = upload.normalizeResponse(response, false);\n\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n\n                    if (\n                        normalizedResponse.reset ||\n                        (xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0)\n                    ) {\n                        chunked.reset(id);\n                    }\n\n                    if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n                        upload.cleanup(id, normalizedResponse, xhr);\n                    }\n                }\n            );\n        },\n\n        handleFailure: function(chunkIdx, id, response, xhr) {\n            var name = options.getName(id);\n\n            log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n\n            handler.clearCachedChunk(id, chunkIdx);\n\n            var responseToReport = upload.normalizeResponse(response, false),\n                inProgressIdx;\n\n            if (responseToReport.reset) {\n                chunked.reset(id);\n            }\n            else {\n                var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n\n                inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n                if (inProgressIdx >= 0) {\n                    handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                    handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                }\n            }\n\n            // We may have aborted all other in-progress chunks for this file due to a failure.\n            // If so, ignore the failures associated with those aborts.\n            if (!handler._getFileState(id).temp.ignoreFailure) {\n                // If this chunk has failed, we want to ignore all other failures of currently in-progress\n                // chunks since they will be explicitly aborted\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = true;\n\n                    log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                    qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                        log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                        ckXhr.abort();\n                        // Flag the transport, in case we are waiting for some other async operation\n                        // to complete before attempting to upload the chunk\n                        ckXhr._cancelled = true;\n                    });\n\n                    // We must indicate that all aborted chunks are no longer in progress\n                    handler.moveInProgressToRemaining(id);\n\n                    // Free up any connections used by these chunks, but don't allow any\n                    // other files to take up the connections (until we have exhausted all auto-retries)\n                    connectionManager.free(id, true);\n                }\n\n                if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                    // If one chunk fails, abort all of the others to avoid odd race conditions that occur\n                    // if a chunk succeeds immediately after one fails before we have determined if the upload\n                    // is a failure or not.\n                    upload.cleanup(id, responseToReport, xhr);\n                }\n            }\n        },\n\n        hasMoreParts: function(id) {\n            return !!handler._getFileState(id).chunking.remaining.length;\n        },\n\n        nextPart: function(id) {\n            var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n\n            if (nextIdx >= handler._getTotalChunks(id)) {\n                nextIdx = null;\n            }\n\n            return nextIdx;\n        },\n\n        reset: function(id) {\n            log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n\n            handler._maybeDeletePersistedChunkData(id);\n            handler.reevaluateChunking(id);\n            handler._getFileState(id).loaded = 0;\n            handler._getFileState(id).attemptingResume = false;\n        },\n\n        sendNext: function(id) {\n            var size = options.getSize(id),\n                name = options.getName(id),\n                chunkIdx = chunked.nextPart(id),\n                chunkData = handler._getChunkData(id, chunkIdx),\n                fileState = handler._getFileState(id),\n                resuming = fileState.attemptingResume,\n                inProgressChunks = fileState.chunking.inProgress || [];\n\n            if (fileState.loaded == null) {\n                fileState.loaded = 0;\n            }\n\n            // Don't follow-through with the resume attempt if the integrator returns false from onResume\n            if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n                chunked.reset(id);\n                chunkIdx = chunked.nextPart(id);\n                chunkData = handler._getChunkData(id, chunkIdx);\n                resuming = false;\n            }\n\n            // If all chunks have already uploaded successfully, we must be re-attempting the finalize step.\n            if (chunkIdx == null && inProgressChunks.length === 0) {\n                chunked.finalize(id);\n            }\n\n            // Send the next chunk\n            else {\n                inProgressChunks.push(chunkIdx);\n                handler._getFileState(id).chunking.inProgress = inProgressChunks;\n\n                if (concurrentChunkingPossible) {\n                    connectionManager.open(id, chunkIdx);\n                }\n\n                if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                    chunked.sendNext(id);\n                }\n\n                if (chunkData.blob.size === 0) {\n                    log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                    chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                }\n\n                var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n\n                onUploadChunkPromise.then(\n                    function(requestOverrides) {\n                        if (!options.isInProgress(id)) {\n                            log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n                        }\n                        else {\n                            log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n\n                            var uploadChunkData = {\n                                chunkIdx: chunkIdx,\n                                id: id,\n                                overrides: requestOverrides,\n                                resuming: resuming\n                            };\n\n                            handler.uploadChunk(uploadChunkData).then(\n                                // upload chunk success\n                                function success(response, xhr) {\n                                    log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n\n                                    handler.clearCachedChunk(id, chunkIdx);\n\n                                    var inProgressChunks = handler._getFileState(id).chunking.inProgress || [],\n                                        responseToReport = upload.normalizeResponse(response, true),\n                                        inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n\n                                    log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n\n                                    chunked.done(id, chunkIdx, responseToReport, xhr);\n\n                                    if (inProgressChunkIdx >= 0) {\n                                        inProgressChunks.splice(inProgressChunkIdx, 1);\n                                    }\n\n                                    handler._maybePersistChunkedState(id);\n\n                                    if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                        chunked.finalize(id);\n                                    }\n                                    else if (chunked.hasMoreParts(id)) {\n                                        chunked.sendNext(id);\n                                    }\n                                    else {\n                                        log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                                    }\n                                },\n\n                                // upload chunk failure\n                                function failure(response, xhr) {\n                                    chunked.handleFailure(chunkIdx, id, response, xhr);\n                                }\n                            )\n                                .done(function () {\n                                    handler.clearXhr(id, chunkIdx);\n                                });\n                        }\n                    },\n\n                    function(error) {\n                        chunked.handleFailure(chunkIdx, id, error, null);\n                    }\n                );\n            }\n        }\n    },\n\n    connectionManager = {\n        _open: [],\n        _openChunks: {},\n        _waiting: [],\n\n        available: function() {\n            var max = options.maxConnections,\n                openChunkEntriesCount = 0,\n                openChunksCount = 0;\n\n            qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                openChunkEntriesCount++;\n                openChunksCount += openChunkIndexes.length;\n            });\n\n            return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n        },\n\n        /**\n         * Removes element from queue, starts upload of next\n         */\n        free: function(id, dontAllowNext) {\n            var allowNext = !dontAllowNext,\n                waitingIndex = qq.indexOf(connectionManager._waiting, id),\n                connectionsIndex = qq.indexOf(connectionManager._open, id),\n                nextId;\n\n            delete connectionManager._openChunks[id];\n\n            if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                delete handler._getFileState(id).file;\n            }\n\n            // If this file was not consuming a connection, it was just waiting, so remove it from the waiting array\n            if (waitingIndex >= 0) {\n                connectionManager._waiting.splice(waitingIndex, 1);\n            }\n            // If this file was consuming a connection, allow the next file to be uploaded\n            else if (allowNext && connectionsIndex >= 0) {\n                connectionManager._open.splice(connectionsIndex, 1);\n\n                nextId = connectionManager._waiting.shift();\n                if (nextId >= 0) {\n                    connectionManager._open.push(nextId);\n                    upload.start(nextId);\n                }\n            }\n        },\n\n        getWaitingOrConnected: function() {\n            var waitingOrConnected = [];\n\n            // Chunked files may have multiple connections open per chunk (if concurrent chunking is enabled)\n            // We need to grab the file ID of any file that has at least one chunk consuming a connection.\n            qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                if (chunks && chunks.length) {\n                    waitingOrConnected.push(parseInt(fileId));\n                }\n            });\n\n            // For non-chunked files, only one connection will be consumed per file.\n            // This is where we aggregate those file IDs.\n            qq.each(connectionManager._open, function(idx, fileId) {\n                if (!connectionManager._openChunks[fileId]) {\n                    waitingOrConnected.push(parseInt(fileId));\n                }\n            });\n\n            // There may be files waiting for a connection.\n            waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n\n            return waitingOrConnected;\n        },\n\n        isUsingConnection: function(id) {\n            return qq.indexOf(connectionManager._open, id) >= 0;\n        },\n\n        open: function(id, chunkIdx) {\n            if (chunkIdx == null) {\n                connectionManager._waiting.push(id);\n            }\n\n            if (connectionManager.available()) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.pop();\n                    connectionManager._open.push(id);\n                }\n                else {\n                    (function() {\n                        var openChunksEntry = connectionManager._openChunks[id] || [];\n                        openChunksEntry.push(chunkIdx);\n                        connectionManager._openChunks[id] = openChunksEntry;\n                    }());\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n        reset: function() {\n            connectionManager._waiting = [];\n            connectionManager._open = [];\n        }\n    },\n\n    simple = {\n        send: function(id, name) {\n            var fileState = handler._getFileState(id);\n\n            if (!fileState) {\n                log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n                return;\n            }\n\n            fileState.loaded = 0;\n\n            log(\"Sending simple upload request for \" + id);\n            handler.uploadFile(id).then(\n                function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n\n                    var responseToReport = upload.normalizeResponse(response, true),\n                        size = options.getSize(id);\n\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                },\n\n                function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n\n                    var responseToReport = upload.normalizeResponse(response, false);\n\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                }\n            );\n        }\n    },\n\n    upload = {\n        cancel: function(id) {\n            log(\"Cancelling \" + id);\n            options.paramsStore.remove(id);\n            connectionManager.free(id);\n        },\n\n        cleanup: function(id, response, optXhr) {\n            var name = options.getName(id);\n\n            options.onComplete(id, name, response, optXhr);\n\n            if (handler._getFileState(id)) {\n                handler._clearXhrs && handler._clearXhrs(id);\n            }\n\n            connectionManager.free(id);\n        },\n\n        // Returns a qq.BlobProxy, or an actual File/Blob if no proxy is involved, or undefined\n        // if none of these are available for the ID\n        getProxyOrBlob: function(id) {\n            return (handler.getProxy && handler.getProxy(id)) ||\n                (handler.getFile && handler.getFile(id));\n        },\n\n        initHandler: function() {\n            var handlerType = namespace ? qq[namespace] : qq.traditional,\n                handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n\n            handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](\n                options,\n                {\n                    getCustomResumeData: options.getCustomResumeData,\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged,\n                    onFinalizing: function(id) {\n                        options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n                    }\n                }\n            );\n\n            if (handler._removeExpiredChunkingRecords) {\n                handler._removeExpiredChunkingRecords();\n            }\n        },\n\n        isDeferredEligibleForUpload: function(id) {\n            return options.isQueued(id);\n        },\n\n        // For Blobs that are part of a group of generated images, along with a reference image,\n        // this will ensure the blobs in the group are uploaded in the order they were triggered,\n        // even if some async processing must be completed on one or more Blobs first.\n        maybeDefer: function(id, blob) {\n            // If we don't have a file/blob yet & no file/blob exists for this item, request it,\n            // and then submit the upload to the specific handler once the blob is available.\n            // ASSUMPTION: This condition will only ever be true if XHR uploading is supported.\n            if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n\n                // Blob creation may take some time, so the caller may want to update the\n                // UI to indicate that an operation is in progress, even before the actual\n                // upload begins and an onUpload callback is invoked.\n                options.onUploadPrep(id);\n\n                log(\"Attempting to generate a blob on-demand for \" + id);\n                blob.create().then(function(generatedBlob) {\n                    log(\"Generated an on-demand blob for \" + id);\n\n                    // Update record associated with this file by providing the generated Blob\n                    handler.updateBlob(id, generatedBlob);\n\n                    // Propagate the size for this generated Blob\n                    options.setSize(id, generatedBlob.size);\n\n                    // Order handler to recalculate chunking possibility, if applicable\n                    handler.reevaluateChunking(id);\n\n                    upload.maybeSendDeferredFiles(id);\n                },\n\n                // Blob could not be generated.  Fail the upload & attempt to prevent retries.  Also bubble error message.\n                function(errorMessage) {\n                    var errorResponse = {};\n\n                    if (errorMessage) {\n                        errorResponse.error = errorMessage;\n                    }\n\n                    log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n\n                    options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                    upload.maybeSendDeferredFiles(id);\n                    connectionManager.free(id);\n                });\n            }\n            else {\n                return upload.maybeSendDeferredFiles(id);\n            }\n\n            return false;\n        },\n\n        // Upload any grouped blobs, in the proper order, that are ready to be uploaded\n        maybeSendDeferredFiles: function(id) {\n            var idsInGroup = options.getIdsInProxyGroup(id),\n                uploadedThisId = false;\n\n            if (idsInGroup && idsInGroup.length) {\n                log(\"Maybe ready to upload proxy group file \" + id);\n\n                qq.each(idsInGroup, function(idx, idInGroup) {\n                    if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                        uploadedThisId = idInGroup === id;\n                        upload.now(idInGroup);\n                    }\n                    else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                        return false;\n                    }\n                });\n            }\n            else {\n                uploadedThisId = true;\n                upload.now(id);\n            }\n\n            return uploadedThisId;\n        },\n\n        maybeNewUuid: function(id, response) {\n            if (response.newUuid !== undefined) {\n                options.onUuidChanged(id, response.newUuid);\n            }\n        },\n\n        // The response coming from handler implementations may be in various formats.\n        // Instead of hoping a promise nested 5 levels deep will always return an object\n        // as its first param, let's just normalize the response here.\n        normalizeResponse: function(originalResponse, successful) {\n            var response = originalResponse;\n\n            // The passed \"response\" param may not be a response at all.\n            // It could be a string, detailing the error, for example.\n            if (!qq.isObject(originalResponse)) {\n                response = {};\n\n                if (qq.isString(originalResponse) && !successful) {\n                    response.error = originalResponse;\n                }\n            }\n\n            response.success = successful;\n\n            return response;\n        },\n\n        now: function(id) {\n            var name = options.getName(id);\n\n            if (!controller.isValid(id)) {\n                throw new qq.Error(id + \" is not a valid file ID to upload!\");\n            }\n\n            options.onUpload(id, name).then(\n                function(response) {\n                    if (response && response.pause) {\n                        options.setStatus(id, qq.status.PAUSED);\n                        handler.pause(id);\n                        connectionManager.free(id);\n                    }\n                    else {\n                        if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                            chunked.sendNext(id);\n                        }\n                        else {\n                            simple.send(id, name);\n                        }\n                    }\n                },\n\n                function(error) {\n                    error = error || {};\n\n                    log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n\n                    if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n                        var response = upload.normalizeResponse(error.responseJSON, false);\n                        upload.cleanup(id, response);\n                    }\n                }\n            );\n        },\n\n        start: function(id) {\n            var blobToUpload = upload.getProxyOrBlob(id);\n\n            if (blobToUpload) {\n                return upload.maybeDefer(id, blobToUpload);\n            }\n            else {\n                upload.now(id);\n                return true;\n            }\n        }\n    };\n\n    qq.extend(this, {\n        /**\n         * Adds file or file input to the queue\n         **/\n        add: function(id, file) {\n            handler.add.apply(this, arguments);\n        },\n\n        /**\n         * Sends the file identified by id\n         */\n        upload: function(id) {\n            if (connectionManager.open(id)) {\n                return upload.start(id);\n            }\n            return false;\n        },\n\n        retry: function(id) {\n            // On retry, if concurrent chunking has been enabled, we may have aborted all other in-progress chunks\n            // for a file when encountering a failed chunk upload.  We then signaled the controller to ignore\n            // all failures associated with these aborts.  We are now retrying, so we don't want to ignore\n            // any more failures at this point.\n            if (concurrentChunkingPossible) {\n                handler._getFileState(id).temp.ignoreFailure = false;\n            }\n\n            // If we are attempting to retry a file that is already consuming a connection, this is likely an auto-retry.\n            // Just go ahead and ask the handler to upload again.\n            if (connectionManager.isUsingConnection(id)) {\n                return upload.start(id);\n            }\n\n            // If we are attempting to retry a file that is not currently consuming a connection,\n            // this is likely a manual retry attempt.  We will need to ensure a connection is available\n            // before the retry commences.\n            else {\n                return controller.upload(id);\n            }\n        },\n\n        /**\n         * Cancels file upload by id\n         */\n        cancel: function(id) {\n            var cancelRetVal = handler.cancel(id);\n\n            if (qq.isGenericPromise(cancelRetVal)) {\n                cancelRetVal.then(function() {\n                    upload.cancel(id);\n                });\n            }\n            else if (cancelRetVal !== false) {\n                upload.cancel(id);\n            }\n        },\n\n        /**\n         * Cancels all queued or in-progress uploads\n         */\n        cancelAll: function() {\n            var waitingOrConnected = connectionManager.getWaitingOrConnected(),\n                i;\n\n            // ensure files are cancelled in reverse order which they were added\n            // to avoid a flash of time where a queued file begins to upload before it is canceled\n            if (waitingOrConnected.length) {\n                for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                    controller.cancel(waitingOrConnected[i]);\n                }\n            }\n\n            connectionManager.reset();\n        },\n\n        // Returns a File, Blob, or the Blob/File for the reference/parent file if the targeted blob is a proxy.\n        // Undefined if no file record is available.\n        getFile: function(id) {\n            if (handler.getProxy && handler.getProxy(id)) {\n                return handler.getProxy(id).referenceBlob;\n            }\n\n            return handler.getFile && handler.getFile(id);\n        },\n\n        // Returns true if the Blob associated with the ID is related to a proxy s\n        isProxied: function(id) {\n            return !!(handler.getProxy && handler.getProxy(id));\n        },\n\n        getInput: function(id) {\n            if (handler.getInput) {\n                return handler.getInput(id);\n            }\n        },\n\n        reset: function() {\n            log(\"Resetting upload handler\");\n            controller.cancelAll();\n            connectionManager.reset();\n            handler.reset();\n        },\n\n        expunge: function(id) {\n            if (controller.isValid(id)) {\n                return handler.expunge(id);\n            }\n        },\n\n        /**\n         * Determine if the file exists.\n         */\n        isValid: function(id) {\n            return handler.isValid(id);\n        },\n\n        hasResumeRecord: function(id) {\n            var key = handler.isValid(id) &&\n                handler._getLocalStorageId &&\n                handler._getLocalStorageId(id);\n\n            if (key) {\n                return !!localStorage.getItem(key);\n            }\n\n            return false;\n        },\n\n        getResumableFilesData: function() {\n            if (handler.getResumableFilesData) {\n                return handler.getResumableFilesData();\n            }\n            return [];\n        },\n\n        /**\n         * This may or may not be implemented, depending on the handler.  For handlers where a third-party ID is\n         * available (such as the \"key\" for Amazon S3), this will return that value.  Otherwise, the return value\n         * will be undefined.\n         *\n         * @param id Internal file ID\n         * @returns {*} Some identifier used by a 3rd-party service involved in the upload process\n         */\n        getThirdPartyFileId: function(id) {\n            if (controller.isValid(id)) {\n                return handler.getThirdPartyFileId(id);\n            }\n        },\n\n        /**\n         * Attempts to pause the associated upload if the specific handler supports this and the file is \"valid\".\n         * @param id ID of the upload/file to pause\n         * @returns {boolean} true if the upload was paused\n         */\n        pause: function(id) {\n            if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                connectionManager.free(id);\n                handler.moveInProgressToRemaining(id);\n                return true;\n            }\n            return false;\n        },\n\n        isAttemptingResume: function(id) {\n            return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n        },\n\n        // True if the file is eligible for pause/resume.\n        isResumable: function(id) {\n            return !!handler.isResumable && handler.isResumable(id);\n        }\n    });\n\n    qq.extend(options, o);\n    log = options.log;\n    chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n    concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n\n    preventRetryResponse = (function() {\n        var response = {};\n\n        response[options.preventRetryParam] = true;\n\n        return response;\n    }());\n\n    upload.initHandler();\n};\n","/*globals qq */\n/*jshint -W117 */\nqq.WindowReceiveMessage = function(o) {\n    \"use strict\";\n\n    var options = {\n            log: function(message, level) {}\n        },\n        callbackWrapperDetachers = {};\n\n    qq.extend(options, o);\n\n    qq.extend(this, {\n        receiveMessage: function(id, callback) {\n            var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n\n            if (window.postMessage) {\n                callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n            }\n            else {\n                log(\"iframe message passing not supported in this browser!\", \"error\");\n            }\n        },\n\n        stopReceivingMessages: function(id) {\n            if (window.postMessage) {\n                var detacher = callbackWrapperDetachers[id];\n                if (detacher) {\n                    detacher();\n                }\n            }\n        }\n    });\n};\n","/* globals qq */\n/**\n * Common APIs exposed to creators of upload via form/iframe handlers.  This is reused and possibly overridden\n * in some cases by specific form upload handlers.\n *\n * @constructor\n */\nqq.FormUploadHandler = function(spec) {\n    \"use strict\";\n\n    var options = spec.options,\n        handler = this,\n        proxy = spec.proxy,\n        formHandlerInstanceId = qq.getUniqueId(),\n        onloadCallbacks = {},\n        detachLoadEvents = {},\n        postMessageCallbackTimers = {},\n        isCors = options.isCors,\n        inputName = options.inputName,\n        getUuid = proxy.getUuid,\n        log = proxy.log,\n        corsMessageReceiver = new qq.WindowReceiveMessage({log: log});\n\n    /**\n     * Remove any trace of the file from the handler.\n     *\n     * @param id ID of the associated file\n     */\n    function expungeFile(id) {\n        delete detachLoadEvents[id];\n\n        // If we are dealing with CORS, we might still be waiting for a response from a loaded iframe.\n        // In that case, terminate the timer waiting for a message from the loaded iframe\n        // and stop listening for any more messages coming from this iframe.\n        if (isCors) {\n            clearTimeout(postMessageCallbackTimers[id]);\n            delete postMessageCallbackTimers[id];\n            corsMessageReceiver.stopReceivingMessages(id);\n        }\n\n        var iframe = document.getElementById(handler._getIframeName(id));\n        if (iframe) {\n            // To cancel request set src to something else.  We use src=\"javascript:false;\"\n            // because it doesn't trigger ie6 prompt on https\n            /* jshint scripturl:true */\n            iframe.setAttribute(\"src\", \"javascript:false;\");\n\n            qq(iframe).remove();\n        }\n    }\n\n    /**\n     * @param iframeName `document`-unique Name of the associated iframe\n     * @returns {*} ID of the associated file\n     */\n    function getFileIdForIframeName(iframeName) {\n        return iframeName.split(\"_\")[0];\n    }\n\n    /**\n     * Generates an iframe to be used as a target for upload-related form submits.  This also adds the iframe\n     * to the current `document`.  Note that the iframe is hidden from view.\n     *\n     * @param name Name of the iframe.\n     * @returns {HTMLIFrameElement} The created iframe\n     */\n    function initIframeForUpload(name) {\n        var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n\n        iframe.setAttribute(\"id\", name);\n\n        iframe.style.display = \"none\";\n        document.body.appendChild(iframe);\n\n        return iframe;\n    }\n\n    /**\n     * If we are in CORS mode, we must listen for messages (containing the server response) from the associated\n     * iframe, since we cannot directly parse the content of the iframe due to cross-origin restrictions.\n     *\n     * @param iframe Listen for messages on this iframe.\n     * @param callback Invoke this callback with the message from the iframe.\n     */\n    function registerPostMessageCallback(iframe, callback) {\n        var iframeName = iframe.id,\n            fileId = getFileIdForIframeName(iframeName),\n            uuid = getUuid(fileId);\n\n        onloadCallbacks[uuid] = callback;\n\n        // When the iframe has loaded (after the server responds to an upload request)\n        // declare the attempt a failure if we don't receive a valid message shortly after the response comes in.\n        detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n            if (handler.getInput(fileId)) {\n                log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n\n                postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                    var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                    log(errorMessage, \"error\");\n                    callback({\n                        error: errorMessage\n                    });\n                }, 1000);\n            }\n        });\n\n        // Listen for messages coming from this iframe.  When a message has been received, cancel the timer\n        // that declares the upload a failure if a message is not received within a reasonable amount of time.\n        corsMessageReceiver.receiveMessage(iframeName, function(message) {\n            log(\"Received the following window message: '\" + message + \"'\");\n            var fileId = getFileIdForIframeName(iframeName),\n                response = handler._parseJsonResponse(message),\n                uuid = response.uuid,\n                onloadCallback;\n\n            if (uuid && onloadCallbacks[uuid]) {\n                log(\"Handling response for iframe name \" + iframeName);\n                clearTimeout(postMessageCallbackTimers[iframeName]);\n                delete postMessageCallbackTimers[iframeName];\n\n                handler._detachLoadEvent(iframeName);\n\n                onloadCallback = onloadCallbacks[uuid];\n\n                delete onloadCallbacks[uuid];\n                corsMessageReceiver.stopReceivingMessages(iframeName);\n                onloadCallback(response);\n            }\n            else if (!uuid) {\n                log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n            }\n        });\n    }\n\n    qq.extend(this, new qq.UploadHandler(spec));\n\n    qq.override(this, function(super_) {\n        return {\n            /**\n             * Adds File or Blob to the queue\n             **/\n            add: function(id, fileInput) {\n                super_.add(id, {input: fileInput});\n\n                fileInput.setAttribute(\"name\", inputName);\n\n                // remove file input from DOM\n                if (fileInput.parentNode) {\n                    qq(fileInput).remove();\n                }\n            },\n\n            expunge: function(id) {\n                expungeFile(id);\n                super_.expunge(id);\n            },\n\n            isValid: function(id) {\n                return super_.isValid(id) &&\n                    handler._getFileState(id).input !== undefined;\n            }\n        };\n    });\n\n    qq.extend(this, {\n        getInput: function(id) {\n            return handler._getFileState(id).input;\n        },\n\n        /**\n         * This function either delegates to a more specific message handler if CORS is involved,\n         * or simply registers a callback when the iframe has been loaded that invokes the passed callback\n         * after determining if the content of the iframe is accessible.\n         *\n         * @param iframe Associated iframe\n         * @param callback Callback to invoke after we have determined if the iframe content is accessible.\n         */\n        _attachLoadEvent: function(iframe, callback) {\n            /*jslint eqeq: true*/\n            var responseDescriptor;\n\n            if (isCors) {\n                registerPostMessageCallback(iframe, callback);\n            }\n            else {\n                detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                    log(\"Received response for \" + iframe.id);\n\n                    // when we remove iframe from dom\n                    // the request stops, but in IE load\n                    // event fires\n                    if (!iframe.parentNode) {\n                        return;\n                    }\n\n                    try {\n                        // fixing Opera 10.53\n                        if (iframe.contentDocument &&\n                            iframe.contentDocument.body &&\n                            iframe.contentDocument.body.innerHTML == \"false\") {\n                            // In Opera event is fired second time\n                            // when body.innerHTML changed from false\n                            // to server response approx. after 1 sec\n                            // when we upload file with iframe\n                            return;\n                        }\n                    }\n                    catch (error) {\n                        //IE may throw an \"access is denied\" error when attempting to access contentDocument on the iframe in some cases\n                        log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                        responseDescriptor = {success: false};\n                    }\n\n                    callback(responseDescriptor);\n                });\n            }\n        },\n\n        /**\n         * Creates an iframe with a specific document-unique name.\n         *\n         * @param id ID of the associated file\n         * @returns {HTMLIFrameElement}\n         */\n        _createIframe: function(id) {\n            var iframeName = handler._getIframeName(id);\n\n            return initIframeForUpload(iframeName);\n        },\n\n        /**\n         * Called when we are no longer interested in being notified when an iframe has loaded.\n         *\n         * @param id Associated file ID\n         */\n        _detachLoadEvent: function(id) {\n            if (detachLoadEvents[id] !== undefined) {\n                detachLoadEvents[id]();\n                delete detachLoadEvents[id];\n            }\n        },\n\n        /**\n         * @param fileId ID of the associated file\n         * @returns {string} The `document`-unique name of the iframe\n         */\n        _getIframeName: function(fileId) {\n            return fileId + \"_\" + formHandlerInstanceId;\n        },\n\n        /**\n         * Generates a form element and appends it to the `document`.  When the form is submitted, a specific iframe is targeted.\n         * The name of the iframe is passed in as a property of the spec parameter, and must be unique in the `document`.  Note\n         * that the form is hidden from view.\n         *\n         * @param spec An object containing various properties to be used when constructing the form.  Required properties are\n         * currently: `method`, `endpoint`, `params`, `paramsInBody`, and `targetName`.\n         * @returns {HTMLFormElement} The created form\n         */\n        _initFormForUpload: function(spec) {\n            var method = spec.method,\n                endpoint = spec.endpoint,\n                params = spec.params,\n                paramsInBody = spec.paramsInBody,\n                targetName = spec.targetName,\n                form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"),\n                url = endpoint;\n\n            if (paramsInBody) {\n                qq.obj2Inputs(params, form);\n            }\n            else {\n                url = qq.obj2url(params, endpoint);\n            }\n\n            form.setAttribute(\"action\", url);\n            form.setAttribute(\"target\", targetName);\n            form.style.display = \"none\";\n            document.body.appendChild(form);\n\n            return form;\n        },\n\n        /**\n         * @param innerHtmlOrMessage JSON message\n         * @returns {*} The parsed response, or an empty object if the response could not be parsed\n         */\n        _parseJsonResponse: function(innerHtmlOrMessage) {\n            var response = {};\n\n            try {\n                response = qq.parseJson(innerHtmlOrMessage);\n            }\n            catch (error) {\n                log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n            }\n\n            return response;\n        }\n    });\n};\n","/* globals qq */\n/**\n * Common API exposed to creators of XHR handlers.  This is reused and possibly overriding in some cases by specific\n * XHR upload handlers.\n *\n * @constructor\n */\nqq.XhrUploadHandler = function(spec) {\n    \"use strict\";\n\n    var handler = this,\n        namespace = spec.options.namespace,\n        proxy = spec.proxy,\n        chunking = spec.options.chunking,\n        getChunkSize = function(id) {\n            var fileState = handler._getFileState(id);\n\n            if (fileState.chunkSize) {\n                return fileState.chunkSize;\n            }\n\n            else {\n                var chunkSize = chunking.partSize;\n\n                if (qq.isFunction(chunkSize)) {\n                    chunkSize = chunkSize(id, getSize(id));\n                }\n\n                fileState.chunkSize = chunkSize;\n                return chunkSize;\n            }\n        },\n        resume = spec.options.resume,\n        chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking,\n        resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume,\n        getName = proxy.getName,\n        getSize = proxy.getSize,\n        getUuid = proxy.getUuid,\n        getEndpoint = proxy.getEndpoint,\n        getDataByUuid = proxy.getDataByUuid,\n        onUuidChanged = proxy.onUuidChanged,\n        onProgress = proxy.onProgress,\n        log = proxy.log,\n        getCustomResumeData = proxy.getCustomResumeData;\n\n    function abort(id) {\n        qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n            var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n\n            xhr.onreadystatechange = null;\n            xhr.upload.onprogress = null;\n            xhr.abort();\n            ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n        });\n    }\n\n    qq.extend(this, new qq.UploadHandler(spec));\n\n    qq.override(this, function(super_) {\n        return {\n            /**\n             * Adds File or Blob to the queue\n             **/\n            add: function(id, blobOrProxy) {\n                if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                    super_.add(id, {file: blobOrProxy});\n                }\n                else if (blobOrProxy instanceof qq.BlobProxy) {\n                    super_.add(id, {proxy: blobOrProxy});\n                }\n                else {\n                    throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                }\n\n                handler._initTempState(id);\n                resumeEnabled && handler._maybePrepareForResume(id);\n            },\n\n            expunge: function(id) {\n                abort(id);\n                handler._maybeDeletePersistedChunkData(id);\n                handler._clearXhrs(id);\n                super_.expunge(id);\n            }\n        };\n    });\n\n    qq.extend(this, {\n        // Clear the cached chunk `Blob` after we are done with it, just in case the `Blob` bytes are stored in memory.\n        clearCachedChunk: function(id, chunkIdx) {\n            var fileState = handler._getFileState(id);\n\n            if (fileState) {\n                delete fileState.temp.cachedChunks[chunkIdx];\n            }\n        },\n\n        clearXhr: function(id, chunkIdx) {\n            var tempState = handler._getFileState(id).temp;\n\n            if (tempState.xhrs) {\n                delete tempState.xhrs[chunkIdx];\n            }\n            if (tempState.ajaxRequesters) {\n                delete tempState.ajaxRequesters[chunkIdx];\n            }\n        },\n\n        // Called when all chunks have been successfully uploaded.  Expected promissory return type.\n        // This defines the default behavior if nothing further is required when all chunks have been uploaded.\n        finalizeChunks: function(id, responseParser) {\n            var lastChunkIdx = handler._getTotalChunks(id) - 1,\n                xhr = handler._getXhr(id, lastChunkIdx);\n\n            if (responseParser) {\n                return new qq.Promise().success(responseParser(xhr), xhr);\n            }\n\n            return new qq.Promise().success({}, xhr);\n        },\n\n        getFile: function(id) {\n            return handler.isValid(id) && handler._getFileState(id).file;\n        },\n\n        getProxy: function(id) {\n            return handler.isValid(id) && handler._getFileState(id).proxy;\n        },\n\n        /**\n         * @returns {Array} Array of objects containing properties useful to integrators\n         * when it is important to determine which files are potentially resumable.\n         */\n        getResumableFilesData: function() {\n            var resumableFilesData = [];\n\n            handler._iterateResumeRecords(function(key, uploadData) {\n                handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress,  uploadData.chunking.remaining);\n\n                var data = {\n                    name: uploadData.name,\n                    remaining: uploadData.chunking.remaining,\n                    size: uploadData.size,\n                    uuid: uploadData.uuid\n                };\n\n                if (uploadData.key) {\n                    data.key = uploadData.key;\n                }\n\n                if (uploadData.customResumeData) {\n                    data.customResumeData = uploadData.customResumeData;\n                }\n\n                resumableFilesData.push(data);\n            });\n\n            return resumableFilesData;\n        },\n\n        isAttemptingResume: function(id) {\n            return handler._getFileState(id).attemptingResume;\n        },\n\n        isResumable: function(id) {\n            return !!chunking && handler.isValid(id) &&\n                !handler._getFileState(id).notResumable;\n        },\n\n        moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n            var fileState = handler._getFileState(id) || {},\n                chunkingState =  fileState.chunking || {},\n                inProgress = optInProgress || chunkingState.inProgress,\n                remaining = optRemaining || chunkingState.remaining;\n\n            if (inProgress) {\n                log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                inProgress.reverse();\n                qq.each(inProgress, function(idx, chunkIdx) {\n                    remaining.unshift(chunkIdx);\n                });\n                inProgress.length = 0;\n            }\n        },\n\n        pause: function(id) {\n            if (handler.isValid(id)) {\n                log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                handler._getFileState(id).paused = true;\n                abort(id);\n                return true;\n            }\n        },\n\n        reevaluateChunking: function(id) {\n            if (chunking && handler.isValid(id)) {\n                var state = handler._getFileState(id),\n                    totalChunks,\n                    i;\n\n                delete state.chunking;\n\n                state.chunking = {};\n                totalChunks = handler._getTotalChunks(id);\n                if (totalChunks > 1 || chunking.mandatory) {\n                    state.chunking.enabled = true;\n                    state.chunking.parts = totalChunks;\n                    state.chunking.remaining = [];\n\n                    for (i = 0; i < totalChunks; i++) {\n                        state.chunking.remaining.push(i);\n                    }\n\n                    handler._initTempState(id);\n                }\n                else {\n                    state.chunking.enabled = false;\n                }\n            }\n        },\n\n        updateBlob: function(id, newBlob) {\n            if (handler.isValid(id)) {\n                handler._getFileState(id).file = newBlob;\n            }\n        },\n\n        _clearXhrs: function(id) {\n            var tempState = handler._getFileState(id).temp;\n\n            qq.each(tempState.ajaxRequesters, function(chunkId) {\n                delete tempState.ajaxRequesters[chunkId];\n            });\n\n            qq.each(tempState.xhrs, function(chunkId) {\n                delete tempState.xhrs[chunkId];\n            });\n        },\n\n        /**\n         * Creates an XHR instance for this file and stores it in the fileState.\n         *\n         * @param id File ID\n         * @param optChunkIdx The chunk index associated with this XHR, if applicable\n         * @returns {XMLHttpRequest}\n         */\n        _createXhr: function(id, optChunkIdx) {\n            return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n        },\n\n        _getAjaxRequester: function(id, optChunkIdx) {\n            var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n            return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n        },\n\n        _getChunkData: function(id, chunkIndex) {\n            var chunkSize = getChunkSize(id),\n                fileSize = getSize(id),\n                fileOrBlob = handler.getFile(id),\n                startBytes = chunkSize * chunkIndex,\n                endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize,\n                totalChunks = handler._getTotalChunks(id),\n                cachedChunks = this._getFileState(id).temp.cachedChunks,\n\n            // To work around a Webkit GC bug, we must keep each chunk `Blob` in scope until we are done with it.\n            // See https://github.com/FineUploader/fine-uploader/issues/937#issuecomment-41418760\n                blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n\n            cachedChunks[chunkIndex] = blob;\n\n            return {\n                part: chunkIndex,\n                start: startBytes,\n                end: endBytes,\n                count: totalChunks,\n                blob: blob,\n                size: endBytes - startBytes\n            };\n        },\n\n        _getChunkDataForCallback: function(chunkData) {\n            return {\n                partIndex: chunkData.part,\n                startByte: chunkData.start + 1,\n                endByte: chunkData.end,\n                totalParts: chunkData.count\n            };\n        },\n\n        /**\n         * @param id File ID\n         * @returns {string} Identifier for this item that may appear in the browser's local storage\n         */\n        _getLocalStorageId: function(id) {\n            var formatVersion = \"5.0\",\n                name = getName(id),\n                size = getSize(id),\n                chunkSize = getChunkSize(id),\n                endpoint = getEndpoint(id),\n                customKeys = resume.customKeys(id),\n                localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n\n            customKeys.forEach(function(key) {\n                localStorageId += \"-\" + key;\n            });\n\n            return localStorageId;\n        },\n\n        _getMimeType: function(id) {\n            return handler.getFile(id).type;\n        },\n\n        _getPersistableData: function(id) {\n            return handler._getFileState(id).chunking;\n        },\n\n        /**\n         * @param id ID of the associated file\n         * @returns {number} Number of parts this file can be divided into, or undefined if chunking is not supported in this UA\n         */\n        _getTotalChunks: function(id) {\n            if (chunking) {\n                var fileSize = getSize(id),\n                    chunkSize = getChunkSize(id);\n\n                return Math.ceil(fileSize / chunkSize);\n            }\n        },\n\n        _getXhr: function(id, optChunkIdx) {\n            var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n            return handler._getFileState(id).temp.xhrs[chunkIdx];\n        },\n\n        _getXhrs: function(id) {\n            return handler._getFileState(id).temp.xhrs;\n        },\n\n        // Iterates through all XHR handler-created resume records (in local storage),\n        // invoking the passed callback and passing in the key and value of each local storage record.\n        _iterateResumeRecords: function(callback) {\n            if (resumeEnabled) {\n                qq.each(localStorage, function(key, item) {\n                    if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                        var uploadData = JSON.parse(item);\n                        callback(key, uploadData);\n                    }\n                });\n            }\n        },\n\n        _initTempState: function(id) {\n            handler._getFileState(id).temp = {\n                ajaxRequesters: {},\n                chunkProgress: {},\n                xhrs: {},\n                cachedChunks: {}\n            };\n        },\n\n        _markNotResumable: function(id) {\n            handler._getFileState(id).notResumable = true;\n        },\n\n        // Removes a chunked upload record from local storage, if possible.\n        // Returns true if the item was removed, false otherwise.\n        _maybeDeletePersistedChunkData: function(id) {\n            var localStorageId;\n\n            if (resumeEnabled && handler.isResumable(id)) {\n                localStorageId = handler._getLocalStorageId(id);\n\n                if (localStorageId && localStorage.getItem(localStorageId)) {\n                    localStorage.removeItem(localStorageId);\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        // If this is a resumable upload, grab the relevant data from storage and items in memory that track this upload\n        // so we can pick up from where we left off.\n        _maybePrepareForResume: function(id) {\n            var state = handler._getFileState(id),\n                localStorageId, persistedData;\n\n            // Resume is enabled and possible and this is the first time we've tried to upload this file in this session,\n            // so prepare for a resume attempt.\n            if (resumeEnabled && state.key === undefined) {\n                localStorageId = handler._getLocalStorageId(id);\n                persistedData = localStorage.getItem(localStorageId);\n\n                // If we found this item in local storage, maybe we should resume it.\n                if (persistedData) {\n                    persistedData = JSON.parse(persistedData);\n\n                    // If we found a resume record but we have already handled this file in this session,\n                    // don't try to resume it & ensure we don't persist future check data\n                    if (getDataByUuid(persistedData.uuid)) {\n                        handler._markNotResumable(id);\n                    }\n                    else {\n                        log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n\n                        onUuidChanged(id, persistedData.uuid);\n\n                        state.key = persistedData.key;\n                        state.chunking = persistedData.chunking;\n                        state.loaded = persistedData.loaded;\n                        state.customResumeData = persistedData.customResumeData;\n                        state.attemptingResume = true;\n\n                        handler.moveInProgressToRemaining(id);\n                    }\n                }\n            }\n        },\n\n        // Persist any data needed to resume this upload in a new session.\n        _maybePersistChunkedState: function(id) {\n            var state = handler._getFileState(id),\n                localStorageId, persistedData;\n\n            // If local storage isn't supported by the browser, or if resume isn't enabled or possible, give up\n            if (resumeEnabled && handler.isResumable(id)) {\n                var customResumeData = getCustomResumeData(id);\n\n                localStorageId = handler._getLocalStorageId(id);\n\n                persistedData = {\n                    name: getName(id),\n                    size: getSize(id),\n                    uuid: getUuid(id),\n                    key: state.key,\n                    chunking: state.chunking,\n                    loaded: state.loaded,\n                    lastUpdated: Date.now(),\n                };\n\n                if (customResumeData) {\n                    persistedData.customResumeData = customResumeData;\n                }\n\n                try {\n                    localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                }\n                catch (error) {\n                    log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                }\n            }\n        },\n\n        _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n            var xhr = handler._getXhr(id, chunkIdx),\n                name = getName(id),\n                progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        }\n                        else {\n                            onProgress(id, name, (loaded >= fileSize ? fileSize - 1 : loaded), fileSize);\n                        }\n                    },\n\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress,\n                            totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded,\n                            loadedForRequest = loaded,\n                            totalForRequest = total,\n                            totalFileSize = getSize(id),\n                            estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize),\n                            totalLoadedForFile = totalSuccessfullyLoadedForFile;\n\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n\n            xhr.upload.onprogress = function(e) {\n                if (e.lengthComputable) {\n                    /* jshint eqnull: true */\n                    var type = chunkSize == null ? \"simple\" : \"chunked\";\n                    progressCalculator[type](e.loaded, e.total);\n                }\n            };\n        },\n\n        /**\n         * Registers an XHR transport instance created elsewhere.\n         *\n         * @param id ID of the associated file\n         * @param optChunkIdx The chunk index associated with this XHR, if applicable\n         * @param xhr XMLHttpRequest object instance\n         * @param optAjaxRequester `qq.AjaxRequester` associated with this request, if applicable.\n         * @returns {XMLHttpRequest}\n         */\n        _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n            var xhrsId = optChunkIdx == null ? -1 : optChunkIdx,\n                tempState = handler._getFileState(id).temp;\n\n            tempState.xhrs = tempState.xhrs || {};\n            tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n\n            tempState.xhrs[xhrsId] = xhr;\n\n            if (optAjaxRequester) {\n                tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n            }\n\n            return xhr;\n        },\n\n        // Deletes any local storage records that are \"expired\".\n        _removeExpiredChunkingRecords: function() {\n            var expirationDays = resume.recordsExpireIn;\n\n            handler._iterateResumeRecords(function(key, uploadData) {\n                var expirationDate = new Date(uploadData.lastUpdated);\n\n                // transform updated date into expiration date\n                expirationDate.setDate(expirationDate.getDate() + expirationDays);\n\n                if (expirationDate.getTime() <= Date.now()) {\n                    log(\"Removing expired resume record with key \" + key);\n                    localStorage.removeItem(key);\n                }\n            });\n        },\n\n        /**\n         * Determine if the associated file should be chunked.\n         *\n         * @param id ID of the associated file\n         * @returns {*} true if chunking is enabled, possible, and the file can be split into more than 1 part\n         */\n        _shouldChunkThisFile: function(id) {\n            var state = handler._getFileState(id);\n\n            // file may no longer be available if it was recently cancelled\n            if (state) {\n                if (!state.chunking) {\n                    handler.reevaluateChunking(id);\n                }\n\n                return state.chunking.enabled;\n            }\n        }\n    });\n};\n","/*globals qq, XMLHttpRequest*/\nqq.DeleteFileAjaxRequester = function(o) {\n    \"use strict\";\n\n    var requester,\n        options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {return {};},\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n\n    qq.extend(options, o);\n\n    function getMandatedParams() {\n        if (options.method.toUpperCase() === \"POST\") {\n            return {\n                _method: \"DELETE\"\n            };\n        }\n\n        return {};\n    }\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n        acceptHeader: \"application/json\",\n        validMethods: [\"POST\", \"DELETE\"],\n        method: options.method,\n        endpointStore: options.endpointStore,\n        paramsStore: options.paramsStore,\n        mandatedParams: getMandatedParams(),\n        maxConnections: options.maxConnections,\n        customHeaders: function(id) {\n            return options.customHeaders.get(id);\n        },\n        log: options.log,\n        onSend: options.onDelete,\n        onComplete: options.onDeleteComplete,\n        cors: options.cors\n    }));\n\n    qq.extend(this, {\n        sendDelete: function(id, uuid, additionalMandatedParams) {\n            var additionalOptions = additionalMandatedParams || {};\n\n            options.log(\"Submitting delete file request for \" + id);\n\n            if (options.method === \"DELETE\") {\n                requester.initTransport(id)\n                    .withPath(uuid)\n                    .withParams(additionalOptions)\n                    .send();\n            }\n            else {\n                additionalOptions[options.uuidParamName] = uuid;\n                requester.initTransport(id)\n                    .withParams(additionalOptions)\n                    .send();\n            }\n        }\n    });\n};\n","/*global qq, define */\n/*jshint strict:false,bitwise:false,nonew:false,asi:true,-W064,-W116,-W089 */\n/**\n * Mega pixel image rendering library for iOS6+\n *\n * Fixes iOS6+'s image file rendering issue for large size image (over mega-pixel),\n * which causes unexpected subsampling when drawing it in canvas.\n * By using this library, you can safely render the image with proper stretching.\n *\n * Copyright (c) 2012 Shinichi Tomita <shinichi.tomita@gmail.com>\n * Released under the MIT license\n *\n * Heavily modified by Widen for Fine Uploader\n */\n(function() {\n\n    /**\n     * Detect subsampling in loaded image.\n     * In iOS, larger images than 2M pixels may be subsampled in rendering.\n     */\n    function detectSubsampling(img) {\n        var iw = img.naturalWidth,\n            ih = img.naturalHeight,\n            canvas = document.createElement(\"canvas\"),\n            ctx;\n\n        if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image\n            canvas.width = canvas.height = 1;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, -iw + 1, 0);\n            // subsampled image becomes half smaller in rendering size.\n            // check alpha channel value to confirm image is covering edge pixel or not.\n            // if alpha value is 0 image is not covering, hence subsampled.\n            return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Detecting vertical squash in loaded image.\n     * Fixes a bug which squash image vertically while drawing into canvas for some images.\n     */\n    function detectVerticalSquash(img, iw, ih) {\n        var canvas = document.createElement(\"canvas\"),\n            sy = 0,\n            ey = ih,\n            py = ih,\n            ctx, data, alpha, ratio;\n\n        canvas.width = 1;\n        canvas.height = ih;\n        ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0);\n        data = ctx.getImageData(0, 0, 1, ih).data;\n\n        // search image edge pixel position in case it is squashed vertically.\n        while (py > sy) {\n            alpha = data[(py - 1) * 4 + 3];\n            if (alpha === 0) {\n                ey = py;\n            } else {\n                sy = py;\n            }\n            py = (ey + sy) >> 1;\n        }\n\n        ratio = (py / ih);\n        return (ratio === 0) ? 1 : ratio;\n    }\n\n    /**\n     * Rendering image element (with resizing) and get its data URL\n     */\n    function renderImageToDataURL(img, blob, options, doSquash) {\n        var canvas = document.createElement(\"canvas\"),\n            mime = options.mime || \"image/jpeg\",\n            promise = new qq.Promise();\n\n        renderImageToCanvas(img, blob, canvas, options, doSquash)\n            .then(function() {\n                promise.success(\n                    canvas.toDataURL(mime, options.quality || 0.8)\n                );\n            });\n\n        return promise;\n    }\n\n    function maybeCalculateDownsampledDimensions(spec) {\n        var maxPixels = 5241000; //iOS specific value\n\n        if (!qq.ios()) {\n            throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n        }\n\n        if (spec.origHeight * spec.origWidth > maxPixels) {\n            return {\n                newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n            };\n        }\n    }\n\n    /**\n     * Rendering image element (with resizing) into the canvas element\n     */\n    function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n        var iw = img.naturalWidth,\n            ih = img.naturalHeight,\n            width = options.width,\n            height = options.height,\n            ctx = canvas.getContext(\"2d\"),\n            promise = new qq.Promise(),\n            modifiedDimensions;\n\n        ctx.save();\n\n        if (options.resize) {\n            return renderImageToCanvasWithCustomResizer({\n                blob: blob,\n                canvas: canvas,\n                image: img,\n                imageHeight: ih,\n                imageWidth: iw,\n                orientation: options.orientation,\n                resize: options.resize,\n                targetHeight: height,\n                targetWidth: width\n            });\n        }\n\n        if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n            modifiedDimensions = maybeCalculateDownsampledDimensions({\n                origWidth: width,\n                origHeight: height\n            });\n\n            if (modifiedDimensions) {\n                qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\",\n                    width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight),\n                    \"warn\");\n\n                width = modifiedDimensions.newWidth;\n                height = modifiedDimensions.newHeight;\n            }\n        }\n\n        transformCoordinate(canvas, width, height, options.orientation);\n\n        // Fine Uploader specific: Save some CPU cycles if not using iOS\n        // Assumption: This logic is only needed to overcome iOS image sampling issues\n        if (qq.ios()) {\n            (function() {\n                if (detectSubsampling(img)) {\n                    iw /= 2;\n                    ih /= 2;\n                }\n\n                var d = 1024, // size of tiling canvas\n                    tmpCanvas = document.createElement(\"canvas\"),\n                    vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1,\n                    dw = Math.ceil(d * width / iw),\n                    dh = Math.ceil(d * height / ih / vertSquashRatio),\n                    sy = 0,\n                    dy = 0,\n                    tmpCtx, sx, dx;\n\n                tmpCanvas.width = tmpCanvas.height = d;\n                tmpCtx = tmpCanvas.getContext(\"2d\");\n\n                while (sy < ih) {\n                    sx = 0;\n                    dx = 0;\n                    while (sx < iw) {\n                        tmpCtx.clearRect(0, 0, d, d);\n                        tmpCtx.drawImage(img, -sx, -sy);\n                        ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                        sx += d;\n                        dx += dw;\n                    }\n                    sy += d;\n                    dy += dh;\n                }\n                ctx.restore();\n                tmpCanvas = tmpCtx = null;\n            }());\n        }\n        else {\n            ctx.drawImage(img, 0, 0, width, height);\n        }\n\n        canvas.qqImageRendered && canvas.qqImageRendered();\n        promise.success();\n\n        return promise;\n    }\n\n    function renderImageToCanvasWithCustomResizer(resizeInfo) {\n        var blob = resizeInfo.blob,\n            image = resizeInfo.image,\n            imageHeight = resizeInfo.imageHeight,\n            imageWidth = resizeInfo.imageWidth,\n            orientation = resizeInfo.orientation,\n            promise = new qq.Promise(),\n            resize = resizeInfo.resize,\n            sourceCanvas = document.createElement(\"canvas\"),\n            sourceCanvasContext = sourceCanvas.getContext(\"2d\"),\n            targetCanvas = resizeInfo.canvas,\n            targetHeight = resizeInfo.targetHeight,\n            targetWidth = resizeInfo.targetWidth;\n\n        transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n\n        targetCanvas.height = targetHeight;\n        targetCanvas.width = targetWidth;\n\n        sourceCanvasContext.drawImage(image, 0, 0);\n\n        resize({\n            blob: blob,\n            height: targetHeight,\n            image: image,\n            sourceCanvas: sourceCanvas,\n            targetCanvas: targetCanvas,\n            width: targetWidth\n        })\n            .then(\n                function success() {\n                    targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                    promise.success();\n                },\n                promise.failure\n            );\n\n        return promise;\n    }\n\n    /**\n     * Transform canvas coordination according to specified frame size and orientation\n     * Orientation value is from EXIF tag\n     */\n    function transformCoordinate(canvas, width, height, orientation) {\n        switch (orientation) {\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n            default:\n                canvas.width = width;\n                canvas.height = height;\n        }\n        var ctx = canvas.getContext(\"2d\");\n        switch (orientation) {\n            case 2:\n                // horizontal flip\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n            case 3:\n                // 180 rotate left\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n            case 4:\n                // vertical flip\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n            case 5:\n                // vertical flip + 90 rotate right\n                ctx.rotate(0.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n            case 6:\n                // 90 rotate right\n                ctx.rotate(0.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n            case 7:\n                // horizontal flip + 90 rotate right\n                ctx.rotate(0.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n            case 8:\n                // 90 rotate left\n                ctx.rotate(-0.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * MegaPixImage class\n     */\n    function MegaPixImage(srcImage, errorCallback) {\n        var self = this;\n\n        if (window.Blob && srcImage instanceof Blob) {\n            (function() {\n                var img = new Image(),\n                    URL = window.URL && window.URL.createObjectURL ? window.URL :\n                        window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (!URL) { throw Error(\"No createObjectURL function found to create blob url\"); }\n                img.src = URL.createObjectURL(srcImage);\n                self.blob = srcImage;\n                srcImage = img;\n            }());\n        }\n        if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n            srcImage.onload = function() {\n                var listeners = self.imageLoadListeners;\n                if (listeners) {\n                    self.imageLoadListeners = null;\n                    // IE11 doesn't reliably report actual image dimensions immediately after onload for small files,\n                    // so let's push this to the end of the UI thread queue.\n                    setTimeout(function() {\n                        for (var i = 0, len = listeners.length; i < len; i++) {\n                            listeners[i]();\n                        }\n                    }, 0);\n                }\n            };\n            srcImage.onerror = errorCallback;\n            this.imageLoadListeners = [];\n        }\n        this.srcImage = srcImage;\n    }\n\n    /**\n     * Rendering megapix image into specified target element\n     */\n    MegaPixImage.prototype.render = function(target, options) {\n        options = options || {};\n\n        var self = this,\n            imgWidth = this.srcImage.naturalWidth,\n            imgHeight = this.srcImage.naturalHeight,\n            width = options.width,\n            height = options.height,\n            maxWidth = options.maxWidth,\n            maxHeight = options.maxHeight,\n            doSquash = !this.blob || this.blob.type === \"image/jpeg\",\n            tagName = target.tagName.toLowerCase(),\n            opt;\n\n        if (this.imageLoadListeners) {\n            this.imageLoadListeners.push(function() { self.render(target, options); });\n            return;\n        }\n\n        if (width && !height) {\n            height = (imgHeight * width / imgWidth) << 0;\n        } else if (height && !width) {\n            width = (imgWidth * height / imgHeight) << 0;\n        } else {\n            width = imgWidth;\n            height = imgHeight;\n        }\n        if (maxWidth && width > maxWidth) {\n            width = maxWidth;\n            height = (imgHeight * width / imgWidth) << 0;\n        }\n        if (maxHeight && height > maxHeight) {\n            height = maxHeight;\n            width = (imgWidth * height / imgHeight) << 0;\n        }\n\n        opt = { width: width, height: height },\n        qq.each(options, function(optionsKey, optionsValue) {\n            opt[optionsKey] = optionsValue;\n        });\n\n        if (tagName === \"img\") {\n            (function() {\n                var oldTargetSrc = target.src;\n                renderImageToDataURL(self.srcImage, self.blob, opt, doSquash)\n                    .then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n            }());\n        } else if (tagName === \"canvas\") {\n            renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n        }\n        if (typeof this.onrender === \"function\") {\n            this.onrender(target);\n        }\n    };\n\n    qq.MegaPixImage = MegaPixImage;\n})();\n","/*globals qq */\n/**\n * Draws a thumbnail of a Blob/File/URL onto an <img> or <canvas>.\n *\n * @constructor\n */\nqq.ImageGenerator = function(log) {\n    \"use strict\";\n\n    function isImg(el) {\n        return el.tagName.toLowerCase() === \"img\";\n    }\n\n    function isCanvas(el) {\n        return el.tagName.toLowerCase() === \"canvas\";\n    }\n\n    function isImgCorsSupported() {\n        return new Image().crossOrigin !== undefined;\n    }\n\n    function isCanvasSupported() {\n        var canvas = document.createElement(\"canvas\");\n\n        return canvas.getContext && canvas.getContext(\"2d\");\n    }\n\n    // This is only meant to determine the MIME type of a renderable image file.\n    // It is used to ensure images drawn from a URL that have transparent backgrounds\n    // are rendered correctly, among other things.\n    function determineMimeOfFileName(nameWithPath) {\n        /*jshint -W015 */\n        var pathSegments = nameWithPath.split(\"/\"),\n            name = pathSegments[pathSegments.length - 1].split(\"?\")[0],\n            extension = qq.getExtension(name);\n\n        extension = extension && extension.toLowerCase();\n\n        switch (extension) {\n            case \"jpeg\":\n            case \"jpg\":\n                return \"image/jpeg\";\n            case \"png\":\n                return \"image/png\";\n            case \"bmp\":\n                return \"image/bmp\";\n            case \"gif\":\n                return \"image/gif\";\n            case \"tiff\":\n            case \"tif\":\n                return \"image/tiff\";\n        }\n    }\n\n    // This will likely not work correctly in IE8 and older.\n    // It's only used as part of a formula to determine\n    // if a canvas can be used to scale a server-hosted thumbnail.\n    // If canvas isn't supported by the UA (IE8 and older)\n    // this method should not even be called.\n    function isCrossOrigin(url) {\n        var targetAnchor = document.createElement(\"a\"),\n            targetProtocol, targetHostname, targetPort;\n\n        targetAnchor.href = url;\n\n        targetProtocol = targetAnchor.protocol;\n        targetPort = targetAnchor.port;\n        targetHostname = targetAnchor.hostname;\n\n        if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n            return true;\n        }\n\n        if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n            return true;\n        }\n\n        // IE doesn't take ports into consideration when determining if two endpoints are same origin.\n        if (targetPort !== window.location.port && !qq.ie()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function registerImgLoadListeners(img, promise) {\n        img.onload = function() {\n            img.onload = null;\n            img.onerror = null;\n            promise.success(img);\n        };\n\n        img.onerror = function() {\n            img.onload = null;\n            img.onerror = null;\n            log(\"Problem drawing thumbnail!\", \"error\");\n            promise.failure(img, \"Problem drawing thumbnail!\");\n        };\n    }\n\n    function registerCanvasDrawImageListener(canvas, promise) {\n        // The image is drawn on the canvas by a third-party library,\n        // and we want to know when this is completed.  Since the library\n        // may invoke drawImage many times in a loop, we need to be called\n        // back when the image is fully rendered.  So, we are expecting the\n        // code that draws this image to follow a convention that involves a\n        // function attached to the canvas instance be invoked when it is done.\n        canvas.qqImageRendered = function() {\n            promise.success(canvas);\n        };\n    }\n\n    // Fulfills a `qq.Promise` when an image has been drawn onto the target,\n    // whether that is a <canvas> or an <img>.  The attempt is considered a\n    // failure if the target is not an <img> or a <canvas>, or if the drawing\n    // attempt was not successful.\n    function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n        var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n\n        if (isImg(imgOrCanvas)) {\n            registerImgLoadListeners(imgOrCanvas, promise);\n        }\n        else if (isCanvas(imgOrCanvas)) {\n            registerCanvasDrawImageListener(imgOrCanvas, promise);\n        }\n        else {\n            promise.failure(imgOrCanvas);\n            log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n        }\n\n        return registered;\n    }\n\n    // Draw a preview iff the current UA can natively display it.\n    // Also rotate the image if necessary.\n    function draw(fileOrBlob, container, options) {\n        var drawPreview = new qq.Promise(),\n            identifier = new qq.Identify(fileOrBlob, log),\n            maxSize = options.maxSize,\n            // jshint eqnull:true\n            orient = options.orient == null ? true : options.orient,\n            megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n\n        identifier.isPreviewable().then(\n            function(mime) {\n                // If options explicitly specify that Orientation is not desired,\n                // replace the orient task with a dummy promise that \"succeeds\" immediately.\n                var dummyExif = {\n                        parse: function() {\n                            return new qq.Promise().success();\n                        }\n                    },\n                    exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif,\n                    mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(\n                        function(exif) {\n                            var orientation = exif && exif.Orientation;\n\n                            mpImg.render(container, {\n                                maxWidth: maxSize,\n                                maxHeight: maxSize,\n                                orientation: orientation,\n                                mime: mime,\n                                resize: options.customResizeFunction\n                            });\n                        },\n\n                        function(failureMsg) {\n                            log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n\n                            mpImg.render(container, {\n                                maxWidth: maxSize,\n                                maxHeight: maxSize,\n                                mime: mime,\n                                resize: options.customResizeFunction\n                            });\n                        }\n                    );\n                }\n            },\n\n            function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            }\n        );\n\n        return drawPreview;\n    }\n\n    function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n        var tempImg = new Image(),\n            tempImgRender = new qq.Promise();\n\n        registerThumbnailRenderedListener(tempImg, tempImgRender);\n\n        if (isCrossOrigin(url)) {\n            tempImg.crossOrigin = \"anonymous\";\n        }\n\n        tempImg.src = url;\n\n        tempImgRender.then(\n            function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            },\n\n            draw.failure\n        );\n    }\n\n    function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n        registerThumbnailRenderedListener(img, draw);\n        // NOTE: The fact that maxWidth/height is set on the thumbnail for scaled images\n        // that must drop back to CSS is known and exploited by the templating module.\n        // In this module, we pre-render \"waiting\" thumbs for all files immediately after they\n        // are submitted, and we must be sure to pass any style associated with the \"waiting\" preview.\n        qq(img).css({\n            maxWidth: maxSize + \"px\",\n            maxHeight: maxSize + \"px\"\n        });\n\n        img.src = url;\n    }\n\n    // Draw a (server-hosted) thumbnail given a URL.\n    // This will optionally scale the thumbnail as well.\n    // It attempts to use <canvas> to scale, but will fall back\n    // to max-width and max-height style properties if the UA\n    // doesn't support canvas or if the images is cross-domain and\n    // the UA doesn't support the crossorigin attribute on img tags,\n    // which is required to scale a cross-origin image using <canvas> &\n    // then export it back to an <img>.\n    function drawFromUrl(url, container, options) {\n        var draw = new qq.Promise(),\n            scale = options.scale,\n            maxSize = scale ? options.maxSize : null;\n\n        // container is an img, scaling needed\n        if (scale && isImg(container)) {\n            // Iff canvas is available in this UA, try to use it for scaling.\n            // Otherwise, fall back to CSS scaling\n            if (isCanvasSupported()) {\n                // Attempt to use <canvas> for image scaling,\n                // but we must fall back to scaling via CSS/styles\n                // if this is a cross-origin image and the UA doesn't support <img> CORS.\n                if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n                else {\n                    drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                }\n            }\n            else {\n                drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n            }\n        }\n        // container is a canvas, scaling optional\n        else if (isCanvas(container)) {\n            drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n        }\n        // container is an img & no scaling: just set the src attr to the passed url\n        else if (registerThumbnailRenderedListener(container, draw)) {\n            container.src = url;\n        }\n\n        return draw;\n    }\n\n    qq.extend(this, {\n        /**\n         * Generate a thumbnail.  Depending on the arguments, this may either result in\n         * a client-side rendering of an image (if a `Blob` is supplied) or a server-generated\n         * image that may optionally be scaled client-side using <canvas> or CSS/styles (as a fallback).\n         *\n         * @param fileBlobOrUrl a `File`, `Blob`, or a URL pointing to the image\n         * @param container <img> or <canvas> to contain the preview\n         * @param options possible properties include `maxSize` (int), `orient` (bool - default true), resize` (bool - default true), and `customResizeFunction`.\n         * @returns qq.Promise fulfilled when the preview has been drawn, or the attempt has failed\n         */\n        generate: function(fileBlobOrUrl, container, options) {\n            if (qq.isString(fileBlobOrUrl)) {\n                log(\"Attempting to update thumbnail based on server response.\");\n                return drawFromUrl(fileBlobOrUrl, container, options || {});\n            }\n            else {\n                log(\"Attempting to draw client-side image preview.\");\n                return draw(fileBlobOrUrl, container, options || {});\n            }\n        }\n    });\n\n    /*<testing>*/\n    this._testing = {};\n    this._testing.isImg = isImg;\n    this._testing.isCanvas = isCanvas;\n    this._testing.isCrossOrigin = isCrossOrigin;\n    this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    /*</testing>*/\n};\n","/*globals qq */\n/**\n * EXIF image data parser.  Currently only parses the Orientation tag value,\n * but this may be expanded to other tags in the future.\n *\n * @param fileOrBlob Attempt to parse EXIF data in this `Blob`\n * @constructor\n */\nqq.Exif = function(fileOrBlob, log) {\n    \"use strict\";\n\n    // Orientation is the only tag parsed here at this time.\n    var TAG_IDS = [274],\n        TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n\n    // Convert a little endian (hex string) to big endian (decimal).\n    function parseLittleEndian(hex) {\n        var result = 0,\n            pow = 0;\n\n        while (hex.length > 0) {\n            result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n            hex = hex.substring(2, hex.length);\n            pow += 8;\n        }\n\n        return result;\n    }\n\n    // Find the byte offset, of Application Segment 1 (EXIF).\n    // External callers need not supply any arguments.\n    function seekToApp1(offset, promise) {\n        var theOffset = offset,\n            thePromise = promise;\n        if (theOffset === undefined) {\n            theOffset = 2;\n            thePromise = new qq.Promise();\n        }\n\n        qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n            var match = /^ffe([0-9])/.exec(hex),\n                segmentLength;\n\n            if (match) {\n                if (match[1] !== \"1\") {\n                    segmentLength = parseInt(hex.slice(4, 8), 16);\n                    seekToApp1(theOffset + segmentLength + 2, thePromise);\n                }\n                else {\n                    thePromise.success(theOffset);\n                }\n            }\n            else {\n                thePromise.failure(\"No EXIF header to be found!\");\n            }\n        });\n\n        return thePromise;\n    }\n\n    // Find the byte offset of Application Segment 1 (EXIF) for valid JPEGs only.\n    function getApp1Offset() {\n        var promise = new qq.Promise();\n\n        qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n            if (hex.indexOf(\"ffd8\") !== 0) {\n                promise.failure(\"Not a valid JPEG!\");\n            }\n            else {\n                seekToApp1().then(function(offset) {\n                    promise.success(offset);\n                },\n                function(error) {\n                    promise.failure(error);\n                });\n            }\n        });\n\n        return promise;\n    }\n\n    // Determine the byte ordering of the EXIF header.\n    function isLittleEndian(app1Start) {\n        var promise = new qq.Promise();\n\n        qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n            promise.success(hex === \"4949\");\n        });\n\n        return promise;\n    }\n\n    // Determine the number of directory entries in the EXIF header.\n    function getDirEntryCount(app1Start, littleEndian) {\n        var promise = new qq.Promise();\n\n        qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n            if (littleEndian) {\n                return promise.success(parseLittleEndian(hex));\n            }\n            else {\n                promise.success(parseInt(hex, 16));\n            }\n        });\n\n        return promise;\n    }\n\n    // Get the IFD portion of the EXIF header as a hex string.\n    function getIfd(app1Start, dirEntries) {\n        var offset = app1Start + 20,\n            bytes = dirEntries * 12;\n\n        return qq.readBlobToHex(fileOrBlob, offset, bytes);\n    }\n\n    // Obtain an array of all directory entries (as hex strings) in the EXIF header.\n    function getDirEntries(ifdHex) {\n        var entries = [],\n            offset = 0;\n\n        while (offset + 24 <= ifdHex.length) {\n            entries.push(ifdHex.slice(offset, offset + 24));\n            offset += 24;\n        }\n\n        return entries;\n    }\n\n    // Obtain values for all relevant tags and return them.\n    function getTagValues(littleEndian, dirEntries) {\n        var TAG_VAL_OFFSET = 16,\n            tagsToFind = qq.extend([], TAG_IDS),\n            vals = {};\n\n        qq.each(dirEntries, function(idx, entry) {\n            var idHex = entry.slice(0, 4),\n                id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16),\n                tagsToFindIdx = tagsToFind.indexOf(id),\n                tagValHex, tagName, tagValLength;\n\n            if (tagsToFindIdx >= 0) {\n                tagName = TAG_INFO[id].name;\n                tagValLength = TAG_INFO[id].bytes;\n                tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + (tagValLength * 2));\n                vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n\n                tagsToFind.splice(tagsToFindIdx, 1);\n            }\n\n            if (tagsToFind.length === 0) {\n                return false;\n            }\n        });\n\n        return vals;\n    }\n\n    qq.extend(this, {\n        /**\n         * Attempt to parse the EXIF header for the `Blob` associated with this instance.\n         *\n         * @returns {qq.Promise} To be fulfilled when the parsing is complete.\n         * If successful, the parsed EXIF header as an object will be included.\n         */\n        parse: function() {\n            var parser = new qq.Promise(),\n                onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n\n            getApp1Offset().then(function(app1Offset) {\n                log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n\n                isLittleEndian(app1Offset).then(function(littleEndian) {\n\n                    log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n\n                    getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n\n                        log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n\n                        getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                            var dirEntries = getDirEntries(ifdHex),\n                                tagValues = getTagValues(littleEndian, dirEntries);\n\n                            log(\"Successfully parsed some EXIF tags\");\n\n                            parser.success(tagValues);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n            }, onParseFailure);\n\n            return parser;\n        }\n    });\n\n    /*<testing>*/\n    this._testing = {};\n    this._testing.parseLittleEndian = parseLittleEndian;\n    /*</testing>*/\n};\n","/*globals qq */\nqq.Identify = function(fileOrBlob, log) {\n    \"use strict\";\n\n    function isIdentifiable(magicBytes, questionableBytes) {\n        var identifiable = false,\n            magicBytesEntries = [].concat(magicBytes);\n\n        qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n            if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                identifiable = true;\n                return false;\n            }\n        });\n\n        return identifiable;\n    }\n\n    qq.extend(this, {\n        /**\n         * Determines if a Blob can be displayed natively in the current browser.  This is done by reading magic\n         * bytes in the beginning of the file, so this is an asynchronous operation.  Before we attempt to read the\n         * file, we will examine the blob's type attribute to save CPU cycles.\n         *\n         * @returns {qq.Promise} Promise that is fulfilled when identification is complete.\n         * If successful, the MIME string is passed to the success handler.\n         */\n        isPreviewable: function() {\n            var self = this,\n                identifier = new qq.Promise(),\n                previewable = false,\n                name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\n            log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n\n            log(\"First pass: check type attribute of blob object.\");\n\n            if (this.isPreviewableSync()) {\n                log(\"Second pass: check for magic bytes in file header.\");\n\n                qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                    qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                        if (isIdentifiable(bytes, hex)) {\n                            // Safari is the only supported browser that can deal with TIFFs natively,\n                            // so, if this is a TIFF and the UA isn't Safari, declare this file \"non-previewable\".\n                            if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                previewable = true;\n                                identifier.success(mime);\n                            }\n\n                            return false;\n                        }\n                    });\n\n                    log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n\n                    if (!previewable) {\n                        identifier.failure();\n                    }\n                },\n                function() {\n                    log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                    identifier.failure();\n                });\n            }\n            else {\n                identifier.failure();\n            }\n\n            return identifier;\n        },\n\n        /**\n         * Determines if a Blob can be displayed natively in the current browser.  This is done by checking the\n         * blob's type attribute.  This is a synchronous operation, useful for situations where an asynchronous operation\n         * would be challenging to support.  Note that the blob's type property is not as accurate as reading the\n         * file's magic bytes.\n         *\n         * @returns {Boolean} true if the blob can be rendered in the current browser\n         */\n        isPreviewableSync: function() {\n            var fileMime = fileOrBlob.type,\n                // Assumption: This will only ever be executed in browsers that support `Object.keys`.\n                isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0,\n                previewable = false,\n                name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n\n            if (isRecognizedImage) {\n                if (fileMime === \"image/tiff\") {\n                    previewable = qq.supportedFeatures.tiffPreviews;\n                }\n                else {\n                    previewable = true;\n                }\n            }\n\n            !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n\n            return previewable;\n        }\n    });\n};\n\nqq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n    \"image/jpeg\": \"ffd8ff\",\n    \"image/gif\": \"474946\",\n    \"image/png\": \"89504e\",\n    \"image/bmp\": \"424d\",\n    \"image/tiff\": [\"49492a00\", \"4d4d002a\"]\n};\n","/*globals qq*/\n/**\n * Attempts to validate an image, wherever possible.\n *\n * @param blob File or Blob representing a user-selecting image.\n * @param log Uses this to post log messages to the console.\n * @constructor\n */\nqq.ImageValidation = function(blob, log) {\n    \"use strict\";\n\n    /**\n     * @param limits Object with possible image-related limits to enforce.\n     * @returns {boolean} true if at least one of the limits has a non-zero value\n     */\n    function hasNonZeroLimits(limits) {\n        var atLeastOne = false;\n\n        qq.each(limits, function(limit, value) {\n            if (value > 0) {\n                atLeastOne = true;\n                return false;\n            }\n        });\n\n        return atLeastOne;\n    }\n\n    /**\n     * @returns {qq.Promise} The promise is a failure if we can't obtain the width & height.\n     * Otherwise, `success` is called on the returned promise with an object containing\n     * `width` and `height` properties.\n     */\n    function getWidthHeight() {\n        var sizeDetermination = new qq.Promise();\n\n        new qq.Identify(blob, log).isPreviewable().then(function() {\n            var image = new Image(),\n                url = window.URL && window.URL.createObjectURL ? window.URL :\n                      window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL :\n                      null;\n\n            if (url) {\n                image.onerror = function() {\n                    log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                    sizeDetermination.failure();\n                };\n\n                image.onload = function() {\n                    sizeDetermination.success({\n                        width: this.width,\n                        height: this.height\n                    });\n                };\n\n                image.src = url.createObjectURL(blob);\n            }\n            else {\n                log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                sizeDetermination.failure();\n            }\n        }, sizeDetermination.failure);\n\n        return sizeDetermination;\n    }\n\n    /**\n     *\n     * @param limits Object with possible image-related limits to enforce.\n     * @param dimensions Object containing `width` & `height` properties for the image to test.\n     * @returns {String || undefined} The name of the failing limit.  Undefined if no failing limits.\n     */\n    function getFailingLimit(limits, dimensions) {\n        var failingLimit;\n\n        qq.each(limits, function(limitName, limitValue) {\n            if (limitValue > 0) {\n                var limitMatcher = /(max|min)(Width|Height)/.exec(limitName),\n                    dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1),\n                    actualValue = dimensions[dimensionPropName];\n\n                /*jshint -W015*/\n                switch (limitMatcher[1]) {\n                    case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                }\n            }\n        });\n\n        return failingLimit;\n    }\n\n    /**\n     * Validate the associated blob.\n     *\n     * @param limits\n     * @returns {qq.Promise} `success` is called on the promise is the image is valid or\n     * if the blob is not an image, or if the image is not verifiable.\n     * Otherwise, `failure` with the name of the failing limit.\n     */\n    this.validate = function(limits) {\n        var validationEffort = new qq.Promise();\n\n        log(\"Attempting to validate image.\");\n\n        if (hasNonZeroLimits(limits)) {\n            getWidthHeight().then(function(dimensions) {\n                var failingLimit = getFailingLimit(limits, dimensions);\n\n                if (failingLimit) {\n                    validationEffort.failure(failingLimit);\n                }\n                else {\n                    validationEffort.success();\n                }\n            }, validationEffort.success);\n        }\n        else {\n            validationEffort.success();\n        }\n\n        return validationEffort;\n    };\n};\n","/* globals qq */\n/**\n * Module used to control populating the initial list of files.\n *\n * @constructor\n */\nqq.Session = function(spec) {\n    \"use strict\";\n\n    var options = {\n        endpoint: null,\n        params: {},\n        customHeaders: {},\n        cors: {},\n        addFileRecord: function(sessionData) {},\n        log: function(message, level) {}\n    };\n\n    qq.extend(options, spec, true);\n\n    function isJsonResponseValid(response) {\n        if (qq.isArray(response)) {\n            return true;\n        }\n\n        options.log(\"Session response is not an array.\", \"error\");\n    }\n\n    function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n        var someItemsIgnored = false;\n\n        success = success && isJsonResponseValid(fileItems);\n\n        if (success) {\n            qq.each(fileItems, function(idx, fileItem) {\n                /* jshint eqnull:true */\n                if (fileItem.uuid == null) {\n                    someItemsIgnored = true;\n                    options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                }\n                else if (fileItem.name == null) {\n                    someItemsIgnored = true;\n                    options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                }\n                else {\n                    try {\n                        options.addFileRecord(fileItem);\n                        return true;\n                    }\n                    catch (err) {\n                        someItemsIgnored = true;\n                        options.log(err.message, \"error\");\n                    }\n                }\n\n                return false;\n            });\n        }\n\n        promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n    }\n\n    // Initiate a call to the server that will be used to populate the initial file list.\n    // Returns a `qq.Promise`.\n    this.refresh = function() {\n        /*jshint indent:false */\n        var refreshEffort = new qq.Promise(),\n            refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            },\n            requesterOptions = qq.extend({}, options),\n            requester = new qq.SessionAjaxRequester(\n                qq.extend(requesterOptions, {onComplete: refreshCompleteCallback})\n            );\n\n        requester.queryServer();\n\n        return refreshEffort;\n    };\n};\n","/*globals qq, XMLHttpRequest*/\n/**\n * Thin module used to send GET requests to the server, expecting information about session\n * data used to initialize an uploader instance.\n *\n * @param spec Various options used to influence the associated request.\n * @constructor\n */\nqq.SessionAjaxRequester = function(spec) {\n    \"use strict\";\n\n    var requester,\n        options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n\n    qq.extend(options, spec);\n\n    function onComplete(id, xhrOrXdr, isError) {\n        var response = null;\n\n        /* jshint eqnull:true */\n        if (xhrOrXdr.responseText != null) {\n            try {\n                response = qq.parseJson(xhrOrXdr.responseText);\n            }\n            catch (err) {\n                options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                isError = true;\n            }\n        }\n\n        options.onComplete(response, !isError, xhrOrXdr);\n    }\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n        acceptHeader: \"application/json\",\n        validMethods: [\"GET\"],\n        method: \"GET\",\n        endpointStore: {\n            get: function() {\n                return options.endpoint;\n            }\n        },\n        customHeaders: options.customHeaders,\n        log: options.log,\n        onComplete: onComplete,\n        cors: options.cors\n    }));\n\n    qq.extend(this, {\n        queryServer: function() {\n            var params = qq.extend({}, options.params);\n\n            options.log(\"Session query request.\");\n\n            requester.initTransport(\"sessionRefresh\")\n                .withParams(params)\n                .withCacheBuster()\n                .send();\n        }\n    });\n};\n","/* globals qq, ExifRestorer */\n/**\n * Controls generation of scaled images based on a reference image encapsulated in a `File` or `Blob`.\n * Scaled images are generated and converted to blobs on-demand.\n * Multiple scaled images per reference image with varying sizes and other properties are supported.\n *\n * @param spec Information about the scaled images to generate.\n * @param log Logger instance\n * @constructor\n */\nqq.Scaler = function(spec, log) {\n    \"use strict\";\n\n    var self = this,\n        customResizeFunction = spec.customResizer,\n        includeOriginal = spec.sendOriginal,\n        orient = spec.orient,\n        defaultType = spec.defaultType,\n        defaultQuality = spec.defaultQuality / 100,\n        failedToScaleText = spec.failureText,\n        includeExif = spec.includeExif,\n        sizes = this._getSortedSizes(spec.sizes);\n\n    // Revealed API for instances of this module\n    qq.extend(this, {\n        // If no targeted sizes have been declared or if this browser doesn't support\n        // client-side image preview generation, there is no scaling to do.\n        enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n\n        getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n            var self = this,\n                records = [],\n                originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData,\n                identifier = new qq.Identify(originalBlob, log);\n\n            // If the reference file cannot be rendered natively, we can't create scaled versions.\n            if (identifier.isPreviewableSync()) {\n                // Create records for each scaled version & add them to the records array, smallest first.\n                qq.each(sizes, function(idx, sizeRecord) {\n                    var outputType = self._determineOutputType({\n                        defaultType: defaultType,\n                        requestedType: sizeRecord.type,\n                        refType: originalBlob.type\n                    });\n\n                    records.push({\n                        uuid: qq.getUniqueId(),\n                        name: self._getName(originalFileName, {\n                            name: sizeRecord.name,\n                            type: outputType,\n                            refType: originalBlob.type\n                        }),\n                        blob: new qq.BlobProxy(originalBlob,\n                        qq.bind(self._generateScaledImage, self, {\n                            customResizeFunction: customResizeFunction,\n                            maxSize: sizeRecord.maxSize,\n                            orient: orient,\n                            type: outputType,\n                            quality: defaultQuality,\n                            failedText: failedToScaleText,\n                            includeExif: includeExif,\n                            log: log\n                        }))\n                    });\n                });\n\n                records.push({\n                    uuid: originalFileUuid,\n                    name: originalFileName,\n                    size: originalBlob.size,\n                    blob: includeOriginal ? originalBlob : null\n                });\n            }\n            else {\n                records.push({\n                    uuid: originalFileUuid,\n                    name: originalFileName,\n                    size: originalBlob.size,\n                    blob: originalBlob\n                });\n            }\n\n            return records;\n        },\n\n        handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n            var self = this,\n                buttonId = file.qqButtonId || (file.blob && file.blob.qqButtonId),\n                scaledIds = [],\n                originalId = null,\n                addFileToHandler = api.addFileToHandler,\n                uploadData = api.uploadData,\n                paramsStore = api.paramsStore,\n                proxyGroupId = qq.getUniqueId();\n\n            qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                var blobSize = record.size,\n                    id;\n\n                if (record.blob instanceof qq.BlobProxy) {\n                    blobSize = -1;\n                }\n\n                id = uploadData.addFile({\n                    uuid: record.uuid,\n                    name: record.name,\n                    size: blobSize,\n                    batchId: batchId,\n                    proxyGroupId: proxyGroupId\n                });\n\n                if (record.blob instanceof qq.BlobProxy) {\n                    scaledIds.push(id);\n                }\n                else {\n                    originalId = id;\n                }\n\n                if (record.blob) {\n                    addFileToHandler(id, record.blob);\n                    fileList.push({id: id, file: record.blob});\n                }\n                else {\n                    uploadData.setStatus(id, qq.status.REJECTED);\n                }\n            });\n\n            // If we are potentially uploading an original file and some scaled versions,\n            // ensure the scaled versions include reference's to the parent's UUID and size\n            // in their associated upload requests.\n            if (originalId !== null) {\n                qq.each(scaledIds, function(idx, scaledId) {\n                    var params = {\n                        qqparentuuid: uploadData.retrieve({id: originalId}).uuid,\n                        qqparentsize: uploadData.retrieve({id: originalId}).size\n                    };\n\n                    // Make sure the UUID for each scaled image is sent with the upload request,\n                    // to be consistent (since we may need to ensure it is sent for the original file as well).\n                    params[uuidParamName] = uploadData.retrieve({id: scaledId}).uuid;\n\n                    uploadData.setParentId(scaledId, originalId);\n                    paramsStore.addReadOnly(scaledId, params);\n                });\n\n                // If any scaled images are tied to this parent image, be SURE we send its UUID as an upload request\n                // parameter as well.\n                if (scaledIds.length) {\n                    (function() {\n                        var param = {};\n                        param[uuidParamName] = uploadData.retrieve({id: originalId}).uuid;\n                        paramsStore.addReadOnly(originalId, param);\n                    }());\n                }\n            }\n        }\n    });\n};\n\nqq.extend(qq.Scaler.prototype, {\n    scaleImage: function(id, specs, api) {\n        \"use strict\";\n\n        if (!qq.supportedFeatures.scaling) {\n            throw new qq.Error(\"Scaling is not supported in this browser!\");\n        }\n\n        var scalingEffort = new qq.Promise(),\n            log = api.log,\n            file = api.getFile(id),\n            uploadData = api.uploadData.retrieve({id: id}),\n            name = uploadData && uploadData.name,\n            uuid = uploadData && uploadData.uuid,\n            scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [{name: \"\", maxSize: specs.maxSize}]\n            },\n            scaler = new qq.Scaler(scalingOptions, log);\n\n        if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n            scalingEffort.failure();\n\n            log(\"Could not generate requested scaled image for \" + id + \".  \" +\n                \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n        }\n        else {\n            (qq.bind(function() {\n                // Assumption: There will never be more than one record\n                var record = scaler.getFileRecords(uuid, name, file)[0];\n\n                if (record && record.blob instanceof qq.BlobProxy) {\n                    record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                }\n                else {\n                    log(id + \" is not a scalable image!\", \"error\");\n                    scalingEffort.failure();\n                }\n            }, this)());\n        }\n\n        return scalingEffort;\n    },\n\n    // NOTE: We cannot reliably determine at this time if the UA supports a specific MIME type for the target format.\n    // image/jpeg and image/png are the only safe choices at this time.\n    _determineOutputType: function(spec) {\n        \"use strict\";\n\n        var requestedType = spec.requestedType,\n            defaultType = spec.defaultType,\n            referenceType = spec.refType;\n\n        // If a default type and requested type have not been specified, this should be a\n        // JPEG if the original type is a JPEG, otherwise, a PNG.\n        if (!defaultType && !requestedType) {\n            if (referenceType !== \"image/jpeg\") {\n                return \"image/png\";\n            }\n            return referenceType;\n        }\n\n        // A specified default type is used when a requested type is not specified.\n        if (!requestedType) {\n            return defaultType;\n        }\n\n        // If requested type is specified, use it, as long as this recognized type is supported by the current UA\n        if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n            if (requestedType === \"image/tiff\") {\n                return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n            }\n\n            return requestedType;\n        }\n\n        return defaultType;\n    },\n\n    // Get a file name for a generated scaled file record, based on the provided scaled image description\n    _getName: function(originalName, scaledVersionProperties) {\n        \"use strict\";\n\n        var startOfExt = originalName.lastIndexOf(\".\"),\n            versionType = scaledVersionProperties.type || \"image/png\",\n            referenceType = scaledVersionProperties.refType,\n            scaledName = \"\",\n            scaledExt = qq.getExtension(originalName),\n            nameAppendage = \"\";\n\n        if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n            nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n        }\n\n        if (startOfExt >= 0) {\n            scaledName = originalName.substr(0, startOfExt);\n\n            if (referenceType !== versionType) {\n                scaledExt = versionType.split(\"/\")[1];\n            }\n\n            scaledName += nameAppendage + \".\" + scaledExt;\n        }\n        else {\n            scaledName = originalName + nameAppendage;\n        }\n\n        return scaledName;\n    },\n\n    // We want the smallest scaled file to be uploaded first\n    _getSortedSizes: function(sizes) {\n        \"use strict\";\n\n        sizes = qq.extend([], sizes);\n\n        return sizes.sort(function(a, b) {\n            if (a.maxSize > b.maxSize) {\n                return 1;\n            }\n            if (a.maxSize < b.maxSize) {\n                return -1;\n            }\n            return 0;\n        });\n    },\n\n    _generateScaledImage: function(spec, sourceFile) {\n        \"use strict\";\n\n        var self = this,\n            customResizeFunction = spec.customResizeFunction,\n            log = spec.log,\n            maxSize = spec.maxSize,\n            orient = spec.orient,\n            type = spec.type,\n            quality = spec.quality,\n            failedText = spec.failedText,\n            includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\",\n            scalingEffort = new qq.Promise(),\n            imageGenerator = new qq.ImageGenerator(log),\n            canvas = document.createElement(\"canvas\");\n\n        log(\"Attempting to generate scaled version for \" + sourceFile.name);\n\n        imageGenerator.generate(sourceFile, canvas, {maxSize: maxSize, orient: orient, customResizeFunction: customResizeFunction}).then(function() {\n            var scaledImageDataUri = canvas.toDataURL(type, quality),\n                signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n\n            if (includeExif) {\n                self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                    scaledImageDataUri = scaledImageDataUriWithExif;\n                    signalSuccess();\n                },\n                function() {\n                    log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                    signalSuccess();\n                });\n            }\n            else {\n                signalSuccess();\n            }\n        }, function() {\n            log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n            scalingEffort.failure(failedText);\n        });\n\n        return scalingEffort;\n    },\n\n    // Attempt to insert the original image's EXIF header into a scaled version.\n    _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n        \"use strict\";\n\n        var reader = new FileReader(),\n            insertionEffort = new qq.Promise(),\n            originalImageDataUri = \"\";\n\n        reader.onload = function() {\n            originalImageDataUri = reader.result;\n            insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n        };\n\n        reader.onerror = function() {\n            log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n            insertionEffort.failure();\n        };\n\n        reader.readAsDataURL(originalImage);\n\n        return insertionEffort;\n    },\n\n    _dataUriToBlob: function(dataUri) {\n        \"use strict\";\n\n        var byteString, mimeString, arrayBuffer, intArray;\n\n        // convert base64 to raw binary data held in a string\n        if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n            byteString = atob(dataUri.split(\",\")[1]);\n        }\n        else {\n            byteString = decodeURI(dataUri.split(\",\")[1]);\n        }\n\n        // extract the MIME\n        mimeString = dataUri.split(\",\")[0]\n            .split(\":\")[1]\n            .split(\";\")[0];\n\n        // write the bytes of the binary string to an ArrayBuffer\n        arrayBuffer = new ArrayBuffer(byteString.length);\n        intArray = new Uint8Array(arrayBuffer);\n        qq.each(byteString, function(idx, character) {\n            intArray[idx] = character.charCodeAt(0);\n        });\n\n        return this._createBlob(arrayBuffer, mimeString);\n    },\n\n    _createBlob: function(data, mime) {\n        \"use strict\";\n\n        var BlobBuilder = window.BlobBuilder ||\n                window.WebKitBlobBuilder ||\n                window.MozBlobBuilder ||\n                window.MSBlobBuilder,\n            blobBuilder = BlobBuilder && new BlobBuilder();\n\n        if (blobBuilder) {\n            blobBuilder.append(data);\n            return blobBuilder.getBlob(mime);\n        }\n        else {\n            return new Blob([data], {type: mime});\n        }\n    }\n});\n","//Based on MinifyJpeg\n//http://elicon.blog57.fc2.com/blog-entry-206.html\n\nqq.ExifRestorer = (function()\n{\n   \n\tvar ExifRestorer = {};\n\t \n    ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" +\n                         \"QRSTUVWXYZabcdef\" +\n                         \"ghijklmnopqrstuv\" +\n                         \"wxyz0123456789+/\" +\n                         \"=\";\n\n    ExifRestorer.encode64 = function(input)\n    {\n        var output = \"\",\n            chr1, chr2, chr3 = \"\",\n            enc1, enc2, enc3, enc4 = \"\",\n            i = 0;\n\n        do {\n            chr1 = input[i++];\n            chr2 = input[i++];\n            chr3 = input[i++];\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n               enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n               enc4 = 64;\n            }\n\n            output = output +\n               this.KEY_STR.charAt(enc1) +\n               this.KEY_STR.charAt(enc2) +\n               this.KEY_STR.charAt(enc3) +\n               this.KEY_STR.charAt(enc4);\n            chr1 = chr2 = chr3 = \"\";\n            enc1 = enc2 = enc3 = enc4 = \"\";\n        } while (i < input.length);\n\n        return output;\n    };\n    \n    ExifRestorer.restore = function(origFileBase64, resizedFileBase64)\n    {\n        var expectedBase64Header = \"data:image/jpeg;base64,\";\n\n        if (!origFileBase64.match(expectedBase64Header))\n        {\n        \treturn resizedFileBase64;\n        }       \n        \n        var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n        var segments = this.slice2Segments(rawImage);\n                \n        var image = this.exifManipulation(resizedFileBase64, segments);\n        \n        return expectedBase64Header + this.encode64(image);\n        \n    };\n\n\n    ExifRestorer.exifManipulation = function(resizedFileBase64, segments)\n    {\n            var exifArray = this.getExifArray(segments),\n                newImageArray = this.insertExif(resizedFileBase64, exifArray),\n                aBuffer = new Uint8Array(newImageArray);\n\n            return aBuffer;\n    };\n\n\n    ExifRestorer.getExifArray = function(segments)\n    {\n            var seg;\n            for (var x = 0; x < segments.length; x++)\n            {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) //(ff e1)\n                {\n                    return seg;\n                }\n            }\n            return [];\n    };\n\n\n    ExifRestorer.insertExif = function(resizedFileBase64, exifArray)\n    {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"),\n                buf = this.decode64(imageData),\n                separatePoint = buf.indexOf(255,3),\n                mae = buf.slice(0, separatePoint),\n                ato = buf.slice(separatePoint),\n                array = mae;\n\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n           return array;\n    };\n\n\n    \n    ExifRestorer.slice2Segments = function(rawImageArray)\n    {\n        var head = 0,\n            segments = [];\n\n        while (1)\n        {\n            if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218){break;}\n            if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216)\n            {\n                head += 2;\n            }\n            else\n            {\n                var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],\n                    endPoint = head + length + 2,\n                    seg = rawImageArray.slice(head, endPoint);\n                segments.push(seg);\n                head = endPoint;\n            }\n            if (head > rawImageArray.length){break;}\n        }\n\n        return segments;\n    };\n\n\n    \n    ExifRestorer.decode64 = function(input) \n    {\n        var output = \"\",\n            chr1, chr2, chr3 = \"\",\n            enc1, enc2, enc3, enc4 = \"\",\n            i = 0,\n            buf = [];\n\n        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n        var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n        if (base64test.exec(input)) {\n            throw new Error(\"There were invalid base64 characters in the input text.  \" +\n                \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n        }\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n        do {\n            enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n            enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n            enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n            enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            buf.push(chr1);\n\n            if (enc3 != 64) {\n               buf.push(chr2);\n            }\n            if (enc4 != 64) {\n               buf.push(chr3);\n            }\n\n            chr1 = chr2 = chr3 = \"\";\n            enc1 = enc2 = enc3 = enc4 = \"\";\n\n        } while (i < input.length);\n\n        return buf;\n    };\n\n    \n    return ExifRestorer;\n})();\n","/* globals qq */\n/**\n * Keeps a running tally of total upload progress for a batch of files.\n *\n * @param callback Invoked when total progress changes, passing calculated total loaded & total size values.\n * @param getSize Function that returns the size of a file given its ID\n * @constructor\n */\nqq.TotalProgress = function(callback, getSize) {\n    \"use strict\";\n\n    var perFileProgress = {},\n        totalLoaded = 0,\n        totalSize = 0,\n\n        lastLoadedSent = -1,\n        lastTotalSent = -1,\n        callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        },\n\n        /**\n         * @param failed Array of file IDs that have failed\n         * @param retryable Array of file IDs that are retryable\n         * @returns true if none of the failed files are eligible for retry\n         */\n        noRetryableFiles = function(failed, retryable) {\n            var none = true;\n\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n\n            return none;\n        },\n\n        onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        },\n\n        onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        },\n\n        onNew = function(id) {\n            var size = getSize(id);\n\n            // We might not know the size yet, such as for blob proxies\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {loaded: 0, total: size};\n            }\n        },\n\n        /**\n         * Invokes the callback with the current total progress of all files in the batch.  Called whenever it may\n         * be appropriate to re-calculate and disseminate this data.\n         *\n         * @param id ID of a file that has changed in some important way\n         * @param newLoaded New loaded value for this file.  -1 if this value should no longer be part of calculations\n         * @param newTotal New total size of the file.  -1 if this value should no longer be part of calculations\n         */\n        updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0,\n                oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            }\n            else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n\n            callbackProxy(totalLoaded, totalSize);\n        };\n\n    qq.extend(this, {\n        // Called when a batch of files has completed uploading.\n        onAllComplete: onAllComplete,\n\n        // Called when the status of a file has changed.\n        onStatusChange: function(id, oldStatus, newStatus) {\n            if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                onCancel(id);\n            }\n            else if (newStatus === qq.status.SUBMITTING) {\n                onNew(id);\n            }\n        },\n\n        // Called whenever the upload progress of an individual file has changed.\n        onIndividualProgress: function(id, loaded, total) {\n            updateTotalProgress(id, loaded, total);\n            perFileProgress[id] = {loaded: loaded, total: total};\n        },\n\n        // Called whenever the total size of a file has changed, such as when the size of a generated blob is known.\n        onNewSize: function(id) {\n            onNew(id);\n        },\n\n        reset: function() {\n            perFileProgress = {};\n            totalLoaded = 0;\n            totalSize = 0;\n        }\n    });\n};\n","/*globals qq*/\nqq.PasteSupport = function(o) {\n    \"use strict\";\n\n    var options, detachPasteHandler;\n\n    options = {\n        targetElement: null,\n        callbacks: {\n            log: function(message, level) {},\n            pasteReceived: function(blob) {}\n        }\n    };\n\n    function isImage(item) {\n        return item.type &&\n            item.type.indexOf(\"image/\") === 0;\n    }\n\n    function registerPasteHandler() {\n        detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n            var clipboardData = event.clipboardData;\n\n            if (clipboardData) {\n                qq.each(clipboardData.items, function(idx, item) {\n                    if (isImage(item)) {\n                        var blob = item.getAsFile();\n                        options.callbacks.pasteReceived(blob);\n                    }\n                });\n            }\n        });\n    }\n\n    function unregisterPasteHandler() {\n        if (detachPasteHandler) {\n            detachPasteHandler();\n        }\n    }\n\n    qq.extend(options, o);\n    registerPasteHandler();\n\n    qq.extend(this, {\n        reset: function() {\n            unregisterPasteHandler();\n        }\n    });\n};\n","/* globals qq */\n/**\n * Module that handles support for existing forms.\n *\n * @param options Options passed from the integrator-supplied options related to form support.\n * @param startUpload Callback to invoke when files \"stored\" should be uploaded.\n * @param log Proxy for the logger\n * @constructor\n */\nqq.FormSupport = function(options, startUpload, log) {\n    \"use strict\";\n    var self  = this,\n        interceptSubmit = options.interceptSubmit,\n        formEl = options.element,\n        autoUpload = options.autoUpload;\n\n    // Available on the public API associated with this module.\n    qq.extend(this, {\n        // To be used by the caller to determine if the endpoint will be determined by some processing\n        // that occurs in this module, such as if the form has an action attribute.\n        // Ignore if `attachToForm === false`.\n        newEndpoint: null,\n\n        // To be used by the caller to determine if auto uploading should be allowed.\n        // Ignore if `attachToForm === false`.\n        newAutoUpload: autoUpload,\n\n        // true if a form was detected and is being tracked by this module\n        attachedToForm: false,\n\n        // Returns an object with names and values for all valid form elements associated with the attached form.\n        getFormInputsAsObject: function() {\n            /* jshint eqnull:true */\n            if (formEl == null) {\n                return null;\n            }\n\n            return self._form2Obj(formEl);\n        }\n    });\n\n    // If the form contains an action attribute, this should be the new upload endpoint.\n    function determineNewEndpoint(formEl) {\n        if (formEl.getAttribute(\"action\")) {\n            self.newEndpoint = formEl.getAttribute(\"action\");\n        }\n    }\n\n    // Return true only if the form is valid, or if we cannot make this determination.\n    // If the form is invalid, ensure invalid field(s) are highlighted in the UI.\n    function validateForm(formEl, nativeSubmit) {\n        if (formEl.checkValidity && !formEl.checkValidity()) {\n            log(\"Form did not pass validation checks - will not upload.\", \"error\");\n            nativeSubmit();\n        }\n        else {\n            return true;\n        }\n    }\n\n    // Intercept form submit attempts, unless the integrator has told us not to do this.\n    function maybeUploadOnSubmit(formEl) {\n        var nativeSubmit = formEl.submit;\n\n        // Intercept and squelch submit events.\n        qq(formEl).attach(\"submit\", function(event) {\n            event = event || window.event;\n\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            else {\n                event.returnValue = false;\n            }\n\n            validateForm(formEl, nativeSubmit) && startUpload();\n        });\n\n        // The form's `submit()` function may be called instead (i.e. via jQuery.submit()).\n        // Intercept that too.\n        formEl.submit = function() {\n            validateForm(formEl, nativeSubmit) && startUpload();\n        };\n    }\n\n    // If the element value passed from the uploader is a string, assume it is an element ID - select it.\n    // The rest of the code in this module depends on this being an HTMLElement.\n    function determineFormEl(formEl) {\n        if (formEl) {\n            if (qq.isString(formEl)) {\n                formEl = document.getElementById(formEl);\n            }\n\n            if (formEl) {\n                log(\"Attaching to form element.\");\n                determineNewEndpoint(formEl);\n                interceptSubmit && maybeUploadOnSubmit(formEl);\n            }\n        }\n\n        return formEl;\n    }\n\n    formEl = determineFormEl(formEl);\n    this.attachedToForm = !!formEl;\n};\n\nqq.extend(qq.FormSupport.prototype, {\n    // Converts all relevant form fields to key/value pairs.  This is meant to mimic the data a browser will\n    // construct from a given form when the form is submitted.\n    _form2Obj: function(form) {\n        \"use strict\";\n        var obj = {},\n            notIrrelevantType = function(type) {\n                var irrelevantTypes = [\n                    \"button\",\n                    \"image\",\n                    \"reset\",\n                    \"submit\"\n                ];\n\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            },\n            radioOrCheckbox = function(type) {\n                return qq.indexOf([\"checkbox\", \"radio\"], type.toLowerCase()) >= 0;\n            },\n            ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            },\n            selectValue = function(select) {\n                var value = null;\n\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n\n                return value;\n            };\n\n        qq.each(form.elements, function(idx, el) {\n            if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") &&\n                notIrrelevantType(el.type) &&\n                !ignoreValue(el)) {\n\n                obj[el.name] = el.value;\n            }\n            else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                var value = selectValue(el);\n\n                if (value !== null) {\n                    obj[el.name] = value;\n                }\n            }\n        });\n\n        return obj;\n    }\n});\n","/*globals qq*/\n/**\n * Upload handler used that assumes the current user agent does not have any support for the\n * File API, and, therefore, makes use of iframes and forms to submit the files directly to\n * a generic server.\n *\n * @param options Options passed from the base handler\n * @param proxy Callbacks & methods used to query for or push out data/changes\n */\nqq.traditional = qq.traditional || {};\nqq.traditional.FormUploadHandler = function(options, proxy) {\n    \"use strict\";\n\n    var handler = this,\n        getName = proxy.getName,\n        getUuid = proxy.getUuid,\n        log = proxy.log;\n\n    /**\n     * Returns json object received by iframe from server.\n     */\n    function getIframeContentJson(id, iframe) {\n        /*jshint evil: true*/\n\n        var response, doc, innerHtml;\n\n        //IE may throw an \"access is denied\" error when attempting to access contentDocument on the iframe in some cases\n        try {\n            // iframe.contentWindow.document - for IE<7\n            doc = iframe.contentDocument || iframe.contentWindow.document;\n            innerHtml = doc.body.innerHTML;\n\n            log(\"converting iframe's innerHTML to JSON\");\n            log(\"innerHTML = \" + innerHtml);\n            //plain text response may be wrapped in <pre> tag\n            if (innerHtml && innerHtml.match(/^<pre/i)) {\n                innerHtml = doc.body.firstChild.firstChild.nodeValue;\n            }\n\n            response = handler._parseJsonResponse(innerHtml);\n        }\n        catch (error) {\n            log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n            response = {success: false};\n        }\n\n        return response;\n    }\n\n    /**\n     * Creates form, that will be submitted to iframe\n     */\n    function createForm(id, iframe) {\n        var params = options.paramsStore.get(id),\n            method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\",\n            endpoint = options.endpointStore.get(id),\n            name = getName(id);\n\n        params[options.uuidName] = getUuid(id);\n        params[options.filenameParam] = name;\n\n        return handler._initFormForUpload({\n            method: method,\n            endpoint: endpoint,\n            params: params,\n            paramsInBody: options.paramsInBody,\n            targetName: iframe.name\n        });\n    }\n\n    this.uploadFile = function(id) {\n        var input = handler.getInput(id),\n            iframe = handler._createIframe(id),\n            promise = new qq.Promise(),\n            form;\n\n        form = createForm(id, iframe);\n        form.appendChild(input);\n\n        handler._attachLoadEvent(iframe, function(responseFromMessage) {\n            log(\"iframe loaded\");\n\n            var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n\n            handler._detachLoadEvent(id);\n\n            //we can't remove an iframe if the iframe doesn't belong to the same domain\n            if (!options.cors.expected) {\n                qq(iframe).remove();\n            }\n\n            if (response.success) {\n                promise.success(response);\n            }\n            else {\n                promise.failure(response);\n            }\n        });\n\n        log(\"Sending upload request for \" + id);\n        form.submit();\n        qq(form).remove();\n\n        return promise;\n    };\n\n    qq.extend(this, new qq.FormUploadHandler({\n        options: {\n            isCors: options.cors.expected,\n            inputName: options.inputName\n        },\n\n        proxy: {\n            onCancel: options.onCancel,\n            getName: getName,\n            getUuid: getUuid,\n            log: log\n        }\n    }));\n};\n","/*globals qq*/\n/**\n * Upload handler used to upload to traditional endpoints.  It depends on File API support, and, therefore,\n * makes use of `XMLHttpRequest` level 2 to upload `File`s and `Blob`s to a generic server.\n *\n * @param spec Options passed from the base handler\n * @param proxy Callbacks & methods used to query for or push out data/changes\n */\nqq.traditional = qq.traditional || {};\nqq.traditional.XhrUploadHandler = function(spec, proxy) {\n    \"use strict\";\n\n    var handler = this,\n        getName = proxy.getName,\n        getSize = proxy.getSize,\n        getUuid = proxy.getUuid,\n        log = proxy.log,\n        multipart = spec.forceMultipart || spec.paramsInBody,\n\n        addChunkingSpecificParams = function(id, params, chunkData) {\n            var size = getSize(id),\n                name = getName(id);\n\n            if (!spec.omitDefaultParams) {\n                params[spec.chunking.paramNames.partIndex] = chunkData.part;\n                params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n                params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n                params[spec.chunking.paramNames.totalParts] = chunkData.count;\n                params[spec.totalFileSizeName] = size;\n            }\n\n            /**\n             * When a Blob is sent in a multipart request, the filename value in the content-disposition header is either \"blob\"\n             * or an empty string.  So, we will need to include the actual file name as a param in this case.\n             */\n            if (multipart && !spec.omitDefaultParams) {\n                params[spec.filenameParam] = name;\n            }\n        },\n\n        allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n            cors: spec.cors,\n            endpoint: spec.chunking.success.endpoint,\n            headers: spec.chunking.success.headers,\n            jsonPayload: spec.chunking.success.jsonPayload,\n            log: log,\n            method: spec.chunking.success.method,\n            params: spec.chunking.success.params\n        }),\n\n        createReadyStateChangedHandler = function(id, xhr) {\n            var promise = new qq.Promise();\n\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    var result = onUploadOrChunkComplete(id, xhr);\n\n                    if (result.success) {\n                        promise.success(result.response, xhr);\n                    }\n                    else {\n                        promise.failure(result.response, xhr);\n                    }\n                }\n            };\n\n            return promise;\n        },\n\n        getChunksCompleteParams = function(id) {\n            var params = spec.paramsStore.get(id),\n                name = getName(id),\n                size = getSize(id);\n\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            params[spec.totalFileSizeName] = size;\n            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n\n            return params;\n        },\n\n        isErrorUploadResponse = function(xhr, response) {\n            return qq.indexOf([200, 201, 202, 203, 204], xhr.status) < 0 ||\n                (spec.requireSuccessJson && !response.success) ||\n                response.reset;\n        },\n\n        onUploadOrChunkComplete = function(id, xhr) {\n            var response;\n\n            log(\"xhr - server response received for \" + id);\n            log(\"responseText = \" + xhr.responseText);\n\n            response = parseResponse(true, xhr);\n\n            return {\n                success: !isErrorUploadResponse(xhr, response),\n                response: response\n            };\n        },\n\n        // If this is an upload response, we require a JSON payload, otherwise, it is optional.\n        parseResponse = function(upload, xhr) {\n            var response = {};\n\n            try {\n                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                response = qq.parseJson(xhr.responseText);\n            }\n            catch (error) {\n                upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n            }\n\n            return response;\n        },\n\n        sendChunksCompleteRequest = function(id) {\n            var promise = new qq.Promise();\n\n            allChunksDoneRequester.complete(\n                    id,\n                    handler._createXhr(id),\n                    getChunksCompleteParams(id),\n                    spec.customHeaders.get(id)\n                )\n                .then(function(xhr) {\n                    promise.success(parseResponse(false, xhr), xhr);\n                }, function(xhr) {\n                    promise.failure(parseResponse(false, xhr), xhr);\n                });\n\n            return promise;\n        },\n\n        setParamsAndGetEntityToSend = function(entityToSendParams) {\n            var fileOrBlob = entityToSendParams.fileOrBlob;\n            var id = entityToSendParams.id;\n            var xhr = entityToSendParams.xhr;\n            var xhrOverrides = entityToSendParams.xhrOverrides || {};\n            var customParams = entityToSendParams.customParams || {};\n            var defaultParams = entityToSendParams.params || {};\n            var xhrOverrideParams = xhrOverrides.params || {};\n            var params;\n\n            var formData = multipart ? new FormData() : null,\n                method = xhrOverrides.method || spec.method,\n                endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id),\n                name = getName(id),\n                size = getSize(id);\n\n            if (spec.omitDefaultParams) {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n            }\n            else {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n                qq.extend(params, defaultParams);\n\n                params[spec.uuidName] = getUuid(id);\n                params[spec.filenameParam] = name;\n\n                if (multipart) {\n                    params[spec.totalFileSizeName] = size;\n                }\n                else if (!spec.paramsInBody) {\n                    params[spec.inputName] = name;\n                }\n            }\n\n            //build query string\n            if (!spec.paramsInBody) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n\n            xhr.open(method, endpoint, true);\n\n            if (spec.cors.expected && spec.cors.sendCredentials) {\n                xhr.withCredentials = true;\n            }\n\n            if (multipart) {\n                if (spec.paramsInBody) {\n                    qq.obj2FormData(params, formData);\n                }\n\n                formData.append(spec.inputName, fileOrBlob);\n                return formData;\n            }\n\n            return fileOrBlob;\n        },\n\n        setUploadHeaders = function(headersOptions) {\n            var headerOverrides = headersOptions.headerOverrides;\n            var id = headersOptions.id;\n            var xhr = headersOptions.xhr;\n\n            if (headerOverrides) {\n                qq.each(headerOverrides, function(headerName, headerValue) {\n                    xhr.setRequestHeader(headerName, headerValue);\n                });\n            }\n            else {\n                var extraHeaders = spec.customHeaders.get(id),\n                    fileOrBlob = handler.getFile(id);\n\n                xhr.setRequestHeader(\"Accept\", \"application/json\");\n                xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n\n                if (!multipart) {\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                    //NOTE: return mime type in xhr works on chrome 16.0.9 firefox 11.0a2\n                    xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n                }\n\n                qq.each(extraHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        };\n\n    qq.extend(this, {\n        uploadChunk: function(uploadChunkParams) {\n            var id = uploadChunkParams.id;\n            var chunkIdx = uploadChunkParams.chunkIdx;\n            var overrides = uploadChunkParams.overrides || {};\n            var resuming = uploadChunkParams.resuming;\n\n            var chunkData = handler._getChunkData(id, chunkIdx),\n                xhr = handler._createXhr(id, chunkIdx),\n                promise, toSend, customParams, params = {};\n\n            promise = createReadyStateChangedHandler(id, xhr);\n            handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n            customParams = spec.paramsStore.get(id);\n            addChunkingSpecificParams(id, params, chunkData);\n\n            if (resuming) {\n                params[spec.resume.paramNames.resuming] = true;\n            }\n\n            toSend = setParamsAndGetEntityToSend({\n                fileOrBlob: chunkData.blob,\n                id: id,\n                customParams: customParams,\n                params: params,\n                xhr: xhr,\n                xhrOverrides: overrides\n            });\n\n            setUploadHeaders({\n                headerOverrides: overrides.headers,\n                id: id,\n                xhr: xhr\n            });\n\n            xhr.send(toSend);\n\n            return promise;\n        },\n\n        uploadFile: function(id) {\n            var fileOrBlob = handler.getFile(id),\n                promise, xhr, customParams, toSend;\n\n            xhr = handler._createXhr(id);\n            handler._registerProgressHandler(id);\n            promise = createReadyStateChangedHandler(id, xhr);\n            customParams = spec.paramsStore.get(id);\n\n            toSend = setParamsAndGetEntityToSend({\n                fileOrBlob: fileOrBlob,\n                id: id,\n                customParams: customParams,\n                xhr: xhr\n            });\n\n            setUploadHeaders({\n                id: id,\n                xhr: xhr\n            });\n\n            xhr.send(toSend);\n\n            return promise;\n        }\n    });\n\n    qq.extend(this, new qq.XhrUploadHandler({\n        options: qq.extend({namespace: \"traditional\"}, spec),\n        proxy: qq.extend({getEndpoint: spec.endpointStore.get}, proxy)\n    }));\n\n    qq.override(this, function(super_) {\n        return {\n            finalizeChunks: function(id) {\n                proxy.onFinalizing(id);\n\n                if (spec.chunking.success.endpoint) {\n                    return sendChunksCompleteRequest(id);\n                }\n                else {\n                    return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n                }\n            }\n        };\n    });\n};\n","/*globals qq*/\n/**\n * Ajax requester used to send a POST to a traditional endpoint once all chunks for a specific file have uploaded\n * successfully.\n *\n * @param o Options from the caller - will override the defaults.\n * @constructor\n */\nqq.traditional.AllChunksDoneAjaxRequester = function(o) {\n    \"use strict\";\n\n    var requester,\n        options = {\n            cors: {\n                allowXdr: false,\n                expected: false,\n                sendCredentials: false\n            },\n            endpoint: null,\n            log: function(str, level) {},\n            method: \"POST\"\n        },\n        promises = {},\n        endpointHandler = {\n            get: function(id) {\n                if (qq.isFunction(options.endpoint)) {\n                    return options.endpoint(id);\n                }\n\n                return options.endpoint;\n            }\n        };\n\n    qq.extend(options, o);\n\n    requester = qq.extend(this, new qq.AjaxRequester({\n        acceptHeader: \"application/json\",\n        contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n        validMethods: [options.method],\n        method: options.method,\n        endpointStore: endpointHandler,\n        allowXRequestedWithAndCacheControl: false,\n        cors: options.cors,\n        log: options.log,\n        onComplete: function(id, xhr, isError) {\n            var promise = promises[id];\n\n            delete promises[id];\n\n            if (isError) {\n                promise.failure(xhr);\n            }\n            else {\n                promise.success(xhr);\n            }\n        }\n    }));\n\n    qq.extend(this, {\n        complete: function(id, xhr, params, headers) {\n            var promise = new qq.Promise();\n\n            options.log(\"Submitting All Chunks Done request for \" + id);\n\n            promises[id] = promise;\n\n            requester.initTransport(id)\n                .withParams(options.params(id) || params)\n                .withHeaders(options.headers(id) || headers)\n                .send(xhr);\n\n            return promise;\n        }\n    });\n};\n"]},"metadata":{},"sourceType":"script"}