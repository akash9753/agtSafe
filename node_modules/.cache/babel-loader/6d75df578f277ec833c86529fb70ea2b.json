{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as json from './_deps/jsonc-parser/main.js';\nexport function createTokenizationSupport(supportComments) {\n  return {\n    getInitialState: function getInitialState() {\n      return new JSONState(null, null, false);\n    },\n    tokenize: function tokenize(line, state, offsetDelta, stopAtOffset) {\n      return _tokenize(supportComments, line, state, offsetDelta, stopAtOffset);\n    }\n  };\n}\nexport var TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\nexport var TOKEN_DELIM_ARRAY = 'delimiter.array.json';\nexport var TOKEN_DELIM_COLON = 'delimiter.colon.json';\nexport var TOKEN_DELIM_COMMA = 'delimiter.comma.json';\nexport var TOKEN_VALUE_BOOLEAN = 'keyword.json';\nexport var TOKEN_VALUE_NULL = 'keyword.json';\nexport var TOKEN_VALUE_STRING = 'string.value.json';\nexport var TOKEN_VALUE_NUMBER = 'number.json';\nexport var TOKEN_PROPERTY_NAME = 'string.key.json';\nexport var TOKEN_COMMENT_BLOCK = 'comment.block.json';\nexport var TOKEN_COMMENT_LINE = 'comment.line.json';\nvar JSONState = /** @class */function () {\n  function JSONState(state, scanError, lastWasColon) {\n    this._state = state;\n    this.scanError = scanError;\n    this.lastWasColon = lastWasColon;\n  }\n  JSONState.prototype.clone = function () {\n    return new JSONState(this._state, this.scanError, this.lastWasColon);\n  };\n  JSONState.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n    if (!other || !(other instanceof JSONState)) {\n      return false;\n    }\n    return this.scanError === other.scanError && this.lastWasColon === other.lastWasColon;\n  };\n  JSONState.prototype.getStateData = function () {\n    return this._state;\n  };\n  JSONState.prototype.setStateData = function (state) {\n    this._state = state;\n  };\n  return JSONState;\n}();\nfunction _tokenize(comments, line, state, offsetDelta, stopAtOffset) {\n  if (offsetDelta === void 0) {\n    offsetDelta = 0;\n  }\n  // handle multiline strings and block comments\n  var numberOfInsertedCharacters = 0,\n    adjustOffset = false;\n  switch (state.scanError) {\n    case 2 /* UnexpectedEndOfString */:\n      line = '\"' + line;\n      numberOfInsertedCharacters = 1;\n      break;\n    case 1 /* UnexpectedEndOfComment */:\n      line = '/*' + line;\n      numberOfInsertedCharacters = 2;\n      break;\n  }\n  var scanner = json.createScanner(line),\n    kind,\n    ret,\n    lastWasColon = state.lastWasColon;\n  ret = {\n    tokens: [],\n    endState: state.clone()\n  };\n  while (true) {\n    var offset = offsetDelta + scanner.getPosition(),\n      type = '';\n    kind = scanner.scan();\n    if (kind === 17 /* EOF */) {\n      break;\n    }\n    // Check that the scanner has advanced\n    if (offset === offsetDelta + scanner.getPosition()) {\n      throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n    }\n    // In case we inserted /* or \" character, we need to\n    // adjust the offset of all tokens (except the first)\n    if (adjustOffset) {\n      offset -= numberOfInsertedCharacters;\n    }\n    adjustOffset = numberOfInsertedCharacters > 0;\n    // brackets and type\n    switch (kind) {\n      case 1 /* OpenBraceToken */:\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n      case 2 /* CloseBraceToken */:\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n      case 3 /* OpenBracketToken */:\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n      case 4 /* CloseBracketToken */:\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n      case 6 /* ColonToken */:\n        type = TOKEN_DELIM_COLON;\n        lastWasColon = true;\n        break;\n      case 5 /* CommaToken */:\n        type = TOKEN_DELIM_COMMA;\n        lastWasColon = false;\n        break;\n      case 8 /* TrueKeyword */:\n      case 9 /* FalseKeyword */:\n        type = TOKEN_VALUE_BOOLEAN;\n        lastWasColon = false;\n        break;\n      case 7 /* NullKeyword */:\n        type = TOKEN_VALUE_NULL;\n        lastWasColon = false;\n        break;\n      case 10 /* StringLiteral */:\n        type = lastWasColon ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\n        lastWasColon = false;\n        break;\n      case 11 /* NumericLiteral */:\n        type = TOKEN_VALUE_NUMBER;\n        lastWasColon = false;\n        break;\n    }\n    // comments, iff enabled\n    if (comments) {\n      switch (kind) {\n        case 12 /* LineCommentTrivia */:\n          type = TOKEN_COMMENT_LINE;\n          break;\n        case 13 /* BlockCommentTrivia */:\n          type = TOKEN_COMMENT_BLOCK;\n          break;\n      }\n    }\n    ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon);\n    ret.tokens.push({\n      startIndex: offset,\n      scopes: type\n    });\n  }\n  return ret;\n}","map":{"version":3,"names":["json","createTokenizationSupport","supportComments","getInitialState","JSONState","tokenize","line","state","offsetDelta","stopAtOffset","TOKEN_DELIM_OBJECT","TOKEN_DELIM_ARRAY","TOKEN_DELIM_COLON","TOKEN_DELIM_COMMA","TOKEN_VALUE_BOOLEAN","TOKEN_VALUE_NULL","TOKEN_VALUE_STRING","TOKEN_VALUE_NUMBER","TOKEN_PROPERTY_NAME","TOKEN_COMMENT_BLOCK","TOKEN_COMMENT_LINE","scanError","lastWasColon","_state","prototype","clone","equals","other","getStateData","setStateData","comments","numberOfInsertedCharacters","adjustOffset","scanner","createScanner","kind","ret","tokens","endState","offset","getPosition","type","scan","Error","substr","getTokenError","push","startIndex","scopes"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/json/tokenization.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n'use strict';\r\nimport * as json from './_deps/jsonc-parser/main.js';\r\nexport function createTokenizationSupport(supportComments) {\r\n    return {\r\n        getInitialState: function () { return new JSONState(null, null, false); },\r\n        tokenize: function (line, state, offsetDelta, stopAtOffset) { return tokenize(supportComments, line, state, offsetDelta, stopAtOffset); }\r\n    };\r\n}\r\nexport var TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\r\nexport var TOKEN_DELIM_ARRAY = 'delimiter.array.json';\r\nexport var TOKEN_DELIM_COLON = 'delimiter.colon.json';\r\nexport var TOKEN_DELIM_COMMA = 'delimiter.comma.json';\r\nexport var TOKEN_VALUE_BOOLEAN = 'keyword.json';\r\nexport var TOKEN_VALUE_NULL = 'keyword.json';\r\nexport var TOKEN_VALUE_STRING = 'string.value.json';\r\nexport var TOKEN_VALUE_NUMBER = 'number.json';\r\nexport var TOKEN_PROPERTY_NAME = 'string.key.json';\r\nexport var TOKEN_COMMENT_BLOCK = 'comment.block.json';\r\nexport var TOKEN_COMMENT_LINE = 'comment.line.json';\r\nvar JSONState = /** @class */ (function () {\r\n    function JSONState(state, scanError, lastWasColon) {\r\n        this._state = state;\r\n        this.scanError = scanError;\r\n        this.lastWasColon = lastWasColon;\r\n    }\r\n    JSONState.prototype.clone = function () {\r\n        return new JSONState(this._state, this.scanError, this.lastWasColon);\r\n    };\r\n    JSONState.prototype.equals = function (other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        if (!other || !(other instanceof JSONState)) {\r\n            return false;\r\n        }\r\n        return this.scanError === other.scanError &&\r\n            this.lastWasColon === other.lastWasColon;\r\n    };\r\n    JSONState.prototype.getStateData = function () {\r\n        return this._state;\r\n    };\r\n    JSONState.prototype.setStateData = function (state) {\r\n        this._state = state;\r\n    };\r\n    return JSONState;\r\n}());\r\nfunction tokenize(comments, line, state, offsetDelta, stopAtOffset) {\r\n    if (offsetDelta === void 0) { offsetDelta = 0; }\r\n    // handle multiline strings and block comments\r\n    var numberOfInsertedCharacters = 0, adjustOffset = false;\r\n    switch (state.scanError) {\r\n        case 2 /* UnexpectedEndOfString */:\r\n            line = '\"' + line;\r\n            numberOfInsertedCharacters = 1;\r\n            break;\r\n        case 1 /* UnexpectedEndOfComment */:\r\n            line = '/*' + line;\r\n            numberOfInsertedCharacters = 2;\r\n            break;\r\n    }\r\n    var scanner = json.createScanner(line), kind, ret, lastWasColon = state.lastWasColon;\r\n    ret = {\r\n        tokens: [],\r\n        endState: state.clone()\r\n    };\r\n    while (true) {\r\n        var offset = offsetDelta + scanner.getPosition(), type = '';\r\n        kind = scanner.scan();\r\n        if (kind === 17 /* EOF */) {\r\n            break;\r\n        }\r\n        // Check that the scanner has advanced\r\n        if (offset === offsetDelta + scanner.getPosition()) {\r\n            throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\r\n        }\r\n        // In case we inserted /* or \" character, we need to\r\n        // adjust the offset of all tokens (except the first)\r\n        if (adjustOffset) {\r\n            offset -= numberOfInsertedCharacters;\r\n        }\r\n        adjustOffset = numberOfInsertedCharacters > 0;\r\n        // brackets and type\r\n        switch (kind) {\r\n            case 1 /* OpenBraceToken */:\r\n                type = TOKEN_DELIM_OBJECT;\r\n                lastWasColon = false;\r\n                break;\r\n            case 2 /* CloseBraceToken */:\r\n                type = TOKEN_DELIM_OBJECT;\r\n                lastWasColon = false;\r\n                break;\r\n            case 3 /* OpenBracketToken */:\r\n                type = TOKEN_DELIM_ARRAY;\r\n                lastWasColon = false;\r\n                break;\r\n            case 4 /* CloseBracketToken */:\r\n                type = TOKEN_DELIM_ARRAY;\r\n                lastWasColon = false;\r\n                break;\r\n            case 6 /* ColonToken */:\r\n                type = TOKEN_DELIM_COLON;\r\n                lastWasColon = true;\r\n                break;\r\n            case 5 /* CommaToken */:\r\n                type = TOKEN_DELIM_COMMA;\r\n                lastWasColon = false;\r\n                break;\r\n            case 8 /* TrueKeyword */:\r\n            case 9 /* FalseKeyword */:\r\n                type = TOKEN_VALUE_BOOLEAN;\r\n                lastWasColon = false;\r\n                break;\r\n            case 7 /* NullKeyword */:\r\n                type = TOKEN_VALUE_NULL;\r\n                lastWasColon = false;\r\n                break;\r\n            case 10 /* StringLiteral */:\r\n                type = lastWasColon ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\r\n                lastWasColon = false;\r\n                break;\r\n            case 11 /* NumericLiteral */:\r\n                type = TOKEN_VALUE_NUMBER;\r\n                lastWasColon = false;\r\n                break;\r\n        }\r\n        // comments, iff enabled\r\n        if (comments) {\r\n            switch (kind) {\r\n                case 12 /* LineCommentTrivia */:\r\n                    type = TOKEN_COMMENT_LINE;\r\n                    break;\r\n                case 13 /* BlockCommentTrivia */:\r\n                    type = TOKEN_COMMENT_BLOCK;\r\n                    break;\r\n            }\r\n        }\r\n        ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon);\r\n        ret.tokens.push({\r\n            startIndex: offset,\r\n            scopes: type\r\n        });\r\n    }\r\n    return ret;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}