{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { format, isEOL } from './format.js';\nimport { parseTree, findNodeAtLocation } from './parser.js';\nexport function removeProperty(text, path, formattingOptions) {\n  return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n  var _a;\n  var path = originalPath.slice();\n  var errors = [];\n  var root = parseTree(text, errors);\n  var parent = void 0;\n  var lastSegment = void 0;\n  while (path.length > 0) {\n    lastSegment = path.pop();\n    parent = findNodeAtLocation(root, path);\n    if (parent === void 0 && value !== void 0) {\n      if (typeof lastSegment === 'string') {\n        value = (_a = {}, _a[lastSegment] = value, _a);\n      } else {\n        value = [value];\n      }\n    } else {\n      break;\n    }\n  }\n  if (!parent) {\n    // empty document\n    if (value === void 0) {\n      // delete\n      throw new Error('Can not delete in empty document');\n    }\n    return withFormatting(text, {\n      offset: root ? root.offset : 0,\n      length: root ? root.length : 0,\n      content: JSON.stringify(value)\n    }, formattingOptions);\n  } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n    var existing = findNodeAtLocation(parent, [lastSegment]);\n    if (existing !== void 0) {\n      if (value === void 0) {\n        // delete\n        if (!existing.parent) {\n          throw new Error('Malformed AST');\n        }\n        var propertyIndex = parent.children.indexOf(existing.parent);\n        var removeBegin = void 0;\n        var removeEnd = existing.parent.offset + existing.parent.length;\n        if (propertyIndex > 0) {\n          // remove the comma of the previous node\n          var previous = parent.children[propertyIndex - 1];\n          removeBegin = previous.offset + previous.length;\n        } else {\n          removeBegin = parent.offset + 1;\n          if (parent.children.length > 1) {\n            // remove the comma of the next node\n            var next = parent.children[1];\n            removeEnd = next.offset;\n          }\n        }\n        return withFormatting(text, {\n          offset: removeBegin,\n          length: removeEnd - removeBegin,\n          content: ''\n        }, formattingOptions);\n      } else {\n        // set value of existing property\n        return withFormatting(text, {\n          offset: existing.offset,\n          length: existing.length,\n          content: JSON.stringify(value)\n        }, formattingOptions);\n      }\n    } else {\n      if (value === void 0) {\n        // delete\n        return []; // property does not exist, nothing to do\n      }\n\n      var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n      var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) {\n        return p.children[0].value;\n      })) : parent.children.length;\n      var edit = void 0;\n      if (index > 0) {\n        var previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      } else if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty + ','\n        };\n      }\n      return withFormatting(text, edit, formattingOptions);\n    }\n  } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n    var insertIndex = lastSegment;\n    if (insertIndex === -1) {\n      // Insert\n      var newProperty = \"\" + JSON.stringify(value);\n      var edit = void 0;\n      if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        var previous = parent.children[parent.children.length - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n      return withFormatting(text, edit, formattingOptions);\n    } else {\n      if (value === void 0 && parent.children.length >= 0) {\n        //Removal\n        var removalIndex = lastSegment;\n        var toRemove = parent.children[removalIndex];\n        var edit = void 0;\n        if (parent.children.length === 1) {\n          // only item\n          edit = {\n            offset: parent.offset + 1,\n            length: parent.length - 2,\n            content: ''\n          };\n        } else if (parent.children.length - 1 === removalIndex) {\n          // last item\n          var previous = parent.children[removalIndex - 1];\n          var offset = previous.offset + previous.length;\n          var parentEndOffset = parent.offset + parent.length;\n          edit = {\n            offset: offset,\n            length: parentEndOffset - 2 - offset,\n            content: ''\n          };\n        } else {\n          edit = {\n            offset: toRemove.offset,\n            length: parent.children[removalIndex + 1].offset - toRemove.offset,\n            content: ''\n          };\n        }\n        return withFormatting(text, edit, formattingOptions);\n      } else {\n        throw new Error('Array modification not supported yet');\n      }\n    }\n  } else {\n    throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n  }\n}\nfunction withFormatting(text, edit, formattingOptions) {\n  // apply the edit\n  var newText = applyEdit(text, edit);\n  // format the new text\n  var begin = edit.offset;\n  var end = edit.offset + edit.content.length;\n  if (edit.length === 0 || edit.content.length === 0) {\n    // insert or remove\n    while (begin > 0 && !isEOL(newText, begin - 1)) {\n      begin--;\n    }\n    while (end < newText.length && !isEOL(newText, end)) {\n      end++;\n    }\n  }\n  var edits = format(newText, {\n    offset: begin,\n    length: end - begin\n  }, formattingOptions);\n  // apply the formatting edits and track the begin and end offsets of the changes\n  for (var i = edits.length - 1; i >= 0; i--) {\n    var edit_1 = edits[i];\n    newText = applyEdit(newText, edit_1);\n    begin = Math.min(begin, edit_1.offset);\n    end = Math.max(end, edit_1.offset + edit_1.length);\n    end += edit_1.content.length - edit_1.length;\n  }\n  // create a single edit with all changes\n  var editLength = text.length - (newText.length - end) - begin;\n  return [{\n    offset: begin,\n    length: editLength,\n    content: newText.substring(begin, end)\n  }];\n}\nexport function applyEdit(text, edit) {\n  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n  return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"names":["format","isEOL","parseTree","findNodeAtLocation","removeProperty","text","path","formattingOptions","setProperty","originalPath","value","getInsertionIndex","_a","slice","errors","root","parent","lastSegment","length","pop","Error","withFormatting","offset","content","JSON","stringify","type","Array","isArray","children","existing","propertyIndex","indexOf","removeBegin","removeEnd","previous","next","newProperty","index","map","p","edit","insertIndex","removalIndex","toRemove","parentEndOffset","newText","applyEdit","begin","end","edits","i","edit_1","Math","min","max","editLength","substring","isWS","charAt"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/edit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format.js';\nimport { parseTree, findNodeAtLocation } from './parser.js';\nexport function removeProperty(text, path, formattingOptions) {\n    return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, formattingOptions);\n        }\n        else {\n            if (value === void 0 && parent.children.length >= 0) {\n                //Removal\n                var removalIndex = lastSegment;\n                var toRemove = parent.children[removalIndex];\n                var edit = void 0;\n                if (parent.children.length === 1) {\n                    // only item\n                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                }\n                else if (parent.children.length - 1 === removalIndex) {\n                    // last item\n                    var previous = parent.children[removalIndex - 1];\n                    var offset = previous.offset + previous.length;\n                    var parentEndOffset = parent.offset + parent.length;\n                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n                }\n                else {\n                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                throw new Error('Array modification not supported yet');\n            }\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n}\nfunction withFormatting(text, edit, formattingOptions) {\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}