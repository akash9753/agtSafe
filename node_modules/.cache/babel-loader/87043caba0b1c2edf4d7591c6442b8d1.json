{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nvar TextAreaState = /** @class */function () {\n  function TextAreaState(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n    this.value = value;\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n    this.selectionStartPosition = selectionStartPosition;\n    this.selectionEndPosition = selectionEndPosition;\n  }\n  TextAreaState.prototype.toString = function () {\n    return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\n  };\n  TextAreaState.readFromTextArea = function (textArea) {\n    return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n  };\n  TextAreaState.prototype.collapseSelection = function () {\n    return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n  };\n  TextAreaState.prototype.writeToTextArea = function (reason, textArea, select) {\n    // console.log(Date.now() + ': writeToTextArea ' + reason + ': ' + this.toString());\n    textArea.setValue(reason, this.value);\n    if (select) {\n      textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n    }\n  };\n  TextAreaState.prototype.deduceEditorPosition = function (offset) {\n    if (offset <= this.selectionStart) {\n      var str = this.value.substring(offset, this.selectionStart);\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n    }\n    if (offset >= this.selectionEnd) {\n      var str = this.value.substring(this.selectionEnd, offset);\n      return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\n    }\n    var str1 = this.value.substring(this.selectionStart, offset);\n    if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n      return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n    }\n    var str2 = this.value.substring(offset, this.selectionEnd);\n    return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n  };\n  TextAreaState.prototype._finishDeduceEditorPosition = function (anchor, deltaText, signum) {\n    var lineFeedCnt = 0;\n    var lastLineFeedIndex = -1;\n    while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n      lineFeedCnt++;\n    }\n    return [anchor, signum * deltaText.length, lineFeedCnt];\n  };\n  TextAreaState.selectedText = function (text) {\n    return new TextAreaState(text, 0, text.length, null, null);\n  };\n  TextAreaState.deduceInput = function (previousState, currentState, couldBeEmojiInput) {\n    if (!previousState) {\n      // This is the EMPTY state\n      return {\n        text: '',\n        replaceCharCnt: 0\n      };\n    }\n    // console.log('------------------------deduceInput');\n    // console.log('PREVIOUS STATE: ' + previousState.toString());\n    // console.log('CURRENT STATE: ' + currentState.toString());\n    var previousValue = previousState.value;\n    var previousSelectionStart = previousState.selectionStart;\n    var previousSelectionEnd = previousState.selectionEnd;\n    var currentValue = currentState.value;\n    var currentSelectionStart = currentState.selectionStart;\n    var currentSelectionEnd = currentState.selectionEnd;\n    // Strip the previous suffix from the value (without interfering with the current selection)\n    var previousSuffix = previousValue.substring(previousSelectionEnd);\n    var currentSuffix = currentValue.substring(currentSelectionEnd);\n    var suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\n    currentValue = currentValue.substring(0, currentValue.length - suffixLength);\n    previousValue = previousValue.substring(0, previousValue.length - suffixLength);\n    var previousPrefix = previousValue.substring(0, previousSelectionStart);\n    var currentPrefix = currentValue.substring(0, currentSelectionStart);\n    var prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\n    currentValue = currentValue.substring(prefixLength);\n    previousValue = previousValue.substring(prefixLength);\n    currentSelectionStart -= prefixLength;\n    previousSelectionStart -= prefixLength;\n    currentSelectionEnd -= prefixLength;\n    previousSelectionEnd -= prefixLength;\n    // console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n    // console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n    if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\n      // on OSX, emojis from the emoji picker are inserted at random locations\n      // the only hints we can use is that the selection is immediately after the inserted emoji\n      // and that none of the old text has been deleted\n      var potentialEmojiInput = null;\n      if (currentSelectionStart === currentValue.length) {\n        // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\n        if (strings.startsWith(currentValue, previousValue)) {\n          // only if all of the old text is accounted for\n          potentialEmojiInput = currentValue.substring(previousValue.length);\n        }\n      } else {\n        // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\n        if (strings.endsWith(currentValue, previousValue)) {\n          // only if all of the old text is accounted for\n          potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\n        }\n      }\n      if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\n        // now we check that this is indeed an emoji\n        // emojis can grow quite long, so a length check is of no help\n        // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ England\n        // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\n        // http://emojipedia.org/variation-selector-16/\n        // > An invisible codepoint which specifies that the preceding character\n        // > should be displayed with emoji presentation. Only required if the\n        // > preceding character defaults to text presentation.\n        if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\n          return {\n            text: potentialEmojiInput,\n            replaceCharCnt: 0\n          };\n        }\n      }\n    }\n    if (currentSelectionStart === currentSelectionEnd) {\n      // composition accept case (noticed in FF + Japanese)\n      // [blahblah] => blahblah|\n      if (previousValue === currentValue && previousSelectionStart === 0 && previousSelectionEnd === previousValue.length && currentSelectionStart === currentValue.length && currentValue.indexOf('\\n') === -1) {\n        if (strings.containsFullWidthCharacter(currentValue)) {\n          return {\n            text: '',\n            replaceCharCnt: 0\n          };\n        }\n      }\n      // no current selection\n      var replacePreviousCharacters_1 = previousPrefix.length - prefixLength;\n      // console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\n      return {\n        text: currentValue,\n        replaceCharCnt: replacePreviousCharacters_1\n      };\n    }\n    // there is a current selection => composition case\n    var replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n    return {\n      text: currentValue,\n      replaceCharCnt: replacePreviousCharacters\n    };\n  };\n  TextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\n  return TextAreaState;\n}();\nexport { TextAreaState };\nvar PagedScreenReaderStrategy = /** @class */function () {\n  function PagedScreenReaderStrategy() {}\n  PagedScreenReaderStrategy._getPageOfLine = function (lineNumber, linesPerPage) {\n    return Math.floor((lineNumber - 1) / linesPerPage);\n  };\n  PagedScreenReaderStrategy._getRangeForPage = function (page, linesPerPage) {\n    var offset = page * linesPerPage;\n    var startLineNumber = offset + 1;\n    var endLineNumber = offset + linesPerPage;\n    return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n  };\n  PagedScreenReaderStrategy.fromEditorSelection = function (previousState, model, selection, linesPerPage, trimLongText) {\n    var selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n    var selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n    var selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n    var selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n    var pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n    var pretext = model.getValueInRange(pretextRange, 1 /* LF */);\n    var lastLine = model.getLineCount();\n    var lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n    var posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n    var posttext = model.getValueInRange(posttextRange, 1 /* LF */);\n    var text;\n    if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n      // take full selection\n      text = model.getValueInRange(selection, 1 /* LF */);\n    } else {\n      var selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n      var selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n      text = model.getValueInRange(selectionRange1, 1 /* LF */) + String.fromCharCode(8230) + model.getValueInRange(selectionRange2, 1 /* LF */);\n    }\n    // Chromium handles very poorly text even of a few thousand chars\n    // Cut text to avoid stalling the entire UI\n    if (trimLongText) {\n      var LIMIT_CHARS = 500;\n      if (pretext.length > LIMIT_CHARS) {\n        pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n      }\n      if (posttext.length > LIMIT_CHARS) {\n        posttext = posttext.substring(0, LIMIT_CHARS);\n      }\n      if (text.length > 2 * LIMIT_CHARS) {\n        text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n      }\n    }\n    return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n  };\n  return PagedScreenReaderStrategy;\n}();\nexport { PagedScreenReaderStrategy };","map":{"version":3,"names":["strings","Position","Range","TextAreaState","value","selectionStart","selectionEnd","selectionStartPosition","selectionEndPosition","prototype","toString","readFromTextArea","textArea","getValue","getSelectionStart","getSelectionEnd","collapseSelection","length","writeToTextArea","reason","select","setValue","setSelectionRange","deduceEditorPosition","offset","str","substring","_finishDeduceEditorPosition","str1","indexOf","String","fromCharCode","str2","anchor","deltaText","signum","lineFeedCnt","lastLineFeedIndex","selectedText","text","deduceInput","previousState","currentState","couldBeEmojiInput","replaceCharCnt","previousValue","previousSelectionStart","previousSelectionEnd","currentValue","currentSelectionStart","currentSelectionEnd","previousSuffix","currentSuffix","suffixLength","commonSuffixLength","previousPrefix","currentPrefix","prefixLength","commonPrefixLength","potentialEmojiInput","startsWith","endsWith","test","containsEmoji","containsFullWidthCharacter","replacePreviousCharacters_1","replacePreviousCharacters","EMPTY","PagedScreenReaderStrategy","_getPageOfLine","lineNumber","linesPerPage","Math","floor","_getRangeForPage","page","startLineNumber","endLineNumber","fromEditorSelection","model","selection","trimLongText","selectionStartPage","selectionStartPageRange","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttext","selectionRange1","selectionRange2","LIMIT_CHARS"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nvar TextAreaState = /** @class */ (function () {\r\n    function TextAreaState(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\r\n        this.value = value;\r\n        this.selectionStart = selectionStart;\r\n        this.selectionEnd = selectionEnd;\r\n        this.selectionStartPosition = selectionStartPosition;\r\n        this.selectionEndPosition = selectionEndPosition;\r\n    }\r\n    TextAreaState.prototype.toString = function () {\r\n        return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\r\n    };\r\n    TextAreaState.readFromTextArea = function (textArea) {\r\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\r\n    };\r\n    TextAreaState.prototype.collapseSelection = function () {\r\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\r\n    };\r\n    TextAreaState.prototype.writeToTextArea = function (reason, textArea, select) {\r\n        // console.log(Date.now() + ': writeToTextArea ' + reason + ': ' + this.toString());\r\n        textArea.setValue(reason, this.value);\r\n        if (select) {\r\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\r\n        }\r\n    };\r\n    TextAreaState.prototype.deduceEditorPosition = function (offset) {\r\n        if (offset <= this.selectionStart) {\r\n            var str = this.value.substring(offset, this.selectionStart);\r\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\r\n        }\r\n        if (offset >= this.selectionEnd) {\r\n            var str = this.value.substring(this.selectionEnd, offset);\r\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\r\n        }\r\n        var str1 = this.value.substring(this.selectionStart, offset);\r\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\r\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\r\n        }\r\n        var str2 = this.value.substring(offset, this.selectionEnd);\r\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\r\n    };\r\n    TextAreaState.prototype._finishDeduceEditorPosition = function (anchor, deltaText, signum) {\r\n        var lineFeedCnt = 0;\r\n        var lastLineFeedIndex = -1;\r\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\r\n            lineFeedCnt++;\r\n        }\r\n        return [anchor, signum * deltaText.length, lineFeedCnt];\r\n    };\r\n    TextAreaState.selectedText = function (text) {\r\n        return new TextAreaState(text, 0, text.length, null, null);\r\n    };\r\n    TextAreaState.deduceInput = function (previousState, currentState, couldBeEmojiInput) {\r\n        if (!previousState) {\r\n            // This is the EMPTY state\r\n            return {\r\n                text: '',\r\n                replaceCharCnt: 0\r\n            };\r\n        }\r\n        // console.log('------------------------deduceInput');\r\n        // console.log('PREVIOUS STATE: ' + previousState.toString());\r\n        // console.log('CURRENT STATE: ' + currentState.toString());\r\n        var previousValue = previousState.value;\r\n        var previousSelectionStart = previousState.selectionStart;\r\n        var previousSelectionEnd = previousState.selectionEnd;\r\n        var currentValue = currentState.value;\r\n        var currentSelectionStart = currentState.selectionStart;\r\n        var currentSelectionEnd = currentState.selectionEnd;\r\n        // Strip the previous suffix from the value (without interfering with the current selection)\r\n        var previousSuffix = previousValue.substring(previousSelectionEnd);\r\n        var currentSuffix = currentValue.substring(currentSelectionEnd);\r\n        var suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\r\n        currentValue = currentValue.substring(0, currentValue.length - suffixLength);\r\n        previousValue = previousValue.substring(0, previousValue.length - suffixLength);\r\n        var previousPrefix = previousValue.substring(0, previousSelectionStart);\r\n        var currentPrefix = currentValue.substring(0, currentSelectionStart);\r\n        var prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\r\n        currentValue = currentValue.substring(prefixLength);\r\n        previousValue = previousValue.substring(prefixLength);\r\n        currentSelectionStart -= prefixLength;\r\n        previousSelectionStart -= prefixLength;\r\n        currentSelectionEnd -= prefixLength;\r\n        previousSelectionEnd -= prefixLength;\r\n        // console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\r\n        // console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\r\n        if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\r\n            // on OSX, emojis from the emoji picker are inserted at random locations\r\n            // the only hints we can use is that the selection is immediately after the inserted emoji\r\n            // and that none of the old text has been deleted\r\n            var potentialEmojiInput = null;\r\n            if (currentSelectionStart === currentValue.length) {\r\n                // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\r\n                if (strings.startsWith(currentValue, previousValue)) {\r\n                    // only if all of the old text is accounted for\r\n                    potentialEmojiInput = currentValue.substring(previousValue.length);\r\n                }\r\n            }\r\n            else {\r\n                // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\r\n                if (strings.endsWith(currentValue, previousValue)) {\r\n                    // only if all of the old text is accounted for\r\n                    potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\r\n                }\r\n            }\r\n            if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\r\n                // now we check that this is indeed an emoji\r\n                // emojis can grow quite long, so a length check is of no help\r\n                // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ England\r\n                // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\r\n                // http://emojipedia.org/variation-selector-16/\r\n                // > An invisible codepoint which specifies that the preceding character\r\n                // > should be displayed with emoji presentation. Only required if the\r\n                // > preceding character defaults to text presentation.\r\n                if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\r\n                    return {\r\n                        text: potentialEmojiInput,\r\n                        replaceCharCnt: 0\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        if (currentSelectionStart === currentSelectionEnd) {\r\n            // composition accept case (noticed in FF + Japanese)\r\n            // [blahblah] => blahblah|\r\n            if (previousValue === currentValue\r\n                && previousSelectionStart === 0\r\n                && previousSelectionEnd === previousValue.length\r\n                && currentSelectionStart === currentValue.length\r\n                && currentValue.indexOf('\\n') === -1) {\r\n                if (strings.containsFullWidthCharacter(currentValue)) {\r\n                    return {\r\n                        text: '',\r\n                        replaceCharCnt: 0\r\n                    };\r\n                }\r\n            }\r\n            // no current selection\r\n            var replacePreviousCharacters_1 = (previousPrefix.length - prefixLength);\r\n            // console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\r\n            return {\r\n                text: currentValue,\r\n                replaceCharCnt: replacePreviousCharacters_1\r\n            };\r\n        }\r\n        // there is a current selection => composition case\r\n        var replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\r\n        return {\r\n            text: currentValue,\r\n            replaceCharCnt: replacePreviousCharacters\r\n        };\r\n    };\r\n    TextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\r\n    return TextAreaState;\r\n}());\r\nexport { TextAreaState };\r\nvar PagedScreenReaderStrategy = /** @class */ (function () {\r\n    function PagedScreenReaderStrategy() {\r\n    }\r\n    PagedScreenReaderStrategy._getPageOfLine = function (lineNumber, linesPerPage) {\r\n        return Math.floor((lineNumber - 1) / linesPerPage);\r\n    };\r\n    PagedScreenReaderStrategy._getRangeForPage = function (page, linesPerPage) {\r\n        var offset = page * linesPerPage;\r\n        var startLineNumber = offset + 1;\r\n        var endLineNumber = offset + linesPerPage;\r\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\r\n    };\r\n    PagedScreenReaderStrategy.fromEditorSelection = function (previousState, model, selection, linesPerPage, trimLongText) {\r\n        var selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\r\n        var selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\r\n        var selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\r\n        var selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\r\n        var pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\r\n        var pretext = model.getValueInRange(pretextRange, 1 /* LF */);\r\n        var lastLine = model.getLineCount();\r\n        var lastLineMaxColumn = model.getLineMaxColumn(lastLine);\r\n        var posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\r\n        var posttext = model.getValueInRange(posttextRange, 1 /* LF */);\r\n        var text;\r\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\r\n            // take full selection\r\n            text = model.getValueInRange(selection, 1 /* LF */);\r\n        }\r\n        else {\r\n            var selectionRange1 = selectionStartPageRange.intersectRanges(selection);\r\n            var selectionRange2 = selectionEndPageRange.intersectRanges(selection);\r\n            text = (model.getValueInRange(selectionRange1, 1 /* LF */)\r\n                + String.fromCharCode(8230)\r\n                + model.getValueInRange(selectionRange2, 1 /* LF */));\r\n        }\r\n        // Chromium handles very poorly text even of a few thousand chars\r\n        // Cut text to avoid stalling the entire UI\r\n        if (trimLongText) {\r\n            var LIMIT_CHARS = 500;\r\n            if (pretext.length > LIMIT_CHARS) {\r\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\r\n            }\r\n            if (posttext.length > LIMIT_CHARS) {\r\n                posttext = posttext.substring(0, LIMIT_CHARS);\r\n            }\r\n            if (text.length > 2 * LIMIT_CHARS) {\r\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\r\n            }\r\n        }\r\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\r\n    };\r\n    return PagedScreenReaderStrategy;\r\n}());\r\nexport { PagedScreenReaderStrategy };\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,iCAAiC;AAC1D,SAASC,QAAQ,QAAQ,+BAA+B;AACxD,SAASC,KAAK,QAAQ,4BAA4B;AAClD,IAAIC,aAAa,GAAG,aAAe,YAAY;EAC3C,SAASA,aAAa,CAACC,KAAK,EAAEC,cAAc,EAAEC,YAAY,EAAEC,sBAAsB,EAAEC,oBAAoB,EAAE;IACtG,IAAI,CAACJ,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,sBAAsB,GAAGA,sBAAsB;IACpD,IAAI,CAACC,oBAAoB,GAAGA,oBAAoB;EACpD;EACAL,aAAa,CAACM,SAAS,CAACC,QAAQ,GAAG,YAAY;IAC3C,OAAO,KAAK,GAAG,IAAI,CAACN,KAAK,GAAG,qBAAqB,GAAG,IAAI,CAACC,cAAc,GAAG,kBAAkB,GAAG,IAAI,CAACC,YAAY,GAAG,GAAG;EAC1H,CAAC;EACDH,aAAa,CAACQ,gBAAgB,GAAG,UAAUC,QAAQ,EAAE;IACjD,OAAO,IAAIT,aAAa,CAACS,QAAQ,CAACC,QAAQ,EAAE,EAAED,QAAQ,CAACE,iBAAiB,EAAE,EAAEF,QAAQ,CAACG,eAAe,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC;EACvH,CAAC;EACDZ,aAAa,CAACM,SAAS,CAACO,iBAAiB,GAAG,YAAY;IACpD,OAAO,IAAIb,aAAa,CAAC,IAAI,CAACC,KAAK,EAAE,IAAI,CAACA,KAAK,CAACa,MAAM,EAAE,IAAI,CAACb,KAAK,CAACa,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC;EAC1F,CAAC;EACDd,aAAa,CAACM,SAAS,CAACS,eAAe,GAAG,UAAUC,MAAM,EAAEP,QAAQ,EAAEQ,MAAM,EAAE;IAC1E;IACAR,QAAQ,CAACS,QAAQ,CAACF,MAAM,EAAE,IAAI,CAACf,KAAK,CAAC;IACrC,IAAIgB,MAAM,EAAE;MACRR,QAAQ,CAACU,iBAAiB,CAACH,MAAM,EAAE,IAAI,CAACd,cAAc,EAAE,IAAI,CAACC,YAAY,CAAC;IAC9E;EACJ,CAAC;EACDH,aAAa,CAACM,SAAS,CAACc,oBAAoB,GAAG,UAAUC,MAAM,EAAE;IAC7D,IAAIA,MAAM,IAAI,IAAI,CAACnB,cAAc,EAAE;MAC/B,IAAIoB,GAAG,GAAG,IAAI,CAACrB,KAAK,CAACsB,SAAS,CAACF,MAAM,EAAE,IAAI,CAACnB,cAAc,CAAC;MAC3D,OAAO,IAAI,CAACsB,2BAA2B,CAAC,IAAI,CAACpB,sBAAsB,EAAEkB,GAAG,EAAE,CAAC,CAAC,CAAC;IACjF;IACA,IAAID,MAAM,IAAI,IAAI,CAAClB,YAAY,EAAE;MAC7B,IAAImB,GAAG,GAAG,IAAI,CAACrB,KAAK,CAACsB,SAAS,CAAC,IAAI,CAACpB,YAAY,EAAEkB,MAAM,CAAC;MACzD,OAAO,IAAI,CAACG,2BAA2B,CAAC,IAAI,CAACnB,oBAAoB,EAAEiB,GAAG,EAAE,CAAC,CAAC;IAC9E;IACA,IAAIG,IAAI,GAAG,IAAI,CAACxB,KAAK,CAACsB,SAAS,CAAC,IAAI,CAACrB,cAAc,EAAEmB,MAAM,CAAC;IAC5D,IAAII,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,YAAY,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;MAChD,OAAO,IAAI,CAACJ,2BAA2B,CAAC,IAAI,CAACpB,sBAAsB,EAAEqB,IAAI,EAAE,CAAC,CAAC;IACjF;IACA,IAAII,IAAI,GAAG,IAAI,CAAC5B,KAAK,CAACsB,SAAS,CAACF,MAAM,EAAE,IAAI,CAAClB,YAAY,CAAC;IAC1D,OAAO,IAAI,CAACqB,2BAA2B,CAAC,IAAI,CAACnB,oBAAoB,EAAEwB,IAAI,EAAE,CAAC,CAAC,CAAC;EAChF,CAAC;EACD7B,aAAa,CAACM,SAAS,CAACkB,2BAA2B,GAAG,UAAUM,MAAM,EAAEC,SAAS,EAAEC,MAAM,EAAE;IACvF,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,iBAAiB,GAAG,CAAC,CAAC;IAC1B,OAAO,CAACA,iBAAiB,GAAGH,SAAS,CAACL,OAAO,CAAC,IAAI,EAAEQ,iBAAiB,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;MAChFD,WAAW,EAAE;IACjB;IACA,OAAO,CAACH,MAAM,EAAEE,MAAM,GAAGD,SAAS,CAACjB,MAAM,EAAEmB,WAAW,CAAC;EAC3D,CAAC;EACDjC,aAAa,CAACmC,YAAY,GAAG,UAAUC,IAAI,EAAE;IACzC,OAAO,IAAIpC,aAAa,CAACoC,IAAI,EAAE,CAAC,EAAEA,IAAI,CAACtB,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC;EAC9D,CAAC;EACDd,aAAa,CAACqC,WAAW,GAAG,UAAUC,aAAa,EAAEC,YAAY,EAAEC,iBAAiB,EAAE;IAClF,IAAI,CAACF,aAAa,EAAE;MAChB;MACA,OAAO;QACHF,IAAI,EAAE,EAAE;QACRK,cAAc,EAAE;MACpB,CAAC;IACL;IACA;IACA;IACA;IACA,IAAIC,aAAa,GAAGJ,aAAa,CAACrC,KAAK;IACvC,IAAI0C,sBAAsB,GAAGL,aAAa,CAACpC,cAAc;IACzD,IAAI0C,oBAAoB,GAAGN,aAAa,CAACnC,YAAY;IACrD,IAAI0C,YAAY,GAAGN,YAAY,CAACtC,KAAK;IACrC,IAAI6C,qBAAqB,GAAGP,YAAY,CAACrC,cAAc;IACvD,IAAI6C,mBAAmB,GAAGR,YAAY,CAACpC,YAAY;IACnD;IACA,IAAI6C,cAAc,GAAGN,aAAa,CAACnB,SAAS,CAACqB,oBAAoB,CAAC;IAClE,IAAIK,aAAa,GAAGJ,YAAY,CAACtB,SAAS,CAACwB,mBAAmB,CAAC;IAC/D,IAAIG,YAAY,GAAGrD,OAAO,CAACsD,kBAAkB,CAACH,cAAc,EAAEC,aAAa,CAAC;IAC5EJ,YAAY,GAAGA,YAAY,CAACtB,SAAS,CAAC,CAAC,EAAEsB,YAAY,CAAC/B,MAAM,GAAGoC,YAAY,CAAC;IAC5ER,aAAa,GAAGA,aAAa,CAACnB,SAAS,CAAC,CAAC,EAAEmB,aAAa,CAAC5B,MAAM,GAAGoC,YAAY,CAAC;IAC/E,IAAIE,cAAc,GAAGV,aAAa,CAACnB,SAAS,CAAC,CAAC,EAAEoB,sBAAsB,CAAC;IACvE,IAAIU,aAAa,GAAGR,YAAY,CAACtB,SAAS,CAAC,CAAC,EAAEuB,qBAAqB,CAAC;IACpE,IAAIQ,YAAY,GAAGzD,OAAO,CAAC0D,kBAAkB,CAACH,cAAc,EAAEC,aAAa,CAAC;IAC5ER,YAAY,GAAGA,YAAY,CAACtB,SAAS,CAAC+B,YAAY,CAAC;IACnDZ,aAAa,GAAGA,aAAa,CAACnB,SAAS,CAAC+B,YAAY,CAAC;IACrDR,qBAAqB,IAAIQ,YAAY;IACrCX,sBAAsB,IAAIW,YAAY;IACtCP,mBAAmB,IAAIO,YAAY;IACnCV,oBAAoB,IAAIU,YAAY;IACpC;IACA;IACA,IAAId,iBAAiB,IAAIM,qBAAqB,KAAKC,mBAAmB,IAAIL,aAAa,CAAC5B,MAAM,GAAG,CAAC,EAAE;MAChG;MACA;MACA;MACA,IAAI0C,mBAAmB,GAAG,IAAI;MAC9B,IAAIV,qBAAqB,KAAKD,YAAY,CAAC/B,MAAM,EAAE;QAC/C;QACA,IAAIjB,OAAO,CAAC4D,UAAU,CAACZ,YAAY,EAAEH,aAAa,CAAC,EAAE;UACjD;UACAc,mBAAmB,GAAGX,YAAY,CAACtB,SAAS,CAACmB,aAAa,CAAC5B,MAAM,CAAC;QACtE;MACJ,CAAC,MACI;QACD;QACA,IAAIjB,OAAO,CAAC6D,QAAQ,CAACb,YAAY,EAAEH,aAAa,CAAC,EAAE;UAC/C;UACAc,mBAAmB,GAAGX,YAAY,CAACtB,SAAS,CAAC,CAAC,EAAEsB,YAAY,CAAC/B,MAAM,GAAG4B,aAAa,CAAC5B,MAAM,CAAC;QAC/F;MACJ;MACA,IAAI0C,mBAAmB,KAAK,IAAI,IAAIA,mBAAmB,CAAC1C,MAAM,GAAG,CAAC,EAAE;QAChE;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI,QAAQ,CAAC6C,IAAI,CAACH,mBAAmB,CAAC,IAAI3D,OAAO,CAAC+D,aAAa,CAACJ,mBAAmB,CAAC,EAAE;UAClF,OAAO;YACHpB,IAAI,EAAEoB,mBAAmB;YACzBf,cAAc,EAAE;UACpB,CAAC;QACL;MACJ;IACJ;IACA,IAAIK,qBAAqB,KAAKC,mBAAmB,EAAE;MAC/C;MACA;MACA,IAAIL,aAAa,KAAKG,YAAY,IAC3BF,sBAAsB,KAAK,CAAC,IAC5BC,oBAAoB,KAAKF,aAAa,CAAC5B,MAAM,IAC7CgC,qBAAqB,KAAKD,YAAY,CAAC/B,MAAM,IAC7C+B,YAAY,CAACnB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;QACtC,IAAI7B,OAAO,CAACgE,0BAA0B,CAAChB,YAAY,CAAC,EAAE;UAClD,OAAO;YACHT,IAAI,EAAE,EAAE;YACRK,cAAc,EAAE;UACpB,CAAC;QACL;MACJ;MACA;MACA,IAAIqB,2BAA2B,GAAIV,cAAc,CAACtC,MAAM,GAAGwC,YAAa;MACxE;MACA,OAAO;QACHlB,IAAI,EAAES,YAAY;QAClBJ,cAAc,EAAEqB;MACpB,CAAC;IACL;IACA;IACA,IAAIC,yBAAyB,GAAGnB,oBAAoB,GAAGD,sBAAsB;IAC7E,OAAO;MACHP,IAAI,EAAES,YAAY;MAClBJ,cAAc,EAAEsB;IACpB,CAAC;EACL,CAAC;EACD/D,aAAa,CAACgE,KAAK,GAAG,IAAIhE,aAAa,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;EAC7D,OAAOA,aAAa;AACxB,CAAC,EAAG;AACJ,SAASA,aAAa;AACtB,IAAIiE,yBAAyB,GAAG,aAAe,YAAY;EACvD,SAASA,yBAAyB,GAAG,CACrC;EACAA,yBAAyB,CAACC,cAAc,GAAG,UAAUC,UAAU,EAAEC,YAAY,EAAE;IAC3E,OAAOC,IAAI,CAACC,KAAK,CAAC,CAACH,UAAU,GAAG,CAAC,IAAIC,YAAY,CAAC;EACtD,CAAC;EACDH,yBAAyB,CAACM,gBAAgB,GAAG,UAAUC,IAAI,EAAEJ,YAAY,EAAE;IACvE,IAAI/C,MAAM,GAAGmD,IAAI,GAAGJ,YAAY;IAChC,IAAIK,eAAe,GAAGpD,MAAM,GAAG,CAAC;IAChC,IAAIqD,aAAa,GAAGrD,MAAM,GAAG+C,YAAY;IACzC,OAAO,IAAIrE,KAAK,CAAC0E,eAAe,EAAE,CAAC,EAAEC,aAAa,GAAG,CAAC,EAAE,CAAC,CAAC;EAC9D,CAAC;EACDT,yBAAyB,CAACU,mBAAmB,GAAG,UAAUrC,aAAa,EAAEsC,KAAK,EAAEC,SAAS,EAAET,YAAY,EAAEU,YAAY,EAAE;IACnH,IAAIC,kBAAkB,GAAGd,yBAAyB,CAACC,cAAc,CAACW,SAAS,CAACJ,eAAe,EAAEL,YAAY,CAAC;IAC1G,IAAIY,uBAAuB,GAAGf,yBAAyB,CAACM,gBAAgB,CAACQ,kBAAkB,EAAEX,YAAY,CAAC;IAC1G,IAAIa,gBAAgB,GAAGhB,yBAAyB,CAACC,cAAc,CAACW,SAAS,CAACH,aAAa,EAAEN,YAAY,CAAC;IACtG,IAAIc,qBAAqB,GAAGjB,yBAAyB,CAACM,gBAAgB,CAACU,gBAAgB,EAAEb,YAAY,CAAC;IACtG,IAAIe,YAAY,GAAGH,uBAAuB,CAACI,eAAe,CAAC,IAAIrF,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE8E,SAAS,CAACJ,eAAe,EAAEI,SAAS,CAACQ,WAAW,CAAC,CAAC;IAC7H,IAAIC,OAAO,GAAGV,KAAK,CAACW,eAAe,CAACJ,YAAY,EAAE,CAAC,CAAC,SAAS;IAC7D,IAAIK,QAAQ,GAAGZ,KAAK,CAACa,YAAY,EAAE;IACnC,IAAIC,iBAAiB,GAAGd,KAAK,CAACe,gBAAgB,CAACH,QAAQ,CAAC;IACxD,IAAII,aAAa,GAAGV,qBAAqB,CAACE,eAAe,CAAC,IAAIrF,KAAK,CAAC8E,SAAS,CAACH,aAAa,EAAEG,SAAS,CAACgB,SAAS,EAAEL,QAAQ,EAAEE,iBAAiB,CAAC,CAAC;IAC/I,IAAII,QAAQ,GAAGlB,KAAK,CAACW,eAAe,CAACK,aAAa,EAAE,CAAC,CAAC,SAAS;IAC/D,IAAIxD,IAAI;IACR,IAAI2C,kBAAkB,KAAKE,gBAAgB,IAAIF,kBAAkB,GAAG,CAAC,KAAKE,gBAAgB,EAAE;MACxF;MACA7C,IAAI,GAAGwC,KAAK,CAACW,eAAe,CAACV,SAAS,EAAE,CAAC,CAAC,SAAS;IACvD,CAAC,MACI;MACD,IAAIkB,eAAe,GAAGf,uBAAuB,CAACI,eAAe,CAACP,SAAS,CAAC;MACxE,IAAImB,eAAe,GAAGd,qBAAqB,CAACE,eAAe,CAACP,SAAS,CAAC;MACtEzC,IAAI,GAAIwC,KAAK,CAACW,eAAe,CAACQ,eAAe,EAAE,CAAC,CAAC,SAAS,GACpDpE,MAAM,CAACC,YAAY,CAAC,IAAI,CAAC,GACzBgD,KAAK,CAACW,eAAe,CAACS,eAAe,EAAE,CAAC,CAAC,SAAU;IAC7D;IACA;IACA;IACA,IAAIlB,YAAY,EAAE;MACd,IAAImB,WAAW,GAAG,GAAG;MACrB,IAAIX,OAAO,CAACxE,MAAM,GAAGmF,WAAW,EAAE;QAC9BX,OAAO,GAAGA,OAAO,CAAC/D,SAAS,CAAC+D,OAAO,CAACxE,MAAM,GAAGmF,WAAW,EAAEX,OAAO,CAACxE,MAAM,CAAC;MAC7E;MACA,IAAIgF,QAAQ,CAAChF,MAAM,GAAGmF,WAAW,EAAE;QAC/BH,QAAQ,GAAGA,QAAQ,CAACvE,SAAS,CAAC,CAAC,EAAE0E,WAAW,CAAC;MACjD;MACA,IAAI7D,IAAI,CAACtB,MAAM,GAAG,CAAC,GAAGmF,WAAW,EAAE;QAC/B7D,IAAI,GAAGA,IAAI,CAACb,SAAS,CAAC,CAAC,EAAE0E,WAAW,CAAC,GAAGtE,MAAM,CAACC,YAAY,CAAC,IAAI,CAAC,GAAGQ,IAAI,CAACb,SAAS,CAACa,IAAI,CAACtB,MAAM,GAAGmF,WAAW,EAAE7D,IAAI,CAACtB,MAAM,CAAC;MAC9H;IACJ;IACA,OAAO,IAAId,aAAa,CAACsF,OAAO,GAAGlD,IAAI,GAAG0D,QAAQ,EAAER,OAAO,CAACxE,MAAM,EAAEwE,OAAO,CAACxE,MAAM,GAAGsB,IAAI,CAACtB,MAAM,EAAE,IAAIhB,QAAQ,CAAC+E,SAAS,CAACJ,eAAe,EAAEI,SAAS,CAACQ,WAAW,CAAC,EAAE,IAAIvF,QAAQ,CAAC+E,SAAS,CAACH,aAAa,EAAEG,SAAS,CAACgB,SAAS,CAAC,CAAC;EACjO,CAAC;EACD,OAAO5B,yBAAyB;AACpC,CAAC,EAAG;AACJ,SAASA,yBAAyB"},"metadata":{},"sourceType":"module"}