{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { TokenType, Scanner } from '../parser/cssScanner.js';\nimport { SCSSScanner, InterpolationFunction } from '../parser/scssScanner.js';\nimport { LESSScanner } from '../parser/lessScanner.js';\nexport function getFoldingRanges(document, context) {\n  var ranges = computeFoldingRanges(document);\n  return limitFoldingRanges(ranges, context);\n}\nfunction computeFoldingRanges(document) {\n  function getStartLine(t) {\n    return document.positionAt(t.offset).line;\n  }\n  function getEndLine(t) {\n    return document.positionAt(t.offset + t.len).line;\n  }\n  function getScanner() {\n    switch (document.languageId) {\n      case 'scss':\n        return new SCSSScanner();\n      case 'less':\n        return new LESSScanner();\n      default:\n        return new Scanner();\n    }\n  }\n  function tokenToRange(t, kind) {\n    var startLine = getStartLine(t);\n    var endLine = getEndLine(t);\n    if (startLine !== endLine) {\n      return {\n        startLine: startLine,\n        endLine: endLine,\n        kind: kind\n      };\n    } else {\n      return null;\n    }\n  }\n  var ranges = [];\n  var delimiterStack = [];\n  var scanner = getScanner();\n  scanner.ignoreComment = false;\n  scanner.setSource(document.getText());\n  var token = scanner.scan();\n  var prevToken = null;\n  var _loop_1 = function _loop_1() {\n    switch (token.type) {\n      case TokenType.CurlyL:\n      case InterpolationFunction:\n        {\n          delimiterStack.push({\n            line: getStartLine(token),\n            type: 'brace',\n            isStart: true\n          });\n          break;\n        }\n      case TokenType.CurlyR:\n        {\n          if (delimiterStack.length !== 0) {\n            var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'brace');\n            if (!prevDelimiter) {\n              break;\n            }\n            var endLine = getEndLine(token);\n            if (prevDelimiter.type === 'brace') {\n              /**\n               * Other than the case when curly brace is not on a new line by itself, for example\n               * .foo {\n               *   color: red; }\n               * Use endLine minus one to show ending curly brace\n               */\n              if (prevToken && getEndLine(prevToken) !== endLine) {\n                endLine--;\n              }\n              if (prevDelimiter.line !== endLine) {\n                ranges.push({\n                  startLine: prevDelimiter.line,\n                  endLine: endLine,\n                  kind: undefined\n                });\n              }\n            }\n          }\n          break;\n        }\n      /**\n       * In CSS, there is no single line comment prefixed with //\n       * All comments are marked as `Comment`\n       */\n      case TokenType.Comment:\n        {\n          var commentRegionMarkerToDelimiter_1 = function commentRegionMarkerToDelimiter_1(marker) {\n            if (marker === '#region') {\n              return {\n                line: getStartLine(token),\n                type: 'comment',\n                isStart: true\n              };\n            } else {\n              return {\n                line: getEndLine(token),\n                type: 'comment',\n                isStart: false\n              };\n            }\n          };\n          var getCurrDelimiter = function getCurrDelimiter(token) {\n            var matches = token.text.match(/^\\s*\\/\\*\\s*(#region|#endregion)\\b\\s*(.*?)\\s*\\*\\//);\n            if (matches) {\n              return commentRegionMarkerToDelimiter_1(matches[1]);\n            } else if (document.languageId === 'scss' || document.languageId === 'less') {\n              var matches_1 = token.text.match(/^\\s*\\/\\/\\s*(#region|#endregion)\\b\\s*(.*?)\\s*/);\n              if (matches_1) {\n                return commentRegionMarkerToDelimiter_1(matches_1[1]);\n              }\n            }\n            return null;\n          };\n          var currDelimiter = getCurrDelimiter(token);\n          // /* */ comment region folding\n          // All #region and #endregion cases\n          if (currDelimiter) {\n            if (currDelimiter.isStart) {\n              delimiterStack.push(currDelimiter);\n            } else {\n              var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'comment');\n              if (!prevDelimiter) {\n                break;\n              }\n              if (prevDelimiter.type === 'comment') {\n                if (prevDelimiter.line !== currDelimiter.line) {\n                  ranges.push({\n                    startLine: prevDelimiter.line,\n                    endLine: currDelimiter.line,\n                    kind: 'region'\n                  });\n                }\n              }\n            }\n          }\n          // Multiline comment case\n          else {\n            var range = tokenToRange(token, 'comment');\n            if (range) {\n              ranges.push(range);\n            }\n          }\n          break;\n        }\n    }\n    prevToken = token;\n    token = scanner.scan();\n  };\n  while (token.type !== TokenType.EOF) {\n    _loop_1();\n  }\n  return ranges;\n}\nfunction popPrevStartDelimiterOfType(stack, type) {\n  if (stack.length === 0) {\n    return null;\n  }\n  for (var i = stack.length - 1; i >= 0; i--) {\n    if (stack[i].type === type && stack[i].isStart) {\n      return stack.splice(i, 1)[0];\n    }\n  }\n  return null;\n}\n/**\n * - Sort regions\n * - Remove invalid regions (intersections)\n * - If limit exceeds, only return `rangeLimit` amount of ranges\n */\nfunction limitFoldingRanges(ranges, context) {\n  var maxRanges = context && context.rangeLimit || Number.MAX_VALUE;\n  var sortedRanges = ranges.sort(function (r1, r2) {\n    var diff = r1.startLine - r2.startLine;\n    if (diff === 0) {\n      diff = r1.endLine - r2.endLine;\n    }\n    return diff;\n  });\n  var validRanges = [];\n  var prevEndLine = -1;\n  sortedRanges.forEach(function (r) {\n    if (!(r.startLine < prevEndLine && prevEndLine < r.endLine)) {\n      validRanges.push(r);\n      prevEndLine = r.endLine;\n    }\n  });\n  if (validRanges.length < maxRanges) {\n    return validRanges;\n  } else {\n    return validRanges.slice(0, maxRanges);\n  }\n}","map":{"version":3,"names":["TokenType","Scanner","SCSSScanner","InterpolationFunction","LESSScanner","getFoldingRanges","document","context","ranges","computeFoldingRanges","limitFoldingRanges","getStartLine","t","positionAt","offset","line","getEndLine","len","getScanner","languageId","tokenToRange","kind","startLine","endLine","delimiterStack","scanner","ignoreComment","setSource","getText","token","scan","prevToken","_loop_1","type","CurlyL","push","isStart","CurlyR","length","prevDelimiter","popPrevStartDelimiterOfType","undefined","Comment","commentRegionMarkerToDelimiter_1","marker","getCurrDelimiter","matches","text","match","matches_1","currDelimiter","range","EOF","stack","i","splice","maxRanges","rangeLimit","Number","MAX_VALUE","sortedRanges","sort","r1","r2","diff","validRanges","prevEndLine","forEach","r","slice"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/css/_deps/vscode-css-languageservice/services/cssFolding.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { TokenType, Scanner } from '../parser/cssScanner.js';\nimport { SCSSScanner, InterpolationFunction } from '../parser/scssScanner.js';\nimport { LESSScanner } from '../parser/lessScanner.js';\nexport function getFoldingRanges(document, context) {\n    var ranges = computeFoldingRanges(document);\n    return limitFoldingRanges(ranges, context);\n}\nfunction computeFoldingRanges(document) {\n    function getStartLine(t) {\n        return document.positionAt(t.offset).line;\n    }\n    function getEndLine(t) {\n        return document.positionAt(t.offset + t.len).line;\n    }\n    function getScanner() {\n        switch (document.languageId) {\n            case 'scss':\n                return new SCSSScanner();\n            case 'less':\n                return new LESSScanner();\n            default:\n                return new Scanner();\n        }\n    }\n    function tokenToRange(t, kind) {\n        var startLine = getStartLine(t);\n        var endLine = getEndLine(t);\n        if (startLine !== endLine) {\n            return {\n                startLine: startLine,\n                endLine: endLine,\n                kind: kind\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    var ranges = [];\n    var delimiterStack = [];\n    var scanner = getScanner();\n    scanner.ignoreComment = false;\n    scanner.setSource(document.getText());\n    var token = scanner.scan();\n    var prevToken = null;\n    var _loop_1 = function () {\n        switch (token.type) {\n            case TokenType.CurlyL:\n            case InterpolationFunction:\n                {\n                    delimiterStack.push({ line: getStartLine(token), type: 'brace', isStart: true });\n                    break;\n                }\n            case TokenType.CurlyR: {\n                if (delimiterStack.length !== 0) {\n                    var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'brace');\n                    if (!prevDelimiter) {\n                        break;\n                    }\n                    var endLine = getEndLine(token);\n                    if (prevDelimiter.type === 'brace') {\n                        /**\n                         * Other than the case when curly brace is not on a new line by itself, for example\n                         * .foo {\n                         *   color: red; }\n                         * Use endLine minus one to show ending curly brace\n                         */\n                        if (prevToken && getEndLine(prevToken) !== endLine) {\n                            endLine--;\n                        }\n                        if (prevDelimiter.line !== endLine) {\n                            ranges.push({\n                                startLine: prevDelimiter.line,\n                                endLine: endLine,\n                                kind: undefined\n                            });\n                        }\n                    }\n                }\n                break;\n            }\n            /**\n             * In CSS, there is no single line comment prefixed with //\n             * All comments are marked as `Comment`\n             */\n            case TokenType.Comment: {\n                var commentRegionMarkerToDelimiter_1 = function (marker) {\n                    if (marker === '#region') {\n                        return { line: getStartLine(token), type: 'comment', isStart: true };\n                    }\n                    else {\n                        return { line: getEndLine(token), type: 'comment', isStart: false };\n                    }\n                };\n                var getCurrDelimiter = function (token) {\n                    var matches = token.text.match(/^\\s*\\/\\*\\s*(#region|#endregion)\\b\\s*(.*?)\\s*\\*\\//);\n                    if (matches) {\n                        return commentRegionMarkerToDelimiter_1(matches[1]);\n                    }\n                    else if (document.languageId === 'scss' || document.languageId === 'less') {\n                        var matches_1 = token.text.match(/^\\s*\\/\\/\\s*(#region|#endregion)\\b\\s*(.*?)\\s*/);\n                        if (matches_1) {\n                            return commentRegionMarkerToDelimiter_1(matches_1[1]);\n                        }\n                    }\n                    return null;\n                };\n                var currDelimiter = getCurrDelimiter(token);\n                // /* */ comment region folding\n                // All #region and #endregion cases\n                if (currDelimiter) {\n                    if (currDelimiter.isStart) {\n                        delimiterStack.push(currDelimiter);\n                    }\n                    else {\n                        var prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, 'comment');\n                        if (!prevDelimiter) {\n                            break;\n                        }\n                        if (prevDelimiter.type === 'comment') {\n                            if (prevDelimiter.line !== currDelimiter.line) {\n                                ranges.push({\n                                    startLine: prevDelimiter.line,\n                                    endLine: currDelimiter.line,\n                                    kind: 'region'\n                                });\n                            }\n                        }\n                    }\n                }\n                // Multiline comment case\n                else {\n                    var range = tokenToRange(token, 'comment');\n                    if (range) {\n                        ranges.push(range);\n                    }\n                }\n                break;\n            }\n        }\n        prevToken = token;\n        token = scanner.scan();\n    };\n    while (token.type !== TokenType.EOF) {\n        _loop_1();\n    }\n    return ranges;\n}\nfunction popPrevStartDelimiterOfType(stack, type) {\n    if (stack.length === 0) {\n        return null;\n    }\n    for (var i = stack.length - 1; i >= 0; i--) {\n        if (stack[i].type === type && stack[i].isStart) {\n            return stack.splice(i, 1)[0];\n        }\n    }\n    return null;\n}\n/**\n * - Sort regions\n * - Remove invalid regions (intersections)\n * - If limit exceeds, only return `rangeLimit` amount of ranges\n */\nfunction limitFoldingRanges(ranges, context) {\n    var maxRanges = context && context.rangeLimit || Number.MAX_VALUE;\n    var sortedRanges = ranges.sort(function (r1, r2) {\n        var diff = r1.startLine - r2.startLine;\n        if (diff === 0) {\n            diff = r1.endLine - r2.endLine;\n        }\n        return diff;\n    });\n    var validRanges = [];\n    var prevEndLine = -1;\n    sortedRanges.forEach(function (r) {\n        if (!(r.startLine < prevEndLine && prevEndLine < r.endLine)) {\n            validRanges.push(r);\n            prevEndLine = r.endLine;\n        }\n    });\n    if (validRanges.length < maxRanges) {\n        return validRanges;\n    }\n    else {\n        return validRanges.slice(0, maxRanges);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}