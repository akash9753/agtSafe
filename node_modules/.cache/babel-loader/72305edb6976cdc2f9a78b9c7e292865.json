{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport var AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n  var r;\n  if (arr[arr.length - 1] < 65536) {\n    r = new Uint16Array(arr.length);\n  } else {\n    r = new Uint32Array(arr.length);\n  }\n  r.set(arr, 0);\n  return r;\n}\nvar LineStarts = /** @class */function () {\n  function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\n    this.lineStarts = lineStarts;\n    this.cr = cr;\n    this.lf = lf;\n    this.crlf = crlf;\n    this.isBasicASCII = isBasicASCII;\n  }\n  return LineStarts;\n}();\nexport { LineStarts };\nexport function createLineStartsFast(str, readonly) {\n  if (readonly === void 0) {\n    readonly = true;\n  }\n  var r = [0],\n    rLength = 1;\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n    if (chr === 13 /* CarriageReturn */) {\n      if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n        // \\r\\n... case\n        r[rLength++] = i + 2;\n        i++; // skip \\n\n      } else {\n        // \\r... case\n        r[rLength++] = i + 1;\n      }\n    } else if (chr === 10 /* LineFeed */) {\n      r[rLength++] = i + 1;\n    }\n  }\n  if (readonly) {\n    return createUintArray(r);\n  } else {\n    return r;\n  }\n}\nexport function createLineStarts(r, str) {\n  r.length = 0;\n  r[0] = 0;\n  var rLength = 1;\n  var cr = 0,\n    lf = 0,\n    crlf = 0;\n  var isBasicASCII = true;\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n    if (chr === 13 /* CarriageReturn */) {\n      if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\n        // \\r\\n... case\n        crlf++;\n        r[rLength++] = i + 2;\n        i++; // skip \\n\n      } else {\n        cr++;\n        // \\r... case\n        r[rLength++] = i + 1;\n      }\n    } else if (chr === 10 /* LineFeed */) {\n      lf++;\n      r[rLength++] = i + 1;\n    } else {\n      if (isBasicASCII) {\n        if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\n          isBasicASCII = false;\n        }\n      }\n    }\n  }\n  var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n  r.length = 0;\n  return result;\n}\nvar Piece = /** @class */function () {\n  function Piece(bufferIndex, start, end, lineFeedCnt, length) {\n    this.bufferIndex = bufferIndex;\n    this.start = start;\n    this.end = end;\n    this.lineFeedCnt = lineFeedCnt;\n    this.length = length;\n  }\n  return Piece;\n}();\nexport { Piece };\nvar StringBuffer = /** @class */function () {\n  function StringBuffer(buffer, lineStarts) {\n    this.buffer = buffer;\n    this.lineStarts = lineStarts;\n  }\n  return StringBuffer;\n}();\nexport { StringBuffer };\nvar PieceTreeSearchCache = /** @class */function () {\n  function PieceTreeSearchCache(limit) {\n    this._limit = limit;\n    this._cache = [];\n  }\n  PieceTreeSearchCache.prototype.get = function (offset) {\n    for (var i = this._cache.length - 1; i >= 0; i--) {\n      var nodePos = this._cache[i];\n      if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n        return nodePos;\n      }\n    }\n    return null;\n  };\n  PieceTreeSearchCache.prototype.get2 = function (lineNumber) {\n    for (var i = this._cache.length - 1; i >= 0; i--) {\n      var nodePos = this._cache[i];\n      if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n        return nodePos;\n      }\n    }\n    return null;\n  };\n  PieceTreeSearchCache.prototype.set = function (nodePosition) {\n    if (this._cache.length >= this._limit) {\n      this._cache.shift();\n    }\n    this._cache.push(nodePosition);\n  };\n  PieceTreeSearchCache.prototype.valdiate = function (offset) {\n    var hasInvalidVal = false;\n    var tmp = this._cache;\n    for (var i = 0; i < tmp.length; i++) {\n      var nodePos = tmp[i];\n      if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n        tmp[i] = null;\n        hasInvalidVal = true;\n        continue;\n      }\n    }\n    if (hasInvalidVal) {\n      var newArr = [];\n      for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {\n        var entry = tmp_1[_i];\n        if (entry !== null) {\n          newArr.push(entry);\n        }\n      }\n      this._cache = newArr;\n    }\n  };\n  return PieceTreeSearchCache;\n}();\nvar PieceTreeBase = /** @class */function () {\n  function PieceTreeBase(chunks, eol, eolNormalized) {\n    this.create(chunks, eol, eolNormalized);\n  }\n  PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {\n    this._buffers = [new StringBuffer('', [0])];\n    this._lastChangeBufferPos = {\n      line: 0,\n      column: 0\n    };\n    this.root = SENTINEL;\n    this._lineCnt = 1;\n    this._length = 0;\n    this._EOL = eol;\n    this._EOLLength = eol.length;\n    this._EOLNormalized = eolNormalized;\n    var lastNode = null;\n    for (var i = 0, len = chunks.length; i < len; i++) {\n      if (chunks[i].buffer.length > 0) {\n        if (!chunks[i].lineStarts) {\n          chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n        }\n        var piece = new Piece(i + 1, {\n          line: 0,\n          column: 0\n        }, {\n          line: chunks[i].lineStarts.length - 1,\n          column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]\n        }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n        this._buffers.push(chunks[i]);\n        lastNode = this.rbInsertRight(lastNode, piece);\n      }\n    }\n    this._searchCache = new PieceTreeSearchCache(1);\n    this._lastVisitedLine = {\n      lineNumber: 0,\n      value: ''\n    };\n    this.computeBufferMetadata();\n  };\n  PieceTreeBase.prototype.normalizeEOL = function (eol) {\n    var _this = this;\n    var averageBufferSize = AverageBufferSize;\n    var min = averageBufferSize - Math.floor(averageBufferSize / 3);\n    var max = min * 2;\n    var tempChunk = '';\n    var tempChunkLen = 0;\n    var chunks = [];\n    this.iterate(this.root, function (node) {\n      var str = _this.getNodeContent(node);\n      var len = str.length;\n      if (tempChunkLen <= min || tempChunkLen + len < max) {\n        tempChunk += str;\n        tempChunkLen += len;\n        return true;\n      }\n      // flush anyways\n      var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n      tempChunk = str;\n      tempChunkLen = len;\n      return true;\n    });\n    if (tempChunkLen > 0) {\n      var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n      chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n    }\n    this.create(chunks, eol, true);\n  };\n  // #region Buffer API\n  PieceTreeBase.prototype.getEOL = function () {\n    return this._EOL;\n  };\n  PieceTreeBase.prototype.setEOL = function (newEOL) {\n    this._EOL = newEOL;\n    this._EOLLength = this._EOL.length;\n    this.normalizeEOL(newEOL);\n  };\n  PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {\n    var leftLen = 0; // inorder\n    var x = this.root;\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n        leftLen += x.size_left;\n        // lineNumber >= 2\n        var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        return leftLen += accumualtedValInCurrentIndex + column - 1;\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        leftLen += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n    return leftLen;\n  };\n  PieceTreeBase.prototype.getPositionAt = function (offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    var x = this.root;\n    var lfCnt = 0;\n    var originalOffset = offset;\n    while (x !== SENTINEL) {\n      if (x.size_left !== 0 && x.size_left >= offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        var out = this.getIndexOf(x, offset - x.size_left);\n        lfCnt += x.lf_left + out.index;\n        if (out.index === 0) {\n          var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          var column = originalOffset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        }\n        return new Position(lfCnt + 1, out.remainder + 1);\n      } else {\n        offset -= x.size_left + x.piece.length;\n        lfCnt += x.lf_left + x.piece.lineFeedCnt;\n        if (x.right === SENTINEL) {\n          // last node\n          var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n          var column = originalOffset - offset - lineStartOffset;\n          return new Position(lfCnt + 1, column + 1);\n        } else {\n          x = x.right;\n        }\n      }\n    }\n    return new Position(1, 1);\n  };\n  PieceTreeBase.prototype.getValueInRange = function (range, eol) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      return '';\n    }\n    var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n    var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n    var value = this.getValueInRange2(startPosition, endPosition);\n    if (eol) {\n      if (eol !== this._EOL || !this._EOLNormalized) {\n        return value.replace(/\\r\\n|\\r|\\n/g, eol);\n      }\n      if (eol === this.getEOL() && this._EOLNormalized) {\n        if (eol === '\\r\\n') {}\n        return value;\n      }\n      return value.replace(/\\r\\n|\\r|\\n/g, eol);\n    }\n    return value;\n  };\n  PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {\n    if (startPosition.node === endPosition.node) {\n      var node = startPosition.node;\n      var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;\n      var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n      return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);\n    }\n    var x = startPosition.node;\n    var buffer = this._buffers[x.piece.bufferIndex].buffer;\n    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n    var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n    x = x.next();\n    while (x !== SENTINEL) {\n      var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n      if (x === endPosition.node) {\n        ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);\n        break;\n      } else {\n        ret += buffer_2.substr(startOffset_2, x.piece.length);\n      }\n      x = x.next();\n    }\n    return ret;\n  };\n  PieceTreeBase.prototype.getLinesContent = function () {\n    var _this = this;\n    var lines = [];\n    var linesLength = 0;\n    var currentLine = '';\n    var danglingCR = false;\n    this.iterate(this.root, function (node) {\n      if (node === SENTINEL) {\n        return true;\n      }\n      var piece = node.piece;\n      var pieceLength = piece.length;\n      if (pieceLength === 0) {\n        return true;\n      }\n      var buffer = _this._buffers[piece.bufferIndex].buffer;\n      var lineStarts = _this._buffers[piece.bufferIndex].lineStarts;\n      var pieceStartLine = piece.start.line;\n      var pieceEndLine = piece.end.line;\n      var pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n      if (danglingCR) {\n        if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\n          // pretend the \\n was in the previous piece..\n          pieceStartOffset++;\n          pieceLength--;\n        }\n        lines[linesLength++] = currentLine;\n        currentLine = '';\n        danglingCR = false;\n        if (pieceLength === 0) {\n          return true;\n        }\n      }\n      if (pieceStartLine === pieceEndLine) {\n        // this piece has no new lines\n        if (!_this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\n          danglingCR = true;\n          currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n        } else {\n          currentLine += buffer.substr(pieceStartOffset, pieceLength);\n        }\n        return true;\n      }\n      // add the text before the first line start in this piece\n      currentLine += _this._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - _this._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n      lines[linesLength++] = currentLine;\n      for (var line = pieceStartLine + 1; line < pieceEndLine; line++) {\n        currentLine = _this._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - _this._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n        lines[linesLength++] = currentLine;\n      }\n      if (!_this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\n        danglingCR = true;\n        if (piece.end.column === 0) {\n          // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n          linesLength--;\n        } else {\n          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n        }\n      } else {\n        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n      }\n      return true;\n    });\n    if (danglingCR) {\n      lines[linesLength++] = currentLine;\n      currentLine = '';\n    }\n    lines[linesLength++] = currentLine;\n    return lines;\n  };\n  PieceTreeBase.prototype.getLength = function () {\n    return this._length;\n  };\n  PieceTreeBase.prototype.getLineCount = function () {\n    return this._lineCnt;\n  };\n  PieceTreeBase.prototype.getLineContent = function (lineNumber) {\n    if (this._lastVisitedLine.lineNumber === lineNumber) {\n      return this._lastVisitedLine.value;\n    }\n    this._lastVisitedLine.lineNumber = lineNumber;\n    if (lineNumber === this._lineCnt) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n    } else if (this._EOLNormalized) {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n    } else {\n      this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n    }\n    return this._lastVisitedLine.value;\n  };\n  PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {\n    var nodePos = this.nodeAt2(lineNumber, index + 1);\n    if (nodePos.remainder === nodePos.node.piece.length) {\n      // the char we want to fetch is at the head of next node.\n      var matchingNode = nodePos.node.next();\n      if (!matchingNode) {\n        return 0;\n      }\n      var buffer = this._buffers[matchingNode.piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n      return buffer.buffer.charCodeAt(startOffset);\n    } else {\n      var buffer = this._buffers[nodePos.node.piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n      var targetOffset = startOffset + nodePos.remainder;\n      return buffer.buffer.charCodeAt(targetOffset);\n    }\n  };\n  PieceTreeBase.prototype.getLineLength = function (lineNumber) {\n    if (lineNumber === this.getLineCount()) {\n      var startOffset = this.getOffsetAt(lineNumber, 1);\n      return this.getLength() - startOffset;\n    }\n    return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n  };\n  PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n    var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n    var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n    var m;\n    // Reset regex to search from the beginning\n    var ret = {\n      line: 0,\n      column: 0\n    };\n    var searchText;\n    var offsetInBuffer;\n    if (searcher._wordSeparators) {\n      searchText = buffer.buffer.substring(start, end);\n      offsetInBuffer = function offsetInBuffer(offset) {\n        return offset + start;\n      };\n      searcher.reset(-1);\n    } else {\n      searchText = buffer.buffer;\n      offsetInBuffer = function offsetInBuffer(offset) {\n        return offset;\n      };\n      searcher.reset(start);\n    }\n    do {\n      m = searcher.next(searchText);\n      if (m) {\n        if (offsetInBuffer(m.index) >= end) {\n          return resultLen;\n        }\n        this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n        var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n        var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n        var retEndColumn = retStartColumn + m[0].length;\n        result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n        if (offsetInBuffer(m.index) + m[0].length >= end) {\n          return resultLen;\n        }\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n    return resultLen;\n  };\n  PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    var result = [];\n    var resultLen = 0;\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n    if (startPosition === null) {\n      return [];\n    }\n    var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n    if (endPosition === null) {\n      return [];\n    }\n    var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n    if (startPosition.node === endPosition.node) {\n      this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n      return result;\n    }\n    var startLineNumber = searchRange.startLineNumber;\n    var currentNode = startPosition.node;\n    while (currentNode !== endPosition.node) {\n      var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n      if (lineBreakCnt >= 1) {\n        // last line break position\n        var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n        var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n        var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n        var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n        if (resultLen >= limitResultCount) {\n          return result;\n        }\n        startLineNumber += lineBreakCnt;\n      }\n      var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n      // search for the remaining content\n      if (startLineNumber === searchRange.endLineNumber) {\n        var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n      resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n      if (resultLen >= limitResultCount) {\n        return result;\n      }\n      startLineNumber++;\n      startPosition = this.nodeAt2(startLineNumber, 1);\n      currentNode = startPosition.node;\n      start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n    }\n    if (startLineNumber === searchRange.endLineNumber) {\n      var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n      var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    }\n    var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n    resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n    return result;\n  };\n  PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    var wordSeparators = searchData.wordSeparators;\n    if (!captureMatches && searchData.simpleSearch) {\n      var searchString = searchData.simpleSearch;\n      var searchStringLen = searchString.length;\n      var textLength = text.length;\n      var lastMatchIndex = -searchStringLen;\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n      return resultLen;\n    }\n    var m;\n    // Reset regex to search from the beginning\n    searcher.reset(0);\n    do {\n      m = searcher.next(text);\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n    return resultLen;\n  };\n  // #endregion\n  // #region Piece Table\n  PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {\n    if (eolNormalized === void 0) {\n      eolNormalized = false;\n    }\n    this._EOLNormalized = this._EOLNormalized && eolNormalized;\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n    if (this.root !== SENTINEL) {\n      var _a = this.nodeAt(offset),\n        node = _a.node,\n        remainder = _a.remainder,\n        nodeStartOffset = _a.nodeStartOffset;\n      var piece = node.piece;\n      var bufferIndex = piece.bufferIndex;\n      var insertPosInBuffer = this.positionInBuffer(node, remainder);\n      if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {\n        // changed buffer\n        this.appendToNode(node, value);\n        this.computeBufferMetadata();\n        return;\n      }\n      if (nodeStartOffset === offset) {\n        this.insertContentToNodeLeft(value, node);\n        this._searchCache.valdiate(offset);\n      } else if (nodeStartOffset + node.piece.length > offset) {\n        // we are inserting into the middle of a node.\n        var nodesToDel = [];\n        var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n          var headOfRight = this.nodeCharCodeAt(node, remainder);\n          if (headOfRight === 10 /** \\n */) {\n            var newStart = {\n              line: newRightPiece.start.line + 1,\n              column: 0\n            };\n            newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n            value += '\\n';\n          }\n        }\n        // reuse node for content before insertion point.\n        if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n          var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n          if (tailOfLeft === 13 /** \\r */) {\n            var previousPos = this.positionInBuffer(node, remainder - 1);\n            this.deleteNodeTail(node, previousPos);\n            value = '\\r' + value;\n            if (node.piece.length === 0) {\n              nodesToDel.push(node);\n            }\n          } else {\n            this.deleteNodeTail(node, insertPosInBuffer);\n          }\n        } else {\n          this.deleteNodeTail(node, insertPosInBuffer);\n        }\n        var newPieces = this.createNewPieces(value);\n        if (newRightPiece.length > 0) {\n          this.rbInsertRight(node, newRightPiece);\n        }\n        var tmpNode = node;\n        for (var k = 0; k < newPieces.length; k++) {\n          tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.deleteNodes(nodesToDel);\n      } else {\n        this.insertContentToNodeRight(value, node);\n      }\n    } else {\n      // insert new node\n      var pieces = this.createNewPieces(value);\n      var node = this.rbInsertLeft(null, pieces[0]);\n      for (var k = 1; k < pieces.length; k++) {\n        node = this.rbInsertRight(node, pieces[k]);\n      }\n    }\n    // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n    this.computeBufferMetadata();\n  };\n  PieceTreeBase.prototype.delete = function (offset, cnt) {\n    this._lastVisitedLine.lineNumber = 0;\n    this._lastVisitedLine.value = '';\n    if (cnt <= 0 || this.root === SENTINEL) {\n      return;\n    }\n    var startPosition = this.nodeAt(offset);\n    var endPosition = this.nodeAt(offset + cnt);\n    var startNode = startPosition.node;\n    var endNode = endPosition.node;\n    if (startNode === endNode) {\n      var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);\n      var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);\n      if (startPosition.nodeStartOffset === offset) {\n        if (cnt === startNode.piece.length) {\n          // delete node\n          var next = startNode.next();\n          rbDelete(this, startNode);\n          this.validateCRLFWithPrevNode(next);\n          this.computeBufferMetadata();\n          return;\n        }\n        this.deleteNodeHead(startNode, endSplitPosInBuffer_1);\n        this._searchCache.valdiate(offset);\n        this.validateCRLFWithPrevNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      }\n      if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n        this.deleteNodeTail(startNode, startSplitPosInBuffer_1);\n        this.validateCRLFWithNextNode(startNode);\n        this.computeBufferMetadata();\n        return;\n      }\n      // delete content in the middle, this node will be splitted to nodes\n      this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);\n      this.computeBufferMetadata();\n      return;\n    }\n    var nodesToDel = [];\n    var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n    this.deleteNodeTail(startNode, startSplitPosInBuffer);\n    this._searchCache.valdiate(offset);\n    if (startNode.piece.length === 0) {\n      nodesToDel.push(startNode);\n    }\n    // update last touched node\n    var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n    this.deleteNodeHead(endNode, endSplitPosInBuffer);\n    if (endNode.piece.length === 0) {\n      nodesToDel.push(endNode);\n    }\n    // delete nodes in between\n    var secondNode = startNode.next();\n    for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n      nodesToDel.push(node);\n    }\n    var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n    this.deleteNodes(nodesToDel);\n    this.validateCRLFWithNextNode(prev);\n    this.computeBufferMetadata();\n  };\n  PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {\n    // we are inserting content to the beginning of node\n    var nodesToDel = [];\n    if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n      // move `\\n` to new node.\n      var piece = node.piece;\n      var newStart = {\n        line: piece.start.line + 1,\n        column: 0\n      };\n      var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n      node.piece = nPiece;\n      value += '\\n';\n      updateTreeMetadata(this, node, -1, -1);\n      if (node.piece.length === 0) {\n        nodesToDel.push(node);\n      }\n    }\n    var newPieces = this.createNewPieces(value);\n    var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n    for (var k = newPieces.length - 2; k >= 0; k--) {\n      newNode = this.rbInsertLeft(newNode, newPieces[k]);\n    }\n    this.validateCRLFWithPrevNode(newNode);\n    this.deleteNodes(nodesToDel);\n  };\n  PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {\n    // we are inserting to the right of this node.\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      // move \\n to the new node.\n      value += '\\n';\n    }\n    var newPieces = this.createNewPieces(value);\n    var newNode = this.rbInsertRight(node, newPieces[0]);\n    var tmpNode = newNode;\n    for (var k = 1; k < newPieces.length; k++) {\n      tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n    }\n    this.validateCRLFWithPrevNode(newNode);\n  };\n  PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {\n    var piece = node.piece;\n    var bufferIndex = node.piece.bufferIndex;\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    var startOffset = lineStarts[piece.start.line] + piece.start.column;\n    var offset = startOffset + remainder;\n    // binary search offset between startOffset and endOffset\n    var low = piece.start.line;\n    var high = piece.end.line;\n    var mid = 0;\n    var midStop = 0;\n    var midStart = 0;\n    while (low <= high) {\n      mid = low + (high - low) / 2 | 0;\n      midStart = lineStarts[mid];\n      if (mid === high) {\n        break;\n      }\n      midStop = lineStarts[mid + 1];\n      if (offset < midStart) {\n        high = mid - 1;\n      } else if (offset >= midStop) {\n        low = mid + 1;\n      } else {\n        break;\n      }\n    }\n    if (ret) {\n      ret.line = mid;\n      ret.column = offset - midStart;\n      return null;\n    }\n    return {\n      line: mid,\n      column: offset - midStart\n    };\n  };\n  PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {\n    // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n    // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n    if (end.column === 0) {\n      return end.line - start.line;\n    }\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    if (end.line === lineStarts.length - 1) {\n      // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n      return end.line - start.line;\n    }\n    var nextLineStartOffset = lineStarts[end.line + 1];\n    var endOffset = lineStarts[end.line] + end.column;\n    if (nextLineStartOffset > endOffset + 1) {\n      // there are more than 1 character after end, which means it can't be \\n\n      return end.line - start.line;\n    }\n    // endOffset + 1 === nextLineStartOffset\n    // character at endOffset is \\n, so we check the character before first\n    // if character at endOffset is \\r, end.column is 0 and we can't get here.\n    var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n    var buffer = this._buffers[bufferIndex].buffer;\n    if (buffer.charCodeAt(previousCharOffset) === 13) {\n      return end.line - start.line + 1;\n    } else {\n      return end.line - start.line;\n    }\n  };\n  PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {\n    var lineStarts = this._buffers[bufferIndex].lineStarts;\n    return lineStarts[cursor.line] + cursor.column;\n  };\n  PieceTreeBase.prototype.deleteNodes = function (nodes) {\n    for (var i = 0; i < nodes.length; i++) {\n      rbDelete(this, nodes[i]);\n    }\n  };\n  PieceTreeBase.prototype.createNewPieces = function (text) {\n    if (text.length > AverageBufferSize) {\n      // the content is large, operations like substring, charCode becomes slow\n      // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n      var newPieces = [];\n      while (text.length > AverageBufferSize) {\n        var lastChar = text.charCodeAt(AverageBufferSize - 1);\n        var splitText = void 0;\n        if (lastChar === 13 /* CarriageReturn */ || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n          // last character is \\r or a high surrogate => keep it back\n          splitText = text.substring(0, AverageBufferSize - 1);\n          text = text.substring(AverageBufferSize - 1);\n        } else {\n          splitText = text.substring(0, AverageBufferSize);\n          text = text.substring(AverageBufferSize);\n        }\n        var lineStarts_1 = createLineStartsFast(splitText);\n        newPieces.push(new Piece(this._buffers.length, /* buffer index */{\n          line: 0,\n          column: 0\n        }, {\n          line: lineStarts_1.length - 1,\n          column: splitText.length - lineStarts_1[lineStarts_1.length - 1]\n        }, lineStarts_1.length - 1, splitText.length));\n        this._buffers.push(new StringBuffer(splitText, lineStarts_1));\n      }\n      var lineStarts_2 = createLineStartsFast(text);\n      newPieces.push(new Piece(this._buffers.length, /* buffer index */{\n        line: 0,\n        column: 0\n      }, {\n        line: lineStarts_2.length - 1,\n        column: text.length - lineStarts_2[lineStarts_2.length - 1]\n      }, lineStarts_2.length - 1, text.length));\n      this._buffers.push(new StringBuffer(text, lineStarts_2));\n      return newPieces;\n    }\n    var startOffset = this._buffers[0].buffer.length;\n    var lineStarts = createLineStartsFast(text, false);\n    var start = this._lastChangeBufferPos;\n    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n    ) {\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line,\n        column: this._lastChangeBufferPos.column + 1\n      };\n      start = this._lastChangeBufferPos;\n      for (var i = 0; i < lineStarts.length; i++) {\n        lineStarts[i] += startOffset + 1;\n      }\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += '_' + text;\n      startOffset += 1;\n    } else {\n      if (startOffset !== 0) {\n        for (var i = 0; i < lineStarts.length; i++) {\n          lineStarts[i] += startOffset;\n        }\n      }\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      this._buffers[0].buffer += text;\n    }\n    var endOffset = this._buffers[0].buffer.length;\n    var endIndex = this._buffers[0].lineStarts.length - 1;\n    var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n    var endPos = {\n      line: endIndex,\n      column: endColumn\n    };\n    var newPiece = new Piece(0, /** todo@peng */start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n    this._lastChangeBufferPos = endPos;\n    return [newPiece];\n  };\n  PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {\n    if (endOffset === void 0) {\n      endOffset = 0;\n    }\n    var x = this.root;\n    var ret = '';\n    var cache = this._searchCache.get2(lineNumber);\n    if (cache) {\n      x = cache.node;\n      var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n      if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n        ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n      } else {\n        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n        return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n      }\n    } else {\n      var nodeStartOffset = 0;\n      var originalLineNumber = lineNumber;\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n          var buffer = this._buffers[x.piece.bufferIndex].buffer;\n          var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          nodeStartOffset += x.size_left;\n          this._searchCache.set({\n            node: x,\n            nodeStartOffset: nodeStartOffset,\n            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n          });\n          return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var buffer = this._buffers[x.piece.bufferIndex].buffer;\n          var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n          break;\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n    }\n    // search in order, to find the node contains end column\n    x = x.next();\n    while (x !== SENTINEL) {\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n      if (x.piece.lineFeedCnt > 0) {\n        var accumualtedValue = this.getAccumulatedValue(x, 0);\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\n        return ret;\n      } else {\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        ret += buffer.substr(startOffset, x.piece.length);\n      }\n      x = x.next();\n    }\n    return ret;\n  };\n  PieceTreeBase.prototype.computeBufferMetadata = function () {\n    var x = this.root;\n    var lfCnt = 1;\n    var len = 0;\n    while (x !== SENTINEL) {\n      lfCnt += x.lf_left + x.piece.lineFeedCnt;\n      len += x.size_left + x.piece.length;\n      x = x.right;\n    }\n    this._lineCnt = lfCnt;\n    this._length = len;\n    this._searchCache.valdiate(this._length);\n  };\n  // #region node operations\n  PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {\n    var piece = node.piece;\n    var pos = this.positionInBuffer(node, accumulatedValue);\n    var lineCnt = pos.line - piece.start.line;\n    if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n      // we are checking the end of this node, so a CRLF check is necessary.\n      var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n      if (realLineCnt !== lineCnt) {\n        // aha yes, CRLF\n        return {\n          index: realLineCnt,\n          remainder: 0\n        };\n      }\n    }\n    return {\n      index: lineCnt,\n      remainder: pos.column\n    };\n  };\n  PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {\n    if (index < 0) {\n      return 0;\n    }\n    var piece = node.piece;\n    var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    var expectedLineStartIndex = piece.start.line + index + 1;\n    if (expectedLineStartIndex > piece.end.line) {\n      return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n    } else {\n      return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n    }\n  };\n  PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {\n    var piece = node.piece;\n    var originalLFCnt = piece.lineFeedCnt;\n    var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    var newEnd = pos;\n    var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    var lf_delta = newLineFeedCnt - originalLFCnt;\n    var size_delta = newEndOffset - originalEndOffset;\n    var newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  };\n  PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {\n    var piece = node.piece;\n    var originalLFCnt = piece.lineFeedCnt;\n    var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    var newStart = pos;\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n    var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n    var lf_delta = newLineFeedCnt - originalLFCnt;\n    var size_delta = originalStartOffset - newStartOffset;\n    var newLength = piece.length + size_delta;\n    node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, size_delta, lf_delta);\n  };\n  PieceTreeBase.prototype.shrinkNode = function (node, start, end) {\n    var piece = node.piece;\n    var originalStartPos = piece.start;\n    var originalEndPos = piece.end;\n    // old piece, originalStartPos, start\n    var oldLength = piece.length;\n    var oldLFCnt = piece.lineFeedCnt;\n    var newEnd = start;\n    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n    var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n    node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n    // new right piece, end, originalEndPos\n    var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n    var newNode = this.rbInsertRight(node, newPiece);\n    this.validateCRLFWithPrevNode(newNode);\n  };\n  PieceTreeBase.prototype.appendToNode = function (node, value) {\n    if (this.adjustCarriageReturnFromNext(value, node)) {\n      value += '\\n';\n    }\n    var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n    var startOffset = this._buffers[0].buffer.length;\n    this._buffers[0].buffer += value;\n    var lineStarts = createLineStartsFast(value, false);\n    for (var i = 0; i < lineStarts.length; i++) {\n      lineStarts[i] += startOffset;\n    }\n    if (hitCRLF) {\n      var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n      this._buffers[0].lineStarts.pop();\n      // _lastChangeBufferPos is already wrong\n      this._lastChangeBufferPos = {\n        line: this._lastChangeBufferPos.line - 1,\n        column: startOffset - prevStartOffset\n      };\n    }\n    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n    var endIndex = this._buffers[0].lineStarts.length - 1;\n    var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n    var newEnd = {\n      line: endIndex,\n      column: endColumn\n    };\n    var newLength = node.piece.length + value.length;\n    var oldLineFeedCnt = node.piece.lineFeedCnt;\n    var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n    var lf_delta = newLineFeedCnt - oldLineFeedCnt;\n    node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n    this._lastChangeBufferPos = newEnd;\n    updateTreeMetadata(this, node, value.length, lf_delta);\n  };\n  PieceTreeBase.prototype.nodeAt = function (offset) {\n    var x = this.root;\n    var cache = this._searchCache.get(offset);\n    if (cache) {\n      return {\n        node: cache.node,\n        nodeStartOffset: cache.nodeStartOffset,\n        remainder: offset - cache.nodeStartOffset\n      };\n    }\n    var nodeStartOffset = 0;\n    while (x !== SENTINEL) {\n      if (x.size_left > offset) {\n        x = x.left;\n      } else if (x.size_left + x.piece.length >= offset) {\n        nodeStartOffset += x.size_left;\n        var ret = {\n          node: x,\n          remainder: offset - x.size_left,\n          nodeStartOffset: nodeStartOffset\n        };\n        this._searchCache.set(ret);\n        return ret;\n      } else {\n        offset -= x.size_left + x.piece.length;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n    return null;\n  };\n  PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {\n    var x = this.root;\n    var nodeStartOffset = 0;\n    while (x !== SENTINEL) {\n      if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n        x = x.left;\n      } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n        nodeStartOffset += x.size_left;\n        return {\n          node: x,\n          remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\n          nodeStartOffset: nodeStartOffset\n        };\n      } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n        var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n        if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n          return {\n            node: x,\n            remainder: prevAccumualtedValue + column - 1,\n            nodeStartOffset: nodeStartOffset\n          };\n        } else {\n          column -= x.piece.length - prevAccumualtedValue;\n          break;\n        }\n      } else {\n        lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n        nodeStartOffset += x.size_left + x.piece.length;\n        x = x.right;\n      }\n    }\n    // search in order, to find the node contains position.column\n    x = x.next();\n    while (x !== SENTINEL) {\n      if (x.piece.lineFeedCnt > 0) {\n        var accumualtedValue = this.getAccumulatedValue(x, 0);\n        var nodeStartOffset_1 = this.offsetOfNode(x);\n        return {\n          node: x,\n          remainder: Math.min(column - 1, accumualtedValue),\n          nodeStartOffset: nodeStartOffset_1\n        };\n      } else {\n        if (x.piece.length >= column - 1) {\n          var nodeStartOffset_2 = this.offsetOfNode(x);\n          return {\n            node: x,\n            remainder: column - 1,\n            nodeStartOffset: nodeStartOffset_2\n          };\n        } else {\n          column -= x.piece.length;\n        }\n      }\n      x = x.next();\n    }\n    return null;\n  };\n  PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {\n    if (node.piece.lineFeedCnt < 1) {\n      return -1;\n    }\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n    return buffer.buffer.charCodeAt(newOffset);\n  };\n  PieceTreeBase.prototype.offsetOfNode = function (node) {\n    if (!node) {\n      return 0;\n    }\n    var pos = node.size_left;\n    while (node !== this.root) {\n      if (node.parent.right === node) {\n        pos += node.parent.size_left + node.parent.piece.length;\n      }\n      node = node.parent;\n    }\n    return pos;\n  };\n  // #endregion\n  // #region CRLF\n  PieceTreeBase.prototype.shouldCheckCRLF = function () {\n    return !(this._EOLNormalized && this._EOL === '\\n');\n  };\n  PieceTreeBase.prototype.startWithLF = function (val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(0) === 10;\n    }\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n    var piece = val.piece;\n    var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n    var line = piece.start.line;\n    var startOffset = lineStarts[line] + piece.start.column;\n    if (line === lineStarts.length - 1) {\n      // last line, so there is no line feed at the end of this line\n      return false;\n    }\n    var nextLineOffset = lineStarts[line + 1];\n    if (nextLineOffset > startOffset + 1) {\n      return false;\n    }\n    return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n  };\n  PieceTreeBase.prototype.endWithCR = function (val) {\n    if (typeof val === 'string') {\n      return val.charCodeAt(val.length - 1) === 13;\n    }\n    if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n      return false;\n    }\n    return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n  };\n  PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {\n    if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n      var node = nextNode.prev();\n      if (this.endWithCR(node)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  };\n  PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n      var nextNode = node.next();\n      if (this.startWithLF(nextNode)) {\n        this.fixCRLF(node, nextNode);\n      }\n    }\n  };\n  PieceTreeBase.prototype.fixCRLF = function (prev, next) {\n    var nodesToDel = [];\n    // update node\n    var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n    var newEnd;\n    if (prev.piece.end.column === 0) {\n      // it means, last line ends with \\r, not \\r\\n\n      newEnd = {\n        line: prev.piece.end.line - 1,\n        column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1\n      };\n    } else {\n      // \\r\\n\n      newEnd = {\n        line: prev.piece.end.line,\n        column: prev.piece.end.column - 1\n      };\n    }\n    var prevNewLength = prev.piece.length - 1;\n    var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n    prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n    updateTreeMetadata(this, prev, -1, -1);\n    if (prev.piece.length === 0) {\n      nodesToDel.push(prev);\n    }\n    // update nextNode\n    var newStart = {\n      line: next.piece.start.line + 1,\n      column: 0\n    };\n    var newLength = next.piece.length - 1;\n    var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n    next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n    updateTreeMetadata(this, next, -1, -1);\n    if (next.piece.length === 0) {\n      nodesToDel.push(next);\n    }\n    // create new piece which contains \\r\\n\n    var pieces = this.createNewPieces('\\r\\n');\n    this.rbInsertRight(prev, pieces[0]);\n    // delete empty nodes\n    for (var i = 0; i < nodesToDel.length; i++) {\n      rbDelete(this, nodesToDel[i]);\n    }\n  };\n  PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {\n    if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n      var nextNode = node.next();\n      if (this.startWithLF(nextNode)) {\n        // move `\\n` forward\n        value += '\\n';\n        if (nextNode.piece.length === 1) {\n          rbDelete(this, nextNode);\n        } else {\n          var piece = nextNode.piece;\n          var newStart = {\n            line: piece.start.line + 1,\n            column: 0\n          };\n          var newLength = piece.length - 1;\n          var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n          nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n          updateTreeMetadata(this, nextNode, -1, -1);\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  // #endregion\n  // #endregion\n  // #region Tree operations\n  PieceTreeBase.prototype.iterate = function (node, callback) {\n    if (node === SENTINEL) {\n      return callback(SENTINEL);\n    }\n    var leftRet = this.iterate(node.left, callback);\n    if (!leftRet) {\n      return leftRet;\n    }\n    return callback(node) && this.iterate(node.right, callback);\n  };\n  PieceTreeBase.prototype.getNodeContent = function (node) {\n    if (node === SENTINEL) {\n      return '';\n    }\n    var buffer = this._buffers[node.piece.bufferIndex];\n    var currentContent;\n    var piece = node.piece;\n    var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n    var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n    currentContent = buffer.buffer.substring(startOffset, endOffset);\n    return currentContent;\n  };\n  /**\r\n   *      node              node\r\n   *     /  \\              /  \\\r\n   *    a   b    <----   a    b\r\n   *                         /\r\n   *                        z\r\n   */\n  PieceTreeBase.prototype.rbInsertRight = function (node, p) {\n    var z = new TreeNode(p, 1 /* Red */);\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n    var x = this.root;\n    if (x === SENTINEL) {\n      this.root = z;\n      z.color = 0 /* Black */;\n    } else if (node.right === SENTINEL) {\n      node.right = z;\n      z.parent = node;\n    } else {\n      var nextNode = leftest(node.right);\n      nextNode.left = z;\n      z.parent = nextNode;\n    }\n    fixInsert(this, z);\n    return z;\n  };\n  /**\r\n   *      node              node\r\n   *     /  \\              /  \\\r\n   *    a   b     ---->   a    b\r\n   *                       \\\r\n   *                        z\r\n   */\n  PieceTreeBase.prototype.rbInsertLeft = function (node, p) {\n    var z = new TreeNode(p, 1 /* Red */);\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    z.parent = SENTINEL;\n    z.size_left = 0;\n    z.lf_left = 0;\n    if (this.root === SENTINEL) {\n      this.root = z;\n      z.color = 0 /* Black */;\n    } else if (node.left === SENTINEL) {\n      node.left = z;\n      z.parent = node;\n    } else {\n      var prevNode = righttest(node.left); // a\n      prevNode.right = z;\n      z.parent = prevNode;\n    }\n    fixInsert(this, z);\n    return z;\n  };\n  return PieceTreeBase;\n}();\nexport { PieceTreeBase };","map":{"version":3,"names":["Position","Range","FindMatch","SENTINEL","TreeNode","fixInsert","leftest","rbDelete","righttest","updateTreeMetadata","Searcher","createFindMatch","isValidMatch","AverageBufferSize","createUintArray","arr","r","length","Uint16Array","Uint32Array","set","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","rLength","i","len","chr","charCodeAt","createLineStarts","result","Piece","bufferIndex","start","end","lineFeedCnt","StringBuffer","buffer","PieceTreeSearchCache","limit","_limit","_cache","prototype","get","offset","nodePos","nodeStartOffset","node","piece","get2","lineNumber","nodeStartLineNumber","nodePosition","shift","push","valdiate","hasInvalidVal","tmp","parent","newArr","_i","tmp_1","entry","PieceTreeBase","chunks","eol","eolNormalized","create","_buffers","_lastChangeBufferPos","line","column","root","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","value","computeBufferMetadata","normalizeEOL","_this","averageBufferSize","min","Math","floor","max","tempChunk","tempChunkLen","iterate","getNodeContent","text","replace","getEOL","setEOL","newEOL","getOffsetAt","leftLen","x","left","lf_left","size_left","accumualtedValInCurrentIndex","getAccumulatedValue","right","getPositionAt","lfCnt","originalOffset","out","getIndexOf","index","lineStartOffset","remainder","getValueInRange","range","startLineNumber","endLineNumber","startColumn","endColumn","startPosition","nodeAt2","endPosition","getValueInRange2","buffer_1","startOffset_1","offsetInBuffer","substring","startOffset","ret","next","buffer_2","startOffset_2","substr","getLinesContent","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineCount","getLineContent","getLineRawContent","getLineCharCode","matchingNode","targetOffset","getLineLength","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","startOffsetInBuffer","m","searchText","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","startColumn_1","startColumn_2","_findMatchesInLine","startColumn_3","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","insert","_a","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","delete","cnt","startNode","endNode","startSplitPosInBuffer_1","endSplitPosInBuffer_1","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","startSplitPosInBuffer","endSplitPosInBuffer","secondNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","lineStarts_1","lineStarts_2","concat","slice","endIndex","endPos","newPiece","cache","prevAccumualtedValue","accumualtedValue","originalLineNumber","accumulatedValue","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","lf_delta","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","nodeStartOffset_1","offsetOfNode","nodeStartOffset_2","newOffset","val","nextLineOffset","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","currentContent","p","z","color","prevNode"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Position } from '../../core/position.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { FindMatch } from '../../model.js';\r\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\r\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\r\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\r\nexport var AverageBufferSize = 65535;\r\nexport function createUintArray(arr) {\r\n    var r;\r\n    if (arr[arr.length - 1] < 65536) {\r\n        r = new Uint16Array(arr.length);\r\n    }\r\n    else {\r\n        r = new Uint32Array(arr.length);\r\n    }\r\n    r.set(arr, 0);\r\n    return r;\r\n}\r\nvar LineStarts = /** @class */ (function () {\r\n    function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\r\n        this.lineStarts = lineStarts;\r\n        this.cr = cr;\r\n        this.lf = lf;\r\n        this.crlf = crlf;\r\n        this.isBasicASCII = isBasicASCII;\r\n    }\r\n    return LineStarts;\r\n}());\r\nexport { LineStarts };\r\nexport function createLineStartsFast(str, readonly) {\r\n    if (readonly === void 0) { readonly = true; }\r\n    var r = [0], rLength = 1;\r\n    for (var i = 0, len = str.length; i < len; i++) {\r\n        var chr = str.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                r[rLength++] = i + 2;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n                r[rLength++] = i + 1;\r\n            }\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            r[rLength++] = i + 1;\r\n        }\r\n    }\r\n    if (readonly) {\r\n        return createUintArray(r);\r\n    }\r\n    else {\r\n        return r;\r\n    }\r\n}\r\nexport function createLineStarts(r, str) {\r\n    r.length = 0;\r\n    r[0] = 0;\r\n    var rLength = 1;\r\n    var cr = 0, lf = 0, crlf = 0;\r\n    var isBasicASCII = true;\r\n    for (var i = 0, len = str.length; i < len; i++) {\r\n        var chr = str.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                crlf++;\r\n                r[rLength++] = i + 2;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                cr++;\r\n                // \\r... case\r\n                r[rLength++] = i + 1;\r\n            }\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            lf++;\r\n            r[rLength++] = i + 1;\r\n        }\r\n        else {\r\n            if (isBasicASCII) {\r\n                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\r\n                    isBasicASCII = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\r\n    r.length = 0;\r\n    return result;\r\n}\r\nvar Piece = /** @class */ (function () {\r\n    function Piece(bufferIndex, start, end, lineFeedCnt, length) {\r\n        this.bufferIndex = bufferIndex;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.lineFeedCnt = lineFeedCnt;\r\n        this.length = length;\r\n    }\r\n    return Piece;\r\n}());\r\nexport { Piece };\r\nvar StringBuffer = /** @class */ (function () {\r\n    function StringBuffer(buffer, lineStarts) {\r\n        this.buffer = buffer;\r\n        this.lineStarts = lineStarts;\r\n    }\r\n    return StringBuffer;\r\n}());\r\nexport { StringBuffer };\r\nvar PieceTreeSearchCache = /** @class */ (function () {\r\n    function PieceTreeSearchCache(limit) {\r\n        this._limit = limit;\r\n        this._cache = [];\r\n    }\r\n    PieceTreeSearchCache.prototype.get = function (offset) {\r\n        for (var i = this._cache.length - 1; i >= 0; i--) {\r\n            var nodePos = this._cache[i];\r\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\r\n                return nodePos;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeSearchCache.prototype.get2 = function (lineNumber) {\r\n        for (var i = this._cache.length - 1; i >= 0; i--) {\r\n            var nodePos = this._cache[i];\r\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\r\n                return nodePos;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeSearchCache.prototype.set = function (nodePosition) {\r\n        if (this._cache.length >= this._limit) {\r\n            this._cache.shift();\r\n        }\r\n        this._cache.push(nodePosition);\r\n    };\r\n    PieceTreeSearchCache.prototype.valdiate = function (offset) {\r\n        var hasInvalidVal = false;\r\n        var tmp = this._cache;\r\n        for (var i = 0; i < tmp.length; i++) {\r\n            var nodePos = tmp[i];\r\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\r\n                tmp[i] = null;\r\n                hasInvalidVal = true;\r\n                continue;\r\n            }\r\n        }\r\n        if (hasInvalidVal) {\r\n            var newArr = [];\r\n            for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {\r\n                var entry = tmp_1[_i];\r\n                if (entry !== null) {\r\n                    newArr.push(entry);\r\n                }\r\n            }\r\n            this._cache = newArr;\r\n        }\r\n    };\r\n    return PieceTreeSearchCache;\r\n}());\r\nvar PieceTreeBase = /** @class */ (function () {\r\n    function PieceTreeBase(chunks, eol, eolNormalized) {\r\n        this.create(chunks, eol, eolNormalized);\r\n    }\r\n    PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {\r\n        this._buffers = [\r\n            new StringBuffer('', [0])\r\n        ];\r\n        this._lastChangeBufferPos = { line: 0, column: 0 };\r\n        this.root = SENTINEL;\r\n        this._lineCnt = 1;\r\n        this._length = 0;\r\n        this._EOL = eol;\r\n        this._EOLLength = eol.length;\r\n        this._EOLNormalized = eolNormalized;\r\n        var lastNode = null;\r\n        for (var i = 0, len = chunks.length; i < len; i++) {\r\n            if (chunks[i].buffer.length > 0) {\r\n                if (!chunks[i].lineStarts) {\r\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\r\n                }\r\n                var piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\r\n                this._buffers.push(chunks[i]);\r\n                lastNode = this.rbInsertRight(lastNode, piece);\r\n            }\r\n        }\r\n        this._searchCache = new PieceTreeSearchCache(1);\r\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\r\n        this.computeBufferMetadata();\r\n    };\r\n    PieceTreeBase.prototype.normalizeEOL = function (eol) {\r\n        var _this = this;\r\n        var averageBufferSize = AverageBufferSize;\r\n        var min = averageBufferSize - Math.floor(averageBufferSize / 3);\r\n        var max = min * 2;\r\n        var tempChunk = '';\r\n        var tempChunkLen = 0;\r\n        var chunks = [];\r\n        this.iterate(this.root, function (node) {\r\n            var str = _this.getNodeContent(node);\r\n            var len = str.length;\r\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\r\n                tempChunk += str;\r\n                tempChunkLen += len;\r\n                return true;\r\n            }\r\n            // flush anyways\r\n            var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\r\n            tempChunk = str;\r\n            tempChunkLen = len;\r\n            return true;\r\n        });\r\n        if (tempChunkLen > 0) {\r\n            var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\r\n        }\r\n        this.create(chunks, eol, true);\r\n    };\r\n    // #region Buffer API\r\n    PieceTreeBase.prototype.getEOL = function () {\r\n        return this._EOL;\r\n    };\r\n    PieceTreeBase.prototype.setEOL = function (newEOL) {\r\n        this._EOL = newEOL;\r\n        this._EOLLength = this._EOL.length;\r\n        this.normalizeEOL(newEOL);\r\n    };\r\n    PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {\r\n        var leftLen = 0; // inorder\r\n        var x = this.root;\r\n        while (x !== SENTINEL) {\r\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\r\n                x = x.left;\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\r\n                leftLen += x.size_left;\r\n                // lineNumber >= 2\r\n                var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\r\n            }\r\n            else {\r\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                leftLen += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        return leftLen;\r\n    };\r\n    PieceTreeBase.prototype.getPositionAt = function (offset) {\r\n        offset = Math.floor(offset);\r\n        offset = Math.max(0, offset);\r\n        var x = this.root;\r\n        var lfCnt = 0;\r\n        var originalOffset = offset;\r\n        while (x !== SENTINEL) {\r\n            if (x.size_left !== 0 && x.size_left >= offset) {\r\n                x = x.left;\r\n            }\r\n            else if (x.size_left + x.piece.length >= offset) {\r\n                var out = this.getIndexOf(x, offset - x.size_left);\r\n                lfCnt += x.lf_left + out.index;\r\n                if (out.index === 0) {\r\n                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\r\n                    var column = originalOffset - lineStartOffset;\r\n                    return new Position(lfCnt + 1, column + 1);\r\n                }\r\n                return new Position(lfCnt + 1, out.remainder + 1);\r\n            }\r\n            else {\r\n                offset -= x.size_left + x.piece.length;\r\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\r\n                if (x.right === SENTINEL) {\r\n                    // last node\r\n                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\r\n                    var column = originalOffset - offset - lineStartOffset;\r\n                    return new Position(lfCnt + 1, column + 1);\r\n                }\r\n                else {\r\n                    x = x.right;\r\n                }\r\n            }\r\n        }\r\n        return new Position(1, 1);\r\n    };\r\n    PieceTreeBase.prototype.getValueInRange = function (range, eol) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            return '';\r\n        }\r\n        var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\r\n        var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\r\n        var value = this.getValueInRange2(startPosition, endPosition);\r\n        if (eol) {\r\n            if (eol !== this._EOL || !this._EOLNormalized) {\r\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            }\r\n            if (eol === this.getEOL() && this._EOLNormalized) {\r\n                if (eol === '\\r\\n') {\r\n                }\r\n                return value;\r\n            }\r\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\r\n        }\r\n        return value;\r\n    };\r\n    PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {\r\n        if (startPosition.node === endPosition.node) {\r\n            var node = startPosition.node;\r\n            var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;\r\n            var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\r\n            return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);\r\n        }\r\n        var x = startPosition.node;\r\n        var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n        var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;\r\n            var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n            if (x === endPosition.node) {\r\n                ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);\r\n                break;\r\n            }\r\n            else {\r\n                ret += buffer_2.substr(startOffset_2, x.piece.length);\r\n            }\r\n            x = x.next();\r\n        }\r\n        return ret;\r\n    };\r\n    PieceTreeBase.prototype.getLinesContent = function () {\r\n        var _this = this;\r\n        var lines = [];\r\n        var linesLength = 0;\r\n        var currentLine = '';\r\n        var danglingCR = false;\r\n        this.iterate(this.root, function (node) {\r\n            if (node === SENTINEL) {\r\n                return true;\r\n            }\r\n            var piece = node.piece;\r\n            var pieceLength = piece.length;\r\n            if (pieceLength === 0) {\r\n                return true;\r\n            }\r\n            var buffer = _this._buffers[piece.bufferIndex].buffer;\r\n            var lineStarts = _this._buffers[piece.bufferIndex].lineStarts;\r\n            var pieceStartLine = piece.start.line;\r\n            var pieceEndLine = piece.end.line;\r\n            var pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\r\n            if (danglingCR) {\r\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\r\n                    // pretend the \\n was in the previous piece..\r\n                    pieceStartOffset++;\r\n                    pieceLength--;\r\n                }\r\n                lines[linesLength++] = currentLine;\r\n                currentLine = '';\r\n                danglingCR = false;\r\n                if (pieceLength === 0) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (pieceStartLine === pieceEndLine) {\r\n                // this piece has no new lines\r\n                if (!_this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\r\n                    danglingCR = true;\r\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\r\n                }\r\n                else {\r\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\r\n                }\r\n                return true;\r\n            }\r\n            // add the text before the first line start in this piece\r\n            currentLine += (_this._EOLNormalized\r\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - _this._EOLLength))\r\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\r\n            lines[linesLength++] = currentLine;\r\n            for (var line = pieceStartLine + 1; line < pieceEndLine; line++) {\r\n                currentLine = (_this._EOLNormalized\r\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - _this._EOLLength)\r\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\r\n                lines[linesLength++] = currentLine;\r\n            }\r\n            if (!_this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\r\n                danglingCR = true;\r\n                if (piece.end.column === 0) {\r\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\r\n                    linesLength--;\r\n                }\r\n                else {\r\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\r\n                }\r\n            }\r\n            else {\r\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\r\n            }\r\n            return true;\r\n        });\r\n        if (danglingCR) {\r\n            lines[linesLength++] = currentLine;\r\n            currentLine = '';\r\n        }\r\n        lines[linesLength++] = currentLine;\r\n        return lines;\r\n    };\r\n    PieceTreeBase.prototype.getLength = function () {\r\n        return this._length;\r\n    };\r\n    PieceTreeBase.prototype.getLineCount = function () {\r\n        return this._lineCnt;\r\n    };\r\n    PieceTreeBase.prototype.getLineContent = function (lineNumber) {\r\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\r\n            return this._lastVisitedLine.value;\r\n        }\r\n        this._lastVisitedLine.lineNumber = lineNumber;\r\n        if (lineNumber === this._lineCnt) {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\r\n        }\r\n        else if (this._EOLNormalized) {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\r\n        }\r\n        else {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\r\n        }\r\n        return this._lastVisitedLine.value;\r\n    };\r\n    PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {\r\n        var nodePos = this.nodeAt2(lineNumber, index + 1);\r\n        if (nodePos.remainder === nodePos.node.piece.length) {\r\n            // the char we want to fetch is at the head of next node.\r\n            var matchingNode = nodePos.node.next();\r\n            if (!matchingNode) {\r\n                return 0;\r\n            }\r\n            var buffer = this._buffers[matchingNode.piece.bufferIndex];\r\n            var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\r\n            return buffer.buffer.charCodeAt(startOffset);\r\n        }\r\n        else {\r\n            var buffer = this._buffers[nodePos.node.piece.bufferIndex];\r\n            var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\r\n            var targetOffset = startOffset + nodePos.remainder;\r\n            return buffer.buffer.charCodeAt(targetOffset);\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.getLineLength = function (lineNumber) {\r\n        if (lineNumber === this.getLineCount()) {\r\n            var startOffset = this.getOffsetAt(lineNumber, 1);\r\n            return this.getLength() - startOffset;\r\n        }\r\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\r\n    };\r\n    PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\r\n        var buffer = this._buffers[node.piece.bufferIndex];\r\n        var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\r\n        var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\r\n        var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        var ret = { line: 0, column: 0 };\r\n        var searchText;\r\n        var offsetInBuffer;\r\n        if (searcher._wordSeparators) {\r\n            searchText = buffer.buffer.substring(start, end);\r\n            offsetInBuffer = function (offset) { return offset + start; };\r\n            searcher.reset(-1);\r\n        }\r\n        else {\r\n            searchText = buffer.buffer;\r\n            offsetInBuffer = function (offset) { return offset; };\r\n            searcher.reset(start);\r\n        }\r\n        do {\r\n            m = searcher.next(searchText);\r\n            if (m) {\r\n                if (offsetInBuffer(m.index) >= end) {\r\n                    return resultLen;\r\n                }\r\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\r\n                var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\r\n                var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\r\n                var retEndColumn = retStartColumn + m[0].length;\r\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\r\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\r\n                    return resultLen;\r\n                }\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\r\n        var result = [];\r\n        var resultLen = 0;\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\r\n        if (startPosition === null) {\r\n            return [];\r\n        }\r\n        var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\r\n        if (endPosition === null) {\r\n            return [];\r\n        }\r\n        var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\r\n        var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\r\n        if (startPosition.node === endPosition.node) {\r\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\r\n            return result;\r\n        }\r\n        var startLineNumber = searchRange.startLineNumber;\r\n        var currentNode = startPosition.node;\r\n        while (currentNode !== endPosition.node) {\r\n            var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\r\n            if (lineBreakCnt >= 1) {\r\n                // last line break position\r\n                var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\r\n                var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\r\n                var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\r\n                var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\r\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\r\n                if (resultLen >= limitResultCount) {\r\n                    return result;\r\n                }\r\n                startLineNumber += lineBreakCnt;\r\n            }\r\n            var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\r\n            // search for the remaining content\r\n            if (startLineNumber === searchRange.endLineNumber) {\r\n                var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);\r\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\r\n                return result;\r\n            }\r\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\r\n            if (resultLen >= limitResultCount) {\r\n                return result;\r\n            }\r\n            startLineNumber++;\r\n            startPosition = this.nodeAt2(startLineNumber, 1);\r\n            currentNode = startPosition.node;\r\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\r\n        }\r\n        if (startLineNumber === searchRange.endLineNumber) {\r\n            var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\r\n            var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\r\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\r\n        return result;\r\n    };\r\n    PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        var wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            var searchString = searchData.simpleSearch;\r\n            var searchStringLen = searchString.length;\r\n            var textLength = text.length;\r\n            var lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    // #endregion\r\n    // #region Piece Table\r\n    PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {\r\n        if (eolNormalized === void 0) { eolNormalized = false; }\r\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\r\n        this._lastVisitedLine.lineNumber = 0;\r\n        this._lastVisitedLine.value = '';\r\n        if (this.root !== SENTINEL) {\r\n            var _a = this.nodeAt(offset), node = _a.node, remainder = _a.remainder, nodeStartOffset = _a.nodeStartOffset;\r\n            var piece = node.piece;\r\n            var bufferIndex = piece.bufferIndex;\r\n            var insertPosInBuffer = this.positionInBuffer(node, remainder);\r\n            if (node.piece.bufferIndex === 0 &&\r\n                piece.end.line === this._lastChangeBufferPos.line &&\r\n                piece.end.column === this._lastChangeBufferPos.column &&\r\n                (nodeStartOffset + piece.length === offset) &&\r\n                value.length < AverageBufferSize) {\r\n                // changed buffer\r\n                this.appendToNode(node, value);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            if (nodeStartOffset === offset) {\r\n                this.insertContentToNodeLeft(value, node);\r\n                this._searchCache.valdiate(offset);\r\n            }\r\n            else if (nodeStartOffset + node.piece.length > offset) {\r\n                // we are inserting into the middle of a node.\r\n                var nodesToDel = [];\r\n                var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\r\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\r\n                    var headOfRight = this.nodeCharCodeAt(node, remainder);\r\n                    if (headOfRight === 10 /** \\n */) {\r\n                        var newStart = { line: newRightPiece.start.line + 1, column: 0 };\r\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\r\n                        value += '\\n';\r\n                    }\r\n                }\r\n                // reuse node for content before insertion point.\r\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\r\n                    var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\r\n                    if (tailOfLeft === 13 /** \\r */) {\r\n                        var previousPos = this.positionInBuffer(node, remainder - 1);\r\n                        this.deleteNodeTail(node, previousPos);\r\n                        value = '\\r' + value;\r\n                        if (node.piece.length === 0) {\r\n                            nodesToDel.push(node);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.deleteNodeTail(node, insertPosInBuffer);\r\n                    }\r\n                }\r\n                else {\r\n                    this.deleteNodeTail(node, insertPosInBuffer);\r\n                }\r\n                var newPieces = this.createNewPieces(value);\r\n                if (newRightPiece.length > 0) {\r\n                    this.rbInsertRight(node, newRightPiece);\r\n                }\r\n                var tmpNode = node;\r\n                for (var k = 0; k < newPieces.length; k++) {\r\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\r\n                }\r\n                this.deleteNodes(nodesToDel);\r\n            }\r\n            else {\r\n                this.insertContentToNodeRight(value, node);\r\n            }\r\n        }\r\n        else {\r\n            // insert new node\r\n            var pieces = this.createNewPieces(value);\r\n            var node = this.rbInsertLeft(null, pieces[0]);\r\n            for (var k = 1; k < pieces.length; k++) {\r\n                node = this.rbInsertRight(node, pieces[k]);\r\n            }\r\n        }\r\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\r\n        this.computeBufferMetadata();\r\n    };\r\n    PieceTreeBase.prototype.delete = function (offset, cnt) {\r\n        this._lastVisitedLine.lineNumber = 0;\r\n        this._lastVisitedLine.value = '';\r\n        if (cnt <= 0 || this.root === SENTINEL) {\r\n            return;\r\n        }\r\n        var startPosition = this.nodeAt(offset);\r\n        var endPosition = this.nodeAt(offset + cnt);\r\n        var startNode = startPosition.node;\r\n        var endNode = endPosition.node;\r\n        if (startNode === endNode) {\r\n            var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);\r\n            var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);\r\n            if (startPosition.nodeStartOffset === offset) {\r\n                if (cnt === startNode.piece.length) { // delete node\r\n                    var next = startNode.next();\r\n                    rbDelete(this, startNode);\r\n                    this.validateCRLFWithPrevNode(next);\r\n                    this.computeBufferMetadata();\r\n                    return;\r\n                }\r\n                this.deleteNodeHead(startNode, endSplitPosInBuffer_1);\r\n                this._searchCache.valdiate(offset);\r\n                this.validateCRLFWithPrevNode(startNode);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\r\n                this.deleteNodeTail(startNode, startSplitPosInBuffer_1);\r\n                this.validateCRLFWithNextNode(startNode);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            // delete content in the middle, this node will be splitted to nodes\r\n            this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);\r\n            this.computeBufferMetadata();\r\n            return;\r\n        }\r\n        var nodesToDel = [];\r\n        var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\r\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\r\n        this._searchCache.valdiate(offset);\r\n        if (startNode.piece.length === 0) {\r\n            nodesToDel.push(startNode);\r\n        }\r\n        // update last touched node\r\n        var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\r\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\r\n        if (endNode.piece.length === 0) {\r\n            nodesToDel.push(endNode);\r\n        }\r\n        // delete nodes in between\r\n        var secondNode = startNode.next();\r\n        for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\r\n            nodesToDel.push(node);\r\n        }\r\n        var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\r\n        this.deleteNodes(nodesToDel);\r\n        this.validateCRLFWithNextNode(prev);\r\n        this.computeBufferMetadata();\r\n    };\r\n    PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {\r\n        // we are inserting content to the beginning of node\r\n        var nodesToDel = [];\r\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\r\n            // move `\\n` to new node.\r\n            var piece = node.piece;\r\n            var newStart = { line: piece.start.line + 1, column: 0 };\r\n            var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\r\n            node.piece = nPiece;\r\n            value += '\\n';\r\n            updateTreeMetadata(this, node, -1, -1);\r\n            if (node.piece.length === 0) {\r\n                nodesToDel.push(node);\r\n            }\r\n        }\r\n        var newPieces = this.createNewPieces(value);\r\n        var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\r\n        for (var k = newPieces.length - 2; k >= 0; k--) {\r\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\r\n        }\r\n        this.validateCRLFWithPrevNode(newNode);\r\n        this.deleteNodes(nodesToDel);\r\n    };\r\n    PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {\r\n        // we are inserting to the right of this node.\r\n        if (this.adjustCarriageReturnFromNext(value, node)) {\r\n            // move \\n to the new node.\r\n            value += '\\n';\r\n        }\r\n        var newPieces = this.createNewPieces(value);\r\n        var newNode = this.rbInsertRight(node, newPieces[0]);\r\n        var tmpNode = newNode;\r\n        for (var k = 1; k < newPieces.length; k++) {\r\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\r\n        }\r\n        this.validateCRLFWithPrevNode(newNode);\r\n    };\r\n    PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {\r\n        var piece = node.piece;\r\n        var bufferIndex = node.piece.bufferIndex;\r\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        var startOffset = lineStarts[piece.start.line] + piece.start.column;\r\n        var offset = startOffset + remainder;\r\n        // binary search offset between startOffset and endOffset\r\n        var low = piece.start.line;\r\n        var high = piece.end.line;\r\n        var mid = 0;\r\n        var midStop = 0;\r\n        var midStart = 0;\r\n        while (low <= high) {\r\n            mid = low + ((high - low) / 2) | 0;\r\n            midStart = lineStarts[mid];\r\n            if (mid === high) {\r\n                break;\r\n            }\r\n            midStop = lineStarts[mid + 1];\r\n            if (offset < midStart) {\r\n                high = mid - 1;\r\n            }\r\n            else if (offset >= midStop) {\r\n                low = mid + 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (ret) {\r\n            ret.line = mid;\r\n            ret.column = offset - midStart;\r\n            return null;\r\n        }\r\n        return {\r\n            line: mid,\r\n            column: offset - midStart\r\n        };\r\n    };\r\n    PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {\r\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\r\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\r\n        if (end.column === 0) {\r\n            return end.line - start.line;\r\n        }\r\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\r\n            return end.line - start.line;\r\n        }\r\n        var nextLineStartOffset = lineStarts[end.line + 1];\r\n        var endOffset = lineStarts[end.line] + end.column;\r\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\r\n            return end.line - start.line;\r\n        }\r\n        // endOffset + 1 === nextLineStartOffset\r\n        // character at endOffset is \\n, so we check the character before first\r\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\r\n        var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\r\n        var buffer = this._buffers[bufferIndex].buffer;\r\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\r\n            return end.line - start.line + 1;\r\n        }\r\n        else {\r\n            return end.line - start.line;\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {\r\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        return lineStarts[cursor.line] + cursor.column;\r\n    };\r\n    PieceTreeBase.prototype.deleteNodes = function (nodes) {\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            rbDelete(this, nodes[i]);\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.createNewPieces = function (text) {\r\n        if (text.length > AverageBufferSize) {\r\n            // the content is large, operations like substring, charCode becomes slow\r\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\r\n            var newPieces = [];\r\n            while (text.length > AverageBufferSize) {\r\n                var lastChar = text.charCodeAt(AverageBufferSize - 1);\r\n                var splitText = void 0;\r\n                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\r\n                    // last character is \\r or a high surrogate => keep it back\r\n                    splitText = text.substring(0, AverageBufferSize - 1);\r\n                    text = text.substring(AverageBufferSize - 1);\r\n                }\r\n                else {\r\n                    splitText = text.substring(0, AverageBufferSize);\r\n                    text = text.substring(AverageBufferSize);\r\n                }\r\n                var lineStarts_1 = createLineStartsFast(splitText);\r\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_1.length - 1, column: splitText.length - lineStarts_1[lineStarts_1.length - 1] }, lineStarts_1.length - 1, splitText.length));\r\n                this._buffers.push(new StringBuffer(splitText, lineStarts_1));\r\n            }\r\n            var lineStarts_2 = createLineStartsFast(text);\r\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_2.length - 1, column: text.length - lineStarts_2[lineStarts_2.length - 1] }, lineStarts_2.length - 1, text.length));\r\n            this._buffers.push(new StringBuffer(text, lineStarts_2));\r\n            return newPieces;\r\n        }\r\n        var startOffset = this._buffers[0].buffer.length;\r\n        var lineStarts = createLineStartsFast(text, false);\r\n        var start = this._lastChangeBufferPos;\r\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\r\n            && startOffset !== 0\r\n            && this.startWithLF(text)\r\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\r\n        ) {\r\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\r\n            start = this._lastChangeBufferPos;\r\n            for (var i = 0; i < lineStarts.length; i++) {\r\n                lineStarts[i] += startOffset + 1;\r\n            }\r\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n            this._buffers[0].buffer += '_' + text;\r\n            startOffset += 1;\r\n        }\r\n        else {\r\n            if (startOffset !== 0) {\r\n                for (var i = 0; i < lineStarts.length; i++) {\r\n                    lineStarts[i] += startOffset;\r\n                }\r\n            }\r\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n            this._buffers[0].buffer += text;\r\n        }\r\n        var endOffset = this._buffers[0].buffer.length;\r\n        var endIndex = this._buffers[0].lineStarts.length - 1;\r\n        var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\r\n        var endPos = { line: endIndex, column: endColumn };\r\n        var newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\r\n        this._lastChangeBufferPos = endPos;\r\n        return [newPiece];\r\n    };\r\n    PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {\r\n        if (endOffset === void 0) { endOffset = 0; }\r\n        var x = this.root;\r\n        var ret = '';\r\n        var cache = this._searchCache.get2(lineNumber);\r\n        if (cache) {\r\n            x = cache.node;\r\n            var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\r\n            var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\r\n                ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\r\n            }\r\n            else {\r\n                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\r\n                return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\r\n            }\r\n        }\r\n        else {\r\n            var nodeStartOffset = 0;\r\n            var originalLineNumber = lineNumber;\r\n            while (x !== SENTINEL) {\r\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\r\n                    x = x.left;\r\n                }\r\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\r\n                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                    var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\r\n                    var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                    nodeStartOffset += x.size_left;\r\n                    this._searchCache.set({\r\n                        node: x,\r\n                        nodeStartOffset: nodeStartOffset,\r\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\r\n                    });\r\n                    return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\r\n                }\r\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\r\n                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                    var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                    ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\r\n                    break;\r\n                }\r\n                else {\r\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                    nodeStartOffset += x.size_left + x.piece.length;\r\n                    x = x.right;\r\n                }\r\n            }\r\n        }\r\n        // search in order, to find the node contains end column\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            var buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            if (x.piece.lineFeedCnt > 0) {\r\n                var accumualtedValue = this.getAccumulatedValue(x, 0);\r\n                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\r\n                return ret;\r\n            }\r\n            else {\r\n                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                ret += buffer.substr(startOffset, x.piece.length);\r\n            }\r\n            x = x.next();\r\n        }\r\n        return ret;\r\n    };\r\n    PieceTreeBase.prototype.computeBufferMetadata = function () {\r\n        var x = this.root;\r\n        var lfCnt = 1;\r\n        var len = 0;\r\n        while (x !== SENTINEL) {\r\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\r\n            len += x.size_left + x.piece.length;\r\n            x = x.right;\r\n        }\r\n        this._lineCnt = lfCnt;\r\n        this._length = len;\r\n        this._searchCache.valdiate(this._length);\r\n    };\r\n    // #region node operations\r\n    PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {\r\n        var piece = node.piece;\r\n        var pos = this.positionInBuffer(node, accumulatedValue);\r\n        var lineCnt = pos.line - piece.start.line;\r\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\r\n            // we are checking the end of this node, so a CRLF check is necessary.\r\n            var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\r\n            if (realLineCnt !== lineCnt) {\r\n                // aha yes, CRLF\r\n                return { index: realLineCnt, remainder: 0 };\r\n            }\r\n        }\r\n        return { index: lineCnt, remainder: pos.column };\r\n    };\r\n    PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {\r\n        if (index < 0) {\r\n            return 0;\r\n        }\r\n        var piece = node.piece;\r\n        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n        var expectedLineStartIndex = piece.start.line + index + 1;\r\n        if (expectedLineStartIndex > piece.end.line) {\r\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\r\n        }\r\n        else {\r\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {\r\n        var piece = node.piece;\r\n        var originalLFCnt = piece.lineFeedCnt;\r\n        var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        var newEnd = pos;\r\n        var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\r\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\r\n        var lf_delta = newLineFeedCnt - originalLFCnt;\r\n        var size_delta = newEndOffset - originalEndOffset;\r\n        var newLength = piece.length + size_delta;\r\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, size_delta, lf_delta);\r\n    };\r\n    PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {\r\n        var piece = node.piece;\r\n        var originalLFCnt = piece.lineFeedCnt;\r\n        var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        var newStart = pos;\r\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\r\n        var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\r\n        var lf_delta = newLineFeedCnt - originalLFCnt;\r\n        var size_delta = originalStartOffset - newStartOffset;\r\n        var newLength = piece.length + size_delta;\r\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, size_delta, lf_delta);\r\n    };\r\n    PieceTreeBase.prototype.shrinkNode = function (node, start, end) {\r\n        var piece = node.piece;\r\n        var originalStartPos = piece.start;\r\n        var originalEndPos = piece.end;\r\n        // old piece, originalStartPos, start\r\n        var oldLength = piece.length;\r\n        var oldLFCnt = piece.lineFeedCnt;\r\n        var newEnd = start;\r\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\r\n        var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\r\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\r\n        // new right piece, end, originalEndPos\r\n        var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\r\n        var newNode = this.rbInsertRight(node, newPiece);\r\n        this.validateCRLFWithPrevNode(newNode);\r\n    };\r\n    PieceTreeBase.prototype.appendToNode = function (node, value) {\r\n        if (this.adjustCarriageReturnFromNext(value, node)) {\r\n            value += '\\n';\r\n        }\r\n        var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\r\n        var startOffset = this._buffers[0].buffer.length;\r\n        this._buffers[0].buffer += value;\r\n        var lineStarts = createLineStartsFast(value, false);\r\n        for (var i = 0; i < lineStarts.length; i++) {\r\n            lineStarts[i] += startOffset;\r\n        }\r\n        if (hitCRLF) {\r\n            var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\r\n            this._buffers[0].lineStarts.pop();\r\n            // _lastChangeBufferPos is already wrong\r\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\r\n        }\r\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n        var endIndex = this._buffers[0].lineStarts.length - 1;\r\n        var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\r\n        var newEnd = { line: endIndex, column: endColumn };\r\n        var newLength = node.piece.length + value.length;\r\n        var oldLineFeedCnt = node.piece.lineFeedCnt;\r\n        var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\r\n        var lf_delta = newLineFeedCnt - oldLineFeedCnt;\r\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\r\n        this._lastChangeBufferPos = newEnd;\r\n        updateTreeMetadata(this, node, value.length, lf_delta);\r\n    };\r\n    PieceTreeBase.prototype.nodeAt = function (offset) {\r\n        var x = this.root;\r\n        var cache = this._searchCache.get(offset);\r\n        if (cache) {\r\n            return {\r\n                node: cache.node,\r\n                nodeStartOffset: cache.nodeStartOffset,\r\n                remainder: offset - cache.nodeStartOffset\r\n            };\r\n        }\r\n        var nodeStartOffset = 0;\r\n        while (x !== SENTINEL) {\r\n            if (x.size_left > offset) {\r\n                x = x.left;\r\n            }\r\n            else if (x.size_left + x.piece.length >= offset) {\r\n                nodeStartOffset += x.size_left;\r\n                var ret = {\r\n                    node: x,\r\n                    remainder: offset - x.size_left,\r\n                    nodeStartOffset: nodeStartOffset\r\n                };\r\n                this._searchCache.set(ret);\r\n                return ret;\r\n            }\r\n            else {\r\n                offset -= x.size_left + x.piece.length;\r\n                nodeStartOffset += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {\r\n        var x = this.root;\r\n        var nodeStartOffset = 0;\r\n        while (x !== SENTINEL) {\r\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\r\n                x = x.left;\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\r\n                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\r\n                nodeStartOffset += x.size_left;\r\n                return {\r\n                    node: x,\r\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\r\n                    nodeStartOffset: nodeStartOffset\r\n                };\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\r\n                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\r\n                    return {\r\n                        node: x,\r\n                        remainder: prevAccumualtedValue + column - 1,\r\n                        nodeStartOffset: nodeStartOffset\r\n                    };\r\n                }\r\n                else {\r\n                    column -= x.piece.length - prevAccumualtedValue;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                nodeStartOffset += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        // search in order, to find the node contains position.column\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            if (x.piece.lineFeedCnt > 0) {\r\n                var accumualtedValue = this.getAccumulatedValue(x, 0);\r\n                var nodeStartOffset_1 = this.offsetOfNode(x);\r\n                return {\r\n                    node: x,\r\n                    remainder: Math.min(column - 1, accumualtedValue),\r\n                    nodeStartOffset: nodeStartOffset_1\r\n                };\r\n            }\r\n            else {\r\n                if (x.piece.length >= column - 1) {\r\n                    var nodeStartOffset_2 = this.offsetOfNode(x);\r\n                    return {\r\n                        node: x,\r\n                        remainder: column - 1,\r\n                        nodeStartOffset: nodeStartOffset_2\r\n                    };\r\n                }\r\n                else {\r\n                    column -= x.piece.length;\r\n                }\r\n            }\r\n            x = x.next();\r\n        }\r\n        return null;\r\n    };\r\n    PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {\r\n        if (node.piece.lineFeedCnt < 1) {\r\n            return -1;\r\n        }\r\n        var buffer = this._buffers[node.piece.bufferIndex];\r\n        var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\r\n        return buffer.buffer.charCodeAt(newOffset);\r\n    };\r\n    PieceTreeBase.prototype.offsetOfNode = function (node) {\r\n        if (!node) {\r\n            return 0;\r\n        }\r\n        var pos = node.size_left;\r\n        while (node !== this.root) {\r\n            if (node.parent.right === node) {\r\n                pos += node.parent.size_left + node.parent.piece.length;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return pos;\r\n    };\r\n    // #endregion\r\n    // #region CRLF\r\n    PieceTreeBase.prototype.shouldCheckCRLF = function () {\r\n        return !(this._EOLNormalized && this._EOL === '\\n');\r\n    };\r\n    PieceTreeBase.prototype.startWithLF = function (val) {\r\n        if (typeof val === 'string') {\r\n            return val.charCodeAt(0) === 10;\r\n        }\r\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\r\n            return false;\r\n        }\r\n        var piece = val.piece;\r\n        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n        var line = piece.start.line;\r\n        var startOffset = lineStarts[line] + piece.start.column;\r\n        if (line === lineStarts.length - 1) {\r\n            // last line, so there is no line feed at the end of this line\r\n            return false;\r\n        }\r\n        var nextLineOffset = lineStarts[line + 1];\r\n        if (nextLineOffset > startOffset + 1) {\r\n            return false;\r\n        }\r\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\r\n    };\r\n    PieceTreeBase.prototype.endWithCR = function (val) {\r\n        if (typeof val === 'string') {\r\n            return val.charCodeAt(val.length - 1) === 13;\r\n        }\r\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\r\n            return false;\r\n        }\r\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\r\n    };\r\n    PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {\r\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\r\n            var node = nextNode.prev();\r\n            if (this.endWithCR(node)) {\r\n                this.fixCRLF(node, nextNode);\r\n            }\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {\r\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\r\n            var nextNode = node.next();\r\n            if (this.startWithLF(nextNode)) {\r\n                this.fixCRLF(node, nextNode);\r\n            }\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.fixCRLF = function (prev, next) {\r\n        var nodesToDel = [];\r\n        // update node\r\n        var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\r\n        var newEnd;\r\n        if (prev.piece.end.column === 0) {\r\n            // it means, last line ends with \\r, not \\r\\n\r\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\r\n        }\r\n        else {\r\n            // \\r\\n\r\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\r\n        }\r\n        var prevNewLength = prev.piece.length - 1;\r\n        var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\r\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\r\n        updateTreeMetadata(this, prev, -1, -1);\r\n        if (prev.piece.length === 0) {\r\n            nodesToDel.push(prev);\r\n        }\r\n        // update nextNode\r\n        var newStart = { line: next.piece.start.line + 1, column: 0 };\r\n        var newLength = next.piece.length - 1;\r\n        var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\r\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, next, -1, -1);\r\n        if (next.piece.length === 0) {\r\n            nodesToDel.push(next);\r\n        }\r\n        // create new piece which contains \\r\\n\r\n        var pieces = this.createNewPieces('\\r\\n');\r\n        this.rbInsertRight(prev, pieces[0]);\r\n        // delete empty nodes\r\n        for (var i = 0; i < nodesToDel.length; i++) {\r\n            rbDelete(this, nodesToDel[i]);\r\n        }\r\n    };\r\n    PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {\r\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\r\n            var nextNode = node.next();\r\n            if (this.startWithLF(nextNode)) {\r\n                // move `\\n` forward\r\n                value += '\\n';\r\n                if (nextNode.piece.length === 1) {\r\n                    rbDelete(this, nextNode);\r\n                }\r\n                else {\r\n                    var piece = nextNode.piece;\r\n                    var newStart = { line: piece.start.line + 1, column: 0 };\r\n                    var newLength = piece.length - 1;\r\n                    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\r\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\r\n                    updateTreeMetadata(this, nextNode, -1, -1);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    // #endregion\r\n    // #endregion\r\n    // #region Tree operations\r\n    PieceTreeBase.prototype.iterate = function (node, callback) {\r\n        if (node === SENTINEL) {\r\n            return callback(SENTINEL);\r\n        }\r\n        var leftRet = this.iterate(node.left, callback);\r\n        if (!leftRet) {\r\n            return leftRet;\r\n        }\r\n        return callback(node) && this.iterate(node.right, callback);\r\n    };\r\n    PieceTreeBase.prototype.getNodeContent = function (node) {\r\n        if (node === SENTINEL) {\r\n            return '';\r\n        }\r\n        var buffer = this._buffers[node.piece.bufferIndex];\r\n        var currentContent;\r\n        var piece = node.piece;\r\n        var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\r\n        return currentContent;\r\n    };\r\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b    <----   a    b\r\n     *                         /\r\n     *                        z\r\n     */\r\n    PieceTreeBase.prototype.rbInsertRight = function (node, p) {\r\n        var z = new TreeNode(p, 1 /* Red */);\r\n        z.left = SENTINEL;\r\n        z.right = SENTINEL;\r\n        z.parent = SENTINEL;\r\n        z.size_left = 0;\r\n        z.lf_left = 0;\r\n        var x = this.root;\r\n        if (x === SENTINEL) {\r\n            this.root = z;\r\n            z.color = 0 /* Black */;\r\n        }\r\n        else if (node.right === SENTINEL) {\r\n            node.right = z;\r\n            z.parent = node;\r\n        }\r\n        else {\r\n            var nextNode = leftest(node.right);\r\n            nextNode.left = z;\r\n            z.parent = nextNode;\r\n        }\r\n        fixInsert(this, z);\r\n        return z;\r\n    };\r\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b     ---->   a    b\r\n     *                       \\\r\n     *                        z\r\n     */\r\n    PieceTreeBase.prototype.rbInsertLeft = function (node, p) {\r\n        var z = new TreeNode(p, 1 /* Red */);\r\n        z.left = SENTINEL;\r\n        z.right = SENTINEL;\r\n        z.parent = SENTINEL;\r\n        z.size_left = 0;\r\n        z.lf_left = 0;\r\n        if (this.root === SENTINEL) {\r\n            this.root = z;\r\n            z.color = 0 /* Black */;\r\n        }\r\n        else if (node.left === SENTINEL) {\r\n            node.left = z;\r\n            z.parent = node;\r\n        }\r\n        else {\r\n            var prevNode = righttest(node.left); // a\r\n            prevNode.right = z;\r\n            z.parent = prevNode;\r\n        }\r\n        fixInsert(this, z);\r\n        return z;\r\n    };\r\n    return PieceTreeBase;\r\n}());\r\nexport { PieceTreeBase };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}