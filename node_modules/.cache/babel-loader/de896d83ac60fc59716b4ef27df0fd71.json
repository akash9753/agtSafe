{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nvar LinePart = /** @class */function () {\n  function LinePart(endIndex, type) {\n    this.endIndex = endIndex;\n    this.type = type;\n  }\n  return LinePart;\n}();\nvar LineRange = /** @class */function () {\n  function LineRange(startIndex, endIndex) {\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n  LineRange.prototype.equals = function (otherLineRange) {\n    return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n  };\n  return LineRange;\n}();\nexport { LineRange };\nvar RenderLineInput = /** @class */function () {\n  function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.middotWidth = middotWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 3 /* All */ : renderWhitespace === 'boundary' ? 1 /* Boundary */ : renderWhitespace === 'selection' ? 2 /* Selection */ : 0 /* None */;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) {\n      return a.startOffset < b.startOffset ? -1 : 1;\n    });\n  }\n  RenderLineInput.prototype.sameSelection = function (otherSelections) {\n    if (this.selectionsOnLine === null) {\n      return otherSelections === null;\n    }\n    if (otherSelections === null) {\n      return false;\n    }\n    if (otherSelections.length !== this.selectionsOnLine.length) {\n      return false;\n    }\n    for (var i = 0; i < this.selectionsOnLine.length; i++) {\n      if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n  RenderLineInput.prototype.equals = function (other) {\n    return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n  };\n  return RenderLineInput;\n}();\nexport { RenderLineInput };\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\nvar CharacterMapping = /** @class */function () {\n  function CharacterMapping(length, partCount) {\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._absoluteOffsets = new Uint32Array(this.length);\n  }\n  CharacterMapping.getPartIndex = function (partData) {\n    return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\n  };\n\n  CharacterMapping.getCharIndex = function (partData) {\n    return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\n  };\n\n  CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {\n    var partData = (partIndex << 16 /* PART_INDEX_OFFSET */ | charIndex << 0 /* CHAR_INDEX_OFFSET */) >>> 0;\n    this._data[charOffset] = partData;\n    this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n  };\n  CharacterMapping.prototype.getAbsoluteOffsets = function () {\n    return this._absoluteOffsets;\n  };\n  CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {\n    if (this.length === 0) {\n      return 0;\n    }\n    if (charOffset < 0) {\n      return this._data[0];\n    }\n    if (charOffset >= this.length) {\n      return this._data[this.length - 1];\n    }\n    return this._data[charOffset];\n  };\n  CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {\n    if (this.length === 0) {\n      return 0;\n    }\n    var searchEntry = (partIndex << 16 /* PART_INDEX_OFFSET */ | charIndex << 0 /* CHAR_INDEX_OFFSET */) >>> 0;\n    var min = 0;\n    var max = this.length - 1;\n    while (min + 1 < max) {\n      var mid = min + max >>> 1;\n      var midEntry = this._data[mid];\n      if (midEntry === searchEntry) {\n        return mid;\n      } else if (midEntry > searchEntry) {\n        max = mid;\n      } else {\n        min = mid;\n      }\n    }\n    if (min === max) {\n      return min;\n    }\n    var minEntry = this._data[min];\n    var maxEntry = this._data[max];\n    if (minEntry === searchEntry) {\n      return min;\n    }\n    if (maxEntry === searchEntry) {\n      return max;\n    }\n    var minPartIndex = CharacterMapping.getPartIndex(minEntry);\n    var minCharIndex = CharacterMapping.getCharIndex(minEntry);\n    var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n    var maxCharIndex;\n    if (minPartIndex !== maxPartIndex) {\n      // sitting between parts\n      maxCharIndex = partLength;\n    } else {\n      maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n    }\n    var minEntryDistance = charIndex - minCharIndex;\n    var maxEntryDistance = maxCharIndex - charIndex;\n    if (minEntryDistance <= maxEntryDistance) {\n      return min;\n    }\n    return max;\n  };\n  return CharacterMapping;\n}();\nexport { CharacterMapping };\nvar RenderLineOutput = /** @class */function () {\n  function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n  return RenderLineOutput;\n}();\nexport { RenderLineOutput };\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    var containsForeignElements = 0 /* None */;\n    // This is basically for IE's hit test to work\n    var content = \"<span><span>\\xA0</span></span>\";\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      var beforeClassNames = [];\n      var afterClassNames = [];\n      for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\n        var lineDecoration = input.lineDecorations[i];\n        if (lineDecoration.type === 1 /* Before */) {\n          beforeClassNames.push(input.lineDecorations[i].className);\n          containsForeignElements |= 1 /* Before */;\n        }\n\n        if (lineDecoration.type === 2 /* After */) {\n          afterClassNames.push(input.lineDecorations[i].className);\n          containsForeignElements |= 2 /* After */;\n        }\n      }\n\n      if (containsForeignElements !== 0 /* None */) {\n        var beforeSpan = beforeClassNames.length > 0 ? \"<span class=\\\"\" + beforeClassNames.join(' ') + \"\\\"></span>\" : \"\";\n        var afterSpan = afterClassNames.length > 0 ? \"<span class=\\\"\" + afterClassNames.join(' ') + \"\\\"></span>\" : \"\";\n        content = \"<span>\" + beforeSpan + afterSpan + \"</span>\";\n      }\n    }\n    sb.appendASCIIString(content);\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n  }\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\nvar RenderLineOutput2 = /** @class */function () {\n  function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\n    this.characterMapping = characterMapping;\n    this.html = html;\n    this.containsRTL = containsRTL;\n    this.containsForeignElements = containsForeignElements;\n  }\n  return RenderLineOutput2;\n}();\nexport { RenderLineOutput2 };\nexport function renderViewLine2(input) {\n  var sb = createStringBuilder(10000);\n  var out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nvar ResolvedRenderLineInput = /** @class */function () {\n  function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, middotWidth, renderWhitespace, renderControlCharacters) {\n    this.fontIsMonospace = fontIsMonospace;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.len = len;\n    this.isOverflowing = isOverflowing;\n    this.parts = parts;\n    this.containsForeignElements = containsForeignElements;\n    this.fauxIndentLength = fauxIndentLength;\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.containsRTL = containsRTL;\n    this.spaceWidth = spaceWidth;\n    this.middotWidth = middotWidth;\n    this.renderWhitespace = renderWhitespace;\n    this.renderControlCharacters = renderControlCharacters;\n    //\n  }\n\n  return ResolvedRenderLineInput;\n}();\nfunction resolveRenderLineInput(input) {\n  var useMonospaceOptimizations = input.useMonospaceOptimizations;\n  var lineContent = input.lineContent;\n  var isOverflowing;\n  var len;\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    len = lineContent.length;\n  }\n  var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n  if (input.renderWhitespace === 3 /* All */ || input.renderWhitespace === 1 /* Boundary */ || input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) {\n    tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, useMonospaceOptimizations, input.selectionsOnLine, input.renderWhitespace === 1 /* Boundary */);\n  }\n\n  var containsForeignElements = 0 /* None */;\n  if (input.lineDecorations.length > 0) {\n    for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {\n      var lineDecoration = input.lineDecorations[i];\n      if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\n        // Pretend there are foreign elements... although not 100% accurate.\n        containsForeignElements |= 1 /* Before */;\n      } else if (lineDecoration.type === 1 /* Before */) {\n        containsForeignElements |= 1 /* Before */;\n      } else if (lineDecoration.type === 2 /* After */) {\n        containsForeignElements |= 2 /* After */;\n      }\n    }\n\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n  return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.middotWidth, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n  var result = [],\n    resultLen = 0;\n  // The faux indent part of the line should have no token type\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '');\n  }\n  for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    var endIndex = tokens.getEndOffset(tokenIndex);\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n    var type = tokens.getClassName(tokenIndex);\n    if (endIndex >= len) {\n      result[resultLen++] = new LinePart(len, type);\n      break;\n    }\n    result[resultLen++] = new LinePart(endIndex, type);\n  }\n  return result;\n}\n/**\r\n * See https://github.com/Microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  var lastTokenEndIndex = 0;\n  var result = [],\n    resultLen = 0;\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n      if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\n        var tokenType = token.type;\n        var lastSpaceOffset = -1;\n        var currTokenStart = lastTokenEndIndex;\n        for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32 /* Space */) {\n            lastSpaceOffset = j;\n          }\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\n            // Split at `lastSpaceOffset` + 1\n            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\n            currTokenStart = lastSpaceOffset + 1;\n            lastSpaceOffset = -1;\n          }\n        }\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n      var diff = tokenEndIndex - lastTokenEndIndex;\n      if (diff > 50 /* LongToken */) {\n        var tokenType = token.type;\n        var piecesCount = Math.ceil(diff / 50 /* LongToken */);\n        for (var j = 1; j < piecesCount; j++) {\n          var pieceEndIndex = lastTokenEndIndex + j * 50 /* LongToken */;\n          result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\n        }\n        result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  }\n  return result;\n}\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\nfunction _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, startVisibleColumn, useMonospaceOptimizations, selections, onlyBoundary) {\n  var result = [],\n    resultLen = 0;\n  var tokenIndex = 0;\n  var tokenType = tokens[tokenIndex].type;\n  var tokenEndIndex = tokens[tokenIndex].endIndex;\n  var tokensLength = tokens.length;\n  var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  var lastNonWhitespaceIndex;\n  if (firstNonWhitespaceIndex === -1) {\n    // The entire line is whitespace\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n  var wasInWhitespace = false;\n  var currentSelectionIndex = 0;\n  var currentSelection = selections && selections[currentSelectionIndex];\n  var tmpIndent = startVisibleColumn % tabSize;\n  for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    var chCode = lineContent.charCodeAt(charIndex);\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n    var isInWhitespace = void 0;\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9 /* Tab */) {\n      // a tab character is rendered both in all and boundary cases\n      isInWhitespace = true;\n    } else if (chCode === 32 /* Space */) {\n      // hit a space character\n      if (onlyBoundary) {\n        // rendering only boundary whitespace\n        if (wasInWhitespace) {\n          isInWhitespace = true;\n        } else {\n          var nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */;\n          isInWhitespace = nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */;\n        }\n      } else {\n        isInWhitespace = true;\n      }\n    } else {\n      isInWhitespace = false;\n    }\n    // If rendering whitespace on selection, check that the charIndex falls within a selection\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    }\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n    if (chCode === 9 /* Tab */) {\n      tmpIndent = tabSize;\n    } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n    wasInWhitespace = isInWhitespace;\n    if (charIndex === tokenEndIndex) {\n      tokenIndex++;\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      }\n    }\n  }\n  var generateWhitespace = false;\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      var lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */;\n      var prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */;\n      var isSingleTrailingSpace = lastCharCode === 32 /* Space */ && prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */;\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n  result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\n  return result;\n}\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n  var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  var lineDecorationsLen = lineDecorations.length;\n  var lineDecorationIndex = 0;\n  var result = [],\n    resultLen = 0,\n    lastResultEndIndex = 0;\n  for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {\n    var token = tokens[tokenIndex];\n    var tokenEndIndex = token.endIndex;\n    var tokenType = token.type;\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      var lineDecoration = lineDecorations[lineDecorationIndex];\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n      }\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\n        break;\n      }\n    }\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\n    }\n  }\n  var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    var classNames = [];\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      classNames.push(lineDecorations[lineDecorationIndex].className);\n      lineDecorationIndex++;\n    }\n    result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\n  }\n  return result;\n}\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\nfunction _renderLine(input, sb) {\n  var fontIsMonospace = input.fontIsMonospace;\n  var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  var containsForeignElements = input.containsForeignElements;\n  var lineContent = input.lineContent;\n  var len = input.len;\n  var isOverflowing = input.isOverflowing;\n  var parts = input.parts;\n  var fauxIndentLength = input.fauxIndentLength;\n  var tabSize = input.tabSize;\n  var startVisibleColumn = input.startVisibleColumn;\n  var containsRTL = input.containsRTL;\n  var spaceWidth = input.spaceWidth;\n  var middotWidth = input.middotWidth;\n  var renderWhitespace = input.renderWhitespace;\n  var renderControlCharacters = input.renderControlCharacters;\n  // use U+2E31 - WORD SEPARATOR MIDDLE DOT or U+00B7 - MIDDLE DOT\n  var spaceRenderWhitespaceCharacter = middotWidth > spaceWidth ? 0x2E31 : 0xB7;\n  var characterMapping = new CharacterMapping(len + 1, parts.length);\n  var charIndex = 0;\n  var visibleColumn = startVisibleColumn;\n  var charOffsetInPart = 0;\n  var prevPartContentCnt = 0;\n  var partAbsoluteOffset = 0;\n  sb.appendASCIIString('<span>');\n  for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    partAbsoluteOffset += prevPartContentCnt;\n    var part = parts[partIndex];\n    var partEndIndex = part.endIndex;\n    var partType = part.type;\n    var partRendersWhitespace = renderWhitespace !== 0 /* None */ && partType.indexOf('vs-whitespace') >= 0;\n    charOffsetInPart = 0;\n    sb.appendASCIIString('<span class=\"');\n    sb.appendASCIIString(partType);\n    sb.appendASCII(34 /* DoubleQuote */);\n    if (partRendersWhitespace) {\n      var partContentCnt = 0;\n      {\n        var _charIndex = charIndex;\n        var _visibleColumn = visibleColumn;\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          var charCode = lineContent.charCodeAt(_charIndex);\n          var charWidth = (charCode === 9 /* Tab */ ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partContentCnt += charWidth;\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n      if (!fontIsMonospace) {\n        var partIsOnlyWhitespace = partType === 'vs-whitespace';\n        if (partIsOnlyWhitespace || !containsForeignElements) {\n          sb.appendASCIIString(' style=\"display:inline-block;width:');\n          sb.appendASCIIString(String(spaceWidth * partContentCnt));\n          sb.appendASCIIString('px\"');\n        }\n      }\n      sb.appendASCII(62 /* GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n        var charCode = lineContent.charCodeAt(charIndex);\n        var charWidth = void 0;\n        if (charCode === 9 /* Tab */) {\n          charWidth = tabSize - visibleColumn % tabSize | 0;\n          if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n            sb.write1(0x2192); // RIGHTWARDS ARROW\n          } else {\n            sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n          }\n\n          for (var space = 2; space <= charWidth; space++) {\n            sb.write1(0xA0); // &nbsp;\n          }\n        } else {\n          // must be CharCode.Space\n          charWidth = 1;\n          sb.write1(spaceRenderWhitespaceCharacter); // &middot; or word separator middle dot\n        }\n\n        charOffsetInPart += charWidth;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n      prevPartContentCnt = partContentCnt;\n    } else {\n      var partContentCnt = 0;\n      if (containsRTL) {\n        sb.appendASCIIString(' dir=\"ltr\"');\n      }\n      sb.appendASCII(62 /* GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\n        var charCode = lineContent.charCodeAt(charIndex);\n        var producedCharacters = 1;\n        var charWidth = 1;\n        switch (charCode) {\n          case 9 /* Tab */:\n            producedCharacters = tabSize - visibleColumn % tabSize;\n            charWidth = producedCharacters;\n            for (var space = 1; space <= producedCharacters; space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n\n            break;\n          case 32 /* Space */:\n            sb.write1(0xA0); // &nbsp;\n            break;\n          case 60 /* LessThan */:\n            sb.appendASCIIString('&lt;');\n            break;\n          case 62 /* GreaterThan */:\n            sb.appendASCIIString('&gt;');\n            break;\n          case 38 /* Ampersand */:\n            sb.appendASCIIString('&amp;');\n            break;\n          case 0 /* Null */:\n            sb.appendASCIIString('&#00;');\n            break;\n          case 65279 /* UTF8_BOM */:\n          case 8232 /* LINE_SEPARATOR_2028 */:\n            sb.write1(0xFFFD);\n            break;\n          default:\n            if (strings.isFullWidthCharacter(charCode)) {\n              charWidth++;\n            }\n            if (renderControlCharacters && charCode < 32) {\n              sb.write1(9216 + charCode);\n            } else {\n              sb.write1(charCode);\n            }\n        }\n        charOffsetInPart += producedCharacters;\n        partContentCnt += producedCharacters;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += charWidth;\n        }\n      }\n      prevPartContentCnt = partContentCnt;\n    }\n    sb.appendASCIIString('</span>');\n  }\n  // When getting client rects for the last character, we will position the\n  // text range at the end of the span, insteaf of at the beginning of next span\n  characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n  if (isOverflowing) {\n    sb.appendASCIIString('<span>&hellip;</span>');\n  }\n  sb.appendASCIIString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}","map":{"version":3,"names":["strings","createStringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","endIndex","type","LineRange","startIndex","startOffset","endOffset","prototype","equals","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","a","b","sameSelection","otherSelections","length","i","other","equalsArr","CharacterMapping","partCount","_data","Uint32Array","_absoluteOffsets","getPartIndex","partData","getCharIndex","setPartData","charOffset","partIndex","charIndex","partAbsoluteOffset","getAbsoluteOffsets","charOffsetToPartData","partDataToCharOffset","partLength","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","renderViewLine","input","sb","content","beforeClassNames","afterClassNames","len","lineDecoration","push","className","beforeSpan","join","afterSpan","appendASCIIString","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","isOverflowing","parts","tokens","transformAndRemoveOverflowing","_applyRenderWhitespace","len_1","_applyInlineDecorations","splitLargeTokens","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","Math","ceil","pieceEndIndex","selections","onlyBoundary","tokensLength","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","compare","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","len_2","classNames","spaceRenderWhitespaceCharacter","visibleColumn","charOffsetInPart","prevPartContentCnt","part","partEndIndex","partType","partRendersWhitespace","indexOf","appendASCII","partContentCnt","_charIndex","_visibleColumn","charCode","charWidth","partIsOnlyWhitespace","String","write1","space","producedCharacters"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { createStringBuilder } from '../core/stringBuilder.js';\r\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\r\nvar LinePart = /** @class */ (function () {\r\n    function LinePart(endIndex, type) {\r\n        this.endIndex = endIndex;\r\n        this.type = type;\r\n    }\r\n    return LinePart;\r\n}());\r\nvar LineRange = /** @class */ (function () {\r\n    function LineRange(startIndex, endIndex) {\r\n        this.startOffset = startIndex;\r\n        this.endOffset = endIndex;\r\n    }\r\n    LineRange.prototype.equals = function (otherLineRange) {\r\n        return this.startOffset === otherLineRange.startOffset\r\n            && this.endOffset === otherLineRange.endOffset;\r\n    };\r\n    return LineRange;\r\n}());\r\nexport { LineRange };\r\nvar RenderLineInput = /** @class */ (function () {\r\n    function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\r\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\r\n        this.isBasicASCII = isBasicASCII;\r\n        this.containsRTL = containsRTL;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.lineTokens = lineTokens;\r\n        this.lineDecorations = lineDecorations;\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.spaceWidth = spaceWidth;\r\n        this.middotWidth = middotWidth;\r\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\r\n        this.renderWhitespace = (renderWhitespace === 'all'\r\n            ? 3 /* All */\r\n            : renderWhitespace === 'boundary'\r\n                ? 1 /* Boundary */\r\n                : renderWhitespace === 'selection'\r\n                    ? 2 /* Selection */\r\n                    : 0 /* None */);\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        this.fontLigatures = fontLigatures;\r\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) { return a.startOffset < b.startOffset ? -1 : 1; });\r\n    }\r\n    RenderLineInput.prototype.sameSelection = function (otherSelections) {\r\n        if (this.selectionsOnLine === null) {\r\n            return otherSelections === null;\r\n        }\r\n        if (otherSelections === null) {\r\n            return false;\r\n        }\r\n        if (otherSelections.length !== this.selectionsOnLine.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < this.selectionsOnLine.length; i++) {\r\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    RenderLineInput.prototype.equals = function (other) {\r\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\r\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\r\n            && this.lineContent === other.lineContent\r\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\r\n            && this.isBasicASCII === other.isBasicASCII\r\n            && this.containsRTL === other.containsRTL\r\n            && this.fauxIndentLength === other.fauxIndentLength\r\n            && this.tabSize === other.tabSize\r\n            && this.startVisibleColumn === other.startVisibleColumn\r\n            && this.spaceWidth === other.spaceWidth\r\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\r\n            && this.renderWhitespace === other.renderWhitespace\r\n            && this.renderControlCharacters === other.renderControlCharacters\r\n            && this.fontLigatures === other.fontLigatures\r\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\r\n            && this.lineTokens.equals(other.lineTokens)\r\n            && this.sameSelection(other.selectionsOnLine));\r\n    };\r\n    return RenderLineInput;\r\n}());\r\nexport { RenderLineInput };\r\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\r\nvar CharacterMapping = /** @class */ (function () {\r\n    function CharacterMapping(length, partCount) {\r\n        this.length = length;\r\n        this._data = new Uint32Array(this.length);\r\n        this._absoluteOffsets = new Uint32Array(this.length);\r\n    }\r\n    CharacterMapping.getPartIndex = function (partData) {\r\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\r\n    };\r\n    CharacterMapping.getCharIndex = function (partData) {\r\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\r\n    };\r\n    CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex, partAbsoluteOffset) {\r\n        var partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        this._data[charOffset] = partData;\r\n        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\r\n    };\r\n    CharacterMapping.prototype.getAbsoluteOffsets = function () {\r\n        return this._absoluteOffsets;\r\n    };\r\n    CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        if (charOffset < 0) {\r\n            return this._data[0];\r\n        }\r\n        if (charOffset >= this.length) {\r\n            return this._data[this.length - 1];\r\n        }\r\n        return this._data[charOffset];\r\n    };\r\n    CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        var searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        var min = 0;\r\n        var max = this.length - 1;\r\n        while (min + 1 < max) {\r\n            var mid = ((min + max) >>> 1);\r\n            var midEntry = this._data[mid];\r\n            if (midEntry === searchEntry) {\r\n                return mid;\r\n            }\r\n            else if (midEntry > searchEntry) {\r\n                max = mid;\r\n            }\r\n            else {\r\n                min = mid;\r\n            }\r\n        }\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        var minEntry = this._data[min];\r\n        var maxEntry = this._data[max];\r\n        if (minEntry === searchEntry) {\r\n            return min;\r\n        }\r\n        if (maxEntry === searchEntry) {\r\n            return max;\r\n        }\r\n        var minPartIndex = CharacterMapping.getPartIndex(minEntry);\r\n        var minCharIndex = CharacterMapping.getCharIndex(minEntry);\r\n        var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\r\n        var maxCharIndex;\r\n        if (minPartIndex !== maxPartIndex) {\r\n            // sitting between parts\r\n            maxCharIndex = partLength;\r\n        }\r\n        else {\r\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\r\n        }\r\n        var minEntryDistance = charIndex - minCharIndex;\r\n        var maxEntryDistance = maxCharIndex - charIndex;\r\n        if (minEntryDistance <= maxEntryDistance) {\r\n            return min;\r\n        }\r\n        return max;\r\n    };\r\n    return CharacterMapping;\r\n}());\r\nexport { CharacterMapping };\r\nvar RenderLineOutput = /** @class */ (function () {\r\n    function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n    return RenderLineOutput;\r\n}());\r\nexport { RenderLineOutput };\r\nexport function renderViewLine(input, sb) {\r\n    if (input.lineContent.length === 0) {\r\n        var containsForeignElements = 0 /* None */;\r\n        // This is basically for IE's hit test to work\r\n        var content = '<span><span>\\u00a0</span></span>';\r\n        if (input.lineDecorations.length > 0) {\r\n            // This line is empty, but it contains inline decorations\r\n            var beforeClassNames = [];\r\n            var afterClassNames = [];\r\n            for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\r\n                var lineDecoration = input.lineDecorations[i];\r\n                if (lineDecoration.type === 1 /* Before */) {\r\n                    beforeClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 1 /* Before */;\r\n                }\r\n                if (lineDecoration.type === 2 /* After */) {\r\n                    afterClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 2 /* After */;\r\n                }\r\n            }\r\n            if (containsForeignElements !== 0 /* None */) {\r\n                var beforeSpan = (beforeClassNames.length > 0 ? \"<span class=\\\"\" + beforeClassNames.join(' ') + \"\\\"></span>\" : \"\");\r\n                var afterSpan = (afterClassNames.length > 0 ? \"<span class=\\\"\" + afterClassNames.join(' ') + \"\\\"></span>\" : \"\");\r\n                content = \"<span>\" + beforeSpan + afterSpan + \"</span>\";\r\n            }\r\n        }\r\n        sb.appendASCIIString(content);\r\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\r\n    }\r\n    return _renderLine(resolveRenderLineInput(input), sb);\r\n}\r\nvar RenderLineOutput2 = /** @class */ (function () {\r\n    function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.html = html;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n    return RenderLineOutput2;\r\n}());\r\nexport { RenderLineOutput2 };\r\nexport function renderViewLine2(input) {\r\n    var sb = createStringBuilder(10000);\r\n    var out = renderViewLine(input, sb);\r\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\r\n}\r\nvar ResolvedRenderLineInput = /** @class */ (function () {\r\n    function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, middotWidth, renderWhitespace, renderControlCharacters) {\r\n        this.fontIsMonospace = fontIsMonospace;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.len = len;\r\n        this.isOverflowing = isOverflowing;\r\n        this.parts = parts;\r\n        this.containsForeignElements = containsForeignElements;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.containsRTL = containsRTL;\r\n        this.spaceWidth = spaceWidth;\r\n        this.middotWidth = middotWidth;\r\n        this.renderWhitespace = renderWhitespace;\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        //\r\n    }\r\n    return ResolvedRenderLineInput;\r\n}());\r\nfunction resolveRenderLineInput(input) {\r\n    var useMonospaceOptimizations = input.useMonospaceOptimizations;\r\n    var lineContent = input.lineContent;\r\n    var isOverflowing;\r\n    var len;\r\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\r\n        isOverflowing = true;\r\n        len = input.stopRenderingLineAfter;\r\n    }\r\n    else {\r\n        isOverflowing = false;\r\n        len = lineContent.length;\r\n    }\r\n    var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\r\n    if (input.renderWhitespace === 3 /* All */ || input.renderWhitespace === 1 /* Boundary */ || (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine)) {\r\n        tokens = _applyRenderWhitespace(lineContent, len, input.continuesWithWrappedLine, tokens, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, useMonospaceOptimizations, input.selectionsOnLine, input.renderWhitespace === 1 /* Boundary */);\r\n    }\r\n    var containsForeignElements = 0 /* None */;\r\n    if (input.lineDecorations.length > 0) {\r\n        for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {\r\n            var lineDecoration = input.lineDecorations[i];\r\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\r\n                // Pretend there are foreign elements... although not 100% accurate.\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 1 /* Before */) {\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 2 /* After */) {\r\n                containsForeignElements |= 2 /* After */;\r\n            }\r\n        }\r\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\r\n    }\r\n    if (!input.containsRTL) {\r\n        // We can never split RTL text, as it ruins the rendering\r\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\r\n    }\r\n    return new ResolvedRenderLineInput(useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.middotWidth, input.renderWhitespace, input.renderControlCharacters);\r\n}\r\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\r\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\r\n    var result = [], resultLen = 0;\r\n    // The faux indent part of the line should have no token type\r\n    if (fauxIndentLength > 0) {\r\n        result[resultLen++] = new LinePart(fauxIndentLength, '');\r\n    }\r\n    for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\r\n        var endIndex = tokens.getEndOffset(tokenIndex);\r\n        if (endIndex <= fauxIndentLength) {\r\n            // The faux indent part of the line should have no token type\r\n            continue;\r\n        }\r\n        var type = tokens.getClassName(tokenIndex);\r\n        if (endIndex >= len) {\r\n            result[resultLen++] = new LinePart(len, type);\r\n            break;\r\n        }\r\n        result[resultLen++] = new LinePart(endIndex, type);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * See https://github.com/Microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\r\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\r\n    var lastTokenEndIndex = 0;\r\n    var result = [], resultLen = 0;\r\n    if (onlyAtSpaces) {\r\n        // Split only at spaces => we need to walk each character\r\n        for (var i = 0, len = tokens.length; i < len; i++) {\r\n            var token = tokens[i];\r\n            var tokenEndIndex = token.endIndex;\r\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\r\n                var tokenType = token.type;\r\n                var lastSpaceOffset = -1;\r\n                var currTokenStart = lastTokenEndIndex;\r\n                for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\r\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\r\n                        lastSpaceOffset = j;\r\n                    }\r\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\r\n                        // Split at `lastSpaceOffset` + 1\r\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType);\r\n                        currTokenStart = lastSpaceOffset + 1;\r\n                        lastSpaceOffset = -1;\r\n                    }\r\n                }\r\n                if (currTokenStart !== tokenEndIndex) {\r\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\r\n                }\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    else {\r\n        // Split anywhere => we don't need to walk each character\r\n        for (var i = 0, len = tokens.length; i < len; i++) {\r\n            var token = tokens[i];\r\n            var tokenEndIndex = token.endIndex;\r\n            var diff = (tokenEndIndex - lastTokenEndIndex);\r\n            if (diff > 50 /* LongToken */) {\r\n                var tokenType = token.type;\r\n                var piecesCount = Math.ceil(diff / 50 /* LongToken */);\r\n                for (var j = 1; j < piecesCount; j++) {\r\n                    var pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\r\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType);\r\n                }\r\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType);\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\r\nfunction _applyRenderWhitespace(lineContent, len, continuesWithWrappedLine, tokens, fauxIndentLength, tabSize, startVisibleColumn, useMonospaceOptimizations, selections, onlyBoundary) {\r\n    var result = [], resultLen = 0;\r\n    var tokenIndex = 0;\r\n    var tokenType = tokens[tokenIndex].type;\r\n    var tokenEndIndex = tokens[tokenIndex].endIndex;\r\n    var tokensLength = tokens.length;\r\n    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n    var lastNonWhitespaceIndex;\r\n    if (firstNonWhitespaceIndex === -1) {\r\n        // The entire line is whitespace\r\n        firstNonWhitespaceIndex = len;\r\n        lastNonWhitespaceIndex = len;\r\n    }\r\n    else {\r\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\r\n    }\r\n    var wasInWhitespace = false;\r\n    var currentSelectionIndex = 0;\r\n    var currentSelection = selections && selections[currentSelectionIndex];\r\n    var tmpIndent = startVisibleColumn % tabSize;\r\n    for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\r\n        var chCode = lineContent.charCodeAt(charIndex);\r\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\r\n            currentSelectionIndex++;\r\n            currentSelection = selections && selections[currentSelectionIndex];\r\n        }\r\n        var isInWhitespace = void 0;\r\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\r\n            // in leading or trailing whitespace\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 9 /* Tab */) {\r\n            // a tab character is rendered both in all and boundary cases\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 32 /* Space */) {\r\n            // hit a space character\r\n            if (onlyBoundary) {\r\n                // rendering only boundary whitespace\r\n                if (wasInWhitespace) {\r\n                    isInWhitespace = true;\r\n                }\r\n                else {\r\n                    var nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\r\n                }\r\n            }\r\n            else {\r\n                isInWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            isInWhitespace = false;\r\n        }\r\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\r\n        if (isInWhitespace && selections) {\r\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\r\n        }\r\n        if (wasInWhitespace) {\r\n            // was in whitespace token\r\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\r\n                // leaving whitespace token or entering a new indent\r\n                result[resultLen++] = new LinePart(charIndex, 'vs-whitespace');\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        else {\r\n            // was in regular token\r\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\r\n                result[resultLen++] = new LinePart(charIndex, tokenType);\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        if (chCode === 9 /* Tab */) {\r\n            tmpIndent = tabSize;\r\n        }\r\n        else if (strings.isFullWidthCharacter(chCode)) {\r\n            tmpIndent += 2;\r\n        }\r\n        else {\r\n            tmpIndent++;\r\n        }\r\n        wasInWhitespace = isInWhitespace;\r\n        if (charIndex === tokenEndIndex) {\r\n            tokenIndex++;\r\n            if (tokenIndex < tokensLength) {\r\n                tokenType = tokens[tokenIndex].type;\r\n                tokenEndIndex = tokens[tokenIndex].endIndex;\r\n            }\r\n        }\r\n    }\r\n    var generateWhitespace = false;\r\n    if (wasInWhitespace) {\r\n        // was in whitespace token\r\n        if (continuesWithWrappedLine && onlyBoundary) {\r\n            var lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\r\n            var prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\r\n            var isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\r\n            if (!isSingleTrailingSpace) {\r\n                generateWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            generateWhitespace = true;\r\n        }\r\n    }\r\n    result[resultLen++] = new LinePart(len, generateWhitespace ? 'vs-whitespace' : tokenType);\r\n    return result;\r\n}\r\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\r\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\r\n    _lineDecorations.sort(LineDecoration.compare);\r\n    var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\r\n    var lineDecorationsLen = lineDecorations.length;\r\n    var lineDecorationIndex = 0;\r\n    var result = [], resultLen = 0, lastResultEndIndex = 0;\r\n    for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {\r\n        var token = tokens[tokenIndex];\r\n        var tokenEndIndex = token.endIndex;\r\n        var tokenType = token.type;\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\r\n            var lineDecoration = lineDecorations[lineDecorationIndex];\r\n            if (lineDecoration.startOffset > lastResultEndIndex) {\r\n                lastResultEndIndex = lineDecoration.startOffset;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\r\n            }\r\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\r\n                // This line decoration ends before this token ends\r\n                lastResultEndIndex = lineDecoration.endOffset + 1;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\r\n                lineDecorationIndex++;\r\n            }\r\n            else {\r\n                // This line decoration continues on to the next token\r\n                lastResultEndIndex = tokenEndIndex;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);\r\n                break;\r\n            }\r\n        }\r\n        if (tokenEndIndex > lastResultEndIndex) {\r\n            lastResultEndIndex = tokenEndIndex;\r\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType);\r\n        }\r\n    }\r\n    var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\r\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n        var classNames = [];\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n            classNames.push(lineDecorations[lineDecorationIndex].className);\r\n            lineDecorationIndex++;\r\n        }\r\n        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '));\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\r\nfunction _renderLine(input, sb) {\r\n    var fontIsMonospace = input.fontIsMonospace;\r\n    var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\r\n    var containsForeignElements = input.containsForeignElements;\r\n    var lineContent = input.lineContent;\r\n    var len = input.len;\r\n    var isOverflowing = input.isOverflowing;\r\n    var parts = input.parts;\r\n    var fauxIndentLength = input.fauxIndentLength;\r\n    var tabSize = input.tabSize;\r\n    var startVisibleColumn = input.startVisibleColumn;\r\n    var containsRTL = input.containsRTL;\r\n    var spaceWidth = input.spaceWidth;\r\n    var middotWidth = input.middotWidth;\r\n    var renderWhitespace = input.renderWhitespace;\r\n    var renderControlCharacters = input.renderControlCharacters;\r\n    // use U+2E31 - WORD SEPARATOR MIDDLE DOT or U+00B7 - MIDDLE DOT\r\n    var spaceRenderWhitespaceCharacter = (middotWidth > spaceWidth ? 0x2E31 : 0xB7);\r\n    var characterMapping = new CharacterMapping(len + 1, parts.length);\r\n    var charIndex = 0;\r\n    var visibleColumn = startVisibleColumn;\r\n    var charOffsetInPart = 0;\r\n    var prevPartContentCnt = 0;\r\n    var partAbsoluteOffset = 0;\r\n    sb.appendASCIIString('<span>');\r\n    for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\r\n        partAbsoluteOffset += prevPartContentCnt;\r\n        var part = parts[partIndex];\r\n        var partEndIndex = part.endIndex;\r\n        var partType = part.type;\r\n        var partRendersWhitespace = (renderWhitespace !== 0 /* None */ && (partType.indexOf('vs-whitespace') >= 0));\r\n        charOffsetInPart = 0;\r\n        sb.appendASCIIString('<span class=\"');\r\n        sb.appendASCIIString(partType);\r\n        sb.appendASCII(34 /* DoubleQuote */);\r\n        if (partRendersWhitespace) {\r\n            var partContentCnt = 0;\r\n            {\r\n                var _charIndex = charIndex;\r\n                var _visibleColumn = visibleColumn;\r\n                for (; _charIndex < partEndIndex; _charIndex++) {\r\n                    var charCode = lineContent.charCodeAt(_charIndex);\r\n                    var charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\r\n                    partContentCnt += charWidth;\r\n                    if (_charIndex >= fauxIndentLength) {\r\n                        _visibleColumn += charWidth;\r\n                    }\r\n                }\r\n            }\r\n            if (!fontIsMonospace) {\r\n                var partIsOnlyWhitespace = (partType === 'vs-whitespace');\r\n                if (partIsOnlyWhitespace || !containsForeignElements) {\r\n                    sb.appendASCIIString(' style=\"display:inline-block;width:');\r\n                    sb.appendASCIIString(String(spaceWidth * partContentCnt));\r\n                    sb.appendASCIIString('px\"');\r\n                }\r\n            }\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\r\n                var charCode = lineContent.charCodeAt(charIndex);\r\n                var charWidth = void 0;\r\n                if (charCode === 9 /* Tab */) {\r\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\r\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\r\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\r\n                    }\r\n                    else {\r\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\r\n                    }\r\n                    for (var space = 2; space <= charWidth; space++) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                }\r\n                else { // must be CharCode.Space\r\n                    charWidth = 1;\r\n                    sb.write1(spaceRenderWhitespaceCharacter); // &middot; or word separator middle dot\r\n                }\r\n                charOffsetInPart += charWidth;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        else {\r\n            var partContentCnt = 0;\r\n            if (containsRTL) {\r\n                sb.appendASCIIString(' dir=\"ltr\"');\r\n            }\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex, charOffsetInPart, partAbsoluteOffset);\r\n                var charCode = lineContent.charCodeAt(charIndex);\r\n                var producedCharacters = 1;\r\n                var charWidth = 1;\r\n                switch (charCode) {\r\n                    case 9 /* Tab */:\r\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                        charWidth = producedCharacters;\r\n                        for (var space = 1; space <= producedCharacters; space++) {\r\n                            sb.write1(0xA0); // &nbsp;\r\n                        }\r\n                        break;\r\n                    case 32 /* Space */:\r\n                        sb.write1(0xA0); // &nbsp;\r\n                        break;\r\n                    case 60 /* LessThan */:\r\n                        sb.appendASCIIString('&lt;');\r\n                        break;\r\n                    case 62 /* GreaterThan */:\r\n                        sb.appendASCIIString('&gt;');\r\n                        break;\r\n                    case 38 /* Ampersand */:\r\n                        sb.appendASCIIString('&amp;');\r\n                        break;\r\n                    case 0 /* Null */:\r\n                        sb.appendASCIIString('&#00;');\r\n                        break;\r\n                    case 65279 /* UTF8_BOM */:\r\n                    case 8232 /* LINE_SEPARATOR_2028 */:\r\n                        sb.write1(0xFFFD);\r\n                        break;\r\n                    default:\r\n                        if (strings.isFullWidthCharacter(charCode)) {\r\n                            charWidth++;\r\n                        }\r\n                        if (renderControlCharacters && charCode < 32) {\r\n                            sb.write1(9216 + charCode);\r\n                        }\r\n                        else {\r\n                            sb.write1(charCode);\r\n                        }\r\n                }\r\n                charOffsetInPart += producedCharacters;\r\n                partContentCnt += producedCharacters;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        sb.appendASCIIString('</span>');\r\n    }\r\n    // When getting client rects for the last character, we will position the\r\n    // text range at the end of the span, insteaf of at the beginning of next span\r\n    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\r\n    if (isOverflowing) {\r\n        sb.appendASCIIString('<span>&hellip;</span>');\r\n    }\r\n    sb.appendASCIIString('</span>');\r\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,iCAAiC;AAC1D,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,cAAc,EAAEC,yBAAyB,QAAQ,sBAAsB;AAChF,IAAIC,QAAQ,GAAG,aAAe,YAAY;EACtC,SAASA,QAAQ,CAACC,QAAQ,EAAEC,IAAI,EAAE;IAC9B,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,IAAI,GAAGA,IAAI;EACpB;EACA,OAAOF,QAAQ;AACnB,CAAC,EAAG;AACJ,IAAIG,SAAS,GAAG,aAAe,YAAY;EACvC,SAASA,SAAS,CAACC,UAAU,EAAEH,QAAQ,EAAE;IACrC,IAAI,CAACI,WAAW,GAAGD,UAAU;IAC7B,IAAI,CAACE,SAAS,GAAGL,QAAQ;EAC7B;EACAE,SAAS,CAACI,SAAS,CAACC,MAAM,GAAG,UAAUC,cAAc,EAAE;IACnD,OAAO,IAAI,CAACJ,WAAW,KAAKI,cAAc,CAACJ,WAAW,IAC/C,IAAI,CAACC,SAAS,KAAKG,cAAc,CAACH,SAAS;EACtD,CAAC;EACD,OAAOH,SAAS;AACpB,CAAC,EAAG;AACJ,SAASA,SAAS;AAClB,IAAIO,eAAe,GAAG,aAAe,YAAY;EAC7C,SAASA,eAAe,CAACC,yBAAyB,EAAEC,8BAA8B,EAAEC,WAAW,EAAEC,wBAAwB,EAAEC,YAAY,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,UAAU,EAAEC,eAAe,EAAEC,OAAO,EAAEC,kBAAkB,EAAEC,UAAU,EAAEC,WAAW,EAAEC,sBAAsB,EAAEC,gBAAgB,EAAEC,uBAAuB,EAAEC,aAAa,EAAEC,gBAAgB,EAAE;IAC3V,IAAI,CAACjB,yBAAyB,GAAGA,yBAAyB;IAC1D,IAAI,CAACC,8BAA8B,GAAGA,8BAA8B;IACpE,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,wBAAwB,GAAGA,wBAAwB;IACxD,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,sBAAsB,GAAGA,sBAAsB;IACpD,IAAI,CAACC,gBAAgB,GAAIA,gBAAgB,KAAK,KAAK,GAC7C,CAAC,CAAC,YACFA,gBAAgB,KAAK,UAAU,GAC3B,CAAC,CAAC,iBACFA,gBAAgB,KAAK,WAAW,GAC5B,CAAC,CAAC,kBACF,CAAC,CAAC,UAAW;IAC3B,IAAI,CAACC,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB,IAAIA,gBAAgB,CAACC,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAOD,CAAC,CAACzB,WAAW,GAAG0B,CAAC,CAAC1B,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC;IAAE,CAAC,CAAC;EACzI;EACAK,eAAe,CAACH,SAAS,CAACyB,aAAa,GAAG,UAAUC,eAAe,EAAE;IACjE,IAAI,IAAI,CAACL,gBAAgB,KAAK,IAAI,EAAE;MAChC,OAAOK,eAAe,KAAK,IAAI;IACnC;IACA,IAAIA,eAAe,KAAK,IAAI,EAAE;MAC1B,OAAO,KAAK;IAChB;IACA,IAAIA,eAAe,CAACC,MAAM,KAAK,IAAI,CAACN,gBAAgB,CAACM,MAAM,EAAE;MACzD,OAAO,KAAK;IAChB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACP,gBAAgB,CAACM,MAAM,EAAEC,CAAC,EAAE,EAAE;MACnD,IAAI,CAAC,IAAI,CAACP,gBAAgB,CAACO,CAAC,CAAC,CAAC3B,MAAM,CAACyB,eAAe,CAACE,CAAC,CAAC,CAAC,EAAE;QACtD,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf,CAAC;EACDzB,eAAe,CAACH,SAAS,CAACC,MAAM,GAAG,UAAU4B,KAAK,EAAE;IAChD,OAAQ,IAAI,CAACzB,yBAAyB,KAAKyB,KAAK,CAACzB,yBAAyB,IACnE,IAAI,CAACC,8BAA8B,KAAKwB,KAAK,CAACxB,8BAA8B,IAC5E,IAAI,CAACC,WAAW,KAAKuB,KAAK,CAACvB,WAAW,IACtC,IAAI,CAACC,wBAAwB,KAAKsB,KAAK,CAACtB,wBAAwB,IAChE,IAAI,CAACC,YAAY,KAAKqB,KAAK,CAACrB,YAAY,IACxC,IAAI,CAACC,WAAW,KAAKoB,KAAK,CAACpB,WAAW,IACtC,IAAI,CAACC,gBAAgB,KAAKmB,KAAK,CAACnB,gBAAgB,IAChD,IAAI,CAACG,OAAO,KAAKgB,KAAK,CAAChB,OAAO,IAC9B,IAAI,CAACC,kBAAkB,KAAKe,KAAK,CAACf,kBAAkB,IACpD,IAAI,CAACC,UAAU,KAAKc,KAAK,CAACd,UAAU,IACpC,IAAI,CAACE,sBAAsB,KAAKY,KAAK,CAACZ,sBAAsB,IAC5D,IAAI,CAACC,gBAAgB,KAAKW,KAAK,CAACX,gBAAgB,IAChD,IAAI,CAACC,uBAAuB,KAAKU,KAAK,CAACV,uBAAuB,IAC9D,IAAI,CAACC,aAAa,KAAKS,KAAK,CAACT,aAAa,IAC1C7B,cAAc,CAACuC,SAAS,CAAC,IAAI,CAAClB,eAAe,EAAEiB,KAAK,CAACjB,eAAe,CAAC,IACrE,IAAI,CAACD,UAAU,CAACV,MAAM,CAAC4B,KAAK,CAAClB,UAAU,CAAC,IACxC,IAAI,CAACc,aAAa,CAACI,KAAK,CAACR,gBAAgB,CAAC;EACrD,CAAC;EACD,OAAOlB,eAAe;AAC1B,CAAC,EAAG;AACJ,SAASA,eAAe;AACxB;AACA;AACA;AACA,IAAI4B,gBAAgB,GAAG,aAAe,YAAY;EAC9C,SAASA,gBAAgB,CAACJ,MAAM,EAAEK,SAAS,EAAE;IACzC,IAAI,CAACL,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACM,KAAK,GAAG,IAAIC,WAAW,CAAC,IAAI,CAACP,MAAM,CAAC;IACzC,IAAI,CAACQ,gBAAgB,GAAG,IAAID,WAAW,CAAC,IAAI,CAACP,MAAM,CAAC;EACxD;EACAI,gBAAgB,CAACK,YAAY,GAAG,UAAUC,QAAQ,EAAE;IAChD,OAAO,CAACA,QAAQ,GAAG,UAAU,CAAC,2BAA2B,EAAE,CAAC;EAChE,CAAC;;EACDN,gBAAgB,CAACO,YAAY,GAAG,UAAUD,QAAQ,EAAE;IAChD,OAAO,CAACA,QAAQ,GAAG,KAAK,CAAC,2BAA2B,CAAC,CAAC;EAC1D,CAAC;;EACDN,gBAAgB,CAAC/B,SAAS,CAACuC,WAAW,GAAG,UAAUC,UAAU,EAAEC,SAAS,EAAEC,SAAS,EAAEC,kBAAkB,EAAE;IACrG,IAAIN,QAAQ,GAAG,CAAEI,SAAS,IAAI,EAAE,CAAC,0BAC1BC,SAAS,IAAI,CAAC,CAAC,uBAAwB,MAAM,CAAC;IACrD,IAAI,CAACT,KAAK,CAACO,UAAU,CAAC,GAAGH,QAAQ;IACjC,IAAI,CAACF,gBAAgB,CAACK,UAAU,CAAC,GAAGG,kBAAkB,GAAGD,SAAS;EACtE,CAAC;EACDX,gBAAgB,CAAC/B,SAAS,CAAC4C,kBAAkB,GAAG,YAAY;IACxD,OAAO,IAAI,CAACT,gBAAgB;EAChC,CAAC;EACDJ,gBAAgB,CAAC/B,SAAS,CAAC6C,oBAAoB,GAAG,UAAUL,UAAU,EAAE;IACpE,IAAI,IAAI,CAACb,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,CAAC;IACZ;IACA,IAAIa,UAAU,GAAG,CAAC,EAAE;MAChB,OAAO,IAAI,CAACP,KAAK,CAAC,CAAC,CAAC;IACxB;IACA,IAAIO,UAAU,IAAI,IAAI,CAACb,MAAM,EAAE;MAC3B,OAAO,IAAI,CAACM,KAAK,CAAC,IAAI,CAACN,MAAM,GAAG,CAAC,CAAC;IACtC;IACA,OAAO,IAAI,CAACM,KAAK,CAACO,UAAU,CAAC;EACjC,CAAC;EACDT,gBAAgB,CAAC/B,SAAS,CAAC8C,oBAAoB,GAAG,UAAUL,SAAS,EAAEM,UAAU,EAAEL,SAAS,EAAE;IAC1F,IAAI,IAAI,CAACf,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,CAAC;IACZ;IACA,IAAIqB,WAAW,GAAG,CAAEP,SAAS,IAAI,EAAE,CAAC,0BAC7BC,SAAS,IAAI,CAAC,CAAC,uBAAwB,MAAM,CAAC;IACrD,IAAIO,GAAG,GAAG,CAAC;IACX,IAAIC,GAAG,GAAG,IAAI,CAACvB,MAAM,GAAG,CAAC;IACzB,OAAOsB,GAAG,GAAG,CAAC,GAAGC,GAAG,EAAE;MAClB,IAAIC,GAAG,GAAKF,GAAG,GAAGC,GAAG,KAAM,CAAE;MAC7B,IAAIE,QAAQ,GAAG,IAAI,CAACnB,KAAK,CAACkB,GAAG,CAAC;MAC9B,IAAIC,QAAQ,KAAKJ,WAAW,EAAE;QAC1B,OAAOG,GAAG;MACd,CAAC,MACI,IAAIC,QAAQ,GAAGJ,WAAW,EAAE;QAC7BE,GAAG,GAAGC,GAAG;MACb,CAAC,MACI;QACDF,GAAG,GAAGE,GAAG;MACb;IACJ;IACA,IAAIF,GAAG,KAAKC,GAAG,EAAE;MACb,OAAOD,GAAG;IACd;IACA,IAAII,QAAQ,GAAG,IAAI,CAACpB,KAAK,CAACgB,GAAG,CAAC;IAC9B,IAAIK,QAAQ,GAAG,IAAI,CAACrB,KAAK,CAACiB,GAAG,CAAC;IAC9B,IAAIG,QAAQ,KAAKL,WAAW,EAAE;MAC1B,OAAOC,GAAG;IACd;IACA,IAAIK,QAAQ,KAAKN,WAAW,EAAE;MAC1B,OAAOE,GAAG;IACd;IACA,IAAIK,YAAY,GAAGxB,gBAAgB,CAACK,YAAY,CAACiB,QAAQ,CAAC;IAC1D,IAAIG,YAAY,GAAGzB,gBAAgB,CAACO,YAAY,CAACe,QAAQ,CAAC;IAC1D,IAAII,YAAY,GAAG1B,gBAAgB,CAACK,YAAY,CAACkB,QAAQ,CAAC;IAC1D,IAAII,YAAY;IAChB,IAAIH,YAAY,KAAKE,YAAY,EAAE;MAC/B;MACAC,YAAY,GAAGX,UAAU;IAC7B,CAAC,MACI;MACDW,YAAY,GAAG3B,gBAAgB,CAACO,YAAY,CAACgB,QAAQ,CAAC;IAC1D;IACA,IAAIK,gBAAgB,GAAGjB,SAAS,GAAGc,YAAY;IAC/C,IAAII,gBAAgB,GAAGF,YAAY,GAAGhB,SAAS;IAC/C,IAAIiB,gBAAgB,IAAIC,gBAAgB,EAAE;MACtC,OAAOX,GAAG;IACd;IACA,OAAOC,GAAG;EACd,CAAC;EACD,OAAOnB,gBAAgB;AAC3B,CAAC,EAAG;AACJ,SAASA,gBAAgB;AACzB,IAAI8B,gBAAgB,GAAG,aAAe,YAAY;EAC9C,SAASA,gBAAgB,CAACC,gBAAgB,EAAErD,WAAW,EAAEsD,uBAAuB,EAAE;IAC9E,IAAI,CAACD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACrD,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACsD,uBAAuB,GAAGA,uBAAuB;EAC1D;EACA,OAAOF,gBAAgB;AAC3B,CAAC,EAAG;AACJ,SAASA,gBAAgB;AACzB,OAAO,SAASG,cAAc,CAACC,KAAK,EAAEC,EAAE,EAAE;EACtC,IAAID,KAAK,CAAC3D,WAAW,CAACqB,MAAM,KAAK,CAAC,EAAE;IAChC,IAAIoC,uBAAuB,GAAG,CAAC,CAAC;IAChC;IACA,IAAII,OAAO,GAAG,gCAAkC;IAChD,IAAIF,KAAK,CAACrD,eAAe,CAACe,MAAM,GAAG,CAAC,EAAE;MAClC;MACA,IAAIyC,gBAAgB,GAAG,EAAE;MACzB,IAAIC,eAAe,GAAG,EAAE;MACxB,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAE0C,GAAG,GAAGL,KAAK,CAACrD,eAAe,CAACe,MAAM,EAAEC,CAAC,GAAG0C,GAAG,EAAE1C,CAAC,EAAE,EAAE;QAC9D,IAAI2C,cAAc,GAAGN,KAAK,CAACrD,eAAe,CAACgB,CAAC,CAAC;QAC7C,IAAI2C,cAAc,CAAC5E,IAAI,KAAK,CAAC,CAAC,cAAc;UACxCyE,gBAAgB,CAACI,IAAI,CAACP,KAAK,CAACrD,eAAe,CAACgB,CAAC,CAAC,CAAC6C,SAAS,CAAC;UACzDV,uBAAuB,IAAI,CAAC,CAAC;QACjC;;QACA,IAAIQ,cAAc,CAAC5E,IAAI,KAAK,CAAC,CAAC,aAAa;UACvC0E,eAAe,CAACG,IAAI,CAACP,KAAK,CAACrD,eAAe,CAACgB,CAAC,CAAC,CAAC6C,SAAS,CAAC;UACxDV,uBAAuB,IAAI,CAAC,CAAC;QACjC;MACJ;;MACA,IAAIA,uBAAuB,KAAK,CAAC,CAAC,YAAY;QAC1C,IAAIW,UAAU,GAAIN,gBAAgB,CAACzC,MAAM,GAAG,CAAC,GAAG,gBAAgB,GAAGyC,gBAAgB,CAACO,IAAI,CAAC,GAAG,CAAC,GAAG,YAAY,GAAG,EAAG;QAClH,IAAIC,SAAS,GAAIP,eAAe,CAAC1C,MAAM,GAAG,CAAC,GAAG,gBAAgB,GAAG0C,eAAe,CAACM,IAAI,CAAC,GAAG,CAAC,GAAG,YAAY,GAAG,EAAG;QAC/GR,OAAO,GAAG,QAAQ,GAAGO,UAAU,GAAGE,SAAS,GAAG,SAAS;MAC3D;IACJ;IACAV,EAAE,CAACW,iBAAiB,CAACV,OAAO,CAAC;IAC7B,OAAO,IAAIN,gBAAgB,CAAC,IAAI9B,gBAAgB,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,EAAEgC,uBAAuB,CAAC;EAC3F;EACA,OAAOe,WAAW,CAACC,sBAAsB,CAACd,KAAK,CAAC,EAAEC,EAAE,CAAC;AACzD;AACA,IAAIc,iBAAiB,GAAG,aAAe,YAAY;EAC/C,SAASA,iBAAiB,CAAClB,gBAAgB,EAAEmB,IAAI,EAAExE,WAAW,EAAEsD,uBAAuB,EAAE;IACrF,IAAI,CAACD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACmB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACxE,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACsD,uBAAuB,GAAGA,uBAAuB;EAC1D;EACA,OAAOiB,iBAAiB;AAC5B,CAAC,EAAG;AACJ,SAASA,iBAAiB;AAC1B,OAAO,SAASE,eAAe,CAACjB,KAAK,EAAE;EACnC,IAAIC,EAAE,GAAG5E,mBAAmB,CAAC,KAAK,CAAC;EACnC,IAAI6F,GAAG,GAAGnB,cAAc,CAACC,KAAK,EAAEC,EAAE,CAAC;EACnC,OAAO,IAAIc,iBAAiB,CAACG,GAAG,CAACrB,gBAAgB,EAAEI,EAAE,CAACkB,KAAK,EAAE,EAAED,GAAG,CAAC1E,WAAW,EAAE0E,GAAG,CAACpB,uBAAuB,CAAC;AAChH;AACA,IAAIsB,uBAAuB,GAAG,aAAe,YAAY;EACrD,SAASA,uBAAuB,CAACC,eAAe,EAAEjF,8BAA8B,EAAEC,WAAW,EAAEgE,GAAG,EAAEiB,aAAa,EAAEC,KAAK,EAAEzB,uBAAuB,EAAErD,gBAAgB,EAAEG,OAAO,EAAEC,kBAAkB,EAAEL,WAAW,EAAEM,UAAU,EAAEC,WAAW,EAAEE,gBAAgB,EAAEC,uBAAuB,EAAE;IAC/Q,IAAI,CAACmE,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACjF,8BAA8B,GAAGA,8BAA8B;IACpE,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACgE,GAAG,GAAGA,GAAG;IACd,IAAI,CAACiB,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACzB,uBAAuB,GAAGA,uBAAuB;IACtD,IAAI,CAACrD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACG,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACL,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACM,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACE,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,uBAAuB,GAAGA,uBAAuB;IACtD;EACJ;;EACA,OAAOkE,uBAAuB;AAClC,CAAC,EAAG;AACJ,SAASN,sBAAsB,CAACd,KAAK,EAAE;EACnC,IAAI7D,yBAAyB,GAAG6D,KAAK,CAAC7D,yBAAyB;EAC/D,IAAIE,WAAW,GAAG2D,KAAK,CAAC3D,WAAW;EACnC,IAAIiF,aAAa;EACjB,IAAIjB,GAAG;EACP,IAAIL,KAAK,CAAChD,sBAAsB,KAAK,CAAC,CAAC,IAAIgD,KAAK,CAAChD,sBAAsB,GAAGX,WAAW,CAACqB,MAAM,EAAE;IAC1F4D,aAAa,GAAG,IAAI;IACpBjB,GAAG,GAAGL,KAAK,CAAChD,sBAAsB;EACtC,CAAC,MACI;IACDsE,aAAa,GAAG,KAAK;IACrBjB,GAAG,GAAGhE,WAAW,CAACqB,MAAM;EAC5B;EACA,IAAI8D,MAAM,GAAGC,6BAA6B,CAACzB,KAAK,CAACtD,UAAU,EAAEsD,KAAK,CAACvD,gBAAgB,EAAE4D,GAAG,CAAC;EACzF,IAAIL,KAAK,CAAC/C,gBAAgB,KAAK,CAAC,CAAC,aAAa+C,KAAK,CAAC/C,gBAAgB,KAAK,CAAC,CAAC,kBAAmB+C,KAAK,CAAC/C,gBAAgB,KAAK,CAAC,CAAC,mBAAmB,CAAC,CAAC+C,KAAK,CAAC5C,gBAAiB,EAAE;IACrKoE,MAAM,GAAGE,sBAAsB,CAACrF,WAAW,EAAEgE,GAAG,EAAEL,KAAK,CAAC1D,wBAAwB,EAAEkF,MAAM,EAAExB,KAAK,CAACvD,gBAAgB,EAAEuD,KAAK,CAACpD,OAAO,EAAEoD,KAAK,CAACnD,kBAAkB,EAAEV,yBAAyB,EAAE6D,KAAK,CAAC5C,gBAAgB,EAAE4C,KAAK,CAAC/C,gBAAgB,KAAK,CAAC,CAAC,eAAe;EAC9P;;EACA,IAAI6C,uBAAuB,GAAG,CAAC,CAAC;EAChC,IAAIE,KAAK,CAACrD,eAAe,CAACe,MAAM,GAAG,CAAC,EAAE;IAClC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEgE,KAAK,GAAG3B,KAAK,CAACrD,eAAe,CAACe,MAAM,EAAEC,CAAC,GAAGgE,KAAK,EAAEhE,CAAC,EAAE,EAAE;MAClE,IAAI2C,cAAc,GAAGN,KAAK,CAACrD,eAAe,CAACgB,CAAC,CAAC;MAC7C,IAAI2C,cAAc,CAAC5E,IAAI,KAAK,CAAC,CAAC,qCAAqC;QAC/D;QACAoE,uBAAuB,IAAI,CAAC,CAAC;MACjC,CAAC,MACI,IAAIQ,cAAc,CAAC5E,IAAI,KAAK,CAAC,CAAC,cAAc;QAC7CoE,uBAAuB,IAAI,CAAC,CAAC;MACjC,CAAC,MACI,IAAIQ,cAAc,CAAC5E,IAAI,KAAK,CAAC,CAAC,aAAa;QAC5CoE,uBAAuB,IAAI,CAAC,CAAC;MACjC;IACJ;;IACA0B,MAAM,GAAGI,uBAAuB,CAACvF,WAAW,EAAEgE,GAAG,EAAEmB,MAAM,EAAExB,KAAK,CAACrD,eAAe,CAAC;EACrF;EACA,IAAI,CAACqD,KAAK,CAACxD,WAAW,EAAE;IACpB;IACAgF,MAAM,GAAGK,gBAAgB,CAACxF,WAAW,EAAEmF,MAAM,EAAE,CAACxB,KAAK,CAACzD,YAAY,IAAIyD,KAAK,CAAC7C,aAAa,CAAC;EAC9F;EACA,OAAO,IAAIiE,uBAAuB,CAACjF,yBAAyB,EAAE6D,KAAK,CAAC5D,8BAA8B,EAAEC,WAAW,EAAEgE,GAAG,EAAEiB,aAAa,EAAEE,MAAM,EAAE1B,uBAAuB,EAAEE,KAAK,CAACvD,gBAAgB,EAAEuD,KAAK,CAACpD,OAAO,EAAEoD,KAAK,CAACnD,kBAAkB,EAAEmD,KAAK,CAACxD,WAAW,EAAEwD,KAAK,CAAClD,UAAU,EAAEkD,KAAK,CAACjD,WAAW,EAAEiD,KAAK,CAAC/C,gBAAgB,EAAE+C,KAAK,CAAC9C,uBAAuB,CAAC;AACzV;AACA;AACA;AACA;AACA;AACA,SAASuE,6BAA6B,CAACD,MAAM,EAAE/E,gBAAgB,EAAE4D,GAAG,EAAE;EAClE,IAAIyB,MAAM,GAAG,EAAE;IAAEC,SAAS,GAAG,CAAC;EAC9B;EACA,IAAItF,gBAAgB,GAAG,CAAC,EAAE;IACtBqF,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiB,gBAAgB,EAAE,EAAE,CAAC;EAC5D;EACA,KAAK,IAAIuF,UAAU,GAAG,CAAC,EAAEC,SAAS,GAAGT,MAAM,CAACU,QAAQ,EAAE,EAAEF,UAAU,GAAGC,SAAS,EAAED,UAAU,EAAE,EAAE;IAC1F,IAAIvG,QAAQ,GAAG+F,MAAM,CAACW,YAAY,CAACH,UAAU,CAAC;IAC9C,IAAIvG,QAAQ,IAAIgB,gBAAgB,EAAE;MAC9B;MACA;IACJ;IACA,IAAIf,IAAI,GAAG8F,MAAM,CAACY,YAAY,CAACJ,UAAU,CAAC;IAC1C,IAAIvG,QAAQ,IAAI4E,GAAG,EAAE;MACjByB,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAAC6E,GAAG,EAAE3E,IAAI,CAAC;MAC7C;IACJ;IACAoG,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACC,QAAQ,EAAEC,IAAI,CAAC;EACtD;EACA,OAAOoG,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,gBAAgB,CAACxF,WAAW,EAAEmF,MAAM,EAAEa,YAAY,EAAE;EACzD,IAAIC,iBAAiB,GAAG,CAAC;EACzB,IAAIR,MAAM,GAAG,EAAE;IAAEC,SAAS,GAAG,CAAC;EAC9B,IAAIM,YAAY,EAAE;IACd;IACA,KAAK,IAAI1E,CAAC,GAAG,CAAC,EAAE0C,GAAG,GAAGmB,MAAM,CAAC9D,MAAM,EAAEC,CAAC,GAAG0C,GAAG,EAAE1C,CAAC,EAAE,EAAE;MAC/C,IAAI4E,KAAK,GAAGf,MAAM,CAAC7D,CAAC,CAAC;MACrB,IAAI6E,aAAa,GAAGD,KAAK,CAAC9G,QAAQ;MAClC,IAAI6G,iBAAiB,GAAG,EAAE,CAAC,kBAAkBE,aAAa,EAAE;QACxD,IAAIC,SAAS,GAAGF,KAAK,CAAC7G,IAAI;QAC1B,IAAIgH,eAAe,GAAG,CAAC,CAAC;QACxB,IAAIC,cAAc,GAAGL,iBAAiB;QACtC,KAAK,IAAIM,CAAC,GAAGN,iBAAiB,EAAEM,CAAC,GAAGJ,aAAa,EAAEI,CAAC,EAAE,EAAE;UACpD,IAAIvG,WAAW,CAACwG,UAAU,CAACD,CAAC,CAAC,KAAK,EAAE,CAAC,aAAa;YAC9CF,eAAe,GAAGE,CAAC;UACvB;UACA,IAAIF,eAAe,KAAK,CAAC,CAAC,IAAIE,CAAC,GAAGD,cAAc,IAAI,EAAE,CAAC,iBAAiB;YACpE;YACAb,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACkH,eAAe,GAAG,CAAC,EAAED,SAAS,CAAC;YAClEE,cAAc,GAAGD,eAAe,GAAG,CAAC;YACpCA,eAAe,GAAG,CAAC,CAAC;UACxB;QACJ;QACA,IAAIC,cAAc,KAAKH,aAAa,EAAE;UAClCV,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACgH,aAAa,EAAEC,SAAS,CAAC;QAChE;MACJ,CAAC,MACI;QACDX,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGQ,KAAK;MAC/B;MACAD,iBAAiB,GAAGE,aAAa;IACrC;EACJ,CAAC,MACI;IACD;IACA,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAE0C,GAAG,GAAGmB,MAAM,CAAC9D,MAAM,EAAEC,CAAC,GAAG0C,GAAG,EAAE1C,CAAC,EAAE,EAAE;MAC/C,IAAI4E,KAAK,GAAGf,MAAM,CAAC7D,CAAC,CAAC;MACrB,IAAI6E,aAAa,GAAGD,KAAK,CAAC9G,QAAQ;MAClC,IAAIqH,IAAI,GAAIN,aAAa,GAAGF,iBAAkB;MAC9C,IAAIQ,IAAI,GAAG,EAAE,CAAC,iBAAiB;QAC3B,IAAIL,SAAS,GAAGF,KAAK,CAAC7G,IAAI;QAC1B,IAAIqH,WAAW,GAAGC,IAAI,CAACC,IAAI,CAACH,IAAI,GAAG,EAAE,CAAC,gBAAgB;QACtD,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,WAAW,EAAEH,CAAC,EAAE,EAAE;UAClC,IAAIM,aAAa,GAAGZ,iBAAiB,GAAIM,CAAC,GAAG,EAAE,CAAC,eAAgB;UAChEd,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAAC0H,aAAa,EAAET,SAAS,CAAC;QAChE;QACAX,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACgH,aAAa,EAAEC,SAAS,CAAC;MAChE,CAAC,MACI;QACDX,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGQ,KAAK;MAC/B;MACAD,iBAAiB,GAAGE,aAAa;IACrC;EACJ;EACA,OAAOV,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,sBAAsB,CAACrF,WAAW,EAAEgE,GAAG,EAAE/D,wBAAwB,EAAEkF,MAAM,EAAE/E,gBAAgB,EAAEG,OAAO,EAAEC,kBAAkB,EAAEV,yBAAyB,EAAEgH,UAAU,EAAEC,YAAY,EAAE;EACpL,IAAItB,MAAM,GAAG,EAAE;IAAEC,SAAS,GAAG,CAAC;EAC9B,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIS,SAAS,GAAGjB,MAAM,CAACQ,UAAU,CAAC,CAACtG,IAAI;EACvC,IAAI8G,aAAa,GAAGhB,MAAM,CAACQ,UAAU,CAAC,CAACvG,QAAQ;EAC/C,IAAI4H,YAAY,GAAG7B,MAAM,CAAC9D,MAAM;EAChC,IAAI4F,uBAAuB,GAAGlI,OAAO,CAACkI,uBAAuB,CAACjH,WAAW,CAAC;EAC1E,IAAIkH,sBAAsB;EAC1B,IAAID,uBAAuB,KAAK,CAAC,CAAC,EAAE;IAChC;IACAA,uBAAuB,GAAGjD,GAAG;IAC7BkD,sBAAsB,GAAGlD,GAAG;EAChC,CAAC,MACI;IACDkD,sBAAsB,GAAGnI,OAAO,CAACmI,sBAAsB,CAAClH,WAAW,CAAC;EACxE;EACA,IAAImH,eAAe,GAAG,KAAK;EAC3B,IAAIC,qBAAqB,GAAG,CAAC;EAC7B,IAAIC,gBAAgB,GAAGP,UAAU,IAAIA,UAAU,CAACM,qBAAqB,CAAC;EACtE,IAAIE,SAAS,GAAG9G,kBAAkB,GAAGD,OAAO;EAC5C,KAAK,IAAI6B,SAAS,GAAGhC,gBAAgB,EAAEgC,SAAS,GAAG4B,GAAG,EAAE5B,SAAS,EAAE,EAAE;IACjE,IAAImF,MAAM,GAAGvH,WAAW,CAACwG,UAAU,CAACpE,SAAS,CAAC;IAC9C,IAAIiF,gBAAgB,IAAIjF,SAAS,IAAIiF,gBAAgB,CAAC5H,SAAS,EAAE;MAC7D2H,qBAAqB,EAAE;MACvBC,gBAAgB,GAAGP,UAAU,IAAIA,UAAU,CAACM,qBAAqB,CAAC;IACtE;IACA,IAAII,cAAc,GAAG,KAAK,CAAC;IAC3B,IAAIpF,SAAS,GAAG6E,uBAAuB,IAAI7E,SAAS,GAAG8E,sBAAsB,EAAE;MAC3E;MACAM,cAAc,GAAG,IAAI;IACzB,CAAC,MACI,IAAID,MAAM,KAAK,CAAC,CAAC,WAAW;MAC7B;MACAC,cAAc,GAAG,IAAI;IACzB,CAAC,MACI,IAAID,MAAM,KAAK,EAAE,CAAC,aAAa;MAChC;MACA,IAAIR,YAAY,EAAE;QACd;QACA,IAAII,eAAe,EAAE;UACjBK,cAAc,GAAG,IAAI;QACzB,CAAC,MACI;UACD,IAAIC,UAAU,GAAIrF,SAAS,GAAG,CAAC,GAAG4B,GAAG,GAAGhE,WAAW,CAACwG,UAAU,CAACpE,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,UAAW;UAC7FoF,cAAc,GAAIC,UAAU,KAAK,EAAE,CAAC,eAAeA,UAAU,KAAK,CAAC,CAAC,SAAU;QAClF;MACJ,CAAC,MACI;QACDD,cAAc,GAAG,IAAI;MACzB;IACJ,CAAC,MACI;MACDA,cAAc,GAAG,KAAK;IAC1B;IACA;IACA,IAAIA,cAAc,IAAIV,UAAU,EAAE;MAC9BU,cAAc,GAAG,CAAC,CAACH,gBAAgB,IAAIA,gBAAgB,CAAC7H,WAAW,IAAI4C,SAAS,IAAIiF,gBAAgB,CAAC5H,SAAS,GAAG2C,SAAS;IAC9H;IACA,IAAI+E,eAAe,EAAE;MACjB;MACA,IAAI,CAACK,cAAc,IAAK,CAAC1H,yBAAyB,IAAIwH,SAAS,IAAI/G,OAAQ,EAAE;QACzE;QACAkF,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiD,SAAS,EAAE,eAAe,CAAC;QAC9DkF,SAAS,GAAGA,SAAS,GAAG/G,OAAO;MACnC;IACJ,CAAC,MACI;MACD;MACA,IAAI6B,SAAS,KAAK+D,aAAa,IAAKqB,cAAc,IAAIpF,SAAS,GAAGhC,gBAAiB,EAAE;QACjFqF,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiD,SAAS,EAAEgE,SAAS,CAAC;QACxDkB,SAAS,GAAGA,SAAS,GAAG/G,OAAO;MACnC;IACJ;IACA,IAAIgH,MAAM,KAAK,CAAC,CAAC,WAAW;MACxBD,SAAS,GAAG/G,OAAO;IACvB,CAAC,MACI,IAAIxB,OAAO,CAAC2I,oBAAoB,CAACH,MAAM,CAAC,EAAE;MAC3CD,SAAS,IAAI,CAAC;IAClB,CAAC,MACI;MACDA,SAAS,EAAE;IACf;IACAH,eAAe,GAAGK,cAAc;IAChC,IAAIpF,SAAS,KAAK+D,aAAa,EAAE;MAC7BR,UAAU,EAAE;MACZ,IAAIA,UAAU,GAAGqB,YAAY,EAAE;QAC3BZ,SAAS,GAAGjB,MAAM,CAACQ,UAAU,CAAC,CAACtG,IAAI;QACnC8G,aAAa,GAAGhB,MAAM,CAACQ,UAAU,CAAC,CAACvG,QAAQ;MAC/C;IACJ;EACJ;EACA,IAAIuI,kBAAkB,GAAG,KAAK;EAC9B,IAAIR,eAAe,EAAE;IACjB;IACA,IAAIlH,wBAAwB,IAAI8G,YAAY,EAAE;MAC1C,IAAIa,YAAY,GAAI5D,GAAG,GAAG,CAAC,GAAGhE,WAAW,CAACwG,UAAU,CAACxC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,UAAW;MAC7E,IAAI6D,YAAY,GAAI7D,GAAG,GAAG,CAAC,GAAGhE,WAAW,CAACwG,UAAU,CAACxC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,UAAW;MAC7E,IAAI8D,qBAAqB,GAAIF,YAAY,KAAK,EAAE,CAAC,eAAgBC,YAAY,KAAK,EAAE,CAAC,eAAeA,YAAY,KAAK,CAAC,CAAC,SAAW;MAClI,IAAI,CAACC,qBAAqB,EAAE;QACxBH,kBAAkB,GAAG,IAAI;MAC7B;IACJ,CAAC,MACI;MACDA,kBAAkB,GAAG,IAAI;IAC7B;EACJ;EACAlC,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAAC6E,GAAG,EAAE2D,kBAAkB,GAAG,eAAe,GAAGvB,SAAS,CAAC;EACzF,OAAOX,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,SAASF,uBAAuB,CAACvF,WAAW,EAAEgE,GAAG,EAAEmB,MAAM,EAAE4C,gBAAgB,EAAE;EACzEA,gBAAgB,CAAC/G,IAAI,CAAC/B,cAAc,CAAC+I,OAAO,CAAC;EAC7C,IAAI1H,eAAe,GAAGpB,yBAAyB,CAAC+I,SAAS,CAACjI,WAAW,EAAE+H,gBAAgB,CAAC;EACxF,IAAIG,kBAAkB,GAAG5H,eAAe,CAACe,MAAM;EAC/C,IAAI8G,mBAAmB,GAAG,CAAC;EAC3B,IAAI1C,MAAM,GAAG,EAAE;IAAEC,SAAS,GAAG,CAAC;IAAE0C,kBAAkB,GAAG,CAAC;EACtD,KAAK,IAAIzC,UAAU,GAAG,CAAC,EAAE0C,KAAK,GAAGlD,MAAM,CAAC9D,MAAM,EAAEsE,UAAU,GAAG0C,KAAK,EAAE1C,UAAU,EAAE,EAAE;IAC9E,IAAIO,KAAK,GAAGf,MAAM,CAACQ,UAAU,CAAC;IAC9B,IAAIQ,aAAa,GAAGD,KAAK,CAAC9G,QAAQ;IAClC,IAAIgH,SAAS,GAAGF,KAAK,CAAC7G,IAAI;IAC1B,OAAO8I,mBAAmB,GAAGD,kBAAkB,IAAI5H,eAAe,CAAC6H,mBAAmB,CAAC,CAAC3I,WAAW,GAAG2G,aAAa,EAAE;MACjH,IAAIlC,cAAc,GAAG3D,eAAe,CAAC6H,mBAAmB,CAAC;MACzD,IAAIlE,cAAc,CAACzE,WAAW,GAAG4I,kBAAkB,EAAE;QACjDA,kBAAkB,GAAGnE,cAAc,CAACzE,WAAW;QAC/CiG,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiJ,kBAAkB,EAAEhC,SAAS,CAAC;MACrE;MACA,IAAInC,cAAc,CAACxE,SAAS,GAAG,CAAC,IAAI0G,aAAa,EAAE;QAC/C;QACAiC,kBAAkB,GAAGnE,cAAc,CAACxE,SAAS,GAAG,CAAC;QACjDgG,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiJ,kBAAkB,EAAEhC,SAAS,GAAG,GAAG,GAAGnC,cAAc,CAACE,SAAS,CAAC;QAClGgE,mBAAmB,EAAE;MACzB,CAAC,MACI;QACD;QACAC,kBAAkB,GAAGjC,aAAa;QAClCV,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiJ,kBAAkB,EAAEhC,SAAS,GAAG,GAAG,GAAGnC,cAAc,CAACE,SAAS,CAAC;QAClG;MACJ;IACJ;IACA,IAAIgC,aAAa,GAAGiC,kBAAkB,EAAE;MACpCA,kBAAkB,GAAGjC,aAAa;MAClCV,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiJ,kBAAkB,EAAEhC,SAAS,CAAC;IACrE;EACJ;EACA,IAAIH,iBAAiB,GAAGd,MAAM,CAACA,MAAM,CAAC9D,MAAM,GAAG,CAAC,CAAC,CAACjC,QAAQ;EAC1D,IAAI+I,mBAAmB,GAAGD,kBAAkB,IAAI5H,eAAe,CAAC6H,mBAAmB,CAAC,CAAC3I,WAAW,KAAKyG,iBAAiB,EAAE;IACpH,IAAIqC,UAAU,GAAG,EAAE;IACnB,OAAOH,mBAAmB,GAAGD,kBAAkB,IAAI5H,eAAe,CAAC6H,mBAAmB,CAAC,CAAC3I,WAAW,KAAKyG,iBAAiB,EAAE;MACvHqC,UAAU,CAACpE,IAAI,CAAC5D,eAAe,CAAC6H,mBAAmB,CAAC,CAAChE,SAAS,CAAC;MAC/DgE,mBAAmB,EAAE;IACzB;IACA1C,MAAM,CAACC,SAAS,EAAE,CAAC,GAAG,IAAIvG,QAAQ,CAACiJ,kBAAkB,EAAEE,UAAU,CAACjE,IAAI,CAAC,GAAG,CAAC,CAAC;EAChF;EACA,OAAOoB,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,SAASjB,WAAW,CAACb,KAAK,EAAEC,EAAE,EAAE;EAC5B,IAAIoB,eAAe,GAAGrB,KAAK,CAACqB,eAAe;EAC3C,IAAIjF,8BAA8B,GAAG4D,KAAK,CAAC5D,8BAA8B;EACzE,IAAI0D,uBAAuB,GAAGE,KAAK,CAACF,uBAAuB;EAC3D,IAAIzD,WAAW,GAAG2D,KAAK,CAAC3D,WAAW;EACnC,IAAIgE,GAAG,GAAGL,KAAK,CAACK,GAAG;EACnB,IAAIiB,aAAa,GAAGtB,KAAK,CAACsB,aAAa;EACvC,IAAIC,KAAK,GAAGvB,KAAK,CAACuB,KAAK;EACvB,IAAI9E,gBAAgB,GAAGuD,KAAK,CAACvD,gBAAgB;EAC7C,IAAIG,OAAO,GAAGoD,KAAK,CAACpD,OAAO;EAC3B,IAAIC,kBAAkB,GAAGmD,KAAK,CAACnD,kBAAkB;EACjD,IAAIL,WAAW,GAAGwD,KAAK,CAACxD,WAAW;EACnC,IAAIM,UAAU,GAAGkD,KAAK,CAAClD,UAAU;EACjC,IAAIC,WAAW,GAAGiD,KAAK,CAACjD,WAAW;EACnC,IAAIE,gBAAgB,GAAG+C,KAAK,CAAC/C,gBAAgB;EAC7C,IAAIC,uBAAuB,GAAG8C,KAAK,CAAC9C,uBAAuB;EAC3D;EACA,IAAI0H,8BAA8B,GAAI7H,WAAW,GAAGD,UAAU,GAAG,MAAM,GAAG,IAAK;EAC/E,IAAI+C,gBAAgB,GAAG,IAAI/B,gBAAgB,CAACuC,GAAG,GAAG,CAAC,EAAEkB,KAAK,CAAC7D,MAAM,CAAC;EAClE,IAAIe,SAAS,GAAG,CAAC;EACjB,IAAIoG,aAAa,GAAGhI,kBAAkB;EACtC,IAAIiI,gBAAgB,GAAG,CAAC;EACxB,IAAIC,kBAAkB,GAAG,CAAC;EAC1B,IAAIrG,kBAAkB,GAAG,CAAC;EAC1BuB,EAAE,CAACW,iBAAiB,CAAC,QAAQ,CAAC;EAC9B,KAAK,IAAIpC,SAAS,GAAG,CAAC,EAAEyD,SAAS,GAAGV,KAAK,CAAC7D,MAAM,EAAEc,SAAS,GAAGyD,SAAS,EAAEzD,SAAS,EAAE,EAAE;IAClFE,kBAAkB,IAAIqG,kBAAkB;IACxC,IAAIC,IAAI,GAAGzD,KAAK,CAAC/C,SAAS,CAAC;IAC3B,IAAIyG,YAAY,GAAGD,IAAI,CAACvJ,QAAQ;IAChC,IAAIyJ,QAAQ,GAAGF,IAAI,CAACtJ,IAAI;IACxB,IAAIyJ,qBAAqB,GAAIlI,gBAAgB,KAAK,CAAC,CAAC,cAAeiI,QAAQ,CAACE,OAAO,CAAC,eAAe,CAAC,IAAI,CAAG;IAC3GN,gBAAgB,GAAG,CAAC;IACpB7E,EAAE,CAACW,iBAAiB,CAAC,eAAe,CAAC;IACrCX,EAAE,CAACW,iBAAiB,CAACsE,QAAQ,CAAC;IAC9BjF,EAAE,CAACoF,WAAW,CAAC,EAAE,CAAC,kBAAkB;IACpC,IAAIF,qBAAqB,EAAE;MACvB,IAAIG,cAAc,GAAG,CAAC;MACtB;QACI,IAAIC,UAAU,GAAG9G,SAAS;QAC1B,IAAI+G,cAAc,GAAGX,aAAa;QAClC,OAAOU,UAAU,GAAGN,YAAY,EAAEM,UAAU,EAAE,EAAE;UAC5C,IAAIE,QAAQ,GAAGpJ,WAAW,CAACwG,UAAU,CAAC0C,UAAU,CAAC;UACjD,IAAIG,SAAS,GAAG,CAACD,QAAQ,KAAK,CAAC,CAAC,YAAa7I,OAAO,GAAI4I,cAAc,GAAG5I,OAAQ,GAAI,CAAC,IAAI,CAAC;UAC3F0I,cAAc,IAAII,SAAS;UAC3B,IAAIH,UAAU,IAAI9I,gBAAgB,EAAE;YAChC+I,cAAc,IAAIE,SAAS;UAC/B;QACJ;MACJ;MACA,IAAI,CAACrE,eAAe,EAAE;QAClB,IAAIsE,oBAAoB,GAAIT,QAAQ,KAAK,eAAgB;QACzD,IAAIS,oBAAoB,IAAI,CAAC7F,uBAAuB,EAAE;UAClDG,EAAE,CAACW,iBAAiB,CAAC,qCAAqC,CAAC;UAC3DX,EAAE,CAACW,iBAAiB,CAACgF,MAAM,CAAC9I,UAAU,GAAGwI,cAAc,CAAC,CAAC;UACzDrF,EAAE,CAACW,iBAAiB,CAAC,KAAK,CAAC;QAC/B;MACJ;MACAX,EAAE,CAACoF,WAAW,CAAC,EAAE,CAAC,kBAAkB;MACpC,OAAO5G,SAAS,GAAGwG,YAAY,EAAExG,SAAS,EAAE,EAAE;QAC1CoB,gBAAgB,CAACvB,WAAW,CAACG,SAAS,EAAED,SAAS,EAAEsG,gBAAgB,EAAEpG,kBAAkB,CAAC;QACxF,IAAI+G,QAAQ,GAAGpJ,WAAW,CAACwG,UAAU,CAACpE,SAAS,CAAC;QAChD,IAAIiH,SAAS,GAAG,KAAK,CAAC;QACtB,IAAID,QAAQ,KAAK,CAAC,CAAC,WAAW;UAC1BC,SAAS,GAAI9I,OAAO,GAAIiI,aAAa,GAAGjI,OAAQ,GAAI,CAAC;UACrD,IAAI,CAACR,8BAA8B,IAAIsJ,SAAS,GAAG,CAAC,EAAE;YAClDzF,EAAE,CAAC4F,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;UACvB,CAAC,MACI;YACD5F,EAAE,CAAC4F,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;UACvB;;UACA,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,IAAIJ,SAAS,EAAEI,KAAK,EAAE,EAAE;YAC7C7F,EAAE,CAAC4F,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;UACrB;QACJ,CAAC,MACI;UAAE;UACHH,SAAS,GAAG,CAAC;UACbzF,EAAE,CAAC4F,MAAM,CAACjB,8BAA8B,CAAC,CAAC,CAAC;QAC/C;;QACAE,gBAAgB,IAAIY,SAAS;QAC7B,IAAIjH,SAAS,IAAIhC,gBAAgB,EAAE;UAC/BoI,aAAa,IAAIa,SAAS;QAC9B;MACJ;MACAX,kBAAkB,GAAGO,cAAc;IACvC,CAAC,MACI;MACD,IAAIA,cAAc,GAAG,CAAC;MACtB,IAAI9I,WAAW,EAAE;QACbyD,EAAE,CAACW,iBAAiB,CAAC,YAAY,CAAC;MACtC;MACAX,EAAE,CAACoF,WAAW,CAAC,EAAE,CAAC,kBAAkB;MACpC,OAAO5G,SAAS,GAAGwG,YAAY,EAAExG,SAAS,EAAE,EAAE;QAC1CoB,gBAAgB,CAACvB,WAAW,CAACG,SAAS,EAAED,SAAS,EAAEsG,gBAAgB,EAAEpG,kBAAkB,CAAC;QACxF,IAAI+G,QAAQ,GAAGpJ,WAAW,CAACwG,UAAU,CAACpE,SAAS,CAAC;QAChD,IAAIsH,kBAAkB,GAAG,CAAC;QAC1B,IAAIL,SAAS,GAAG,CAAC;QACjB,QAAQD,QAAQ;UACZ,KAAK,CAAC,CAAC;YACHM,kBAAkB,GAAInJ,OAAO,GAAIiI,aAAa,GAAGjI,OAAS;YAC1D8I,SAAS,GAAGK,kBAAkB;YAC9B,KAAK,IAAID,KAAK,GAAG,CAAC,EAAEA,KAAK,IAAIC,kBAAkB,EAAED,KAAK,EAAE,EAAE;cACtD7F,EAAE,CAAC4F,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YACrB;;YACA;UACJ,KAAK,EAAE,CAAC;YACJ5F,EAAE,CAAC4F,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YACjB;UACJ,KAAK,EAAE,CAAC;YACJ5F,EAAE,CAACW,iBAAiB,CAAC,MAAM,CAAC;YAC5B;UACJ,KAAK,EAAE,CAAC;YACJX,EAAE,CAACW,iBAAiB,CAAC,MAAM,CAAC;YAC5B;UACJ,KAAK,EAAE,CAAC;YACJX,EAAE,CAACW,iBAAiB,CAAC,OAAO,CAAC;YAC7B;UACJ,KAAK,CAAC,CAAC;YACHX,EAAE,CAACW,iBAAiB,CAAC,OAAO,CAAC;YAC7B;UACJ,KAAK,KAAK,CAAC;UACX,KAAK,IAAI,CAAC;YACNX,EAAE,CAAC4F,MAAM,CAAC,MAAM,CAAC;YACjB;UACJ;YACI,IAAIzK,OAAO,CAAC2I,oBAAoB,CAAC0B,QAAQ,CAAC,EAAE;cACxCC,SAAS,EAAE;YACf;YACA,IAAIxI,uBAAuB,IAAIuI,QAAQ,GAAG,EAAE,EAAE;cAC1CxF,EAAE,CAAC4F,MAAM,CAAC,IAAI,GAAGJ,QAAQ,CAAC;YAC9B,CAAC,MACI;cACDxF,EAAE,CAAC4F,MAAM,CAACJ,QAAQ,CAAC;YACvB;QAAC;QAETX,gBAAgB,IAAIiB,kBAAkB;QACtCT,cAAc,IAAIS,kBAAkB;QACpC,IAAItH,SAAS,IAAIhC,gBAAgB,EAAE;UAC/BoI,aAAa,IAAIa,SAAS;QAC9B;MACJ;MACAX,kBAAkB,GAAGO,cAAc;IACvC;IACArF,EAAE,CAACW,iBAAiB,CAAC,SAAS,CAAC;EACnC;EACA;EACA;EACAf,gBAAgB,CAACvB,WAAW,CAAC+B,GAAG,EAAEkB,KAAK,CAAC7D,MAAM,GAAG,CAAC,EAAEoH,gBAAgB,EAAEpG,kBAAkB,CAAC;EACzF,IAAI4C,aAAa,EAAE;IACfrB,EAAE,CAACW,iBAAiB,CAAC,uBAAuB,CAAC;EACjD;EACAX,EAAE,CAACW,iBAAiB,CAAC,SAAS,CAAC;EAC/B,OAAO,IAAIhB,gBAAgB,CAACC,gBAAgB,EAAErD,WAAW,EAAEsD,uBAAuB,CAAC;AACvF"},"metadata":{},"sourceType":"module"}