{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport './viewLines.css';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\nvar LastRenderedData = /** @class */function () {\n  function LastRenderedData() {\n    this._currentVisibleRange = new Range(1, 1, 1, 1);\n  }\n  LastRenderedData.prototype.getCurrentVisibleRange = function () {\n    return this._currentVisibleRange;\n  };\n  LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {\n    this._currentVisibleRange = currentVisibleRange;\n  };\n  return LastRenderedData;\n}();\nvar HorizontalRevealRequest = /** @class */function () {\n  function HorizontalRevealRequest(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n    this.lineNumber = lineNumber;\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.startScrollTop = startScrollTop;\n    this.stopScrollTop = stopScrollTop;\n    this.scrollType = scrollType;\n  }\n  return HorizontalRevealRequest;\n}();\nvar ViewLines = /** @class */function (_super) {\n  __extends(ViewLines, _super);\n  function ViewLines(context, linesContent) {\n    var _this = _super.call(this, context) || this;\n    _this._linesContent = linesContent;\n    _this._textRangeRestingSpot = document.createElement('div');\n    _this._visibleLines = new VisibleLinesCollection(_this);\n    _this.domNode = _this._visibleLines.domNode;\n    var conf = _this._context.configuration;\n    var options = _this._context.configuration.options;\n    var fontInfo = options.get(34 /* fontInfo */);\n    var wrappingInfo = options.get(108 /* wrappingInfo */);\n    _this._lineHeight = options.get(49 /* lineHeight */);\n    _this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    _this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    _this._revealHorizontalRightPadding = options.get(75 /* revealHorizontalRightPadding */);\n    _this._cursorSurroundingLines = options.get(19 /* cursorSurroundingLines */);\n    _this._cursorSurroundingLinesStyle = options.get(20 /* cursorSurroundingLinesStyle */);\n    _this._canUseLayerHinting = !options.get(22 /* disableLayerHinting */);\n    _this._viewLineOptions = new ViewLineOptions(conf, _this._context.theme.type);\n    PartFingerprints.write(_this.domNode, 7 /* ViewLines */);\n    _this.domNode.setClassName('view-lines');\n    Configuration.applyFontInfo(_this.domNode, fontInfo);\n    // --- width & height\n    _this._maxLineWidth = 0;\n    _this._asyncUpdateLineWidths = new RunOnceScheduler(function () {\n      _this._updateLineWidthsSlow();\n    }, 200);\n    _this._lastRenderedData = new LastRenderedData();\n    _this._horizontalRevealRequest = null;\n    return _this;\n  }\n  ViewLines.prototype.dispose = function () {\n    this._asyncUpdateLineWidths.dispose();\n    _super.prototype.dispose.call(this);\n  };\n  ViewLines.prototype.getDomNode = function () {\n    return this.domNode;\n  };\n  // ---- begin IVisibleLinesHost\n  ViewLines.prototype.createVisibleLine = function () {\n    return new ViewLine(this._viewLineOptions);\n  };\n  // ---- end IVisibleLinesHost\n  // ---- begin view event handlers\n  ViewLines.prototype.onConfigurationChanged = function (e) {\n    this._visibleLines.onConfigurationChanged(e);\n    if (e.hasChanged(108 /* wrappingInfo */)) {\n      this._maxLineWidth = 0;\n    }\n    var options = this._context.configuration.options;\n    var fontInfo = options.get(34 /* fontInfo */);\n    var wrappingInfo = options.get(108 /* wrappingInfo */);\n    this._lineHeight = options.get(49 /* lineHeight */);\n    this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    this._revealHorizontalRightPadding = options.get(75 /* revealHorizontalRightPadding */);\n    this._cursorSurroundingLines = options.get(19 /* cursorSurroundingLines */);\n    this._cursorSurroundingLinesStyle = options.get(20 /* cursorSurroundingLinesStyle */);\n    this._canUseLayerHinting = !options.get(22 /* disableLayerHinting */);\n    Configuration.applyFontInfo(this.domNode, fontInfo);\n    this._onOptionsMaybeChanged();\n    if (e.hasChanged(107 /* layoutInfo */)) {\n      this._maxLineWidth = 0;\n    }\n    return true;\n  };\n  ViewLines.prototype._onOptionsMaybeChanged = function () {\n    var conf = this._context.configuration;\n    var newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n    if (!this._viewLineOptions.equals(newViewLineOptions)) {\n      this._viewLineOptions = newViewLineOptions;\n      var startLineNumber = this._visibleLines.getStartLineNumber();\n      var endLineNumber = this._visibleLines.getEndLineNumber();\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var line = this._visibleLines.getVisibleLine(lineNumber);\n        line.onOptionsChanged(this._viewLineOptions);\n      }\n      return true;\n    }\n    return false;\n  };\n  ViewLines.prototype.onCursorStateChanged = function (e) {\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    var r = false;\n    for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n    }\n    return r;\n  };\n  ViewLines.prototype.onDecorationsChanged = function (e) {\n    if (true /*e.inlineDecorationsChanged*/) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n      }\n    }\n    return true;\n  };\n  ViewLines.prototype.onFlushed = function (e) {\n    var shouldRender = this._visibleLines.onFlushed(e);\n    this._maxLineWidth = 0;\n    return shouldRender;\n  };\n  ViewLines.prototype.onLinesChanged = function (e) {\n    return this._visibleLines.onLinesChanged(e);\n  };\n  ViewLines.prototype.onLinesDeleted = function (e) {\n    return this._visibleLines.onLinesDeleted(e);\n  };\n  ViewLines.prototype.onLinesInserted = function (e) {\n    return this._visibleLines.onLinesInserted(e);\n  };\n  ViewLines.prototype.onRevealRangeRequest = function (e) {\n    // Using the future viewport here in order to handle multiple\n    // incoming reveal range requests that might all desire to be animated\n    var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.verticalType);\n    // validate the new desired scroll top\n    var newScrollPosition = this._context.viewLayout.validateScrollPosition({\n      scrollTop: desiredScrollTop\n    });\n    if (e.revealHorizontal) {\n      if (e.range.startLineNumber !== e.range.endLineNumber) {\n        // Two or more lines? => scroll to base (That's how you see most of the two lines)\n        newScrollPosition = {\n          scrollTop: newScrollPosition.scrollTop,\n          scrollLeft: 0\n        };\n      } else {\n        // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n        this._horizontalRevealRequest = new HorizontalRevealRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n      }\n    } else {\n      this._horizontalRevealRequest = null;\n    }\n    var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n    if (e.scrollType === 0 /* Smooth */ && scrollTopDelta > this._lineHeight) {\n      this._context.viewLayout.setScrollPositionSmooth(newScrollPosition);\n    } else {\n      this._context.viewLayout.setScrollPositionNow(newScrollPosition);\n    }\n    return true;\n  };\n  ViewLines.prototype.onScrollChanged = function (e) {\n    if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n      // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n      this._horizontalRevealRequest = null;\n    }\n    if (this._horizontalRevealRequest && e.scrollTopChanged) {\n      var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n      var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n      if (e.scrollTop < min || e.scrollTop > max) {\n        // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n        this._horizontalRevealRequest = null;\n      }\n    }\n    this.domNode.setWidth(e.scrollWidth);\n    return this._visibleLines.onScrollChanged(e) || true;\n  };\n  ViewLines.prototype.onTokensChanged = function (e) {\n    return this._visibleLines.onTokensChanged(e);\n  };\n  ViewLines.prototype.onZonesChanged = function (e) {\n    this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n    return this._visibleLines.onZonesChanged(e);\n  };\n  ViewLines.prototype.onThemeChanged = function (e) {\n    return this._onOptionsMaybeChanged();\n  };\n  // ---- end view event handlers\n  // ----------- HELPERS FOR OTHERS\n  ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {\n    var viewLineDomNode = this._getViewLineDomNode(spanNode);\n    if (viewLineDomNode === null) {\n      // Couldn't find view line node\n      return null;\n    }\n    var lineNumber = this._getLineNumberFor(viewLineDomNode);\n    if (lineNumber === -1) {\n      // Couldn't find view line node\n      return null;\n    }\n    if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n      // lineNumber is outside range\n      return null;\n    }\n    if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n      // Line is empty\n      return new Position(lineNumber, 1);\n    }\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return null;\n    }\n    var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n    var minColumn = this._context.model.getLineMinColumn(lineNumber);\n    if (column < minColumn) {\n      column = minColumn;\n    }\n    return new Position(lineNumber, column);\n  };\n  ViewLines.prototype._getViewLineDomNode = function (node) {\n    while (node && node.nodeType === 1) {\n      if (node.className === ViewLine.CLASS_NAME) {\n        return node;\n      }\n      node = node.parentElement;\n    }\n    return null;\n  };\n  /**\r\n   * @returns the line number of this view line dom node.\r\n   */\n  ViewLines.prototype._getLineNumberFor = function (domNode) {\n    var startLineNumber = this._visibleLines.getStartLineNumber();\n    var endLineNumber = this._visibleLines.getEndLineNumber();\n    for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      var line = this._visibleLines.getVisibleLine(lineNumber);\n      if (domNode === line.getDomNode()) {\n        return lineNumber;\n      }\n    }\n    return -1;\n  };\n  ViewLines.prototype.getLineWidth = function (lineNumber) {\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n      // Couldn't find line\n      return -1;\n    }\n    return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n  };\n  ViewLines.prototype.linesVisibleRangesForRange = function (_range, includeNewLines) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n    var originalEndLineNumber = _range.endLineNumber;\n    var range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n    if (!range) {\n      return null;\n    }\n    var visibleRanges = [],\n      visibleRangesLen = 0;\n    var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n    var nextLineModelLineNumber = 0;\n    if (includeNewLines) {\n      nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n    }\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        continue;\n      }\n      var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n      var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n      var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n      if (!visibleRangesForLine) {\n        continue;\n      }\n      if (includeNewLines && lineNumber < originalEndLineNumber) {\n        var currentLineModelLineNumber = nextLineModelLineNumber;\n        nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n        if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n          visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n        }\n      }\n      visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\n    }\n    if (visibleRangesLen === 0) {\n      return null;\n    }\n    return visibleRanges;\n  };\n  ViewLines.prototype._visibleRangesForLineRange = function (lineNumber, startColumn, endColumn) {\n    if (this.shouldRender()) {\n      // Cannot read from the DOM because it is dirty\n      // i.e. the model & the dom are out of sync, so I'd be reading something stale\n      return null;\n    }\n    if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n      return null;\n    }\n    return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\n  };\n  ViewLines.prototype.visibleRangeForPosition = function (position) {\n    var visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n    if (!visibleRanges) {\n      return null;\n    }\n    return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n  };\n  // --- implementation\n  ViewLines.prototype.updateLineWidths = function () {\n    this._updateLineWidths(false);\n  };\n  /**\r\n   * Updates the max line width if it is fast to compute.\r\n   * Returns true if all lines were taken into account.\r\n   * Returns false if some lines need to be reevaluated (in a slow fashion).\r\n   */\n  ViewLines.prototype._updateLineWidthsFast = function () {\n    return this._updateLineWidths(true);\n  };\n  ViewLines.prototype._updateLineWidthsSlow = function () {\n    this._updateLineWidths(false);\n  };\n  ViewLines.prototype._updateLineWidths = function (fast) {\n    var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n    var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n    var localMaxLineWidth = 1;\n    var allWidthsComputed = true;\n    for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n      var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n      if (fast && !visibleLine.getWidthIsFast()) {\n        // Cannot compute width in a fast way for this line\n        allWidthsComputed = false;\n        continue;\n      }\n      localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n    }\n    if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n      // we know the max line width for all the lines\n      this._maxLineWidth = 0;\n    }\n    this._ensureMaxLineWidth(localMaxLineWidth);\n    return allWidthsComputed;\n  };\n  ViewLines.prototype.prepareRender = function () {\n    throw new Error('Not supported');\n  };\n  ViewLines.prototype.render = function () {\n    throw new Error('Not supported');\n  };\n  ViewLines.prototype.renderText = function (viewportData) {\n    // (1) render lines - ensures lines are in the DOM\n    this._visibleLines.renderLines(viewportData);\n    this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n    this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n    this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n    // (2) compute horizontal scroll position:\n    //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n    //  - it might change `scrollWidth` and `scrollLeft`\n    if (this._horizontalRevealRequest) {\n      var revealLineNumber = this._horizontalRevealRequest.lineNumber;\n      var revealStartColumn = this._horizontalRevealRequest.startColumn;\n      var revealEndColumn = this._horizontalRevealRequest.endColumn;\n      var scrollType = this._horizontalRevealRequest.scrollType;\n      // Check that we have the line that contains the horizontal range in the viewport\n      if (viewportData.startLineNumber <= revealLineNumber && revealLineNumber <= viewportData.endLineNumber) {\n        this._horizontalRevealRequest = null;\n        // allow `visibleRangesForRange2` to work\n        this.onDidRender();\n        // compute new scroll position\n        var newScrollLeft = this._computeScrollLeftToRevealRange(revealLineNumber, revealStartColumn, revealEndColumn);\n        var isViewportWrapping = this._isViewportWrapping;\n        if (!isViewportWrapping) {\n          // ensure `scrollWidth` is large enough\n          this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n        }\n        // set `scrollLeft`\n        if (scrollType === 0 /* Smooth */) {\n          this._context.viewLayout.setScrollPositionSmooth({\n            scrollLeft: newScrollLeft.scrollLeft\n          });\n        } else {\n          this._context.viewLayout.setScrollPositionNow({\n            scrollLeft: newScrollLeft.scrollLeft\n          });\n        }\n      }\n    }\n    // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n    if (!this._updateLineWidthsFast()) {\n      // Computing the width of some lines would be slow => delay it\n      this._asyncUpdateLineWidths.schedule();\n    }\n    // (3) handle scrolling\n    this._linesContent.setLayerHinting(this._canUseLayerHinting);\n    this._linesContent.setContain('strict');\n    var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n    this._linesContent.setTop(-adjustedScrollTop);\n    this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n  };\n  // --- width\n  ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {\n    var iLineWidth = Math.ceil(lineWidth);\n    if (this._maxLineWidth < iLineWidth) {\n      this._maxLineWidth = iLineWidth;\n      this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\n    }\n  };\n  ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, source, range, verticalType) {\n    var viewportStartY = viewport.top;\n    var viewportHeight = viewport.height;\n    var viewportEndY = viewportStartY + viewportHeight;\n    var boxStartY;\n    var boxEndY;\n    // Have a box that includes one extra line height (for the horizontal scrollbar)\n    boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n    boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n    var shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\n    if (!shouldIgnoreScrollOff) {\n      var context = Math.min(viewportHeight / this._lineHeight / 2, this._cursorSurroundingLines);\n      boxStartY -= context * this._lineHeight;\n      boxEndY += Math.max(0, context - 1) * this._lineHeight;\n    }\n    if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\n      // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n      boxEndY += this._lineHeight;\n    }\n    var newScrollTop;\n    if (boxEndY - boxStartY > viewportHeight) {\n      // the box is larger than the viewport ... scroll to its top\n      newScrollTop = boxStartY;\n    } else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\n      if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n        // Box is already in the viewport... do nothing\n        newScrollTop = viewportStartY;\n      } else {\n        // Box is outside the viewport... center it\n        var boxMiddleY = (boxStartY + boxEndY) / 2;\n        newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n      }\n    } else {\n      newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\n    }\n\n    return newScrollTop;\n  };\n  ViewLines.prototype._computeScrollLeftToRevealRange = function (lineNumber, startColumn, endColumn) {\n    var maxHorizontalOffset = 0;\n    var viewport = this._context.viewLayout.getCurrentViewport();\n    var viewportStartX = viewport.left;\n    var viewportEndX = viewportStartX + viewport.width;\n    var visibleRanges = this._visibleRangesForLineRange(lineNumber, startColumn, endColumn);\n    var boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    var boxEndX = 0;\n    if (!visibleRanges) {\n      // Unknown\n      return {\n        scrollLeft: viewportStartX,\n        maxHorizontalOffset: maxHorizontalOffset\n      };\n    }\n    for (var _i = 0, _a = visibleRanges.ranges; _i < _a.length; _i++) {\n      var visibleRange = _a[_i];\n      if (visibleRange.left < boxStartX) {\n        boxStartX = visibleRange.left;\n      }\n      if (visibleRange.left + visibleRange.width > boxEndX) {\n        boxEndX = visibleRange.left + visibleRange.width;\n      }\n    }\n    maxHorizontalOffset = boxEndX;\n    boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n    boxEndX += this._revealHorizontalRightPadding;\n    var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n    return {\n      scrollLeft: newScrollLeft,\n      maxHorizontalOffset: maxHorizontalOffset\n    };\n  };\n  ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n    viewportStart = viewportStart | 0;\n    viewportEnd = viewportEnd | 0;\n    boxStart = boxStart | 0;\n    boxEnd = boxEnd | 0;\n    revealAtStart = !!revealAtStart;\n    revealAtEnd = !!revealAtEnd;\n    var viewportLength = viewportEnd - viewportStart;\n    var boxLength = boxEnd - boxStart;\n    if (boxLength < viewportLength) {\n      // The box would fit in the viewport\n      if (revealAtStart) {\n        return boxStart;\n      }\n      if (revealAtEnd) {\n        return Math.max(0, boxEnd - viewportLength);\n      }\n      if (boxStart < viewportStart) {\n        // The box is above the viewport\n        return boxStart;\n      } else if (boxEnd > viewportEnd) {\n        // The box is below the viewport\n        return Math.max(0, boxEnd - viewportLength);\n      }\n    } else {\n      // The box would not fit in the viewport\n      // Reveal the beginning of the box\n      return boxStart;\n    }\n    return viewportStart;\n  };\n  /**\r\n   * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\r\n   */\n  ViewLines.HORIZONTAL_EXTRA_PX = 30;\n  return ViewLines;\n}(ViewPart);\nexport { ViewLines };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","RunOnceScheduler","Configuration","VisibleLinesCollection","PartFingerprints","ViewPart","DomReadingContext","ViewLine","ViewLineOptions","Position","Range","LineVisibleRanges","HorizontalPosition","LastRenderedData","_currentVisibleRange","getCurrentVisibleRange","setCurrentVisibleRange","currentVisibleRange","HorizontalRevealRequest","lineNumber","startColumn","endColumn","startScrollTop","stopScrollTop","scrollType","ViewLines","_super","context","linesContent","_this","call","_linesContent","_textRangeRestingSpot","document","createElement","_visibleLines","domNode","conf","_context","configuration","options","fontInfo","get","wrappingInfo","_lineHeight","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_isViewportWrapping","isViewportWrapping","_revealHorizontalRightPadding","_cursorSurroundingLines","_cursorSurroundingLinesStyle","_canUseLayerHinting","_viewLineOptions","theme","type","write","setClassName","applyFontInfo","_maxLineWidth","_asyncUpdateLineWidths","_updateLineWidthsSlow","_lastRenderedData","_horizontalRevealRequest","dispose","getDomNode","createVisibleLine","onConfigurationChanged","e","hasChanged","_onOptionsMaybeChanged","newViewLineOptions","equals","startLineNumber","getStartLineNumber","endLineNumber","getEndLineNumber","line","getVisibleLine","onOptionsChanged","onCursorStateChanged","rendStartLineNumber","rendEndLineNumber","r","onSelectionChanged","onDecorationsChanged","onFlushed","shouldRender","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","desiredScrollTop","_computeScrollTopToRevealRange","viewLayout","getFutureViewport","source","range","verticalType","newScrollPosition","validateScrollPosition","scrollTop","revealHorizontal","scrollLeft","getCurrentScrollTop","scrollTopDelta","Math","abs","setScrollPositionSmooth","setScrollPositionNow","onScrollChanged","scrollLeftChanged","scrollTopChanged","min","max","setWidth","scrollWidth","onTokensChanged","onZonesChanged","onMaxLineWidthChanged","onThemeChanged","getPositionFromDOMInfo","spanNode","offset","viewLineDomNode","_getViewLineDomNode","_getLineNumberFor","model","getLineCount","getLineMaxColumn","column","getColumnOfNodeOffset","minColumn","getLineMinColumn","node","nodeType","className","CLASS_NAME","parentElement","getLineWidth","getWidth","linesVisibleRangesForRange","_range","includeNewLines","originalEndLineNumber","intersectRanges","visibleRanges","visibleRangesLen","domReadingContext","nextLineModelLineNumber","coordinatesConverter","convertViewPositionToModelPosition","visibleRangesForLine","getVisibleRangesForRange","currentLineModelLineNumber","ranges","length","width","outsideRenderedLine","_visibleRangesForLineRange","visibleRangeForPosition","position","left","updateLineWidths","_updateLineWidths","_updateLineWidthsFast","fast","localMaxLineWidth","allWidthsComputed","visibleLine","getWidthIsFast","_ensureMaxLineWidth","prepareRender","Error","render","renderText","viewportData","renderLines","visibleRange","getScrollWidth","setHeight","getScrollHeight","revealLineNumber","revealStartColumn","revealEndColumn","onDidRender","newScrollLeft","_computeScrollLeftToRevealRange","maxHorizontalOffset","schedule","setLayerHinting","setContain","adjustedScrollTop","bigNumbersDelta","setTop","setLeft","getCurrentScrollLeft","lineWidth","iLineWidth","ceil","viewport","viewportStartY","top","viewportHeight","height","viewportEndY","boxStartY","boxEndY","getVerticalOffsetForLineNumber","shouldIgnoreScrollOff","newScrollTop","boxMiddleY","_computeMinimumScrolling","getCurrentViewport","viewportStartX","viewportEndX","boxStartX","boxEndX","_i","_a","HORIZONTAL_EXTRA_PX","viewportStart","viewportEnd","boxStart","boxEnd","revealAtStart","revealAtEnd","viewportLength","boxLength"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport './viewLines.css';\r\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\r\nimport { Configuration } from '../../config/configuration.js';\r\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\r\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\r\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\r\nimport { Position } from '../../../common/core/position.js';\r\nimport { Range } from '../../../common/core/range.js';\r\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\r\nvar LastRenderedData = /** @class */ (function () {\r\n    function LastRenderedData() {\r\n        this._currentVisibleRange = new Range(1, 1, 1, 1);\r\n    }\r\n    LastRenderedData.prototype.getCurrentVisibleRange = function () {\r\n        return this._currentVisibleRange;\r\n    };\r\n    LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {\r\n        this._currentVisibleRange = currentVisibleRange;\r\n    };\r\n    return LastRenderedData;\r\n}());\r\nvar HorizontalRevealRequest = /** @class */ (function () {\r\n    function HorizontalRevealRequest(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\r\n        this.lineNumber = lineNumber;\r\n        this.startColumn = startColumn;\r\n        this.endColumn = endColumn;\r\n        this.startScrollTop = startScrollTop;\r\n        this.stopScrollTop = stopScrollTop;\r\n        this.scrollType = scrollType;\r\n    }\r\n    return HorizontalRevealRequest;\r\n}());\r\nvar ViewLines = /** @class */ (function (_super) {\r\n    __extends(ViewLines, _super);\r\n    function ViewLines(context, linesContent) {\r\n        var _this = _super.call(this, context) || this;\r\n        _this._linesContent = linesContent;\r\n        _this._textRangeRestingSpot = document.createElement('div');\r\n        _this._visibleLines = new VisibleLinesCollection(_this);\r\n        _this.domNode = _this._visibleLines.domNode;\r\n        var conf = _this._context.configuration;\r\n        var options = _this._context.configuration.options;\r\n        var fontInfo = options.get(34 /* fontInfo */);\r\n        var wrappingInfo = options.get(108 /* wrappingInfo */);\r\n        _this._lineHeight = options.get(49 /* lineHeight */);\r\n        _this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        _this._isViewportWrapping = wrappingInfo.isViewportWrapping;\r\n        _this._revealHorizontalRightPadding = options.get(75 /* revealHorizontalRightPadding */);\r\n        _this._cursorSurroundingLines = options.get(19 /* cursorSurroundingLines */);\r\n        _this._cursorSurroundingLinesStyle = options.get(20 /* cursorSurroundingLinesStyle */);\r\n        _this._canUseLayerHinting = !options.get(22 /* disableLayerHinting */);\r\n        _this._viewLineOptions = new ViewLineOptions(conf, _this._context.theme.type);\r\n        PartFingerprints.write(_this.domNode, 7 /* ViewLines */);\r\n        _this.domNode.setClassName('view-lines');\r\n        Configuration.applyFontInfo(_this.domNode, fontInfo);\r\n        // --- width & height\r\n        _this._maxLineWidth = 0;\r\n        _this._asyncUpdateLineWidths = new RunOnceScheduler(function () {\r\n            _this._updateLineWidthsSlow();\r\n        }, 200);\r\n        _this._lastRenderedData = new LastRenderedData();\r\n        _this._horizontalRevealRequest = null;\r\n        return _this;\r\n    }\r\n    ViewLines.prototype.dispose = function () {\r\n        this._asyncUpdateLineWidths.dispose();\r\n        _super.prototype.dispose.call(this);\r\n    };\r\n    ViewLines.prototype.getDomNode = function () {\r\n        return this.domNode;\r\n    };\r\n    // ---- begin IVisibleLinesHost\r\n    ViewLines.prototype.createVisibleLine = function () {\r\n        return new ViewLine(this._viewLineOptions);\r\n    };\r\n    // ---- end IVisibleLinesHost\r\n    // ---- begin view event handlers\r\n    ViewLines.prototype.onConfigurationChanged = function (e) {\r\n        this._visibleLines.onConfigurationChanged(e);\r\n        if (e.hasChanged(108 /* wrappingInfo */)) {\r\n            this._maxLineWidth = 0;\r\n        }\r\n        var options = this._context.configuration.options;\r\n        var fontInfo = options.get(34 /* fontInfo */);\r\n        var wrappingInfo = options.get(108 /* wrappingInfo */);\r\n        this._lineHeight = options.get(49 /* lineHeight */);\r\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\r\n        this._revealHorizontalRightPadding = options.get(75 /* revealHorizontalRightPadding */);\r\n        this._cursorSurroundingLines = options.get(19 /* cursorSurroundingLines */);\r\n        this._cursorSurroundingLinesStyle = options.get(20 /* cursorSurroundingLinesStyle */);\r\n        this._canUseLayerHinting = !options.get(22 /* disableLayerHinting */);\r\n        Configuration.applyFontInfo(this.domNode, fontInfo);\r\n        this._onOptionsMaybeChanged();\r\n        if (e.hasChanged(107 /* layoutInfo */)) {\r\n            this._maxLineWidth = 0;\r\n        }\r\n        return true;\r\n    };\r\n    ViewLines.prototype._onOptionsMaybeChanged = function () {\r\n        var conf = this._context.configuration;\r\n        var newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\r\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\r\n            this._viewLineOptions = newViewLineOptions;\r\n            var startLineNumber = this._visibleLines.getStartLineNumber();\r\n            var endLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n                var line = this._visibleLines.getVisibleLine(lineNumber);\r\n                line.onOptionsChanged(this._viewLineOptions);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    ViewLines.prototype.onCursorStateChanged = function (e) {\r\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        var r = false;\r\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\r\n        }\r\n        return r;\r\n    };\r\n    ViewLines.prototype.onDecorationsChanged = function (e) {\r\n        if (true /*e.inlineDecorationsChanged*/) {\r\n            var rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n            var rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    ViewLines.prototype.onFlushed = function (e) {\r\n        var shouldRender = this._visibleLines.onFlushed(e);\r\n        this._maxLineWidth = 0;\r\n        return shouldRender;\r\n    };\r\n    ViewLines.prototype.onLinesChanged = function (e) {\r\n        return this._visibleLines.onLinesChanged(e);\r\n    };\r\n    ViewLines.prototype.onLinesDeleted = function (e) {\r\n        return this._visibleLines.onLinesDeleted(e);\r\n    };\r\n    ViewLines.prototype.onLinesInserted = function (e) {\r\n        return this._visibleLines.onLinesInserted(e);\r\n    };\r\n    ViewLines.prototype.onRevealRangeRequest = function (e) {\r\n        // Using the future viewport here in order to handle multiple\r\n        // incoming reveal range requests that might all desire to be animated\r\n        var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.verticalType);\r\n        // validate the new desired scroll top\r\n        var newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\r\n        if (e.revealHorizontal) {\r\n            if (e.range.startLineNumber !== e.range.endLineNumber) {\r\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\r\n                newScrollPosition = {\r\n                    scrollTop: newScrollPosition.scrollTop,\r\n                    scrollLeft: 0\r\n                };\r\n            }\r\n            else {\r\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\r\n                this._horizontalRevealRequest = new HorizontalRevealRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\r\n            }\r\n        }\r\n        else {\r\n            this._horizontalRevealRequest = null;\r\n        }\r\n        var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\r\n        if (e.scrollType === 0 /* Smooth */ && scrollTopDelta > this._lineHeight) {\r\n            this._context.viewLayout.setScrollPositionSmooth(newScrollPosition);\r\n        }\r\n        else {\r\n            this._context.viewLayout.setScrollPositionNow(newScrollPosition);\r\n        }\r\n        return true;\r\n    };\r\n    ViewLines.prototype.onScrollChanged = function (e) {\r\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\r\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\r\n            this._horizontalRevealRequest = null;\r\n        }\r\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\r\n            var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\r\n            var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\r\n            if (e.scrollTop < min || e.scrollTop > max) {\r\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\r\n                this._horizontalRevealRequest = null;\r\n            }\r\n        }\r\n        this.domNode.setWidth(e.scrollWidth);\r\n        return this._visibleLines.onScrollChanged(e) || true;\r\n    };\r\n    ViewLines.prototype.onTokensChanged = function (e) {\r\n        return this._visibleLines.onTokensChanged(e);\r\n    };\r\n    ViewLines.prototype.onZonesChanged = function (e) {\r\n        this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\r\n        return this._visibleLines.onZonesChanged(e);\r\n    };\r\n    ViewLines.prototype.onThemeChanged = function (e) {\r\n        return this._onOptionsMaybeChanged();\r\n    };\r\n    // ---- end view event handlers\r\n    // ----------- HELPERS FOR OTHERS\r\n    ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {\r\n        var viewLineDomNode = this._getViewLineDomNode(spanNode);\r\n        if (viewLineDomNode === null) {\r\n            // Couldn't find view line node\r\n            return null;\r\n        }\r\n        var lineNumber = this._getLineNumberFor(viewLineDomNode);\r\n        if (lineNumber === -1) {\r\n            // Couldn't find view line node\r\n            return null;\r\n        }\r\n        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\r\n            // lineNumber is outside range\r\n            return null;\r\n        }\r\n        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\r\n            // Line is empty\r\n            return new Position(lineNumber, 1);\r\n        }\r\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n            // Couldn't find line\r\n            return null;\r\n        }\r\n        var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\r\n        var minColumn = this._context.model.getLineMinColumn(lineNumber);\r\n        if (column < minColumn) {\r\n            column = minColumn;\r\n        }\r\n        return new Position(lineNumber, column);\r\n    };\r\n    ViewLines.prototype._getViewLineDomNode = function (node) {\r\n        while (node && node.nodeType === 1) {\r\n            if (node.className === ViewLine.CLASS_NAME) {\r\n                return node;\r\n            }\r\n            node = node.parentElement;\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * @returns the line number of this view line dom node.\r\n     */\r\n    ViewLines.prototype._getLineNumberFor = function (domNode) {\r\n        var startLineNumber = this._visibleLines.getStartLineNumber();\r\n        var endLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            var line = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (domNode === line.getDomNode()) {\r\n                return lineNumber;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    ViewLines.prototype.getLineWidth = function (lineNumber) {\r\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n            // Couldn't find line\r\n            return -1;\r\n        }\r\n        return this._visibleLines.getVisibleLine(lineNumber).getWidth();\r\n    };\r\n    ViewLines.prototype.linesVisibleRangesForRange = function (_range, includeNewLines) {\r\n        if (this.shouldRender()) {\r\n            // Cannot read from the DOM because it is dirty\r\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\r\n            return null;\r\n        }\r\n        var originalEndLineNumber = _range.endLineNumber;\r\n        var range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        var visibleRanges = [], visibleRangesLen = 0;\r\n        var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\r\n        var nextLineModelLineNumber = 0;\r\n        if (includeNewLines) {\r\n            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\r\n        }\r\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\r\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n                continue;\r\n            }\r\n            var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\r\n            var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\r\n            var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\r\n            if (!visibleRangesForLine) {\r\n                continue;\r\n            }\r\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\r\n                var currentLineModelLineNumber = nextLineModelLineNumber;\r\n                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\r\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\r\n                    visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\r\n                }\r\n            }\r\n            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\r\n        }\r\n        if (visibleRangesLen === 0) {\r\n            return null;\r\n        }\r\n        return visibleRanges;\r\n    };\r\n    ViewLines.prototype._visibleRangesForLineRange = function (lineNumber, startColumn, endColumn) {\r\n        if (this.shouldRender()) {\r\n            // Cannot read from the DOM because it is dirty\r\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\r\n            return null;\r\n        }\r\n        if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\r\n            return null;\r\n        }\r\n        return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\r\n    };\r\n    ViewLines.prototype.visibleRangeForPosition = function (position) {\r\n        var visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\r\n        if (!visibleRanges) {\r\n            return null;\r\n        }\r\n        return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\r\n    };\r\n    // --- implementation\r\n    ViewLines.prototype.updateLineWidths = function () {\r\n        this._updateLineWidths(false);\r\n    };\r\n    /**\r\n     * Updates the max line width if it is fast to compute.\r\n     * Returns true if all lines were taken into account.\r\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\r\n     */\r\n    ViewLines.prototype._updateLineWidthsFast = function () {\r\n        return this._updateLineWidths(true);\r\n    };\r\n    ViewLines.prototype._updateLineWidthsSlow = function () {\r\n        this._updateLineWidths(false);\r\n    };\r\n    ViewLines.prototype._updateLineWidths = function (fast) {\r\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        var localMaxLineWidth = 1;\r\n        var allWidthsComputed = true;\r\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (fast && !visibleLine.getWidthIsFast()) {\r\n                // Cannot compute width in a fast way for this line\r\n                allWidthsComputed = false;\r\n                continue;\r\n            }\r\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\r\n        }\r\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\r\n            // we know the max line width for all the lines\r\n            this._maxLineWidth = 0;\r\n        }\r\n        this._ensureMaxLineWidth(localMaxLineWidth);\r\n        return allWidthsComputed;\r\n    };\r\n    ViewLines.prototype.prepareRender = function () {\r\n        throw new Error('Not supported');\r\n    };\r\n    ViewLines.prototype.render = function () {\r\n        throw new Error('Not supported');\r\n    };\r\n    ViewLines.prototype.renderText = function (viewportData) {\r\n        // (1) render lines - ensures lines are in the DOM\r\n        this._visibleLines.renderLines(viewportData);\r\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\r\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\r\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\r\n        // (2) compute horizontal scroll position:\r\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\r\n        //  - it might change `scrollWidth` and `scrollLeft`\r\n        if (this._horizontalRevealRequest) {\r\n            var revealLineNumber = this._horizontalRevealRequest.lineNumber;\r\n            var revealStartColumn = this._horizontalRevealRequest.startColumn;\r\n            var revealEndColumn = this._horizontalRevealRequest.endColumn;\r\n            var scrollType = this._horizontalRevealRequest.scrollType;\r\n            // Check that we have the line that contains the horizontal range in the viewport\r\n            if (viewportData.startLineNumber <= revealLineNumber && revealLineNumber <= viewportData.endLineNumber) {\r\n                this._horizontalRevealRequest = null;\r\n                // allow `visibleRangesForRange2` to work\r\n                this.onDidRender();\r\n                // compute new scroll position\r\n                var newScrollLeft = this._computeScrollLeftToRevealRange(revealLineNumber, revealStartColumn, revealEndColumn);\r\n                var isViewportWrapping = this._isViewportWrapping;\r\n                if (!isViewportWrapping) {\r\n                    // ensure `scrollWidth` is large enough\r\n                    this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\r\n                }\r\n                // set `scrollLeft`\r\n                if (scrollType === 0 /* Smooth */) {\r\n                    this._context.viewLayout.setScrollPositionSmooth({\r\n                        scrollLeft: newScrollLeft.scrollLeft\r\n                    });\r\n                }\r\n                else {\r\n                    this._context.viewLayout.setScrollPositionNow({\r\n                        scrollLeft: newScrollLeft.scrollLeft\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\r\n        if (!this._updateLineWidthsFast()) {\r\n            // Computing the width of some lines would be slow => delay it\r\n            this._asyncUpdateLineWidths.schedule();\r\n        }\r\n        // (3) handle scrolling\r\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\r\n        this._linesContent.setContain('strict');\r\n        var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\r\n        this._linesContent.setTop(-adjustedScrollTop);\r\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\r\n    };\r\n    // --- width\r\n    ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {\r\n        var iLineWidth = Math.ceil(lineWidth);\r\n        if (this._maxLineWidth < iLineWidth) {\r\n            this._maxLineWidth = iLineWidth;\r\n            this._context.viewLayout.onMaxLineWidthChanged(this._maxLineWidth);\r\n        }\r\n    };\r\n    ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, source, range, verticalType) {\r\n        var viewportStartY = viewport.top;\r\n        var viewportHeight = viewport.height;\r\n        var viewportEndY = viewportStartY + viewportHeight;\r\n        var boxStartY;\r\n        var boxEndY;\r\n        // Have a box that includes one extra line height (for the horizontal scrollbar)\r\n        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\r\n        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\r\n        var shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\r\n        if (!shouldIgnoreScrollOff) {\r\n            var context = Math.min((viewportHeight / this._lineHeight) / 2, this._cursorSurroundingLines);\r\n            boxStartY -= context * this._lineHeight;\r\n            boxEndY += Math.max(0, (context - 1)) * this._lineHeight;\r\n        }\r\n        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\r\n            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\r\n            boxEndY += this._lineHeight;\r\n        }\r\n        var newScrollTop;\r\n        if (boxEndY - boxStartY > viewportHeight) {\r\n            // the box is larger than the viewport ... scroll to its top\r\n            newScrollTop = boxStartY;\r\n        }\r\n        else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\r\n            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\r\n                // Box is already in the viewport... do nothing\r\n                newScrollTop = viewportStartY;\r\n            }\r\n            else {\r\n                // Box is outside the viewport... center it\r\n                var boxMiddleY = (boxStartY + boxEndY) / 2;\r\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\r\n            }\r\n        }\r\n        else {\r\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\r\n        }\r\n        return newScrollTop;\r\n    };\r\n    ViewLines.prototype._computeScrollLeftToRevealRange = function (lineNumber, startColumn, endColumn) {\r\n        var maxHorizontalOffset = 0;\r\n        var viewport = this._context.viewLayout.getCurrentViewport();\r\n        var viewportStartX = viewport.left;\r\n        var viewportEndX = viewportStartX + viewport.width;\r\n        var visibleRanges = this._visibleRangesForLineRange(lineNumber, startColumn, endColumn);\r\n        var boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        var boxEndX = 0;\r\n        if (!visibleRanges) {\r\n            // Unknown\r\n            return {\r\n                scrollLeft: viewportStartX,\r\n                maxHorizontalOffset: maxHorizontalOffset\r\n            };\r\n        }\r\n        for (var _i = 0, _a = visibleRanges.ranges; _i < _a.length; _i++) {\r\n            var visibleRange = _a[_i];\r\n            if (visibleRange.left < boxStartX) {\r\n                boxStartX = visibleRange.left;\r\n            }\r\n            if (visibleRange.left + visibleRange.width > boxEndX) {\r\n                boxEndX = visibleRange.left + visibleRange.width;\r\n            }\r\n        }\r\n        maxHorizontalOffset = boxEndX;\r\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\r\n        boxEndX += this._revealHorizontalRightPadding;\r\n        var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\r\n        return {\r\n            scrollLeft: newScrollLeft,\r\n            maxHorizontalOffset: maxHorizontalOffset\r\n        };\r\n    };\r\n    ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\r\n        viewportStart = viewportStart | 0;\r\n        viewportEnd = viewportEnd | 0;\r\n        boxStart = boxStart | 0;\r\n        boxEnd = boxEnd | 0;\r\n        revealAtStart = !!revealAtStart;\r\n        revealAtEnd = !!revealAtEnd;\r\n        var viewportLength = viewportEnd - viewportStart;\r\n        var boxLength = boxEnd - boxStart;\r\n        if (boxLength < viewportLength) {\r\n            // The box would fit in the viewport\r\n            if (revealAtStart) {\r\n                return boxStart;\r\n            }\r\n            if (revealAtEnd) {\r\n                return Math.max(0, boxEnd - viewportLength);\r\n            }\r\n            if (boxStart < viewportStart) {\r\n                // The box is above the viewport\r\n                return boxStart;\r\n            }\r\n            else if (boxEnd > viewportEnd) {\r\n                // The box is below the viewport\r\n                return Math.max(0, boxEnd - viewportLength);\r\n            }\r\n        }\r\n        else {\r\n            // The box would not fit in the viewport\r\n            // Reveal the beginning of the box\r\n            return boxStart;\r\n        }\r\n        return viewportStart;\r\n    };\r\n    /**\r\n     * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\r\n     */\r\n    ViewLines.HORIZONTAL_EXTRA_PX = 30;\r\n    return ViewLines;\r\n}(ViewPart));\r\nexport { ViewLines };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}