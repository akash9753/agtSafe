{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\nvar _lodash = require('lodash');\nfunction debounce(func, wait, options) {\n  var lastArgs,\n    lastThis,\n    result,\n    timerId,\n    lastCallTime = 0,\n    lastInvokeTime = 0,\n    leading = false,\n    maxWait = false,\n    trailing = true;\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = (0, _lodash.toNumber)(wait) || 0;\n  if ((0, _lodash.isObject)(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && Math.max((0, _lodash.toNumber)(options.maxWait) || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  function invokeFunc(time) {\n    var args = lastArgs,\n      thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime,\n      result = wait - timeSinceLastCall;\n    return maxWait === false ? result : nativeMin(result, maxWait - timeSinceLastInvoke);\n  }\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== false && timeSinceLastInvoke >= maxWait;\n  }\n  function timerExpired() {\n    var time = (0, _lodash.now)();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n  function trailingEdge(time) {\n    clearTimeout(timerId);\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastCallTime = lastInvokeTime = 0;\n    lastArgs = lastThis = timerId = undefined;\n  }\n  function flush() {\n    return timerId === undefined ? result : trailingEdge((0, _lodash.now)());\n  }\n  function debounced() {\n    var time = (0, _lodash.now)(),\n      isInvoking = shouldInvoke(time);\n    lastArgs = (0, _lodash.cloneDeep)(Array.prototype.slice.call(arguments));\n    lastThis = this;\n    lastCallTime = time;\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      // Handle invocations in a tight loop.\n      clearTimeout(timerId);\n      timerId = setTimeout(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","debounce","_lodash","require","func","wait","options","lastArgs","lastThis","result","timerId","lastCallTime","lastInvokeTime","leading","maxWait","trailing","TypeError","FUNC_ERROR_TEXT","toNumber","isObject","Math","max","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","nativeMin","shouldInvoke","now","trailingEdge","clearTimeout","cancel","flush","debounced","isInvoking","cloneDeep","Array","prototype","slice","call","arguments"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/react-throttle/lib/classes/processors/helpers/debounce.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\n\nvar _lodash = require('lodash');\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      result,\n      timerId,\n      lastCallTime = 0,\n      lastInvokeTime = 0,\n      leading = false,\n      maxWait = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = (0, _lodash.toNumber)(wait) || 0;\n  if ((0, _lodash.isObject)(options)) {\n    leading = !!options.leading;\n    maxWait = 'maxWait' in options && Math.max((0, _lodash.toNumber)(options.maxWait) || 0, wait);\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxWait === false ? result : nativeMin(result, maxWait - timeSinceLastInvoke);\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return !lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== false && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = (0, _lodash.now)();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    clearTimeout(timerId);\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastCallTime = lastInvokeTime = 0;\n    lastArgs = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge((0, _lodash.now)());\n  }\n\n  function debounced() {\n    var time = (0, _lodash.now)(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = (0, _lodash.cloneDeep)(Array.prototype.slice.call(arguments));\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      // Handle invocations in a tight loop.\n      clearTimeout(timerId);\n      timerId = setTimeout(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}