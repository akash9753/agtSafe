{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './htmlScanner.js';\nimport { findFirst } from '../utils/arrays.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nvar Node = /** @class */function () {\n  function Node(start, end, children, parent) {\n    this.start = start;\n    this.end = end;\n    this.children = children;\n    this.parent = parent;\n    this.closed = false;\n  }\n  Object.defineProperty(Node.prototype, \"attributeNames\", {\n    get: function get() {\n      return this.attributes ? Object.keys(this.attributes) : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.isSameTag = function (tagInLowerCase) {\n    return this.tag && tagInLowerCase && this.tag.length === tagInLowerCase.length && this.tag.toLowerCase() === tagInLowerCase;\n  };\n  Object.defineProperty(Node.prototype, \"firstChild\", {\n    get: function get() {\n      return this.children[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"lastChild\", {\n    get: function get() {\n      return this.children.length ? this.children[this.children.length - 1] : void 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.findNodeBefore = function (offset) {\n    var idx = findFirst(this.children, function (c) {\n      return offset <= c.start;\n    }) - 1;\n    if (idx >= 0) {\n      var child = this.children[idx];\n      if (offset > child.start) {\n        if (offset < child.end) {\n          return child.findNodeBefore(offset);\n        }\n        var lastChild = child.lastChild;\n        if (lastChild && lastChild.end === child.end) {\n          return child.findNodeBefore(offset);\n        }\n        return child;\n      }\n    }\n    return this;\n  };\n  Node.prototype.findNodeAt = function (offset) {\n    var idx = findFirst(this.children, function (c) {\n      return offset <= c.start;\n    }) - 1;\n    if (idx >= 0) {\n      var child = this.children[idx];\n      if (offset > child.start && offset <= child.end) {\n        return child.findNodeAt(offset);\n      }\n    }\n    return this;\n  };\n  return Node;\n}();\nexport { Node };\nexport function parse(text) {\n  var scanner = createScanner(text);\n  var htmlDocument = new Node(0, text.length, [], void 0);\n  var curr = htmlDocument;\n  var endTagStart = -1;\n  var endTagName = null;\n  var pendingAttribute = null;\n  var token = scanner.scan();\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.StartTagOpen:\n        var child = new Node(scanner.getTokenOffset(), text.length, [], curr);\n        curr.children.push(child);\n        curr = child;\n        break;\n      case TokenType.StartTag:\n        curr.tag = scanner.getTokenText();\n        break;\n      case TokenType.StartTagClose:\n        curr.end = scanner.getTokenEnd(); // might be later set to end tag position\n        curr.startTagEnd = scanner.getTokenEnd();\n        if (curr.tag && isVoidElement(curr.tag) && curr.parent) {\n          curr.closed = true;\n          curr = curr.parent;\n        }\n        break;\n      case TokenType.StartTagSelfClose:\n        if (curr.parent) {\n          curr.closed = true;\n          curr.end = scanner.getTokenEnd();\n          curr.startTagEnd = scanner.getTokenEnd();\n          curr = curr.parent;\n        }\n        break;\n      case TokenType.EndTagOpen:\n        endTagStart = scanner.getTokenOffset();\n        endTagName = null;\n        break;\n      case TokenType.EndTag:\n        endTagName = scanner.getTokenText().toLowerCase();\n        break;\n      case TokenType.EndTagClose:\n        if (endTagName) {\n          var node = curr;\n          // see if we can find a matching tag\n          while (!node.isSameTag(endTagName) && node.parent) {\n            node = node.parent;\n          }\n          if (node.parent) {\n            while (curr !== node) {\n              curr.end = endTagStart;\n              curr.closed = false;\n              curr = curr.parent;\n            }\n            curr.closed = true;\n            curr.endTagStart = endTagStart;\n            curr.end = scanner.getTokenEnd();\n            curr = curr.parent;\n          }\n        }\n        break;\n      case TokenType.AttributeName:\n        {\n          pendingAttribute = scanner.getTokenText();\n          var attributes = curr.attributes;\n          if (!attributes) {\n            curr.attributes = attributes = {};\n          }\n          attributes[pendingAttribute] = null; // Support valueless attributes such as 'checked'\n          break;\n        }\n      case TokenType.AttributeValue:\n        {\n          var value = scanner.getTokenText();\n          var attributes = curr.attributes;\n          if (attributes && pendingAttribute) {\n            attributes[pendingAttribute] = value;\n            pendingAttribute = null;\n          }\n          break;\n        }\n    }\n    token = scanner.scan();\n  }\n  while (curr.parent) {\n    curr.end = text.length;\n    curr.closed = false;\n    curr = curr.parent;\n  }\n  return {\n    roots: htmlDocument.children,\n    findNodeBefore: htmlDocument.findNodeBefore.bind(htmlDocument),\n    findNodeAt: htmlDocument.findNodeAt.bind(htmlDocument)\n  };\n}","map":{"version":3,"names":["createScanner","findFirst","TokenType","isVoidElement","Node","start","end","children","parent","closed","Object","defineProperty","prototype","get","attributes","keys","enumerable","configurable","isSameTag","tagInLowerCase","tag","length","toLowerCase","findNodeBefore","offset","idx","c","child","lastChild","findNodeAt","parse","text","scanner","htmlDocument","curr","endTagStart","endTagName","pendingAttribute","token","scan","EOS","StartTagOpen","getTokenOffset","push","StartTag","getTokenText","StartTagClose","getTokenEnd","startTagEnd","StartTagSelfClose","EndTagOpen","EndTag","EndTagClose","node","AttributeName","AttributeValue","value","roots","bind"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/parser/htmlParser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createScanner } from './htmlScanner.js';\nimport { findFirst } from '../utils/arrays.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nvar Node = /** @class */ (function () {\n    function Node(start, end, children, parent) {\n        this.start = start;\n        this.end = end;\n        this.children = children;\n        this.parent = parent;\n        this.closed = false;\n    }\n    Object.defineProperty(Node.prototype, \"attributeNames\", {\n        get: function () { return this.attributes ? Object.keys(this.attributes) : []; },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.isSameTag = function (tagInLowerCase) {\n        return this.tag && tagInLowerCase && this.tag.length === tagInLowerCase.length && this.tag.toLowerCase() === tagInLowerCase;\n    };\n    Object.defineProperty(Node.prototype, \"firstChild\", {\n        get: function () { return this.children[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"lastChild\", {\n        get: function () { return this.children.length ? this.children[this.children.length - 1] : void 0; },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.findNodeBefore = function (offset) {\n        var idx = findFirst(this.children, function (c) { return offset <= c.start; }) - 1;\n        if (idx >= 0) {\n            var child = this.children[idx];\n            if (offset > child.start) {\n                if (offset < child.end) {\n                    return child.findNodeBefore(offset);\n                }\n                var lastChild = child.lastChild;\n                if (lastChild && lastChild.end === child.end) {\n                    return child.findNodeBefore(offset);\n                }\n                return child;\n            }\n        }\n        return this;\n    };\n    Node.prototype.findNodeAt = function (offset) {\n        var idx = findFirst(this.children, function (c) { return offset <= c.start; }) - 1;\n        if (idx >= 0) {\n            var child = this.children[idx];\n            if (offset > child.start && offset <= child.end) {\n                return child.findNodeAt(offset);\n            }\n        }\n        return this;\n    };\n    return Node;\n}());\nexport { Node };\nexport function parse(text) {\n    var scanner = createScanner(text);\n    var htmlDocument = new Node(0, text.length, [], void 0);\n    var curr = htmlDocument;\n    var endTagStart = -1;\n    var endTagName = null;\n    var pendingAttribute = null;\n    var token = scanner.scan();\n    while (token !== TokenType.EOS) {\n        switch (token) {\n            case TokenType.StartTagOpen:\n                var child = new Node(scanner.getTokenOffset(), text.length, [], curr);\n                curr.children.push(child);\n                curr = child;\n                break;\n            case TokenType.StartTag:\n                curr.tag = scanner.getTokenText();\n                break;\n            case TokenType.StartTagClose:\n                curr.end = scanner.getTokenEnd(); // might be later set to end tag position\n                curr.startTagEnd = scanner.getTokenEnd();\n                if (curr.tag && isVoidElement(curr.tag) && curr.parent) {\n                    curr.closed = true;\n                    curr = curr.parent;\n                }\n                break;\n            case TokenType.StartTagSelfClose:\n                if (curr.parent) {\n                    curr.closed = true;\n                    curr.end = scanner.getTokenEnd();\n                    curr.startTagEnd = scanner.getTokenEnd();\n                    curr = curr.parent;\n                }\n                break;\n            case TokenType.EndTagOpen:\n                endTagStart = scanner.getTokenOffset();\n                endTagName = null;\n                break;\n            case TokenType.EndTag:\n                endTagName = scanner.getTokenText().toLowerCase();\n                break;\n            case TokenType.EndTagClose:\n                if (endTagName) {\n                    var node = curr;\n                    // see if we can find a matching tag\n                    while (!node.isSameTag(endTagName) && node.parent) {\n                        node = node.parent;\n                    }\n                    if (node.parent) {\n                        while (curr !== node) {\n                            curr.end = endTagStart;\n                            curr.closed = false;\n                            curr = curr.parent;\n                        }\n                        curr.closed = true;\n                        curr.endTagStart = endTagStart;\n                        curr.end = scanner.getTokenEnd();\n                        curr = curr.parent;\n                    }\n                }\n                break;\n            case TokenType.AttributeName: {\n                pendingAttribute = scanner.getTokenText();\n                var attributes = curr.attributes;\n                if (!attributes) {\n                    curr.attributes = attributes = {};\n                }\n                attributes[pendingAttribute] = null; // Support valueless attributes such as 'checked'\n                break;\n            }\n            case TokenType.AttributeValue: {\n                var value = scanner.getTokenText();\n                var attributes = curr.attributes;\n                if (attributes && pendingAttribute) {\n                    attributes[pendingAttribute] = value;\n                    pendingAttribute = null;\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    while (curr.parent) {\n        curr.end = text.length;\n        curr.closed = false;\n        curr = curr.parent;\n    }\n    return {\n        roots: htmlDocument.children,\n        findNodeBefore: htmlDocument.findNodeBefore.bind(htmlDocument),\n        findNodeAt: htmlDocument.findNodeAt.bind(htmlDocument)\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}