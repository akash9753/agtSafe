{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport var conf = {\n  comments: {\n    lineComment: '#',\n    blockComment: ['=begin', '=end']\n  },\n  brackets: [['(', ')'], ['{', '}'], ['[', ']']],\n  autoClosingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  surroundingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: '\\'',\n    close: '\\''\n  }],\n  indentationRules: {\n    increaseIndentPattern: new RegExp('^\\\\s*((begin|class|(private|protected)\\\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\\\sdo\\\\b)|([^#]*=\\\\s*(case|if|unless)))\\\\b([^#\\\\{;]|(\"|\\'|\\/).*\\\\4)*(#.*)?$'),\n    decreaseIndentPattern: new RegExp('^\\\\s*([}\\\\]]([,)]?\\\\s*(#|$)|\\\\.[a-zA-Z_]\\\\w*\\\\b)|(end|rescue|ensure|else|elsif|when)\\\\b)')\n  }\n};\n/*\r\n * Ruby language definition\r\n *\r\n * Quite a complex language due to elaborate escape sequences\r\n * and quoting of literate strings/regular expressions, and\r\n * an 'end' keyword that does not always apply to modifiers like until and while,\r\n * and a 'do' keyword that sometimes starts a block, but sometimes is part of\r\n * another statement (like 'while').\r\n *\r\n * (1) end blocks:\r\n * 'end' may end declarations like if or until, but sometimes 'if' or 'until'\r\n * are modifiers where there is no 'end'. Also, 'do' sometimes starts a block\r\n * that is ended by 'end', but sometimes it is part of a 'while', 'for', or 'until'\r\n * To do proper brace matching we do some elaborate state manipulation.\r\n * some examples:\r\n *\r\n *   until bla do\r\n *     work until tired\r\n *     list.each do\r\n *       something if test\r\n *     end\r\n *   end\r\n *\r\n * or\r\n *\r\n * if test\r\n *  something (if test then x end)\r\n *  bar if bla\r\n * end\r\n *\r\n * or, how about using class as a property..\r\n *\r\n * class Test\r\n *   def endpoint\r\n *     self.class.endpoint || routes\r\n *   end\r\n * end\r\n *\r\n * (2) quoting:\r\n * there are many kinds of strings and escape sequences. But also, one can\r\n * start many string-like things as '%qx' where q specifies the kind of string\r\n * (like a command, escape expanded, regular expression, symbol etc.), and x is\r\n * some character and only another 'x' ends the sequence. Except for brackets\r\n * where the closing bracket ends the sequence.. and except for a nested bracket\r\n * inside the string like entity. Also, such strings can contain interpolated\r\n * ruby expressions again (and span multiple lines). Moreover, expanded\r\n * regular expression can also contain comments.\r\n */\nexport var language = {\n  tokenPostfix: '.ruby',\n  keywords: ['__LINE__', '__ENCODING__', '__FILE__', 'BEGIN', 'END', 'alias', 'and', 'begin', 'break', 'case', 'class', 'def', 'defined?', 'do', 'else', 'elsif', 'end', 'ensure', 'for', 'false', 'if', 'in', 'module', 'next', 'nil', 'not', 'or', 'redo', 'rescue', 'retry', 'return', 'self', 'super', 'then', 'true', 'undef', 'unless', 'until', 'when', 'while', 'yield'],\n  keywordops: ['::', '..', '...', '?', ':', '=>'],\n  builtins: ['require', 'public', 'private', 'include', 'extend', 'attr_reader', 'protected', 'private_class_method', 'protected_class_method', 'new'],\n  // these are closed by 'end' (if, while and until are handled separately)\n  declarations: ['module', 'class', 'def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],\n  linedecls: ['def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],\n  operators: ['^', '&', '|', '<=>', '==', '===', '!~', '=~', '>', '>=', '<', '<=', '<<', '>>', '+', '-', '*', '/', '%', '**', '~', '+@', '-@', '[]', '[]=', '`', '+=', '-=', '*=', '**=', '/=', '^=', '%=', '<<=', '>>=', '&=', '&&=', '||=', '|='],\n  brackets: [{\n    open: '(',\n    close: ')',\n    token: 'delimiter.parenthesis'\n  }, {\n    open: '{',\n    close: '}',\n    token: 'delimiter.curly'\n  }, {\n    open: '[',\n    close: ']',\n    token: 'delimiter.square'\n  }],\n  // we include these common regular expressions\n  symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\n  // escape sequences\n  escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\n  escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\n  decpart: /\\d(_?\\d)*/,\n  decimal: /0|@decpart/,\n  delim: /[^a-zA-Z0-9\\s\\n\\r]/,\n  heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\n  regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\n  regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\n  // The main tokenizer for our languages\n  tokenizer: {\n    // Main entry.\n    // root.<decl> where decl is the current opening declaration (like 'class')\n    root: [\n    // identifiers and keywords\n    // most complexity here is due to matching 'end' correctly with declarations.\n    // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)\n    [/^(\\s*)([a-z_]\\w*[!?=]?)/, ['white', {\n      cases: {\n        'for|until|while': {\n          token: 'keyword.$2',\n          next: '@dodecl.$2'\n        },\n        '@declarations': {\n          token: 'keyword.$2',\n          next: '@root.$2'\n        },\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }]], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'if|unless|while|until': {\n          token: 'keyword.$0x',\n          next: '@modifier.$0x'\n        },\n        'for': {\n          token: 'keyword.$2',\n          next: '@dodecl.$2'\n        },\n        '@linedecls': {\n          token: 'keyword.$0',\n          next: '@root.$0'\n        },\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], [/[A-Z][\\w]*[!?=]?/, 'constructor.identifier'], [/\\$[\\w]*/, 'global.constant'], [/@[\\w]*/, 'namespace.instance.identifier'], [/@@[\\w]*/, 'namespace.class.identifier'],\n    // here document\n    [/<<[-~](@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], [/[ \\t\\r\\n]+<<(@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }], [/^<<(@heredelim).*/, {\n      token: 'string.heredoc.delimiter',\n      next: '@heredoc.$1'\n    }],\n    // whitespace\n    {\n      include: '@whitespace'\n    },\n    // strings\n    [/\"/, {\n      token: 'string.d.delim',\n      next: '@dstring.d.\"'\n    }], [/'/, {\n      token: 'string.sq.delim',\n      next: '@sstring.sq'\n    }],\n    // % literals. For efficiency, rematch in the 'pstring' state\n    [/%([rsqxwW]|Q?)/, {\n      token: '@rematch',\n      next: 'pstring'\n    }],\n    // commands and symbols\n    [/`/, {\n      token: 'string.x.delim',\n      next: '@dstring.x.`'\n    }], [/:(\\w|[$@])\\w*[!?=]?/, 'string.s'], [/:\"/, {\n      token: 'string.s.delim',\n      next: '@dstring.s.\"'\n    }], [/:'/, {\n      token: 'string.s.delim',\n      next: '@sstring.s'\n    }],\n    // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line\n    [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, {\n      token: 'regexp.delim',\n      next: '@regexp'\n    }],\n    // delimiters and operators\n    [/[{}()\\[\\]]/, '@brackets'], [/@symbols/, {\n      cases: {\n        '@keywordops': 'keyword',\n        '@operators': 'operator',\n        '@default': ''\n      }\n    }], [/[;,]/, 'delimiter'],\n    // numbers\n    [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, 'number.hex'], [/0[_oO][0-7](_?[0-7])*/, 'number.octal'], [/0[bB][01](_?[01])*/, 'number.binary'], [/0[dD]@decpart/, 'number'], [/@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/, {\n      cases: {\n        '$1': 'number.float',\n        '@default': 'number'\n      }\n    }]],\n    // used to not treat a 'do' as a block opener if it occurs on the same\n    // line as a 'do' statement: 'while|until|for'\n    // dodecl.<decl> where decl is the declarations started, like 'while'\n    dodecl: [[/^/, {\n      token: '',\n      switchTo: '@root.$S2'\n    }], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        'do': {\n          token: 'keyword',\n          switchTo: '@root.$S2'\n        },\n        '@linedecls': {\n          token: '@rematch',\n          switchTo: '@root.$S2'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], {\n      include: '@root'\n    }],\n    // used to prevent potential modifiers ('if|until|while|unless') to match\n    // with 'end' keywords.\n    // modifier.<decl>x where decl is the declaration starter, like 'if'\n    modifier: [[/^/, '', '@pop'], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        'end': {\n          token: 'keyword.$S2',\n          next: '@pop'\n        },\n        'then|else|elsif|do': {\n          token: 'keyword',\n          switchTo: '@root.$S2'\n        },\n        '@linedecls': {\n          token: '@rematch',\n          switchTo: '@root.$S2'\n        },\n        '@keywords': 'keyword',\n        '@builtins': 'predefined',\n        '@default': 'identifier'\n      }\n    }], {\n      include: '@root'\n    }],\n    // single quote strings (also used for symbols)\n    // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)\n    sstring: [[/[^\\\\']+/, 'string.$S2'], [/\\\\\\\\|\\\\'|\\\\$/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.invalid'], [/'/, {\n      token: 'string.$S2.delim',\n      next: '@pop'\n    }]],\n    // double quoted \"string\".\n    // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)\n    // and delim is the ending delimiter (\" or `)\n    dstring: [[/[^\\\\`\"#]+/, 'string.$S2'], [/#/, 'string.$S2.escape', '@interpolated'], [/\\\\$/, 'string.$S2.escape'], [/@escapes/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.escape.invalid'], [/[`\"]/, {\n      cases: {\n        '$#==$S3': {\n          token: 'string.$S2.delim',\n          next: '@pop'\n        },\n        '@default': 'string.$S2'\n      }\n    }]],\n    // literal documents\n    // heredoc.<close> where close is the closing delimiter\n    heredoc: [[/^(\\s*)(@heredelim)$/, {\n      cases: {\n        '$2==$S2': ['string.heredoc', {\n          token: 'string.heredoc.delimiter',\n          next: '@pop'\n        }],\n        '@default': ['string.heredoc', 'string.heredoc']\n      }\n    }], [/.*/, 'string.heredoc']],\n    // interpolated sequence\n    interpolated: [[/\\$\\w*/, 'global.constant', '@pop'], [/@\\w*/, 'namespace.class.identifier', '@pop'], [/@@\\w*/, 'namespace.instance.identifier', '@pop'], [/[{]/, {\n      token: 'string.escape.curly',\n      switchTo: '@interpolated_compound'\n    }], ['', '', '@pop']],\n    // any code\n    interpolated_compound: [[/[}]/, {\n      token: 'string.escape.curly',\n      next: '@pop'\n    }], {\n      include: '@root'\n    }],\n    // %r quoted regexp\n    // pregexp.<open>.<close> where open/close are the open/close delimiter\n    pregexp: [{\n      include: '@whitespace'\n    },\n    // turns out that you can quote using regex control characters, aargh!\n    // for example; %r|kgjgaj| is ok (even though | is used for alternation)\n    // so, we need to match those first\n    [/[^\\(\\{\\[\\\\]/, {\n      cases: {\n        '$#==$S3': {\n          token: 'regexp.delim',\n          next: '@pop'\n        },\n        '$#==$S2': {\n          token: 'regexp.delim',\n          next: '@push'\n        },\n        '~[)}\\\\]]': '@brackets.regexp.escape.control',\n        '~@regexpctl': 'regexp.escape.control',\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexcontrol'\n    }],\n    // We match regular expression quite precisely\n    regexp: [{\n      include: '@regexcontrol'\n    }, [/[^\\\\\\/]/, 'regexp'], ['/[ixmp]*', {\n      token: 'regexp.delim'\n    }, '@pop']],\n    regexcontrol: [[/(\\{)(\\d+(?:,\\d*)?)(\\})/, ['@brackets.regexp.escape.control', 'regexp.escape.control', '@brackets.regexp.escape.control']], [/(\\[)(\\^?)/, ['@brackets.regexp.escape.control', {\n      token: 'regexp.escape.control',\n      next: '@regexrange'\n    }]], [/(\\()(\\?[:=!])/, ['@brackets.regexp.escape.control', 'regexp.escape.control']], [/\\(\\?#/, {\n      token: 'regexp.escape.control',\n      next: '@regexpcomment'\n    }], [/[()]/, '@brackets.regexp.escape.control'], [/@regexpctl/, 'regexp.escape.control'], [/\\\\$/, 'regexp.escape'], [/@regexpesc/, 'regexp.escape'], [/\\\\\\./, 'regexp.invalid'], [/#/, 'regexp.escape', '@interpolated']],\n    regexrange: [[/-/, 'regexp.escape.control'], [/\\^/, 'regexp.invalid'], [/\\\\$/, 'regexp.escape'], [/@regexpesc/, 'regexp.escape'], [/[^\\]]/, 'regexp'], [/\\]/, '@brackets.regexp.escape.control', '@pop']],\n    regexpcomment: [[/[^)]+/, 'comment'], [/\\)/, {\n      token: 'regexp.escape.control',\n      next: '@pop'\n    }]],\n    // % quoted strings\n    // A bit repetitive since we need to often special case the kind of ending delimiter\n    pstring: [[/%([qws])\\(/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.(.)'\n    }], [/%([qws])\\[/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.[.]'\n    }], [/%([qws])\\{/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.{.}'\n    }], [/%([qws])</, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.<.>'\n    }], [/%([qws])(@delim)/, {\n      token: 'string.$1.delim',\n      switchTo: '@qstring.$1.$2.$2'\n    }], [/%r\\(/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.(.)'\n    }], [/%r\\[/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.[.]'\n    }], [/%r\\{/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.{.}'\n    }], [/%r</, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.<.>'\n    }], [/%r(@delim)/, {\n      token: 'regexp.delim',\n      switchTo: '@pregexp.$1.$1'\n    }], [/%(x|W|Q?)\\(/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.(.)'\n    }], [/%(x|W|Q?)\\[/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.[.]'\n    }], [/%(x|W|Q?)\\{/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.{.}'\n    }], [/%(x|W|Q?)</, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.<.>'\n    }], [/%(x|W|Q?)(@delim)/, {\n      token: 'string.$1.delim',\n      switchTo: '@qqstring.$1.$2.$2'\n    }], [/%([rqwsxW]|Q?)./, {\n      token: 'invalid',\n      next: '@pop'\n    }], [/./, {\n      token: 'invalid',\n      next: '@pop'\n    }]],\n    // non-expanded quoted string.\n    // qstring.<kind>.<open>.<close>\n    //  kind = q|w|s  (single quote, array, symbol)\n    //  open = open delimiter\n    //  close = close delimiter\n    qstring: [[/\\\\$/, 'string.$S2.escape'], [/\\\\./, 'string.$S2.escape'], [/./, {\n      cases: {\n        '$#==$S4': {\n          token: 'string.$S2.delim',\n          next: '@pop'\n        },\n        '$#==$S3': {\n          token: 'string.$S2.delim',\n          next: '@push'\n        },\n        '@default': 'string.$S2'\n      }\n    }]],\n    // expanded quoted string.\n    // qqstring.<kind>.<open>.<close>\n    //  kind = Q|W|x  (double quote, array, command)\n    //  open = open delimiter\n    //  close = close delimiter\n    qqstring: [[/#/, 'string.$S2.escape', '@interpolated'], {\n      include: '@qstring'\n    }],\n    // whitespace & comments\n    whitespace: [[/[ \\t\\r\\n]+/, ''], [/^\\s*=begin\\b/, 'comment', '@comment'], [/#.*$/, 'comment']],\n    comment: [[/[^=]+/, 'comment'], [/^\\s*=begin\\b/, 'comment.invalid'], [/^\\s*=end\\b.*/, 'comment', '@pop'], [/[=]/, 'comment']]\n  }\n};","map":{"version":3,"names":["conf","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","indentationRules","increaseIndentPattern","RegExp","decreaseIndentPattern","language","tokenPostfix","keywords","keywordops","builtins","declarations","linedecls","operators","token","symbols","escape","escapes","decpart","decimal","delim","heredelim","regexpctl","regexpesc","tokenizer","root","cases","next","include","dodecl","switchTo","modifier","sstring","dstring","heredoc","interpolated","interpolated_compound","pregexp","regexp","regexcontrol","regexrange","regexpcomment","pstring","qstring","qqstring","whitespace","comment"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n'use strict';\r\nexport var conf = {\r\n    comments: {\r\n        lineComment: '#',\r\n        blockComment: ['=begin', '=end'],\r\n    },\r\n    brackets: [\r\n        ['(', ')'],\r\n        ['{', '}'],\r\n        ['[', ']']\r\n    ],\r\n    autoClosingPairs: [\r\n        { open: '{', close: '}' },\r\n        { open: '[', close: ']' },\r\n        { open: '(', close: ')' },\r\n        { open: '\"', close: '\"' },\r\n        { open: '\\'', close: '\\'' },\r\n    ],\r\n    surroundingPairs: [\r\n        { open: '{', close: '}' },\r\n        { open: '[', close: ']' },\r\n        { open: '(', close: ')' },\r\n        { open: '\"', close: '\"' },\r\n        { open: '\\'', close: '\\'' },\r\n    ],\r\n    indentationRules: {\r\n        increaseIndentPattern: new RegExp('^\\\\s*((begin|class|(private|protected)\\\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\\\sdo\\\\b)|([^#]*=\\\\s*(case|if|unless)))\\\\b([^#\\\\{;]|(\"|\\'|\\/).*\\\\4)*(#.*)?$'),\r\n        decreaseIndentPattern: new RegExp('^\\\\s*([}\\\\]]([,)]?\\\\s*(#|$)|\\\\.[a-zA-Z_]\\\\w*\\\\b)|(end|rescue|ensure|else|elsif|when)\\\\b)'),\r\n    }\r\n};\r\n/*\r\n * Ruby language definition\r\n *\r\n * Quite a complex language due to elaborate escape sequences\r\n * and quoting of literate strings/regular expressions, and\r\n * an 'end' keyword that does not always apply to modifiers like until and while,\r\n * and a 'do' keyword that sometimes starts a block, but sometimes is part of\r\n * another statement (like 'while').\r\n *\r\n * (1) end blocks:\r\n * 'end' may end declarations like if or until, but sometimes 'if' or 'until'\r\n * are modifiers where there is no 'end'. Also, 'do' sometimes starts a block\r\n * that is ended by 'end', but sometimes it is part of a 'while', 'for', or 'until'\r\n * To do proper brace matching we do some elaborate state manipulation.\r\n * some examples:\r\n *\r\n *   until bla do\r\n *     work until tired\r\n *     list.each do\r\n *       something if test\r\n *     end\r\n *   end\r\n *\r\n * or\r\n *\r\n * if test\r\n *  something (if test then x end)\r\n *  bar if bla\r\n * end\r\n *\r\n * or, how about using class as a property..\r\n *\r\n * class Test\r\n *   def endpoint\r\n *     self.class.endpoint || routes\r\n *   end\r\n * end\r\n *\r\n * (2) quoting:\r\n * there are many kinds of strings and escape sequences. But also, one can\r\n * start many string-like things as '%qx' where q specifies the kind of string\r\n * (like a command, escape expanded, regular expression, symbol etc.), and x is\r\n * some character and only another 'x' ends the sequence. Except for brackets\r\n * where the closing bracket ends the sequence.. and except for a nested bracket\r\n * inside the string like entity. Also, such strings can contain interpolated\r\n * ruby expressions again (and span multiple lines). Moreover, expanded\r\n * regular expression can also contain comments.\r\n */\r\nexport var language = {\r\n    tokenPostfix: '.ruby',\r\n    keywords: [\r\n        '__LINE__', '__ENCODING__', '__FILE__', 'BEGIN', 'END', 'alias', 'and', 'begin',\r\n        'break', 'case', 'class', 'def', 'defined?', 'do', 'else', 'elsif', 'end',\r\n        'ensure', 'for', 'false', 'if', 'in', 'module', 'next', 'nil', 'not', 'or', 'redo',\r\n        'rescue', 'retry', 'return', 'self', 'super', 'then', 'true', 'undef', 'unless',\r\n        'until', 'when', 'while', 'yield',\r\n    ],\r\n    keywordops: [\r\n        '::', '..', '...', '?', ':', '=>'\r\n    ],\r\n    builtins: [\r\n        'require', 'public', 'private', 'include', 'extend', 'attr_reader',\r\n        'protected', 'private_class_method', 'protected_class_method', 'new'\r\n    ],\r\n    // these are closed by 'end' (if, while and until are handled separately)\r\n    declarations: [\r\n        'module', 'class', 'def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'\r\n    ],\r\n    linedecls: [\r\n        'def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'\r\n    ],\r\n    operators: [\r\n        '^', '&', '|', '<=>', '==', '===', '!~', '=~', '>', '>=', '<', '<=', '<<', '>>', '+',\r\n        '-', '*', '/', '%', '**', '~', '+@', '-@', '[]', '[]=', '`',\r\n        '+=', '-=', '*=', '**=', '/=', '^=', '%=', '<<=', '>>=', '&=', '&&=', '||=', '|='\r\n    ],\r\n    brackets: [\r\n        { open: '(', close: ')', token: 'delimiter.parenthesis' },\r\n        { open: '{', close: '}', token: 'delimiter.curly' },\r\n        { open: '[', close: ']', token: 'delimiter.square' }\r\n    ],\r\n    // we include these common regular expressions\r\n    symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\r\n    // escape sequences\r\n    escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\r\n    escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\r\n    decpart: /\\d(_?\\d)*/,\r\n    decimal: /0|@decpart/,\r\n    delim: /[^a-zA-Z0-9\\s\\n\\r]/,\r\n    heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\r\n    regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\r\n    regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\r\n    // The main tokenizer for our languages\r\n    tokenizer: {\r\n        // Main entry.\r\n        // root.<decl> where decl is the current opening declaration (like 'class')\r\n        root: [\r\n            // identifiers and keywords\r\n            // most complexity here is due to matching 'end' correctly with declarations.\r\n            // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)\r\n            [/^(\\s*)([a-z_]\\w*[!?=]?)/, ['white',\r\n                    {\r\n                        cases: {\r\n                            'for|until|while': { token: 'keyword.$2', next: '@dodecl.$2' },\r\n                            '@declarations': { token: 'keyword.$2', next: '@root.$2' },\r\n                            'end': { token: 'keyword.$S2', next: '@pop' },\r\n                            '@keywords': 'keyword',\r\n                            '@builtins': 'predefined',\r\n                            '@default': 'identifier'\r\n                        }\r\n                    }]],\r\n            [/[a-z_]\\w*[!?=]?/,\r\n                {\r\n                    cases: {\r\n                        'if|unless|while|until': { token: 'keyword.$0x', next: '@modifier.$0x' },\r\n                        'for': { token: 'keyword.$2', next: '@dodecl.$2' },\r\n                        '@linedecls': { token: 'keyword.$0', next: '@root.$0' },\r\n                        'end': { token: 'keyword.$S2', next: '@pop' },\r\n                        '@keywords': 'keyword',\r\n                        '@builtins': 'predefined',\r\n                        '@default': 'identifier'\r\n                    }\r\n                }],\r\n            [/[A-Z][\\w]*[!?=]?/, 'constructor.identifier'],\r\n            [/\\$[\\w]*/, 'global.constant'],\r\n            [/@[\\w]*/, 'namespace.instance.identifier'],\r\n            [/@@[\\w]*/, 'namespace.class.identifier'],\r\n            // here document\r\n            [/<<[-~](@heredelim).*/, { token: 'string.heredoc.delimiter', next: '@heredoc.$1' }],\r\n            [/[ \\t\\r\\n]+<<(@heredelim).*/, { token: 'string.heredoc.delimiter', next: '@heredoc.$1' }],\r\n            [/^<<(@heredelim).*/, { token: 'string.heredoc.delimiter', next: '@heredoc.$1' }],\r\n            // whitespace\r\n            { include: '@whitespace' },\r\n            // strings\r\n            [/\"/, { token: 'string.d.delim', next: '@dstring.d.\"' }],\r\n            [/'/, { token: 'string.sq.delim', next: '@sstring.sq' }],\r\n            // % literals. For efficiency, rematch in the 'pstring' state\r\n            [/%([rsqxwW]|Q?)/, { token: '@rematch', next: 'pstring' }],\r\n            // commands and symbols\r\n            [/`/, { token: 'string.x.delim', next: '@dstring.x.`' }],\r\n            [/:(\\w|[$@])\\w*[!?=]?/, 'string.s'],\r\n            [/:\"/, { token: 'string.s.delim', next: '@dstring.s.\"' }],\r\n            [/:'/, { token: 'string.s.delim', next: '@sstring.s' }],\r\n            // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line\r\n            [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, { token: 'regexp.delim', next: '@regexp' }],\r\n            // delimiters and operators\r\n            [/[{}()\\[\\]]/, '@brackets'],\r\n            [/@symbols/, {\r\n                    cases: {\r\n                        '@keywordops': 'keyword',\r\n                        '@operators': 'operator',\r\n                        '@default': ''\r\n                    }\r\n                }],\r\n            [/[;,]/, 'delimiter'],\r\n            // numbers\r\n            [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, 'number.hex'],\r\n            [/0[_oO][0-7](_?[0-7])*/, 'number.octal'],\r\n            [/0[bB][01](_?[01])*/, 'number.binary'],\r\n            [/0[dD]@decpart/, 'number'],\r\n            [/@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/, {\r\n                    cases: {\r\n                        '$1': 'number.float',\r\n                        '@default': 'number'\r\n                    }\r\n                }],\r\n        ],\r\n        // used to not treat a 'do' as a block opener if it occurs on the same\r\n        // line as a 'do' statement: 'while|until|for'\r\n        // dodecl.<decl> where decl is the declarations started, like 'while'\r\n        dodecl: [\r\n            [/^/, { token: '', switchTo: '@root.$S2' }],\r\n            [/[a-z_]\\w*[!?=]?/, {\r\n                    cases: {\r\n                        'end': { token: 'keyword.$S2', next: '@pop' },\r\n                        'do': { token: 'keyword', switchTo: '@root.$S2' },\r\n                        '@linedecls': { token: '@rematch', switchTo: '@root.$S2' },\r\n                        '@keywords': 'keyword',\r\n                        '@builtins': 'predefined',\r\n                        '@default': 'identifier'\r\n                    }\r\n                }],\r\n            { include: '@root' }\r\n        ],\r\n        // used to prevent potential modifiers ('if|until|while|unless') to match\r\n        // with 'end' keywords.\r\n        // modifier.<decl>x where decl is the declaration starter, like 'if'\r\n        modifier: [\r\n            [/^/, '', '@pop'],\r\n            [/[a-z_]\\w*[!?=]?/, {\r\n                    cases: {\r\n                        'end': { token: 'keyword.$S2', next: '@pop' },\r\n                        'then|else|elsif|do': { token: 'keyword', switchTo: '@root.$S2' },\r\n                        '@linedecls': { token: '@rematch', switchTo: '@root.$S2' },\r\n                        '@keywords': 'keyword',\r\n                        '@builtins': 'predefined',\r\n                        '@default': 'identifier'\r\n                    }\r\n                }],\r\n            { include: '@root' }\r\n        ],\r\n        // single quote strings (also used for symbols)\r\n        // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)\r\n        sstring: [\r\n            [/[^\\\\']+/, 'string.$S2'],\r\n            [/\\\\\\\\|\\\\'|\\\\$/, 'string.$S2.escape'],\r\n            [/\\\\./, 'string.$S2.invalid'],\r\n            [/'/, { token: 'string.$S2.delim', next: '@pop' }]\r\n        ],\r\n        // double quoted \"string\".\r\n        // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)\r\n        // and delim is the ending delimiter (\" or `)\r\n        dstring: [\r\n            [/[^\\\\`\"#]+/, 'string.$S2'],\r\n            [/#/, 'string.$S2.escape', '@interpolated'],\r\n            [/\\\\$/, 'string.$S2.escape'],\r\n            [/@escapes/, 'string.$S2.escape'],\r\n            [/\\\\./, 'string.$S2.escape.invalid'],\r\n            [/[`\"]/, {\r\n                    cases: {\r\n                        '$#==$S3': { token: 'string.$S2.delim', next: '@pop' },\r\n                        '@default': 'string.$S2'\r\n                    }\r\n                }]\r\n        ],\r\n        // literal documents\r\n        // heredoc.<close> where close is the closing delimiter\r\n        heredoc: [\r\n            [/^(\\s*)(@heredelim)$/, {\r\n                    cases: {\r\n                        '$2==$S2': ['string.heredoc', { token: 'string.heredoc.delimiter', next: '@pop' }],\r\n                        '@default': ['string.heredoc', 'string.heredoc']\r\n                    }\r\n                }],\r\n            [/.*/, 'string.heredoc'],\r\n        ],\r\n        // interpolated sequence\r\n        interpolated: [\r\n            [/\\$\\w*/, 'global.constant', '@pop'],\r\n            [/@\\w*/, 'namespace.class.identifier', '@pop'],\r\n            [/@@\\w*/, 'namespace.instance.identifier', '@pop'],\r\n            [/[{]/, { token: 'string.escape.curly', switchTo: '@interpolated_compound' }],\r\n            ['', '', '@pop'],\r\n        ],\r\n        // any code\r\n        interpolated_compound: [\r\n            [/[}]/, { token: 'string.escape.curly', next: '@pop' }],\r\n            { include: '@root' },\r\n        ],\r\n        // %r quoted regexp\r\n        // pregexp.<open>.<close> where open/close are the open/close delimiter\r\n        pregexp: [\r\n            { include: '@whitespace' },\r\n            // turns out that you can quote using regex control characters, aargh!\r\n            // for example; %r|kgjgaj| is ok (even though | is used for alternation)\r\n            // so, we need to match those first\r\n            [/[^\\(\\{\\[\\\\]/, {\r\n                    cases: {\r\n                        '$#==$S3': { token: 'regexp.delim', next: '@pop' },\r\n                        '$#==$S2': { token: 'regexp.delim', next: '@push' },\r\n                        '~[)}\\\\]]': '@brackets.regexp.escape.control',\r\n                        '~@regexpctl': 'regexp.escape.control',\r\n                        '@default': 'regexp'\r\n                    }\r\n                }],\r\n            { include: '@regexcontrol' },\r\n        ],\r\n        // We match regular expression quite precisely\r\n        regexp: [\r\n            { include: '@regexcontrol' },\r\n            [/[^\\\\\\/]/, 'regexp'],\r\n            ['/[ixmp]*', { token: 'regexp.delim' }, '@pop'],\r\n        ],\r\n        regexcontrol: [\r\n            [/(\\{)(\\d+(?:,\\d*)?)(\\})/, ['@brackets.regexp.escape.control', 'regexp.escape.control', '@brackets.regexp.escape.control']],\r\n            [/(\\[)(\\^?)/, ['@brackets.regexp.escape.control', { token: 'regexp.escape.control', next: '@regexrange' }]],\r\n            [/(\\()(\\?[:=!])/, ['@brackets.regexp.escape.control', 'regexp.escape.control']],\r\n            [/\\(\\?#/, { token: 'regexp.escape.control', next: '@regexpcomment' }],\r\n            [/[()]/, '@brackets.regexp.escape.control'],\r\n            [/@regexpctl/, 'regexp.escape.control'],\r\n            [/\\\\$/, 'regexp.escape'],\r\n            [/@regexpesc/, 'regexp.escape'],\r\n            [/\\\\\\./, 'regexp.invalid'],\r\n            [/#/, 'regexp.escape', '@interpolated'],\r\n        ],\r\n        regexrange: [\r\n            [/-/, 'regexp.escape.control'],\r\n            [/\\^/, 'regexp.invalid'],\r\n            [/\\\\$/, 'regexp.escape'],\r\n            [/@regexpesc/, 'regexp.escape'],\r\n            [/[^\\]]/, 'regexp'],\r\n            [/\\]/, '@brackets.regexp.escape.control', '@pop'],\r\n        ],\r\n        regexpcomment: [\r\n            [/[^)]+/, 'comment'],\r\n            [/\\)/, { token: 'regexp.escape.control', next: '@pop' }]\r\n        ],\r\n        // % quoted strings\r\n        // A bit repetitive since we need to often special case the kind of ending delimiter\r\n        pstring: [\r\n            [/%([qws])\\(/, { token: 'string.$1.delim', switchTo: '@qstring.$1.(.)' }],\r\n            [/%([qws])\\[/, { token: 'string.$1.delim', switchTo: '@qstring.$1.[.]' }],\r\n            [/%([qws])\\{/, { token: 'string.$1.delim', switchTo: '@qstring.$1.{.}' }],\r\n            [/%([qws])</, { token: 'string.$1.delim', switchTo: '@qstring.$1.<.>' }],\r\n            [/%([qws])(@delim)/, { token: 'string.$1.delim', switchTo: '@qstring.$1.$2.$2' }],\r\n            [/%r\\(/, { token: 'regexp.delim', switchTo: '@pregexp.(.)' }],\r\n            [/%r\\[/, { token: 'regexp.delim', switchTo: '@pregexp.[.]' }],\r\n            [/%r\\{/, { token: 'regexp.delim', switchTo: '@pregexp.{.}' }],\r\n            [/%r</, { token: 'regexp.delim', switchTo: '@pregexp.<.>' }],\r\n            [/%r(@delim)/, { token: 'regexp.delim', switchTo: '@pregexp.$1.$1' }],\r\n            [/%(x|W|Q?)\\(/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.(.)' }],\r\n            [/%(x|W|Q?)\\[/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.[.]' }],\r\n            [/%(x|W|Q?)\\{/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.{.}' }],\r\n            [/%(x|W|Q?)</, { token: 'string.$1.delim', switchTo: '@qqstring.$1.<.>' }],\r\n            [/%(x|W|Q?)(@delim)/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.$2.$2' }],\r\n            [/%([rqwsxW]|Q?)./, { token: 'invalid', next: '@pop' }],\r\n            [/./, { token: 'invalid', next: '@pop' }],\r\n        ],\r\n        // non-expanded quoted string.\r\n        // qstring.<kind>.<open>.<close>\r\n        //  kind = q|w|s  (single quote, array, symbol)\r\n        //  open = open delimiter\r\n        //  close = close delimiter\r\n        qstring: [\r\n            [/\\\\$/, 'string.$S2.escape'],\r\n            [/\\\\./, 'string.$S2.escape'],\r\n            [/./, {\r\n                    cases: {\r\n                        '$#==$S4': { token: 'string.$S2.delim', next: '@pop' },\r\n                        '$#==$S3': { token: 'string.$S2.delim', next: '@push' },\r\n                        '@default': 'string.$S2'\r\n                    }\r\n                }],\r\n        ],\r\n        // expanded quoted string.\r\n        // qqstring.<kind>.<open>.<close>\r\n        //  kind = Q|W|x  (double quote, array, command)\r\n        //  open = open delimiter\r\n        //  close = close delimiter\r\n        qqstring: [\r\n            [/#/, 'string.$S2.escape', '@interpolated'],\r\n            { include: '@qstring' }\r\n        ],\r\n        // whitespace & comments\r\n        whitespace: [\r\n            [/[ \\t\\r\\n]+/, ''],\r\n            [/^\\s*=begin\\b/, 'comment', '@comment'],\r\n            [/#.*$/, 'comment'],\r\n        ],\r\n        comment: [\r\n            [/[^=]+/, 'comment'],\r\n            [/^\\s*=begin\\b/, 'comment.invalid'],\r\n            [/^\\s*=end\\b.*/, 'comment', '@pop'],\r\n            [/[=]/, 'comment']\r\n        ],\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}