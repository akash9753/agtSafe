{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n  return r;\n};\nimport { TreeError } from './tree.js';\nimport { tail2 } from '../../../common/arrays.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterator } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1 /* Visible */;\n    case false:\n      return 0 /* Hidden */;\n    default:\n      return visibility;\n  }\n}\nfunction isCollapsibleStateUpdate(update) {\n  return typeof update.collapsible === 'boolean';\n}\nvar IndexTreeModel = /** @class */function () {\n  function IndexTreeModel(user, list, rootElement, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.user = user;\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visible: true,\n      filterData: undefined\n    };\n  }\n  IndexTreeModel.prototype.splice = function (location, deleteCount, toInsert, onDidCreateNode, onDidDeleteNode) {\n    var _a;\n    var _this = this;\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    var _b = this.getParentNodeWithListIndex(location),\n      parentNode = _b.parentNode,\n      listIndex = _b.listIndex,\n      revealed = _b.revealed,\n      visible = _b.visible;\n    var treeListElementsToInsert = [];\n    var nodesToInsertIterator = Iterator.map(Iterator.from(toInsert), function (el) {\n      return _this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode);\n    });\n    var lastIndex = location[location.length - 1];\n    // figure out what's the visible child start index right before the\n    // splice point\n    var visibleChildStartIndex = 0;\n    for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n      var child = parentNode.children[i];\n      if (child.visible) {\n        visibleChildStartIndex = child.visibleChildIndex;\n        break;\n      }\n    }\n    var nodesToInsert = [];\n    var insertedVisibleChildrenCount = 0;\n    var renderNodeCount = 0;\n    Iterator.forEach(nodesToInsertIterator, function (child) {\n      nodesToInsert.push(child);\n      renderNodeCount += child.renderNodeCount;\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n      }\n    });\n    var deletedNodes = (_a = parentNode.children).splice.apply(_a, __spreadArrays([lastIndex, deleteCount], nodesToInsert));\n    // figure out what is the count of deleted visible children\n    var deletedVisibleChildrenCount = 0;\n    for (var _i = 0, deletedNodes_1 = deletedNodes; _i < deletedNodes_1.length; _i++) {\n      var child = deletedNodes_1[_i];\n      if (child.visible) {\n        deletedVisibleChildrenCount++;\n      }\n    }\n    // and adjust for all visible children after the splice point\n    if (deletedVisibleChildrenCount !== 0) {\n      for (var i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n        var child = parentNode.children[i];\n        if (child.visible) {\n          child.visibleChildIndex -= deletedVisibleChildrenCount;\n        }\n      }\n    }\n    // update parent's visible children count\n    parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n    if (revealed && visible) {\n      var visibleDeleteCount = deletedNodes.reduce(function (r, node) {\n        return r + (node.visible ? node.renderNodeCount : 0);\n      }, 0);\n      this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n      this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n    }\n    if (deletedNodes.length > 0 && onDidDeleteNode) {\n      var visit_1 = function visit_1(node) {\n        onDidDeleteNode(node);\n        node.children.forEach(visit_1);\n      };\n      deletedNodes.forEach(visit_1);\n    }\n    this._onDidSplice.fire({\n      insertedNodes: nodesToInsert,\n      deletedNodes: deletedNodes\n    });\n  };\n  IndexTreeModel.prototype.rerender = function (location) {\n    if (location.length === 0) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    var _a = this.getTreeNodeWithListIndex(location),\n      node = _a.node,\n      listIndex = _a.listIndex,\n      revealed = _a.revealed;\n    if (revealed) {\n      this.list.splice(listIndex, 1, [node]);\n    }\n  };\n  IndexTreeModel.prototype.has = function (location) {\n    return this.hasTreeNode(location);\n  };\n  IndexTreeModel.prototype.getListIndex = function (location) {\n    var _a = this.getTreeNodeWithListIndex(location),\n      listIndex = _a.listIndex,\n      visible = _a.visible,\n      revealed = _a.revealed;\n    return visible && revealed ? listIndex : -1;\n  };\n  IndexTreeModel.prototype.getListRenderCount = function (location) {\n    return this.getTreeNode(location).renderNodeCount;\n  };\n  IndexTreeModel.prototype.isCollapsible = function (location) {\n    return this.getTreeNode(location).collapsible;\n  };\n  IndexTreeModel.prototype.setCollapsible = function (location, collapsible) {\n    var _this = this;\n    var node = this.getTreeNode(location);\n    if (typeof collapsible === 'undefined') {\n      collapsible = !node.collapsible;\n    }\n    var update = {\n      collapsible: collapsible\n    };\n    return this.eventBufferer.bufferEvents(function () {\n      return _this._setCollapseState(location, update);\n    });\n  };\n  IndexTreeModel.prototype.isCollapsed = function (location) {\n    return this.getTreeNode(location).collapsed;\n  };\n  IndexTreeModel.prototype.setCollapsed = function (location, collapsed, recursive) {\n    var _this = this;\n    var node = this.getTreeNode(location);\n    if (typeof collapsed === 'undefined') {\n      collapsed = !node.collapsed;\n    }\n    var update = {\n      collapsed: collapsed,\n      recursive: recursive || false\n    };\n    return this.eventBufferer.bufferEvents(function () {\n      return _this._setCollapseState(location, update);\n    });\n  };\n  IndexTreeModel.prototype._setCollapseState = function (location, update) {\n    var _a = this.getTreeNodeWithListIndex(location),\n      node = _a.node,\n      listIndex = _a.listIndex,\n      revealed = _a.revealed;\n    var result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n    if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n      var onlyVisibleChildIndex = -1;\n      for (var i = 0; i < node.children.length; i++) {\n        var child = node.children[i];\n        if (child.visible) {\n          if (onlyVisibleChildIndex > -1) {\n            onlyVisibleChildIndex = -1;\n            break;\n          } else {\n            onlyVisibleChildIndex = i;\n          }\n        }\n      }\n      if (onlyVisibleChildIndex > -1) {\n        this._setCollapseState(__spreadArrays(location, [onlyVisibleChildIndex]), update);\n      }\n    }\n    return result;\n  };\n  IndexTreeModel.prototype._setListNodeCollapseState = function (node, listIndex, revealed, update) {\n    var result = this._setNodeCollapseState(node, update, false);\n    if (!revealed || !node.visible || !result) {\n      return result;\n    }\n    var previousRenderNodeCount = node.renderNodeCount;\n    var toInsert = this.updateNodeAfterCollapseChange(node);\n    var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n    this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n    return result;\n  };\n  IndexTreeModel.prototype._setNodeCollapseState = function (node, update, deep) {\n    var result;\n    if (node === this.root) {\n      result = false;\n    } else {\n      if (isCollapsibleStateUpdate(update)) {\n        result = node.collapsible !== update.collapsible;\n        node.collapsible = update.collapsible;\n      } else if (!node.collapsible) {\n        result = false;\n      } else {\n        result = node.collapsed !== update.collapsed;\n        node.collapsed = update.collapsed;\n      }\n      if (result) {\n        this._onDidChangeCollapseState.fire({\n          node: node,\n          deep: deep\n        });\n      }\n    }\n    if (!isCollapsibleStateUpdate(update) && update.recursive) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        result = this._setNodeCollapseState(child, update, true) || result;\n      }\n    }\n    return result;\n  };\n  IndexTreeModel.prototype.expandTo = function (location) {\n    var _this = this;\n    this.eventBufferer.bufferEvents(function () {\n      var node = _this.getTreeNode(location);\n      while (node.parent) {\n        node = node.parent;\n        location = location.slice(0, location.length - 1);\n        if (node.collapsed) {\n          _this._setCollapseState(location, {\n            collapsed: false,\n            recursive: false\n          });\n        }\n      }\n    });\n  };\n  IndexTreeModel.prototype.refilter = function () {\n    var previousRenderNodeCount = this.root.renderNodeCount;\n    var toInsert = this.updateNodeAfterFilterChange(this.root);\n    this.list.splice(0, previousRenderNodeCount, toInsert);\n  };\n  IndexTreeModel.prototype.createTreeNode = function (treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n    var _this = this;\n    var node = {\n      parent: parent,\n      element: treeElement.element,\n      children: [],\n      depth: parent.depth + 1,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n      collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n      renderNodeCount: 1,\n      visible: true,\n      filterData: undefined\n    };\n    var visibility = this._filterNode(node, parentVisibility);\n    if (revealed) {\n      treeListElements.push(node);\n    }\n    var childElements = Iterator.from(treeElement.children);\n    var childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\n    var childNodes = Iterator.map(childElements, function (el) {\n      return _this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n    });\n    var visibleChildrenCount = 0;\n    var renderNodeCount = 1;\n    Iterator.forEach(childNodes, function (child) {\n      node.children.push(child);\n      renderNodeCount += child.renderNodeCount;\n      if (child.visible) {\n        child.visibleChildIndex = visibleChildrenCount++;\n      }\n    });\n    node.collapsible = node.collapsible || node.children.length > 0;\n    node.visibleChildrenCount = visibleChildrenCount;\n    node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : visibility === 1 /* Visible */;\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n      if (revealed) {\n        treeListElements.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount = renderNodeCount;\n    }\n    if (onDidCreateNode) {\n      onDidCreateNode(node);\n    }\n    return node;\n  };\n  IndexTreeModel.prototype.updateNodeAfterCollapseChange = function (node) {\n    var previousRenderNodeCount = node.renderNodeCount;\n    var result = [];\n    this._updateNodeAfterCollapseChange(node, result);\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n    return result;\n  };\n  IndexTreeModel.prototype._updateNodeAfterCollapseChange = function (node, result) {\n    if (node.visible === false) {\n      return 0;\n    }\n    result.push(node);\n    node.renderNodeCount = 1;\n    if (!node.collapsed) {\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n      }\n    }\n    this._onDidChangeRenderNodeCount.fire(node);\n    return node.renderNodeCount;\n  };\n  IndexTreeModel.prototype.updateNodeAfterFilterChange = function (node) {\n    var previousRenderNodeCount = node.renderNodeCount;\n    var result = [];\n    this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\n    this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n    return result;\n  };\n  IndexTreeModel.prototype._updateNodeAfterFilterChange = function (node, parentVisibility, result, revealed) {\n    if (revealed === void 0) {\n      revealed = true;\n    }\n    var visibility;\n    if (node !== this.root) {\n      visibility = this._filterNode(node, parentVisibility);\n      if (visibility === 0 /* Hidden */) {\n        node.visible = false;\n        node.renderNodeCount = 0;\n        return false;\n      }\n      if (revealed) {\n        result.push(node);\n      }\n    }\n    var resultStartLength = result.length;\n    node.renderNodeCount = node === this.root ? 0 : 1;\n    var hasVisibleDescendants = false;\n    if (!node.collapsed || visibility !== 0 /* Hidden */) {\n      var visibleChildIndex = 0;\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n        if (child.visible) {\n          child.visibleChildIndex = visibleChildIndex++;\n        }\n      }\n      node.visibleChildrenCount = visibleChildIndex;\n    } else {\n      node.visibleChildrenCount = 0;\n    }\n    if (node !== this.root) {\n      node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : visibility === 1 /* Visible */;\n    }\n\n    if (!node.visible) {\n      node.renderNodeCount = 0;\n      if (revealed) {\n        result.pop();\n      }\n    } else if (!node.collapsed) {\n      node.renderNodeCount += result.length - resultStartLength;\n    }\n    this._onDidChangeRenderNodeCount.fire(node);\n    return node.visible;\n  };\n  IndexTreeModel.prototype._updateAncestorsRenderNodeCount = function (node, diff) {\n    if (diff === 0) {\n      return;\n    }\n    while (node) {\n      node.renderNodeCount += diff;\n      this._onDidChangeRenderNodeCount.fire(node);\n      node = node.parent;\n    }\n  };\n  IndexTreeModel.prototype._filterNode = function (node, parentVisibility) {\n    var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\n    if (typeof result === 'boolean') {\n      node.filterData = undefined;\n      return result ? 1 /* Visible */ : 0 /* Hidden */;\n    } else if (isFilterResult(result)) {\n      node.filterData = result.data;\n      return getVisibleState(result.visibility);\n    } else {\n      node.filterData = undefined;\n      return getVisibleState(result);\n    }\n  };\n  // cheap\n  IndexTreeModel.prototype.hasTreeNode = function (location, node) {\n    if (node === void 0) {\n      node = this.root;\n    }\n    if (!location || location.length === 0) {\n      return true;\n    }\n    var index = location[0],\n      rest = location.slice(1);\n    if (index < 0 || index > node.children.length) {\n      return false;\n    }\n    return this.hasTreeNode(rest, node.children[index]);\n  };\n  // cheap\n  IndexTreeModel.prototype.getTreeNode = function (location, node) {\n    if (node === void 0) {\n      node = this.root;\n    }\n    if (!location || location.length === 0) {\n      return node;\n    }\n    var index = location[0],\n      rest = location.slice(1);\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    return this.getTreeNode(rest, node.children[index]);\n  };\n  // expensive\n  IndexTreeModel.prototype.getTreeNodeWithListIndex = function (location) {\n    if (location.length === 0) {\n      return {\n        node: this.root,\n        listIndex: -1,\n        revealed: true,\n        visible: false\n      };\n    }\n    var _a = this.getParentNodeWithListIndex(location),\n      parentNode = _a.parentNode,\n      listIndex = _a.listIndex,\n      revealed = _a.revealed,\n      visible = _a.visible;\n    var index = location[location.length - 1];\n    if (index < 0 || index > parentNode.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    var node = parentNode.children[index];\n    return {\n      node: node,\n      listIndex: listIndex,\n      revealed: revealed,\n      visible: visible && node.visible\n    };\n  };\n  IndexTreeModel.prototype.getParentNodeWithListIndex = function (location, node, listIndex, revealed, visible) {\n    if (node === void 0) {\n      node = this.root;\n    }\n    if (listIndex === void 0) {\n      listIndex = 0;\n    }\n    if (revealed === void 0) {\n      revealed = true;\n    }\n    if (visible === void 0) {\n      visible = true;\n    }\n    var index = location[0],\n      rest = location.slice(1);\n    if (index < 0 || index > node.children.length) {\n      throw new TreeError(this.user, 'Invalid tree location');\n    }\n    // TODO@joao perf!\n    for (var i = 0; i < index; i++) {\n      listIndex += node.children[i].renderNodeCount;\n    }\n    revealed = revealed && !node.collapsed;\n    visible = visible && node.visible;\n    if (rest.length === 0) {\n      return {\n        parentNode: node,\n        listIndex: listIndex,\n        revealed: revealed,\n        visible: visible\n      };\n    }\n    return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n  };\n  IndexTreeModel.prototype.getNode = function (location) {\n    if (location === void 0) {\n      location = [];\n    }\n    return this.getTreeNode(location);\n  };\n  // TODO@joao perf!\n  IndexTreeModel.prototype.getNodeLocation = function (node) {\n    var location = [];\n    var indexTreeNode = node; // typing woes\n    while (indexTreeNode.parent) {\n      location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n      indexTreeNode = indexTreeNode.parent;\n    }\n    return location.reverse();\n  };\n  IndexTreeModel.prototype.getParentNodeLocation = function (location) {\n    if (location.length === 0) {\n      return undefined;\n    } else if (location.length === 1) {\n      return [];\n    } else {\n      return tail2(location)[0];\n    }\n  };\n  return IndexTreeModel;\n}();\nexport { IndexTreeModel };","map":{"version":3,"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","TreeError","tail2","Emitter","EventBufferer","Iterator","isFilterResult","obj","getVisibleState","visibility","isCollapsibleStateUpdate","update","collapsible","IndexTreeModel","user","list","rootElement","options","rootRef","eventBufferer","_onDidChangeCollapseState","onDidChangeCollapseState","wrapEvent","event","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","collapseByDefault","filter","autoExpandSingleChildren","root","parent","undefined","element","children","depth","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","visible","filterData","prototype","splice","location","deleteCount","toInsert","onDidCreateNode","onDidDeleteNode","_a","_this","_b","getParentNodeWithListIndex","parentNode","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","map","from","el","createTreeNode","lastIndex","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","forEach","push","deletedNodes","apply","deletedVisibleChildrenCount","_i","deletedNodes_1","visibleDeleteCount","reduce","node","_updateAncestorsRenderNodeCount","visit_1","fire","insertedNodes","rerender","getTreeNodeWithListIndex","has","hasTreeNode","getListIndex","getListRenderCount","getTreeNode","isCollapsible","setCollapsible","bufferEvents","_setCollapseState","isCollapsed","setCollapsed","recursive","result","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","slice","deep","expandTo","refilter","updateNodeAfterFilterChange","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","childNodes","pop","_updateNodeAfterCollapseChange","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","diff","data","index","rest","getNode","getNodeLocation","indexTreeNode","indexOf","reverse","getParentNodeLocation"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\nimport { TreeError } from './tree.js';\r\nimport { tail2 } from '../../../common/arrays.js';\r\nimport { Emitter, EventBufferer } from '../../../common/event.js';\r\nimport { Iterator } from '../../../common/iterator.js';\r\nexport function isFilterResult(obj) {\r\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\r\n}\r\nexport function getVisibleState(visibility) {\r\n    switch (visibility) {\r\n        case true: return 1 /* Visible */;\r\n        case false: return 0 /* Hidden */;\r\n        default: return visibility;\r\n    }\r\n}\r\nfunction isCollapsibleStateUpdate(update) {\r\n    return typeof update.collapsible === 'boolean';\r\n}\r\nvar IndexTreeModel = /** @class */ (function () {\r\n    function IndexTreeModel(user, list, rootElement, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.user = user;\r\n        this.list = list;\r\n        this.rootRef = [];\r\n        this.eventBufferer = new EventBufferer();\r\n        this._onDidChangeCollapseState = new Emitter();\r\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\r\n        this._onDidChangeRenderNodeCount = new Emitter();\r\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\r\n        this._onDidSplice = new Emitter();\r\n        this.onDidSplice = this._onDidSplice.event;\r\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\r\n        this.filter = options.filter;\r\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\r\n        this.root = {\r\n            parent: undefined,\r\n            element: rootElement,\r\n            children: [],\r\n            depth: 0,\r\n            visibleChildrenCount: 0,\r\n            visibleChildIndex: -1,\r\n            collapsible: false,\r\n            collapsed: false,\r\n            renderNodeCount: 0,\r\n            visible: true,\r\n            filterData: undefined\r\n        };\r\n    }\r\n    IndexTreeModel.prototype.splice = function (location, deleteCount, toInsert, onDidCreateNode, onDidDeleteNode) {\r\n        var _a;\r\n        var _this = this;\r\n        if (location.length === 0) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        var _b = this.getParentNodeWithListIndex(location), parentNode = _b.parentNode, listIndex = _b.listIndex, revealed = _b.revealed, visible = _b.visible;\r\n        var treeListElementsToInsert = [];\r\n        var nodesToInsertIterator = Iterator.map(Iterator.from(toInsert), function (el) { return _this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode); });\r\n        var lastIndex = location[location.length - 1];\r\n        // figure out what's the visible child start index right before the\r\n        // splice point\r\n        var visibleChildStartIndex = 0;\r\n        for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\r\n            var child = parentNode.children[i];\r\n            if (child.visible) {\r\n                visibleChildStartIndex = child.visibleChildIndex;\r\n                break;\r\n            }\r\n        }\r\n        var nodesToInsert = [];\r\n        var insertedVisibleChildrenCount = 0;\r\n        var renderNodeCount = 0;\r\n        Iterator.forEach(nodesToInsertIterator, function (child) {\r\n            nodesToInsert.push(child);\r\n            renderNodeCount += child.renderNodeCount;\r\n            if (child.visible) {\r\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\r\n            }\r\n        });\r\n        var deletedNodes = (_a = parentNode.children).splice.apply(_a, __spreadArrays([lastIndex, deleteCount], nodesToInsert));\r\n        // figure out what is the count of deleted visible children\r\n        var deletedVisibleChildrenCount = 0;\r\n        for (var _i = 0, deletedNodes_1 = deletedNodes; _i < deletedNodes_1.length; _i++) {\r\n            var child = deletedNodes_1[_i];\r\n            if (child.visible) {\r\n                deletedVisibleChildrenCount++;\r\n            }\r\n        }\r\n        // and adjust for all visible children after the splice point\r\n        if (deletedVisibleChildrenCount !== 0) {\r\n            for (var i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\r\n                var child = parentNode.children[i];\r\n                if (child.visible) {\r\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\r\n                }\r\n            }\r\n        }\r\n        // update parent's visible children count\r\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\r\n        if (revealed && visible) {\r\n            var visibleDeleteCount = deletedNodes.reduce(function (r, node) { return r + (node.visible ? node.renderNodeCount : 0); }, 0);\r\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\r\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\r\n        }\r\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\r\n            var visit_1 = function (node) {\r\n                onDidDeleteNode(node);\r\n                node.children.forEach(visit_1);\r\n            };\r\n            deletedNodes.forEach(visit_1);\r\n        }\r\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes: deletedNodes });\r\n    };\r\n    IndexTreeModel.prototype.rerender = function (location) {\r\n        if (location.length === 0) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        var _a = this.getTreeNodeWithListIndex(location), node = _a.node, listIndex = _a.listIndex, revealed = _a.revealed;\r\n        if (revealed) {\r\n            this.list.splice(listIndex, 1, [node]);\r\n        }\r\n    };\r\n    IndexTreeModel.prototype.has = function (location) {\r\n        return this.hasTreeNode(location);\r\n    };\r\n    IndexTreeModel.prototype.getListIndex = function (location) {\r\n        var _a = this.getTreeNodeWithListIndex(location), listIndex = _a.listIndex, visible = _a.visible, revealed = _a.revealed;\r\n        return visible && revealed ? listIndex : -1;\r\n    };\r\n    IndexTreeModel.prototype.getListRenderCount = function (location) {\r\n        return this.getTreeNode(location).renderNodeCount;\r\n    };\r\n    IndexTreeModel.prototype.isCollapsible = function (location) {\r\n        return this.getTreeNode(location).collapsible;\r\n    };\r\n    IndexTreeModel.prototype.setCollapsible = function (location, collapsible) {\r\n        var _this = this;\r\n        var node = this.getTreeNode(location);\r\n        if (typeof collapsible === 'undefined') {\r\n            collapsible = !node.collapsible;\r\n        }\r\n        var update = { collapsible: collapsible };\r\n        return this.eventBufferer.bufferEvents(function () { return _this._setCollapseState(location, update); });\r\n    };\r\n    IndexTreeModel.prototype.isCollapsed = function (location) {\r\n        return this.getTreeNode(location).collapsed;\r\n    };\r\n    IndexTreeModel.prototype.setCollapsed = function (location, collapsed, recursive) {\r\n        var _this = this;\r\n        var node = this.getTreeNode(location);\r\n        if (typeof collapsed === 'undefined') {\r\n            collapsed = !node.collapsed;\r\n        }\r\n        var update = { collapsed: collapsed, recursive: recursive || false };\r\n        return this.eventBufferer.bufferEvents(function () { return _this._setCollapseState(location, update); });\r\n    };\r\n    IndexTreeModel.prototype._setCollapseState = function (location, update) {\r\n        var _a = this.getTreeNodeWithListIndex(location), node = _a.node, listIndex = _a.listIndex, revealed = _a.revealed;\r\n        var result = this._setListNodeCollapseState(node, listIndex, revealed, update);\r\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\r\n            var onlyVisibleChildIndex = -1;\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                var child = node.children[i];\r\n                if (child.visible) {\r\n                    if (onlyVisibleChildIndex > -1) {\r\n                        onlyVisibleChildIndex = -1;\r\n                        break;\r\n                    }\r\n                    else {\r\n                        onlyVisibleChildIndex = i;\r\n                    }\r\n                }\r\n            }\r\n            if (onlyVisibleChildIndex > -1) {\r\n                this._setCollapseState(__spreadArrays(location, [onlyVisibleChildIndex]), update);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._setListNodeCollapseState = function (node, listIndex, revealed, update) {\r\n        var result = this._setNodeCollapseState(node, update, false);\r\n        if (!revealed || !node.visible || !result) {\r\n            return result;\r\n        }\r\n        var previousRenderNodeCount = node.renderNodeCount;\r\n        var toInsert = this.updateNodeAfterCollapseChange(node);\r\n        var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\r\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._setNodeCollapseState = function (node, update, deep) {\r\n        var result;\r\n        if (node === this.root) {\r\n            result = false;\r\n        }\r\n        else {\r\n            if (isCollapsibleStateUpdate(update)) {\r\n                result = node.collapsible !== update.collapsible;\r\n                node.collapsible = update.collapsible;\r\n            }\r\n            else if (!node.collapsible) {\r\n                result = false;\r\n            }\r\n            else {\r\n                result = node.collapsed !== update.collapsed;\r\n                node.collapsed = update.collapsed;\r\n            }\r\n            if (result) {\r\n                this._onDidChangeCollapseState.fire({ node: node, deep: deep });\r\n            }\r\n        }\r\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                result = this._setNodeCollapseState(child, update, true) || result;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype.expandTo = function (location) {\r\n        var _this = this;\r\n        this.eventBufferer.bufferEvents(function () {\r\n            var node = _this.getTreeNode(location);\r\n            while (node.parent) {\r\n                node = node.parent;\r\n                location = location.slice(0, location.length - 1);\r\n                if (node.collapsed) {\r\n                    _this._setCollapseState(location, { collapsed: false, recursive: false });\r\n                }\r\n            }\r\n        });\r\n    };\r\n    IndexTreeModel.prototype.refilter = function () {\r\n        var previousRenderNodeCount = this.root.renderNodeCount;\r\n        var toInsert = this.updateNodeAfterFilterChange(this.root);\r\n        this.list.splice(0, previousRenderNodeCount, toInsert);\r\n    };\r\n    IndexTreeModel.prototype.createTreeNode = function (treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\r\n        var _this = this;\r\n        var node = {\r\n            parent: parent,\r\n            element: treeElement.element,\r\n            children: [],\r\n            depth: parent.depth + 1,\r\n            visibleChildrenCount: 0,\r\n            visibleChildIndex: -1,\r\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\r\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\r\n            renderNodeCount: 1,\r\n            visible: true,\r\n            filterData: undefined\r\n        };\r\n        var visibility = this._filterNode(node, parentVisibility);\r\n        if (revealed) {\r\n            treeListElements.push(node);\r\n        }\r\n        var childElements = Iterator.from(treeElement.children);\r\n        var childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\r\n        var childNodes = Iterator.map(childElements, function (el) { return _this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode); });\r\n        var visibleChildrenCount = 0;\r\n        var renderNodeCount = 1;\r\n        Iterator.forEach(childNodes, function (child) {\r\n            node.children.push(child);\r\n            renderNodeCount += child.renderNodeCount;\r\n            if (child.visible) {\r\n                child.visibleChildIndex = visibleChildrenCount++;\r\n            }\r\n        });\r\n        node.collapsible = node.collapsible || node.children.length > 0;\r\n        node.visibleChildrenCount = visibleChildrenCount;\r\n        node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* Visible */);\r\n        if (!node.visible) {\r\n            node.renderNodeCount = 0;\r\n            if (revealed) {\r\n                treeListElements.pop();\r\n            }\r\n        }\r\n        else if (!node.collapsed) {\r\n            node.renderNodeCount = renderNodeCount;\r\n        }\r\n        if (onDidCreateNode) {\r\n            onDidCreateNode(node);\r\n        }\r\n        return node;\r\n    };\r\n    IndexTreeModel.prototype.updateNodeAfterCollapseChange = function (node) {\r\n        var previousRenderNodeCount = node.renderNodeCount;\r\n        var result = [];\r\n        this._updateNodeAfterCollapseChange(node, result);\r\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._updateNodeAfterCollapseChange = function (node, result) {\r\n        if (node.visible === false) {\r\n            return 0;\r\n        }\r\n        result.push(node);\r\n        node.renderNodeCount = 1;\r\n        if (!node.collapsed) {\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\r\n            }\r\n        }\r\n        this._onDidChangeRenderNodeCount.fire(node);\r\n        return node.renderNodeCount;\r\n    };\r\n    IndexTreeModel.prototype.updateNodeAfterFilterChange = function (node) {\r\n        var previousRenderNodeCount = node.renderNodeCount;\r\n        var result = [];\r\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\r\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\r\n        return result;\r\n    };\r\n    IndexTreeModel.prototype._updateNodeAfterFilterChange = function (node, parentVisibility, result, revealed) {\r\n        if (revealed === void 0) { revealed = true; }\r\n        var visibility;\r\n        if (node !== this.root) {\r\n            visibility = this._filterNode(node, parentVisibility);\r\n            if (visibility === 0 /* Hidden */) {\r\n                node.visible = false;\r\n                node.renderNodeCount = 0;\r\n                return false;\r\n            }\r\n            if (revealed) {\r\n                result.push(node);\r\n            }\r\n        }\r\n        var resultStartLength = result.length;\r\n        node.renderNodeCount = node === this.root ? 0 : 1;\r\n        var hasVisibleDescendants = false;\r\n        if (!node.collapsed || visibility !== 0 /* Hidden */) {\r\n            var visibleChildIndex = 0;\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var child = _a[_i];\r\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\r\n                if (child.visible) {\r\n                    child.visibleChildIndex = visibleChildIndex++;\r\n                }\r\n            }\r\n            node.visibleChildrenCount = visibleChildIndex;\r\n        }\r\n        else {\r\n            node.visibleChildrenCount = 0;\r\n        }\r\n        if (node !== this.root) {\r\n            node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : (visibility === 1 /* Visible */);\r\n        }\r\n        if (!node.visible) {\r\n            node.renderNodeCount = 0;\r\n            if (revealed) {\r\n                result.pop();\r\n            }\r\n        }\r\n        else if (!node.collapsed) {\r\n            node.renderNodeCount += result.length - resultStartLength;\r\n        }\r\n        this._onDidChangeRenderNodeCount.fire(node);\r\n        return node.visible;\r\n    };\r\n    IndexTreeModel.prototype._updateAncestorsRenderNodeCount = function (node, diff) {\r\n        if (diff === 0) {\r\n            return;\r\n        }\r\n        while (node) {\r\n            node.renderNodeCount += diff;\r\n            this._onDidChangeRenderNodeCount.fire(node);\r\n            node = node.parent;\r\n        }\r\n    };\r\n    IndexTreeModel.prototype._filterNode = function (node, parentVisibility) {\r\n        var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\r\n        if (typeof result === 'boolean') {\r\n            node.filterData = undefined;\r\n            return result ? 1 /* Visible */ : 0 /* Hidden */;\r\n        }\r\n        else if (isFilterResult(result)) {\r\n            node.filterData = result.data;\r\n            return getVisibleState(result.visibility);\r\n        }\r\n        else {\r\n            node.filterData = undefined;\r\n            return getVisibleState(result);\r\n        }\r\n    };\r\n    // cheap\r\n    IndexTreeModel.prototype.hasTreeNode = function (location, node) {\r\n        if (node === void 0) { node = this.root; }\r\n        if (!location || location.length === 0) {\r\n            return true;\r\n        }\r\n        var index = location[0], rest = location.slice(1);\r\n        if (index < 0 || index > node.children.length) {\r\n            return false;\r\n        }\r\n        return this.hasTreeNode(rest, node.children[index]);\r\n    };\r\n    // cheap\r\n    IndexTreeModel.prototype.getTreeNode = function (location, node) {\r\n        if (node === void 0) { node = this.root; }\r\n        if (!location || location.length === 0) {\r\n            return node;\r\n        }\r\n        var index = location[0], rest = location.slice(1);\r\n        if (index < 0 || index > node.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        return this.getTreeNode(rest, node.children[index]);\r\n    };\r\n    // expensive\r\n    IndexTreeModel.prototype.getTreeNodeWithListIndex = function (location) {\r\n        if (location.length === 0) {\r\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\r\n        }\r\n        var _a = this.getParentNodeWithListIndex(location), parentNode = _a.parentNode, listIndex = _a.listIndex, revealed = _a.revealed, visible = _a.visible;\r\n        var index = location[location.length - 1];\r\n        if (index < 0 || index > parentNode.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        var node = parentNode.children[index];\r\n        return { node: node, listIndex: listIndex, revealed: revealed, visible: visible && node.visible };\r\n    };\r\n    IndexTreeModel.prototype.getParentNodeWithListIndex = function (location, node, listIndex, revealed, visible) {\r\n        if (node === void 0) { node = this.root; }\r\n        if (listIndex === void 0) { listIndex = 0; }\r\n        if (revealed === void 0) { revealed = true; }\r\n        if (visible === void 0) { visible = true; }\r\n        var index = location[0], rest = location.slice(1);\r\n        if (index < 0 || index > node.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        // TODO@joao perf!\r\n        for (var i = 0; i < index; i++) {\r\n            listIndex += node.children[i].renderNodeCount;\r\n        }\r\n        revealed = revealed && !node.collapsed;\r\n        visible = visible && node.visible;\r\n        if (rest.length === 0) {\r\n            return { parentNode: node, listIndex: listIndex, revealed: revealed, visible: visible };\r\n        }\r\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\r\n    };\r\n    IndexTreeModel.prototype.getNode = function (location) {\r\n        if (location === void 0) { location = []; }\r\n        return this.getTreeNode(location);\r\n    };\r\n    // TODO@joao perf!\r\n    IndexTreeModel.prototype.getNodeLocation = function (node) {\r\n        var location = [];\r\n        var indexTreeNode = node; // typing woes\r\n        while (indexTreeNode.parent) {\r\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\r\n            indexTreeNode = indexTreeNode.parent;\r\n        }\r\n        return location.reverse();\r\n    };\r\n    IndexTreeModel.prototype.getParentNodeLocation = function (location) {\r\n        if (location.length === 0) {\r\n            return undefined;\r\n        }\r\n        else if (location.length === 1) {\r\n            return [];\r\n        }\r\n        else {\r\n            return tail2(location)[0];\r\n        }\r\n    };\r\n    return IndexTreeModel;\r\n}());\r\nexport { IndexTreeModel };\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,cAAc,GAAI,IAAI,IAAI,IAAI,CAACA,cAAc,IAAK,YAAY;EAC9D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEH,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE;IAAED,CAAC,IAAIG,SAAS,CAACF,CAAC,CAAC,CAACG,MAAM;EAAC;EACpF,KAAK,IAAIC,CAAC,GAAGC,KAAK,CAACN,CAAC,CAAC,EAAEO,CAAC,GAAG,CAAC,EAAEN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE;IAC5C,KAAK,IAAIO,CAAC,GAAGL,SAAS,CAACF,CAAC,CAAC,EAAEQ,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGF,CAAC,CAACJ,MAAM,EAAEK,CAAC,GAAGC,EAAE,EAAED,CAAC,EAAE,EAAEF,CAAC,EAAE;MAC7DF,CAAC,CAACE,CAAC,CAAC,GAAGC,CAAC,CAACC,CAAC,CAAC;IAAC;EAAA;EACpB,OAAOJ,CAAC;AACZ,CAAC;AACD,SAASM,SAAS,QAAQ,WAAW;AACrC,SAASC,KAAK,QAAQ,2BAA2B;AACjD,SAASC,OAAO,EAAEC,aAAa,QAAQ,0BAA0B;AACjE,SAASC,QAAQ,QAAQ,6BAA6B;AACtD,OAAO,SAASC,cAAc,CAACC,GAAG,EAAE;EAChC,OAAO,OAAOA,GAAG,KAAK,QAAQ,IAAI,YAAY,IAAIA,GAAG,IAAI,MAAM,IAAIA,GAAG;AAC1E;AACA,OAAO,SAASC,eAAe,CAACC,UAAU,EAAE;EACxC,QAAQA,UAAU;IACd,KAAK,IAAI;MAAE,OAAO,CAAC,CAAC;IACpB,KAAK,KAAK;MAAE,OAAO,CAAC,CAAC;IACrB;MAAS,OAAOA,UAAU;EAAC;AAEnC;AACA,SAASC,wBAAwB,CAACC,MAAM,EAAE;EACtC,OAAO,OAAOA,MAAM,CAACC,WAAW,KAAK,SAAS;AAClD;AACA,IAAIC,cAAc,GAAG,aAAe,YAAY;EAC5C,SAASA,cAAc,CAACC,IAAI,EAAEC,IAAI,EAAEC,WAAW,EAAEC,OAAO,EAAE;IACtD,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;MAAEA,OAAO,GAAG,CAAC,CAAC;IAAE;IACxC,IAAI,CAACH,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACG,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,aAAa,GAAG,IAAIf,aAAa,EAAE;IACxC,IAAI,CAACgB,yBAAyB,GAAG,IAAIjB,OAAO,EAAE;IAC9C,IAAI,CAACkB,wBAAwB,GAAG,IAAI,CAACF,aAAa,CAACG,SAAS,CAAC,IAAI,CAACF,yBAAyB,CAACG,KAAK,CAAC;IAClG,IAAI,CAACC,2BAA2B,GAAG,IAAIrB,OAAO,EAAE;IAChD,IAAI,CAACsB,0BAA0B,GAAG,IAAI,CAACN,aAAa,CAACG,SAAS,CAAC,IAAI,CAACE,2BAA2B,CAACD,KAAK,CAAC;IACtG,IAAI,CAACG,YAAY,GAAG,IAAIvB,OAAO,EAAE;IACjC,IAAI,CAACwB,WAAW,GAAG,IAAI,CAACD,YAAY,CAACH,KAAK;IAC1C,IAAI,CAACK,iBAAiB,GAAG,OAAOX,OAAO,CAACW,iBAAiB,KAAK,WAAW,GAAG,KAAK,GAAGX,OAAO,CAACW,iBAAiB;IAC7G,IAAI,CAACC,MAAM,GAAGZ,OAAO,CAACY,MAAM;IAC5B,IAAI,CAACC,wBAAwB,GAAG,OAAOb,OAAO,CAACa,wBAAwB,KAAK,WAAW,GAAG,KAAK,GAAGb,OAAO,CAACa,wBAAwB;IAClI,IAAI,CAACC,IAAI,GAAG;MACRC,MAAM,EAAEC,SAAS;MACjBC,OAAO,EAAElB,WAAW;MACpBmB,QAAQ,EAAE,EAAE;MACZC,KAAK,EAAE,CAAC;MACRC,oBAAoB,EAAE,CAAC;MACvBC,iBAAiB,EAAE,CAAC,CAAC;MACrB1B,WAAW,EAAE,KAAK;MAClB2B,SAAS,EAAE,KAAK;MAChBC,eAAe,EAAE,CAAC;MAClBC,OAAO,EAAE,IAAI;MACbC,UAAU,EAAET;IAChB,CAAC;EACL;EACApB,cAAc,CAAC8B,SAAS,CAACC,MAAM,GAAG,UAAUC,QAAQ,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,eAAe,EAAE;IAC3G,IAAIC,EAAE;IACN,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIN,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MACvB,MAAM,IAAIO,SAAS,CAAC,IAAI,CAACa,IAAI,EAAE,uBAAuB,CAAC;IAC3D;IACA,IAAIsC,EAAE,GAAG,IAAI,CAACC,0BAA0B,CAACR,QAAQ,CAAC;MAAES,UAAU,GAAGF,EAAE,CAACE,UAAU;MAAEC,SAAS,GAAGH,EAAE,CAACG,SAAS;MAAEC,QAAQ,GAAGJ,EAAE,CAACI,QAAQ;MAAEf,OAAO,GAAGW,EAAE,CAACX,OAAO;IACtJ,IAAIgB,wBAAwB,GAAG,EAAE;IACjC,IAAIC,qBAAqB,GAAGrD,QAAQ,CAACsD,GAAG,CAACtD,QAAQ,CAACuD,IAAI,CAACb,QAAQ,CAAC,EAAE,UAAUc,EAAE,EAAE;MAAE,OAAOV,KAAK,CAACW,cAAc,CAACD,EAAE,EAAEP,UAAU,EAAEA,UAAU,CAACb,OAAO,GAAG,CAAC,CAAC,gBAAgB,CAAC,CAAC,cAAce,QAAQ,EAAEC,wBAAwB,EAAET,eAAe,CAAC;IAAE,CAAC,CAAC;IAC7O,IAAIe,SAAS,GAAGlB,QAAQ,CAACA,QAAQ,CAACnD,MAAM,GAAG,CAAC,CAAC;IAC7C;IACA;IACA,IAAIsE,sBAAsB,GAAG,CAAC;IAC9B,KAAK,IAAIzE,CAAC,GAAGwE,SAAS,EAAExE,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAG+D,UAAU,CAACnB,QAAQ,CAACzC,MAAM,EAAEH,CAAC,EAAE,EAAE;MACnE,IAAI0E,KAAK,GAAGX,UAAU,CAACnB,QAAQ,CAAC5C,CAAC,CAAC;MAClC,IAAI0E,KAAK,CAACxB,OAAO,EAAE;QACfuB,sBAAsB,GAAGC,KAAK,CAAC3B,iBAAiB;QAChD;MACJ;IACJ;IACA,IAAI4B,aAAa,GAAG,EAAE;IACtB,IAAIC,4BAA4B,GAAG,CAAC;IACpC,IAAI3B,eAAe,GAAG,CAAC;IACvBnC,QAAQ,CAAC+D,OAAO,CAACV,qBAAqB,EAAE,UAAUO,KAAK,EAAE;MACrDC,aAAa,CAACG,IAAI,CAACJ,KAAK,CAAC;MACzBzB,eAAe,IAAIyB,KAAK,CAACzB,eAAe;MACxC,IAAIyB,KAAK,CAACxB,OAAO,EAAE;QACfwB,KAAK,CAAC3B,iBAAiB,GAAG0B,sBAAsB,GAAGG,4BAA4B,EAAE;MACrF;IACJ,CAAC,CAAC;IACF,IAAIG,YAAY,GAAG,CAACpB,EAAE,GAAGI,UAAU,CAACnB,QAAQ,EAAES,MAAM,CAAC2B,KAAK,CAACrB,EAAE,EAAE7D,cAAc,CAAC,CAAC0E,SAAS,EAAEjB,WAAW,CAAC,EAAEoB,aAAa,CAAC,CAAC;IACvH;IACA,IAAIM,2BAA2B,GAAG,CAAC;IACnC,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEC,cAAc,GAAGJ,YAAY,EAAEG,EAAE,GAAGC,cAAc,CAAChF,MAAM,EAAE+E,EAAE,EAAE,EAAE;MAC9E,IAAIR,KAAK,GAAGS,cAAc,CAACD,EAAE,CAAC;MAC9B,IAAIR,KAAK,CAACxB,OAAO,EAAE;QACf+B,2BAA2B,EAAE;MACjC;IACJ;IACA;IACA,IAAIA,2BAA2B,KAAK,CAAC,EAAE;MACnC,KAAK,IAAIjF,CAAC,GAAGwE,SAAS,GAAGG,aAAa,CAACxE,MAAM,EAAEH,CAAC,GAAG+D,UAAU,CAACnB,QAAQ,CAACzC,MAAM,EAAEH,CAAC,EAAE,EAAE;QAChF,IAAI0E,KAAK,GAAGX,UAAU,CAACnB,QAAQ,CAAC5C,CAAC,CAAC;QAClC,IAAI0E,KAAK,CAACxB,OAAO,EAAE;UACfwB,KAAK,CAAC3B,iBAAiB,IAAIkC,2BAA2B;QAC1D;MACJ;IACJ;IACA;IACAlB,UAAU,CAACjB,oBAAoB,IAAI8B,4BAA4B,GAAGK,2BAA2B;IAC7F,IAAIhB,QAAQ,IAAIf,OAAO,EAAE;MACrB,IAAIkC,kBAAkB,GAAGL,YAAY,CAACM,MAAM,CAAC,UAAUjF,CAAC,EAAEkF,IAAI,EAAE;QAAE,OAAOlF,CAAC,IAAIkF,IAAI,CAACpC,OAAO,GAAGoC,IAAI,CAACrC,eAAe,GAAG,CAAC,CAAC;MAAE,CAAC,EAAE,CAAC,CAAC;MAC7H,IAAI,CAACsC,+BAA+B,CAACxB,UAAU,EAAEd,eAAe,GAAGmC,kBAAkB,CAAC;MACtF,IAAI,CAAC5D,IAAI,CAAC6B,MAAM,CAACW,SAAS,EAAEoB,kBAAkB,EAAElB,wBAAwB,CAAC;IAC7E;IACA,IAAIa,YAAY,CAAC5E,MAAM,GAAG,CAAC,IAAIuD,eAAe,EAAE;MAC5C,IAAI8B,OAAO,GAAG,SAAVA,OAAO,CAAaF,IAAI,EAAE;QAC1B5B,eAAe,CAAC4B,IAAI,CAAC;QACrBA,IAAI,CAAC1C,QAAQ,CAACiC,OAAO,CAACW,OAAO,CAAC;MAClC,CAAC;MACDT,YAAY,CAACF,OAAO,CAACW,OAAO,CAAC;IACjC;IACA,IAAI,CAACrD,YAAY,CAACsD,IAAI,CAAC;MAAEC,aAAa,EAAEf,aAAa;MAAEI,YAAY,EAAEA;IAAa,CAAC,CAAC;EACxF,CAAC;EACDzD,cAAc,CAAC8B,SAAS,CAACuC,QAAQ,GAAG,UAAUrC,QAAQ,EAAE;IACpD,IAAIA,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MACvB,MAAM,IAAIO,SAAS,CAAC,IAAI,CAACa,IAAI,EAAE,uBAAuB,CAAC;IAC3D;IACA,IAAIoC,EAAE,GAAG,IAAI,CAACiC,wBAAwB,CAACtC,QAAQ,CAAC;MAAEgC,IAAI,GAAG3B,EAAE,CAAC2B,IAAI;MAAEtB,SAAS,GAAGL,EAAE,CAACK,SAAS;MAAEC,QAAQ,GAAGN,EAAE,CAACM,QAAQ;IAClH,IAAIA,QAAQ,EAAE;MACV,IAAI,CAACzC,IAAI,CAAC6B,MAAM,CAACW,SAAS,EAAE,CAAC,EAAE,CAACsB,IAAI,CAAC,CAAC;IAC1C;EACJ,CAAC;EACDhE,cAAc,CAAC8B,SAAS,CAACyC,GAAG,GAAG,UAAUvC,QAAQ,EAAE;IAC/C,OAAO,IAAI,CAACwC,WAAW,CAACxC,QAAQ,CAAC;EACrC,CAAC;EACDhC,cAAc,CAAC8B,SAAS,CAAC2C,YAAY,GAAG,UAAUzC,QAAQ,EAAE;IACxD,IAAIK,EAAE,GAAG,IAAI,CAACiC,wBAAwB,CAACtC,QAAQ,CAAC;MAAEU,SAAS,GAAGL,EAAE,CAACK,SAAS;MAAEd,OAAO,GAAGS,EAAE,CAACT,OAAO;MAAEe,QAAQ,GAAGN,EAAE,CAACM,QAAQ;IACxH,OAAOf,OAAO,IAAIe,QAAQ,GAAGD,SAAS,GAAG,CAAC,CAAC;EAC/C,CAAC;EACD1C,cAAc,CAAC8B,SAAS,CAAC4C,kBAAkB,GAAG,UAAU1C,QAAQ,EAAE;IAC9D,OAAO,IAAI,CAAC2C,WAAW,CAAC3C,QAAQ,CAAC,CAACL,eAAe;EACrD,CAAC;EACD3B,cAAc,CAAC8B,SAAS,CAAC8C,aAAa,GAAG,UAAU5C,QAAQ,EAAE;IACzD,OAAO,IAAI,CAAC2C,WAAW,CAAC3C,QAAQ,CAAC,CAACjC,WAAW;EACjD,CAAC;EACDC,cAAc,CAAC8B,SAAS,CAAC+C,cAAc,GAAG,UAAU7C,QAAQ,EAAEjC,WAAW,EAAE;IACvE,IAAIuC,KAAK,GAAG,IAAI;IAChB,IAAI0B,IAAI,GAAG,IAAI,CAACW,WAAW,CAAC3C,QAAQ,CAAC;IACrC,IAAI,OAAOjC,WAAW,KAAK,WAAW,EAAE;MACpCA,WAAW,GAAG,CAACiE,IAAI,CAACjE,WAAW;IACnC;IACA,IAAID,MAAM,GAAG;MAAEC,WAAW,EAAEA;IAAY,CAAC;IACzC,OAAO,IAAI,CAACO,aAAa,CAACwE,YAAY,CAAC,YAAY;MAAE,OAAOxC,KAAK,CAACyC,iBAAiB,CAAC/C,QAAQ,EAAElC,MAAM,CAAC;IAAE,CAAC,CAAC;EAC7G,CAAC;EACDE,cAAc,CAAC8B,SAAS,CAACkD,WAAW,GAAG,UAAUhD,QAAQ,EAAE;IACvD,OAAO,IAAI,CAAC2C,WAAW,CAAC3C,QAAQ,CAAC,CAACN,SAAS;EAC/C,CAAC;EACD1B,cAAc,CAAC8B,SAAS,CAACmD,YAAY,GAAG,UAAUjD,QAAQ,EAAEN,SAAS,EAAEwD,SAAS,EAAE;IAC9E,IAAI5C,KAAK,GAAG,IAAI;IAChB,IAAI0B,IAAI,GAAG,IAAI,CAACW,WAAW,CAAC3C,QAAQ,CAAC;IACrC,IAAI,OAAON,SAAS,KAAK,WAAW,EAAE;MAClCA,SAAS,GAAG,CAACsC,IAAI,CAACtC,SAAS;IAC/B;IACA,IAAI5B,MAAM,GAAG;MAAE4B,SAAS,EAAEA,SAAS;MAAEwD,SAAS,EAAEA,SAAS,IAAI;IAAM,CAAC;IACpE,OAAO,IAAI,CAAC5E,aAAa,CAACwE,YAAY,CAAC,YAAY;MAAE,OAAOxC,KAAK,CAACyC,iBAAiB,CAAC/C,QAAQ,EAAElC,MAAM,CAAC;IAAE,CAAC,CAAC;EAC7G,CAAC;EACDE,cAAc,CAAC8B,SAAS,CAACiD,iBAAiB,GAAG,UAAU/C,QAAQ,EAAElC,MAAM,EAAE;IACrE,IAAIuC,EAAE,GAAG,IAAI,CAACiC,wBAAwB,CAACtC,QAAQ,CAAC;MAAEgC,IAAI,GAAG3B,EAAE,CAAC2B,IAAI;MAAEtB,SAAS,GAAGL,EAAE,CAACK,SAAS;MAAEC,QAAQ,GAAGN,EAAE,CAACM,QAAQ;IAClH,IAAIwC,MAAM,GAAG,IAAI,CAACC,yBAAyB,CAACpB,IAAI,EAAEtB,SAAS,EAAEC,QAAQ,EAAE7C,MAAM,CAAC;IAC9E,IAAIkE,IAAI,KAAK,IAAI,CAAC9C,IAAI,IAAI,IAAI,CAACD,wBAAwB,IAAIkE,MAAM,IAAI,CAACtF,wBAAwB,CAACC,MAAM,CAAC,IAAIkE,IAAI,CAACjE,WAAW,IAAI,CAACiE,IAAI,CAACtC,SAAS,IAAI,CAAC5B,MAAM,CAACoF,SAAS,EAAE;MAChK,IAAIG,qBAAqB,GAAG,CAAC,CAAC;MAC9B,KAAK,IAAI3G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsF,IAAI,CAAC1C,QAAQ,CAACzC,MAAM,EAAEH,CAAC,EAAE,EAAE;QAC3C,IAAI0E,KAAK,GAAGY,IAAI,CAAC1C,QAAQ,CAAC5C,CAAC,CAAC;QAC5B,IAAI0E,KAAK,CAACxB,OAAO,EAAE;UACf,IAAIyD,qBAAqB,GAAG,CAAC,CAAC,EAAE;YAC5BA,qBAAqB,GAAG,CAAC,CAAC;YAC1B;UACJ,CAAC,MACI;YACDA,qBAAqB,GAAG3G,CAAC;UAC7B;QACJ;MACJ;MACA,IAAI2G,qBAAqB,GAAG,CAAC,CAAC,EAAE;QAC5B,IAAI,CAACN,iBAAiB,CAACvG,cAAc,CAACwD,QAAQ,EAAE,CAACqD,qBAAqB,CAAC,CAAC,EAAEvF,MAAM,CAAC;MACrF;IACJ;IACA,OAAOqF,MAAM;EACjB,CAAC;EACDnF,cAAc,CAAC8B,SAAS,CAACsD,yBAAyB,GAAG,UAAUpB,IAAI,EAAEtB,SAAS,EAAEC,QAAQ,EAAE7C,MAAM,EAAE;IAC9F,IAAIqF,MAAM,GAAG,IAAI,CAACG,qBAAqB,CAACtB,IAAI,EAAElE,MAAM,EAAE,KAAK,CAAC;IAC5D,IAAI,CAAC6C,QAAQ,IAAI,CAACqB,IAAI,CAACpC,OAAO,IAAI,CAACuD,MAAM,EAAE;MACvC,OAAOA,MAAM;IACjB;IACA,IAAII,uBAAuB,GAAGvB,IAAI,CAACrC,eAAe;IAClD,IAAIO,QAAQ,GAAG,IAAI,CAACsD,6BAA6B,CAACxB,IAAI,CAAC;IACvD,IAAI/B,WAAW,GAAGsD,uBAAuB,IAAI7C,SAAS,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACtE,IAAI,CAACxC,IAAI,CAAC6B,MAAM,CAACW,SAAS,GAAG,CAAC,EAAET,WAAW,EAAEC,QAAQ,CAACuD,KAAK,CAAC,CAAC,CAAC,CAAC;IAC/D,OAAON,MAAM;EACjB,CAAC;EACDnF,cAAc,CAAC8B,SAAS,CAACwD,qBAAqB,GAAG,UAAUtB,IAAI,EAAElE,MAAM,EAAE4F,IAAI,EAAE;IAC3E,IAAIP,MAAM;IACV,IAAInB,IAAI,KAAK,IAAI,CAAC9C,IAAI,EAAE;MACpBiE,MAAM,GAAG,KAAK;IAClB,CAAC,MACI;MACD,IAAItF,wBAAwB,CAACC,MAAM,CAAC,EAAE;QAClCqF,MAAM,GAAGnB,IAAI,CAACjE,WAAW,KAAKD,MAAM,CAACC,WAAW;QAChDiE,IAAI,CAACjE,WAAW,GAAGD,MAAM,CAACC,WAAW;MACzC,CAAC,MACI,IAAI,CAACiE,IAAI,CAACjE,WAAW,EAAE;QACxBoF,MAAM,GAAG,KAAK;MAClB,CAAC,MACI;QACDA,MAAM,GAAGnB,IAAI,CAACtC,SAAS,KAAK5B,MAAM,CAAC4B,SAAS;QAC5CsC,IAAI,CAACtC,SAAS,GAAG5B,MAAM,CAAC4B,SAAS;MACrC;MACA,IAAIyD,MAAM,EAAE;QACR,IAAI,CAAC5E,yBAAyB,CAAC4D,IAAI,CAAC;UAAEH,IAAI,EAAEA,IAAI;UAAE0B,IAAI,EAAEA;QAAK,CAAC,CAAC;MACnE;IACJ;IACA,IAAI,CAAC7F,wBAAwB,CAACC,MAAM,CAAC,IAAIA,MAAM,CAACoF,SAAS,EAAE;MACvD,KAAK,IAAItB,EAAE,GAAG,CAAC,EAAEvB,EAAE,GAAG2B,IAAI,CAAC1C,QAAQ,EAAEsC,EAAE,GAAGvB,EAAE,CAACxD,MAAM,EAAE+E,EAAE,EAAE,EAAE;QACvD,IAAIR,KAAK,GAAGf,EAAE,CAACuB,EAAE,CAAC;QAClBuB,MAAM,GAAG,IAAI,CAACG,qBAAqB,CAAClC,KAAK,EAAEtD,MAAM,EAAE,IAAI,CAAC,IAAIqF,MAAM;MACtE;IACJ;IACA,OAAOA,MAAM;EACjB,CAAC;EACDnF,cAAc,CAAC8B,SAAS,CAAC6D,QAAQ,GAAG,UAAU3D,QAAQ,EAAE;IACpD,IAAIM,KAAK,GAAG,IAAI;IAChB,IAAI,CAAChC,aAAa,CAACwE,YAAY,CAAC,YAAY;MACxC,IAAId,IAAI,GAAG1B,KAAK,CAACqC,WAAW,CAAC3C,QAAQ,CAAC;MACtC,OAAOgC,IAAI,CAAC7C,MAAM,EAAE;QAChB6C,IAAI,GAAGA,IAAI,CAAC7C,MAAM;QAClBa,QAAQ,GAAGA,QAAQ,CAACyD,KAAK,CAAC,CAAC,EAAEzD,QAAQ,CAACnD,MAAM,GAAG,CAAC,CAAC;QACjD,IAAImF,IAAI,CAACtC,SAAS,EAAE;UAChBY,KAAK,CAACyC,iBAAiB,CAAC/C,QAAQ,EAAE;YAAEN,SAAS,EAAE,KAAK;YAAEwD,SAAS,EAAE;UAAM,CAAC,CAAC;QAC7E;MACJ;IACJ,CAAC,CAAC;EACN,CAAC;EACDlF,cAAc,CAAC8B,SAAS,CAAC8D,QAAQ,GAAG,YAAY;IAC5C,IAAIL,uBAAuB,GAAG,IAAI,CAACrE,IAAI,CAACS,eAAe;IACvD,IAAIO,QAAQ,GAAG,IAAI,CAAC2D,2BAA2B,CAAC,IAAI,CAAC3E,IAAI,CAAC;IAC1D,IAAI,CAAChB,IAAI,CAAC6B,MAAM,CAAC,CAAC,EAAEwD,uBAAuB,EAAErD,QAAQ,CAAC;EAC1D,CAAC;EACDlC,cAAc,CAAC8B,SAAS,CAACmB,cAAc,GAAG,UAAU6C,WAAW,EAAE3E,MAAM,EAAE4E,gBAAgB,EAAEpD,QAAQ,EAAEqD,gBAAgB,EAAE7D,eAAe,EAAE;IACpI,IAAIG,KAAK,GAAG,IAAI;IAChB,IAAI0B,IAAI,GAAG;MACP7C,MAAM,EAAEA,MAAM;MACdE,OAAO,EAAEyE,WAAW,CAACzE,OAAO;MAC5BC,QAAQ,EAAE,EAAE;MACZC,KAAK,EAAEJ,MAAM,CAACI,KAAK,GAAG,CAAC;MACvBC,oBAAoB,EAAE,CAAC;MACvBC,iBAAiB,EAAE,CAAC,CAAC;MACrB1B,WAAW,EAAE,OAAO+F,WAAW,CAAC/F,WAAW,KAAK,SAAS,GAAG+F,WAAW,CAAC/F,WAAW,GAAI,OAAO+F,WAAW,CAACpE,SAAS,KAAK,WAAY;MACpIA,SAAS,EAAE,OAAOoE,WAAW,CAACpE,SAAS,KAAK,WAAW,GAAG,IAAI,CAACX,iBAAiB,GAAG+E,WAAW,CAACpE,SAAS;MACxGC,eAAe,EAAE,CAAC;MAClBC,OAAO,EAAE,IAAI;MACbC,UAAU,EAAET;IAChB,CAAC;IACD,IAAIxB,UAAU,GAAG,IAAI,CAACqG,WAAW,CAACjC,IAAI,EAAE+B,gBAAgB,CAAC;IACzD,IAAIpD,QAAQ,EAAE;MACVqD,gBAAgB,CAACxC,IAAI,CAACQ,IAAI,CAAC;IAC/B;IACA,IAAIkC,aAAa,GAAG1G,QAAQ,CAACuD,IAAI,CAAC+C,WAAW,CAACxE,QAAQ,CAAC;IACvD,IAAI6E,aAAa,GAAGxD,QAAQ,IAAI/C,UAAU,KAAK,CAAC,CAAC,gBAAgB,CAACoE,IAAI,CAACtC,SAAS;IAChF,IAAI0E,UAAU,GAAG5G,QAAQ,CAACsD,GAAG,CAACoD,aAAa,EAAE,UAAUlD,EAAE,EAAE;MAAE,OAAOV,KAAK,CAACW,cAAc,CAACD,EAAE,EAAEgB,IAAI,EAAEpE,UAAU,EAAEuG,aAAa,EAAEH,gBAAgB,EAAE7D,eAAe,CAAC;IAAE,CAAC,CAAC;IACpK,IAAIX,oBAAoB,GAAG,CAAC;IAC5B,IAAIG,eAAe,GAAG,CAAC;IACvBnC,QAAQ,CAAC+D,OAAO,CAAC6C,UAAU,EAAE,UAAUhD,KAAK,EAAE;MAC1CY,IAAI,CAAC1C,QAAQ,CAACkC,IAAI,CAACJ,KAAK,CAAC;MACzBzB,eAAe,IAAIyB,KAAK,CAACzB,eAAe;MACxC,IAAIyB,KAAK,CAACxB,OAAO,EAAE;QACfwB,KAAK,CAAC3B,iBAAiB,GAAGD,oBAAoB,EAAE;MACpD;IACJ,CAAC,CAAC;IACFwC,IAAI,CAACjE,WAAW,GAAGiE,IAAI,CAACjE,WAAW,IAAIiE,IAAI,CAAC1C,QAAQ,CAACzC,MAAM,GAAG,CAAC;IAC/DmF,IAAI,CAACxC,oBAAoB,GAAGA,oBAAoB;IAChDwC,IAAI,CAACpC,OAAO,GAAGhC,UAAU,KAAK,CAAC,CAAC,gBAAgB4B,oBAAoB,GAAG,CAAC,GAAI5B,UAAU,KAAK,CAAC,CAAC,aAAc;IAC3G,IAAI,CAACoE,IAAI,CAACpC,OAAO,EAAE;MACfoC,IAAI,CAACrC,eAAe,GAAG,CAAC;MACxB,IAAIgB,QAAQ,EAAE;QACVqD,gBAAgB,CAACK,GAAG,EAAE;MAC1B;IACJ,CAAC,MACI,IAAI,CAACrC,IAAI,CAACtC,SAAS,EAAE;MACtBsC,IAAI,CAACrC,eAAe,GAAGA,eAAe;IAC1C;IACA,IAAIQ,eAAe,EAAE;MACjBA,eAAe,CAAC6B,IAAI,CAAC;IACzB;IACA,OAAOA,IAAI;EACf,CAAC;EACDhE,cAAc,CAAC8B,SAAS,CAAC0D,6BAA6B,GAAG,UAAUxB,IAAI,EAAE;IACrE,IAAIuB,uBAAuB,GAAGvB,IAAI,CAACrC,eAAe;IAClD,IAAIwD,MAAM,GAAG,EAAE;IACf,IAAI,CAACmB,8BAA8B,CAACtC,IAAI,EAAEmB,MAAM,CAAC;IACjD,IAAI,CAAClB,+BAA+B,CAACD,IAAI,CAAC7C,MAAM,EAAEgE,MAAM,CAACtG,MAAM,GAAG0G,uBAAuB,CAAC;IAC1F,OAAOJ,MAAM;EACjB,CAAC;EACDnF,cAAc,CAAC8B,SAAS,CAACwE,8BAA8B,GAAG,UAAUtC,IAAI,EAAEmB,MAAM,EAAE;IAC9E,IAAInB,IAAI,CAACpC,OAAO,KAAK,KAAK,EAAE;MACxB,OAAO,CAAC;IACZ;IACAuD,MAAM,CAAC3B,IAAI,CAACQ,IAAI,CAAC;IACjBA,IAAI,CAACrC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACqC,IAAI,CAACtC,SAAS,EAAE;MACjB,KAAK,IAAIkC,EAAE,GAAG,CAAC,EAAEvB,EAAE,GAAG2B,IAAI,CAAC1C,QAAQ,EAAEsC,EAAE,GAAGvB,EAAE,CAACxD,MAAM,EAAE+E,EAAE,EAAE,EAAE;QACvD,IAAIR,KAAK,GAAGf,EAAE,CAACuB,EAAE,CAAC;QAClBI,IAAI,CAACrC,eAAe,IAAI,IAAI,CAAC2E,8BAA8B,CAAClD,KAAK,EAAE+B,MAAM,CAAC;MAC9E;IACJ;IACA,IAAI,CAACxE,2BAA2B,CAACwD,IAAI,CAACH,IAAI,CAAC;IAC3C,OAAOA,IAAI,CAACrC,eAAe;EAC/B,CAAC;EACD3B,cAAc,CAAC8B,SAAS,CAAC+D,2BAA2B,GAAG,UAAU7B,IAAI,EAAE;IACnE,IAAIuB,uBAAuB,GAAGvB,IAAI,CAACrC,eAAe;IAClD,IAAIwD,MAAM,GAAG,EAAE;IACf,IAAI,CAACoB,4BAA4B,CAACvC,IAAI,EAAEA,IAAI,CAACpC,OAAO,GAAG,CAAC,CAAC,gBAAgB,CAAC,CAAC,cAAcuD,MAAM,CAAC;IAChG,IAAI,CAAClB,+BAA+B,CAACD,IAAI,CAAC7C,MAAM,EAAEgE,MAAM,CAACtG,MAAM,GAAG0G,uBAAuB,CAAC;IAC1F,OAAOJ,MAAM;EACjB,CAAC;EACDnF,cAAc,CAAC8B,SAAS,CAACyE,4BAA4B,GAAG,UAAUvC,IAAI,EAAE+B,gBAAgB,EAAEZ,MAAM,EAAExC,QAAQ,EAAE;IACxG,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,IAAI;IAAE;IAC5C,IAAI/C,UAAU;IACd,IAAIoE,IAAI,KAAK,IAAI,CAAC9C,IAAI,EAAE;MACpBtB,UAAU,GAAG,IAAI,CAACqG,WAAW,CAACjC,IAAI,EAAE+B,gBAAgB,CAAC;MACrD,IAAInG,UAAU,KAAK,CAAC,CAAC,cAAc;QAC/BoE,IAAI,CAACpC,OAAO,GAAG,KAAK;QACpBoC,IAAI,CAACrC,eAAe,GAAG,CAAC;QACxB,OAAO,KAAK;MAChB;MACA,IAAIgB,QAAQ,EAAE;QACVwC,MAAM,CAAC3B,IAAI,CAACQ,IAAI,CAAC;MACrB;IACJ;IACA,IAAIwC,iBAAiB,GAAGrB,MAAM,CAACtG,MAAM;IACrCmF,IAAI,CAACrC,eAAe,GAAGqC,IAAI,KAAK,IAAI,CAAC9C,IAAI,GAAG,CAAC,GAAG,CAAC;IACjD,IAAIuF,qBAAqB,GAAG,KAAK;IACjC,IAAI,CAACzC,IAAI,CAACtC,SAAS,IAAI9B,UAAU,KAAK,CAAC,CAAC,cAAc;MAClD,IAAI6B,iBAAiB,GAAG,CAAC;MACzB,KAAK,IAAImC,EAAE,GAAG,CAAC,EAAEvB,EAAE,GAAG2B,IAAI,CAAC1C,QAAQ,EAAEsC,EAAE,GAAGvB,EAAE,CAACxD,MAAM,EAAE+E,EAAE,EAAE,EAAE;QACvD,IAAIR,KAAK,GAAGf,EAAE,CAACuB,EAAE,CAAC;QAClB6C,qBAAqB,GAAG,IAAI,CAACF,4BAA4B,CAACnD,KAAK,EAAExD,UAAU,EAAEuF,MAAM,EAAExC,QAAQ,IAAI,CAACqB,IAAI,CAACtC,SAAS,CAAC,IAAI+E,qBAAqB;QAC1I,IAAIrD,KAAK,CAACxB,OAAO,EAAE;UACfwB,KAAK,CAAC3B,iBAAiB,GAAGA,iBAAiB,EAAE;QACjD;MACJ;MACAuC,IAAI,CAACxC,oBAAoB,GAAGC,iBAAiB;IACjD,CAAC,MACI;MACDuC,IAAI,CAACxC,oBAAoB,GAAG,CAAC;IACjC;IACA,IAAIwC,IAAI,KAAK,IAAI,CAAC9C,IAAI,EAAE;MACpB8C,IAAI,CAACpC,OAAO,GAAGhC,UAAU,KAAK,CAAC,CAAC,gBAAgB6G,qBAAqB,GAAI7G,UAAU,KAAK,CAAC,CAAC,aAAc;IAC5G;;IACA,IAAI,CAACoE,IAAI,CAACpC,OAAO,EAAE;MACfoC,IAAI,CAACrC,eAAe,GAAG,CAAC;MACxB,IAAIgB,QAAQ,EAAE;QACVwC,MAAM,CAACkB,GAAG,EAAE;MAChB;IACJ,CAAC,MACI,IAAI,CAACrC,IAAI,CAACtC,SAAS,EAAE;MACtBsC,IAAI,CAACrC,eAAe,IAAIwD,MAAM,CAACtG,MAAM,GAAG2H,iBAAiB;IAC7D;IACA,IAAI,CAAC7F,2BAA2B,CAACwD,IAAI,CAACH,IAAI,CAAC;IAC3C,OAAOA,IAAI,CAACpC,OAAO;EACvB,CAAC;EACD5B,cAAc,CAAC8B,SAAS,CAACmC,+BAA+B,GAAG,UAAUD,IAAI,EAAE0C,IAAI,EAAE;IAC7E,IAAIA,IAAI,KAAK,CAAC,EAAE;MACZ;IACJ;IACA,OAAO1C,IAAI,EAAE;MACTA,IAAI,CAACrC,eAAe,IAAI+E,IAAI;MAC5B,IAAI,CAAC/F,2BAA2B,CAACwD,IAAI,CAACH,IAAI,CAAC;MAC3CA,IAAI,GAAGA,IAAI,CAAC7C,MAAM;IACtB;EACJ,CAAC;EACDnB,cAAc,CAAC8B,SAAS,CAACmE,WAAW,GAAG,UAAUjC,IAAI,EAAE+B,gBAAgB,EAAE;IACrE,IAAIZ,MAAM,GAAG,IAAI,CAACnE,MAAM,GAAG,IAAI,CAACA,MAAM,CAACA,MAAM,CAACgD,IAAI,CAAC3C,OAAO,EAAE0E,gBAAgB,CAAC,GAAG,CAAC,CAAC;IAClF,IAAI,OAAOZ,MAAM,KAAK,SAAS,EAAE;MAC7BnB,IAAI,CAACnC,UAAU,GAAGT,SAAS;MAC3B,OAAO+D,MAAM,GAAG,CAAC,CAAC,gBAAgB,CAAC,CAAC;IACxC,CAAC,MACI,IAAI1F,cAAc,CAAC0F,MAAM,CAAC,EAAE;MAC7BnB,IAAI,CAACnC,UAAU,GAAGsD,MAAM,CAACwB,IAAI;MAC7B,OAAOhH,eAAe,CAACwF,MAAM,CAACvF,UAAU,CAAC;IAC7C,CAAC,MACI;MACDoE,IAAI,CAACnC,UAAU,GAAGT,SAAS;MAC3B,OAAOzB,eAAe,CAACwF,MAAM,CAAC;IAClC;EACJ,CAAC;EACD;EACAnF,cAAc,CAAC8B,SAAS,CAAC0C,WAAW,GAAG,UAAUxC,QAAQ,EAAEgC,IAAI,EAAE;IAC7D,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;MAAEA,IAAI,GAAG,IAAI,CAAC9C,IAAI;IAAE;IACzC,IAAI,CAACc,QAAQ,IAAIA,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MACpC,OAAO,IAAI;IACf;IACA,IAAI+H,KAAK,GAAG5E,QAAQ,CAAC,CAAC,CAAC;MAAE6E,IAAI,GAAG7E,QAAQ,CAACyD,KAAK,CAAC,CAAC,CAAC;IACjD,IAAImB,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG5C,IAAI,CAAC1C,QAAQ,CAACzC,MAAM,EAAE;MAC3C,OAAO,KAAK;IAChB;IACA,OAAO,IAAI,CAAC2F,WAAW,CAACqC,IAAI,EAAE7C,IAAI,CAAC1C,QAAQ,CAACsF,KAAK,CAAC,CAAC;EACvD,CAAC;EACD;EACA5G,cAAc,CAAC8B,SAAS,CAAC6C,WAAW,GAAG,UAAU3C,QAAQ,EAAEgC,IAAI,EAAE;IAC7D,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;MAAEA,IAAI,GAAG,IAAI,CAAC9C,IAAI;IAAE;IACzC,IAAI,CAACc,QAAQ,IAAIA,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MACpC,OAAOmF,IAAI;IACf;IACA,IAAI4C,KAAK,GAAG5E,QAAQ,CAAC,CAAC,CAAC;MAAE6E,IAAI,GAAG7E,QAAQ,CAACyD,KAAK,CAAC,CAAC,CAAC;IACjD,IAAImB,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG5C,IAAI,CAAC1C,QAAQ,CAACzC,MAAM,EAAE;MAC3C,MAAM,IAAIO,SAAS,CAAC,IAAI,CAACa,IAAI,EAAE,uBAAuB,CAAC;IAC3D;IACA,OAAO,IAAI,CAAC0E,WAAW,CAACkC,IAAI,EAAE7C,IAAI,CAAC1C,QAAQ,CAACsF,KAAK,CAAC,CAAC;EACvD,CAAC;EACD;EACA5G,cAAc,CAAC8B,SAAS,CAACwC,wBAAwB,GAAG,UAAUtC,QAAQ,EAAE;IACpE,IAAIA,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MACvB,OAAO;QAAEmF,IAAI,EAAE,IAAI,CAAC9C,IAAI;QAAEwB,SAAS,EAAE,CAAC,CAAC;QAAEC,QAAQ,EAAE,IAAI;QAAEf,OAAO,EAAE;MAAM,CAAC;IAC7E;IACA,IAAIS,EAAE,GAAG,IAAI,CAACG,0BAA0B,CAACR,QAAQ,CAAC;MAAES,UAAU,GAAGJ,EAAE,CAACI,UAAU;MAAEC,SAAS,GAAGL,EAAE,CAACK,SAAS;MAAEC,QAAQ,GAAGN,EAAE,CAACM,QAAQ;MAAEf,OAAO,GAAGS,EAAE,CAACT,OAAO;IACtJ,IAAIgF,KAAK,GAAG5E,QAAQ,CAACA,QAAQ,CAACnD,MAAM,GAAG,CAAC,CAAC;IACzC,IAAI+H,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAGnE,UAAU,CAACnB,QAAQ,CAACzC,MAAM,EAAE;MACjD,MAAM,IAAIO,SAAS,CAAC,IAAI,CAACa,IAAI,EAAE,uBAAuB,CAAC;IAC3D;IACA,IAAI+D,IAAI,GAAGvB,UAAU,CAACnB,QAAQ,CAACsF,KAAK,CAAC;IACrC,OAAO;MAAE5C,IAAI,EAAEA,IAAI;MAAEtB,SAAS,EAAEA,SAAS;MAAEC,QAAQ,EAAEA,QAAQ;MAAEf,OAAO,EAAEA,OAAO,IAAIoC,IAAI,CAACpC;IAAQ,CAAC;EACrG,CAAC;EACD5B,cAAc,CAAC8B,SAAS,CAACU,0BAA0B,GAAG,UAAUR,QAAQ,EAAEgC,IAAI,EAAEtB,SAAS,EAAEC,QAAQ,EAAEf,OAAO,EAAE;IAC1G,IAAIoC,IAAI,KAAK,KAAK,CAAC,EAAE;MAAEA,IAAI,GAAG,IAAI,CAAC9C,IAAI;IAAE;IACzC,IAAIwB,SAAS,KAAK,KAAK,CAAC,EAAE;MAAEA,SAAS,GAAG,CAAC;IAAE;IAC3C,IAAIC,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,IAAI;IAAE;IAC5C,IAAIf,OAAO,KAAK,KAAK,CAAC,EAAE;MAAEA,OAAO,GAAG,IAAI;IAAE;IAC1C,IAAIgF,KAAK,GAAG5E,QAAQ,CAAC,CAAC,CAAC;MAAE6E,IAAI,GAAG7E,QAAQ,CAACyD,KAAK,CAAC,CAAC,CAAC;IACjD,IAAImB,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAG5C,IAAI,CAAC1C,QAAQ,CAACzC,MAAM,EAAE;MAC3C,MAAM,IAAIO,SAAS,CAAC,IAAI,CAACa,IAAI,EAAE,uBAAuB,CAAC;IAC3D;IACA;IACA,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkI,KAAK,EAAElI,CAAC,EAAE,EAAE;MAC5BgE,SAAS,IAAIsB,IAAI,CAAC1C,QAAQ,CAAC5C,CAAC,CAAC,CAACiD,eAAe;IACjD;IACAgB,QAAQ,GAAGA,QAAQ,IAAI,CAACqB,IAAI,CAACtC,SAAS;IACtCE,OAAO,GAAGA,OAAO,IAAIoC,IAAI,CAACpC,OAAO;IACjC,IAAIiF,IAAI,CAAChI,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO;QAAE4D,UAAU,EAAEuB,IAAI;QAAEtB,SAAS,EAAEA,SAAS;QAAEC,QAAQ,EAAEA,QAAQ;QAAEf,OAAO,EAAEA;MAAQ,CAAC;IAC3F;IACA,OAAO,IAAI,CAACY,0BAA0B,CAACqE,IAAI,EAAE7C,IAAI,CAAC1C,QAAQ,CAACsF,KAAK,CAAC,EAAElE,SAAS,GAAG,CAAC,EAAEC,QAAQ,EAAEf,OAAO,CAAC;EACxG,CAAC;EACD5B,cAAc,CAAC8B,SAAS,CAACgF,OAAO,GAAG,UAAU9E,QAAQ,EAAE;IACnD,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;MAAEA,QAAQ,GAAG,EAAE;IAAE;IAC1C,OAAO,IAAI,CAAC2C,WAAW,CAAC3C,QAAQ,CAAC;EACrC,CAAC;EACD;EACAhC,cAAc,CAAC8B,SAAS,CAACiF,eAAe,GAAG,UAAU/C,IAAI,EAAE;IACvD,IAAIhC,QAAQ,GAAG,EAAE;IACjB,IAAIgF,aAAa,GAAGhD,IAAI,CAAC,CAAC;IAC1B,OAAOgD,aAAa,CAAC7F,MAAM,EAAE;MACzBa,QAAQ,CAACwB,IAAI,CAACwD,aAAa,CAAC7F,MAAM,CAACG,QAAQ,CAAC2F,OAAO,CAACD,aAAa,CAAC,CAAC;MACnEA,aAAa,GAAGA,aAAa,CAAC7F,MAAM;IACxC;IACA,OAAOa,QAAQ,CAACkF,OAAO,EAAE;EAC7B,CAAC;EACDlH,cAAc,CAAC8B,SAAS,CAACqF,qBAAqB,GAAG,UAAUnF,QAAQ,EAAE;IACjE,IAAIA,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MACvB,OAAOuC,SAAS;IACpB,CAAC,MACI,IAAIY,QAAQ,CAACnD,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAO,EAAE;IACb,CAAC,MACI;MACD,OAAOQ,KAAK,CAAC2C,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC7B;EACJ,CAAC;EACD,OAAOhC,cAAc;AACzB,CAAC,EAAG;AACJ,SAASA,cAAc"},"metadata":{},"sourceType":"module"}