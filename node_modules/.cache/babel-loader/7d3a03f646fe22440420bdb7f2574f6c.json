{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nvar LineTokens = /** @class */function () {\n  function LineTokens(tokens, text) {\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n  }\n  LineTokens.prototype.equals = function (other) {\n    if (other instanceof LineTokens) {\n      return this.slicedEquals(other, 0, this._tokensCount);\n    }\n    return false;\n  };\n  LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {\n    if (this._text !== other._text) {\n      return false;\n    }\n    if (this._tokensCount !== other._tokensCount) {\n      return false;\n    }\n    var from = sliceFromTokenIndex << 1;\n    var to = from + (sliceTokenCount << 1);\n    for (var i = from; i < to; i++) {\n      if (this._tokens[i] !== other._tokens[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  LineTokens.prototype.getLineContent = function () {\n    return this._text;\n  };\n  LineTokens.prototype.getCount = function () {\n    return this._tokensCount;\n  };\n  LineTokens.prototype.getStartOffset = function (tokenIndex) {\n    if (tokenIndex > 0) {\n      return this._tokens[tokenIndex - 1 << 1];\n    }\n    return 0;\n  };\n  LineTokens.prototype.getMetadata = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return metadata;\n  };\n  LineTokens.prototype.getLanguageId = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getLanguageId(metadata);\n  };\n  LineTokens.prototype.getStandardTokenType = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getTokenType(metadata);\n  };\n  LineTokens.prototype.getForeground = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getForeground(metadata);\n  };\n  LineTokens.prototype.getClassName = function (tokenIndex) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getClassNameFromMetadata(metadata);\n  };\n  LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\n    var metadata = this._tokens[(tokenIndex << 1) + 1];\n    return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n  };\n  LineTokens.prototype.getEndOffset = function (tokenIndex) {\n    return this._tokens[tokenIndex << 1];\n  };\n  /**\r\n   * Find the token containing offset `offset`.\r\n   * @param offset The search offset\r\n   * @return The index of the token containing the offset.\r\n   */\n  LineTokens.prototype.findTokenIndexAtOffset = function (offset) {\n    return LineTokens.findIndexInTokensArray(this._tokens, offset);\n  };\n  LineTokens.prototype.inflate = function () {\n    return this;\n  };\n  LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {\n    return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n  };\n  LineTokens.convertToEndOffset = function (tokens, lineTextLength) {\n    var tokenCount = tokens.length >>> 1;\n    var lastTokenIndex = tokenCount - 1;\n    for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n      tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n    }\n    tokens[lastTokenIndex << 1] = lineTextLength;\n  };\n  LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {\n    if (tokens.length <= 2) {\n      return 0;\n    }\n    var low = 0;\n    var high = (tokens.length >>> 1) - 1;\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n      var endOffset = tokens[mid << 1];\n      if (endOffset === desiredIndex) {\n        return mid + 1;\n      } else if (endOffset < desiredIndex) {\n        low = mid + 1;\n      } else if (endOffset > desiredIndex) {\n        high = mid;\n      }\n    }\n    return low;\n  };\n  return LineTokens;\n}();\nexport { LineTokens };\nvar SlicedLineTokens = /** @class */function () {\n  function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n    for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      var tokenStartOffset = source.getStartOffset(i);\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n      this._tokensCount++;\n    }\n  }\n  SlicedLineTokens.prototype.equals = function (other) {\n    if (other instanceof SlicedLineTokens) {\n      return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n    }\n    return false;\n  };\n  SlicedLineTokens.prototype.getCount = function () {\n    return this._tokensCount;\n  };\n  SlicedLineTokens.prototype.getForeground = function (tokenIndex) {\n    return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n  };\n  SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {\n    var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n    return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n  };\n  SlicedLineTokens.prototype.getClassName = function (tokenIndex) {\n    return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n  };\n  SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\n    return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n  };\n  SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {\n    return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n  };\n  return SlicedLineTokens;\n}();\nexport { SlicedLineTokens };","map":{"version":3,"names":["TokenMetadata","LineTokens","tokens","text","_tokens","_tokensCount","length","_text","prototype","equals","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","getLineContent","getCount","getStartOffset","tokenIndex","getMetadata","metadata","getLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getEndOffset","findTokenIndexAtOffset","offset","findIndexInTokensArray","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SlicedLineTokens","convertToEndOffset","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","len","tokenStartOffset","tokenEndOffset","min"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { TokenMetadata } from '../modes.js';\r\nvar LineTokens = /** @class */ (function () {\r\n    function LineTokens(tokens, text) {\r\n        this._tokens = tokens;\r\n        this._tokensCount = (this._tokens.length >>> 1);\r\n        this._text = text;\r\n    }\r\n    LineTokens.prototype.equals = function (other) {\r\n        if (other instanceof LineTokens) {\r\n            return this.slicedEquals(other, 0, this._tokensCount);\r\n        }\r\n        return false;\r\n    };\r\n    LineTokens.prototype.slicedEquals = function (other, sliceFromTokenIndex, sliceTokenCount) {\r\n        if (this._text !== other._text) {\r\n            return false;\r\n        }\r\n        if (this._tokensCount !== other._tokensCount) {\r\n            return false;\r\n        }\r\n        var from = (sliceFromTokenIndex << 1);\r\n        var to = from + (sliceTokenCount << 1);\r\n        for (var i = from; i < to; i++) {\r\n            if (this._tokens[i] !== other._tokens[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    LineTokens.prototype.getLineContent = function () {\r\n        return this._text;\r\n    };\r\n    LineTokens.prototype.getCount = function () {\r\n        return this._tokensCount;\r\n    };\r\n    LineTokens.prototype.getStartOffset = function (tokenIndex) {\r\n        if (tokenIndex > 0) {\r\n            return this._tokens[(tokenIndex - 1) << 1];\r\n        }\r\n        return 0;\r\n    };\r\n    LineTokens.prototype.getMetadata = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return metadata;\r\n    };\r\n    LineTokens.prototype.getLanguageId = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getLanguageId(metadata);\r\n    };\r\n    LineTokens.prototype.getStandardTokenType = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getTokenType(metadata);\r\n    };\r\n    LineTokens.prototype.getForeground = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getForeground(metadata);\r\n    };\r\n    LineTokens.prototype.getClassName = function (tokenIndex) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getClassNameFromMetadata(metadata);\r\n    };\r\n    LineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\r\n        var metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\r\n    };\r\n    LineTokens.prototype.getEndOffset = function (tokenIndex) {\r\n        return this._tokens[tokenIndex << 1];\r\n    };\r\n    /**\r\n     * Find the token containing offset `offset`.\r\n     * @param offset The search offset\r\n     * @return The index of the token containing the offset.\r\n     */\r\n    LineTokens.prototype.findTokenIndexAtOffset = function (offset) {\r\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\r\n    };\r\n    LineTokens.prototype.inflate = function () {\r\n        return this;\r\n    };\r\n    LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {\r\n        return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\r\n    };\r\n    LineTokens.convertToEndOffset = function (tokens, lineTextLength) {\r\n        var tokenCount = (tokens.length >>> 1);\r\n        var lastTokenIndex = tokenCount - 1;\r\n        for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\r\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\r\n        }\r\n        tokens[lastTokenIndex << 1] = lineTextLength;\r\n    };\r\n    LineTokens.findIndexInTokensArray = function (tokens, desiredIndex) {\r\n        if (tokens.length <= 2) {\r\n            return 0;\r\n        }\r\n        var low = 0;\r\n        var high = (tokens.length >>> 1) - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            var endOffset = tokens[(mid << 1)];\r\n            if (endOffset === desiredIndex) {\r\n                return mid + 1;\r\n            }\r\n            else if (endOffset < desiredIndex) {\r\n                low = mid + 1;\r\n            }\r\n            else if (endOffset > desiredIndex) {\r\n                high = mid;\r\n            }\r\n        }\r\n        return low;\r\n    };\r\n    return LineTokens;\r\n}());\r\nexport { LineTokens };\r\nvar SlicedLineTokens = /** @class */ (function () {\r\n    function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {\r\n        this._source = source;\r\n        this._startOffset = startOffset;\r\n        this._endOffset = endOffset;\r\n        this._deltaOffset = deltaOffset;\r\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\r\n        this._tokensCount = 0;\r\n        for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\r\n            var tokenStartOffset = source.getStartOffset(i);\r\n            if (tokenStartOffset >= endOffset) {\r\n                break;\r\n            }\r\n            this._tokensCount++;\r\n        }\r\n    }\r\n    SlicedLineTokens.prototype.equals = function (other) {\r\n        if (other instanceof SlicedLineTokens) {\r\n            return (this._startOffset === other._startOffset\r\n                && this._endOffset === other._endOffset\r\n                && this._deltaOffset === other._deltaOffset\r\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\r\n        }\r\n        return false;\r\n    };\r\n    SlicedLineTokens.prototype.getCount = function () {\r\n        return this._tokensCount;\r\n    };\r\n    SlicedLineTokens.prototype.getForeground = function (tokenIndex) {\r\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\r\n    };\r\n    SlicedLineTokens.prototype.getEndOffset = function (tokenIndex) {\r\n        var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\r\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\r\n    };\r\n    SlicedLineTokens.prototype.getClassName = function (tokenIndex) {\r\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\r\n    };\r\n    SlicedLineTokens.prototype.getInlineStyle = function (tokenIndex, colorMap) {\r\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\r\n    };\r\n    SlicedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {\r\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\r\n    };\r\n    return SlicedLineTokens;\r\n}());\r\nexport { SlicedLineTokens };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}