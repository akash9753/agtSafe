{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner.js';\nvar ParseOptions;\n(function (ParseOptions) {\n  ParseOptions.DEFAULT = {\n    allowTrailingComma: false\n  };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n  var segments = []; // strings or numbers\n  var earlyReturnException = new Object();\n  var previousNode = undefined;\n  var previousNodeInst = {\n    value: {},\n    offset: 0,\n    length: 0,\n    type: 'object',\n    parent: undefined\n  };\n  var isAtPropertyKey = false;\n  function setPreviousNode(value, offset, length, type) {\n    previousNodeInst.value = value;\n    previousNodeInst.offset = offset;\n    previousNodeInst.length = length;\n    previousNodeInst.type = type;\n    previousNodeInst.colonOffset = undefined;\n    previousNode = previousNodeInst;\n  }\n  try {\n    visit(text, {\n      onObjectBegin: function onObjectBegin(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        isAtPropertyKey = position > offset;\n        segments.push(''); // push a placeholder (will be replaced)\n      },\n\n      onObjectProperty: function onObjectProperty(name, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n        setPreviousNode(name, offset, length, 'property');\n        segments[segments.length - 1] = name;\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onObjectEnd: function onObjectEnd(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        segments.pop();\n      },\n      onArrayBegin: function onArrayBegin(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        segments.push(0);\n      },\n      onArrayEnd: function onArrayEnd(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        segments.pop();\n      },\n      onLiteralValue: function onLiteralValue(value, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n        setPreviousNode(value, offset, length, getNodeType(value));\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onSeparator: function onSeparator(sep, offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        if (sep === ':' && previousNode && previousNode.type === 'property') {\n          previousNode.colonOffset = offset;\n          isAtPropertyKey = false;\n          previousNode = undefined;\n        } else if (sep === ',') {\n          var last = segments[segments.length - 1];\n          if (typeof last === 'number') {\n            segments[segments.length - 1] = last + 1;\n          } else {\n            isAtPropertyKey = true;\n            segments[segments.length - 1] = '';\n          }\n          previousNode = undefined;\n        }\n      }\n    });\n  } catch (e) {\n    if (e !== earlyReturnException) {\n      throw e;\n    }\n  }\n  return {\n    path: segments,\n    previousNode: previousNode,\n    isAtPropertyKey: isAtPropertyKey,\n    matches: function matches(pattern) {\n      var k = 0;\n      for (var i = 0; k < pattern.length && i < segments.length; i++) {\n        if (pattern[k] === segments[i] || pattern[k] === '*') {\n          k++;\n        } else if (pattern[k] !== '**') {\n          return false;\n        }\n      }\n      return k === pattern.length;\n    }\n  };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n  var currentProperty = null;\n  var currentParent = [];\n  var previousParents = [];\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty !== null) {\n      currentParent[currentProperty] = value;\n    }\n  }\n  var visitor = {\n    onObjectBegin: function onObjectBegin() {\n      var object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: function onObjectProperty(name) {\n      currentProperty = name;\n    },\n    onObjectEnd: function onObjectEnd() {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: function onArrayBegin() {\n      var array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: function onArrayEnd() {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: function onError(error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n  var currentParent = {\n    type: 'array',\n    offset: -1,\n    length: -1,\n    children: [],\n    parent: undefined\n  }; // artificial root\n  function ensurePropertyComplete(endOffset) {\n    if (currentParent.type === 'property') {\n      currentParent.length = endOffset - currentParent.offset;\n      currentParent = currentParent.parent;\n    }\n  }\n  function onValue(valueNode) {\n    currentParent.children.push(valueNode);\n    return valueNode;\n  }\n  var visitor = {\n    onObjectBegin: function onObjectBegin(offset) {\n      currentParent = onValue({\n        type: 'object',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onObjectProperty: function onObjectProperty(name, offset, length) {\n      currentParent = onValue({\n        type: 'property',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n      currentParent.children.push({\n        type: 'string',\n        value: name,\n        offset: offset,\n        length: length,\n        parent: currentParent\n      });\n    },\n    onObjectEnd: function onObjectEnd(offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onArrayBegin: function onArrayBegin(offset, length) {\n      currentParent = onValue({\n        type: 'array',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onArrayEnd: function onArrayEnd(offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onLiteralValue: function onLiteralValue(value, offset, length) {\n      onValue({\n        type: getNodeType(value),\n        offset: offset,\n        length: length,\n        parent: currentParent,\n        value: value\n      });\n      ensurePropertyComplete(offset + length);\n    },\n    onSeparator: function onSeparator(sep, offset, length) {\n      if (currentParent.type === 'property') {\n        if (sep === ':') {\n          currentParent.colonOffset = offset;\n        } else if (sep === ',') {\n          ensurePropertyComplete(offset);\n        }\n      }\n    },\n    onError: function onError(error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  var result = currentParent.children[0];\n  if (result) {\n    delete result.parent;\n  }\n  return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n  if (!root) {\n    return undefined;\n  }\n  var node = root;\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var segment = path_1[_i];\n    if (typeof segment === 'string') {\n      if (node.type !== 'object' || !Array.isArray(node.children)) {\n        return undefined;\n      }\n      var found = false;\n      for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n        var propertyNode = _b[_a];\n        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n          node = propertyNode.children[1];\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return undefined;\n      }\n    } else {\n      var index = segment;\n      if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n        return undefined;\n      }\n      node = node.children[index];\n    }\n  }\n  return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n  var path = getNodePath(node.parent);\n  if (node.parent.type === 'property') {\n    var key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === 'array') {\n    var index = node.parent.children.indexOf(node);\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n  return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n  switch (node.type) {\n    case 'array':\n      return node.children.map(getNodeValue);\n    case 'object':\n      var obj = Object.create(null);\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var prop = _a[_i];\n        var valueNode = prop.children[1];\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n      return obj;\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return node.value;\n    default:\n      return undefined;\n  }\n}\nexport function contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n  if (contains(node, offset, includeRightBound)) {\n    var children = node.children;\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n        var item = findNodeAtOffset(children[i], offset, includeRightBound);\n        if (item) {\n          return item;\n        }\n      }\n    }\n    return node;\n  }\n  return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n  var _scanner = createScanner(text, false);\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n    onObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n    onObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n    onArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n    onArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n    onLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n    onSeparator = toOneArgVisit(visitor.onSeparator),\n    onComment = toNoArgVisit(visitor.onComment),\n    onError = toOneArgVisit(visitor.onError);\n  var disallowComments = options && options.disallowComments;\n  var allowTrailingComma = options && options.allowTrailingComma;\n  function scanNext() {\n    while (true) {\n      var token = _scanner.scan();\n      switch (_scanner.getTokenError()) {\n        case 4 /* InvalidUnicode */:\n          handleError(14 /* InvalidUnicode */);\n          break;\n        case 5 /* InvalidEscapeCharacter */:\n          handleError(15 /* InvalidEscapeCharacter */);\n          break;\n        case 3 /* UnexpectedEndOfNumber */:\n          handleError(13 /* UnexpectedEndOfNumber */);\n          break;\n        case 1 /* UnexpectedEndOfComment */:\n          if (!disallowComments) {\n            handleError(11 /* UnexpectedEndOfComment */);\n          }\n\n          break;\n        case 2 /* UnexpectedEndOfString */:\n          handleError(12 /* UnexpectedEndOfString */);\n          break;\n        case 6 /* InvalidCharacter */:\n          handleError(16 /* InvalidCharacter */);\n          break;\n      }\n      switch (token) {\n        case 12 /* LineCommentTrivia */:\n        case 13 /* BlockCommentTrivia */:\n          if (disallowComments) {\n            handleError(10 /* InvalidCommentToken */);\n          } else {\n            onComment();\n          }\n          break;\n        case 16 /* Unknown */:\n          handleError(1 /* InvalidSymbol */);\n          break;\n        case 15 /* Trivia */:\n        case 14 /* LineBreakTrivia */:\n          break;\n        default:\n          return token;\n      }\n    }\n  }\n  function handleError(error, skipUntilAfter, skipUntil) {\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n    onError(error);\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      var token = _scanner.getToken();\n      while (token !== 17 /* EOF */) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n        token = scanNext();\n      }\n    }\n  }\n  function parseString(isValue) {\n    var value = _scanner.getTokenValue();\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value);\n    }\n    scanNext();\n    return true;\n  }\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11 /* NumericLiteral */:\n        var value = 0;\n        try {\n          value = JSON.parse(_scanner.getTokenValue());\n          if (typeof value !== 'number') {\n            handleError(2 /* InvalidNumberFormat */);\n            value = 0;\n          }\n        } catch (e) {\n          handleError(2 /* InvalidNumberFormat */);\n        }\n\n        onLiteralValue(value);\n        break;\n      case 7 /* NullKeyword */:\n        onLiteralValue(null);\n        break;\n      case 8 /* TrueKeyword */:\n        onLiteralValue(true);\n        break;\n      case 9 /* FalseKeyword */:\n        onLiteralValue(false);\n        break;\n      default:\n        return false;\n    }\n    scanNext();\n    return true;\n  }\n  function parseProperty() {\n    if (_scanner.getToken() !== 10 /* StringLiteral */) {\n      handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n      return false;\n    }\n    parseString(false);\n    if (_scanner.getToken() === 6 /* ColonToken */) {\n      onSeparator(':');\n      scanNext(); // consume colon\n      if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n      }\n    } else {\n      handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n    }\n\n    return true;\n  }\n  function parseObject() {\n    onObjectBegin();\n    scanNext(); // consume open brace\n    var needsComma = false;\n    while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n      if (_scanner.getToken() === 5 /* CommaToken */) {\n        if (!needsComma) {\n          handleError(4 /* ValueExpected */, [], []);\n        }\n        onSeparator(',');\n        scanNext(); // consume comma\n        if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6 /* CommaExpected */, [], []);\n      }\n      if (!parseProperty()) {\n        handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n      }\n\n      needsComma = true;\n    }\n    onObjectEnd();\n    if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n      handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n    } else {\n      scanNext(); // consume close brace\n    }\n\n    return true;\n  }\n  function parseArray() {\n    onArrayBegin();\n    scanNext(); // consume open bracket\n    var needsComma = false;\n    while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n      if (_scanner.getToken() === 5 /* CommaToken */) {\n        if (!needsComma) {\n          handleError(4 /* ValueExpected */, [], []);\n        }\n        onSeparator(',');\n        scanNext(); // consume comma\n        if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6 /* CommaExpected */, [], []);\n      }\n      if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n      }\n\n      needsComma = true;\n    }\n    onArrayEnd();\n    if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n      handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n    } else {\n      scanNext(); // consume close bracket\n    }\n\n    return true;\n  }\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3 /* OpenBracketToken */:\n        return parseArray();\n      case 1 /* OpenBraceToken */:\n        return parseObject();\n      case 10 /* StringLiteral */:\n        return parseString(true);\n      default:\n        return parseLiteral();\n    }\n  }\n  scanNext();\n  if (_scanner.getToken() === 17 /* EOF */) {\n    if (options.allowEmptyContent) {\n      return true;\n    }\n    handleError(4 /* ValueExpected */, [], []);\n    return false;\n  }\n  if (!parseValue()) {\n    handleError(4 /* ValueExpected */, [], []);\n    return false;\n  }\n  if (_scanner.getToken() !== 17 /* EOF */) {\n    handleError(9 /* EndOfFileExpected */, [], []);\n  }\n  return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n  var _scanner = createScanner(text),\n    parts = [],\n    kind,\n    offset = 0,\n    pos;\n  do {\n    pos = _scanner.getPosition();\n    kind = _scanner.scan();\n    switch (kind) {\n      case 12 /* LineCommentTrivia */:\n      case 13 /* BlockCommentTrivia */:\n      case 17 /* EOF */:\n        if (offset !== pos) {\n          parts.push(text.substring(offset, pos));\n        }\n        if (replaceCh !== undefined) {\n          parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n        }\n        offset = _scanner.getPosition();\n        break;\n    }\n  } while (kind !== 17 /* EOF */);\n  return parts.join('');\n}\nexport function getNodeType(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return 'boolean';\n    case 'number':\n      return 'number';\n    case 'string':\n      return 'string';\n    case 'object':\n      {\n        if (!value) {\n          return 'null';\n        } else if (Array.isArray(value)) {\n          return 'array';\n        }\n        return 'object';\n      }\n    default:\n      return 'null';\n  }\n}","map":{"version":3,"names":["createScanner","ParseOptions","DEFAULT","allowTrailingComma","getLocation","text","position","segments","earlyReturnException","Object","previousNode","undefined","previousNodeInst","value","offset","length","type","parent","isAtPropertyKey","setPreviousNode","colonOffset","visit","onObjectBegin","push","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","onArrayEnd","onLiteralValue","getNodeType","onSeparator","sep","last","e","path","matches","pattern","k","i","parse","errors","options","currentProperty","currentParent","previousParents","onValue","Array","isArray","visitor","object","array","onError","error","parseTree","children","ensurePropertyComplete","endOffset","valueNode","result","findNodeAtLocation","root","node","_i","path_1","segment","found","_a","_b","propertyNode","index","getNodePath","key","indexOf","getNodeValue","map","obj","create","prop","contains","includeRightBound","findNodeAtOffset","item","_scanner","toNoArgVisit","visitFunction","getTokenOffset","getTokenLength","getTokenStartLine","getTokenStartCharacter","toOneArgVisit","arg","onComment","disallowComments","scanNext","token","scan","getTokenError","handleError","skipUntilAfter","skipUntil","getToken","parseString","isValue","getTokenValue","parseLiteral","JSON","parseProperty","parseValue","parseObject","needsComma","parseArray","allowEmptyContent","stripComments","replaceCh","parts","kind","pos","getPosition","substring","replace","join"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/parser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner.js';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var value = 0;\n                try {\n                    value = JSON.parse(_scanner.getTokenValue());\n                    if (typeof value !== 'number') {\n                        handleError(2 /* InvalidNumberFormat */);\n                        value = 0;\n                    }\n                }\n                catch (e) {\n                    handleError(2 /* InvalidNumberFormat */);\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}