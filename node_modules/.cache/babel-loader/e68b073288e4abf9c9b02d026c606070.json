{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.index-of\");\nexports.__esModule = true;\nexports.default = void 0;\nvar _element = require(\"./../../../../helpers/dom/element\");\nvar _object = require(\"./../../../../helpers/object\");\nvar _array = require(\"./../../../../helpers/array\");\nvar _console = require(\"./../../../../helpers/console\");\nvar _eventManager = _interopRequireDefault(require(\"./../../../../eventManager\"));\nvar _core = _interopRequireDefault(require(\"./../core\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nvar registeredOverlays = {};\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nvar Overlay = /*#__PURE__*/\nfunction () {\n  _createClass(Overlay, null, [{\n    key: \"registerOverlay\",\n    /**\n     * Register overlay class.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}\n     */\n    value: function registerOverlay(type, overlayClass) {\n      if (Overlay.CLONE_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Unsupported overlay (\".concat(type, \").\"));\n      }\n      registeredOverlays[type] = overlayClass;\n    }\n    /**\n     * Create new instance of overlay type.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Walkontable} wot Walkontable instance\n     */\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(type, wot) {\n      return new registeredOverlays[type](wot);\n    }\n    /**\n     * Check if specified overlay was registered.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"hasOverlay\",\n    value: function hasOverlay(type) {\n      return registeredOverlays[type] !== void 0;\n    }\n    /**\n     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).\n     *\n     * @param {Overlay} overlay Overlay object\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isOverlayTypeOf\",\n    value: function isOverlayTypeOf(overlay, type) {\n      if (!overlay || !registeredOverlays[type]) {\n        return false;\n      }\n      return overlay instanceof registeredOverlays[type];\n    }\n    /**\n     * @param {Walkontable} wotInstance\n     */\n  }, {\n    key: \"CLONE_TOP\",\n    /**\n     * @type {String}\n     */\n    get: function get() {\n      return 'top';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_BOTTOM\",\n    get: function get() {\n      return 'bottom';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_LEFT\",\n    get: function get() {\n      return 'left';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_TOP_LEFT_CORNER\",\n    get: function get() {\n      return 'top_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_BOTTOM_LEFT_CORNER\",\n    get: function get() {\n      return 'bottom_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n  }, {\n    key: \"CLONE_DEBUG\",\n    get: function get() {\n      return 'debug';\n    }\n    /**\n     * List of all availables clone types\n     *\n     * @type {Array}\n     */\n  }, {\n    key: \"CLONE_TYPES\",\n    get: function get() {\n      return [Overlay.CLONE_TOP, Overlay.CLONE_BOTTOM, Overlay.CLONE_LEFT, Overlay.CLONE_TOP_LEFT_CORNER, Overlay.CLONE_BOTTOM_LEFT_CORNER, Overlay.CLONE_DEBUG];\n    }\n  }]);\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n    (0, _object.defineGetter)(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n      TABLE = _this$wot$wtTable.TABLE,\n      hider = _this$wot$wtTable.hider,\n      spreader = _this$wot$wtTable.spreader,\n      holder = _this$wot$wtTable.holder,\n      wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = (0, _element.getTrimmingContainer)(this.hider.parentNode.parentNode);\n    this.areElementSizesAdjusted = false;\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {Boolean} Returns `true` if the state has changed since the last check.\n   */\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = (0, _element.getTrimmingContainer)(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n        wtTable = _this$wot.wtTable,\n        rootWindow = _this$wot.rootWindow;\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {Number} rowIndex Visual row index.\n     * @param {Number} columnIndex Visual column index.\n     * @returns {{top: Number, left: Number}|undefined}\n     */\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        (0, _console.warn)(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay\n     *\n     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`\n     * @returns {Walkontable}\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (Overlay.CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n      var _this$wot2 = this.wot,\n        wtTable = _this$wot2.wtTable,\n        rootDocument = _this$wot2.rootDocument,\n        rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'hidden';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      wtTable.wtRootElement.parentNode.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === Overlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === Overlay.CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);\n      }\n      return new _core.default({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay\n     *\n     * @param {Boolean} [fastDraw=false]\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      (0, _array.arrayEach)([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new _eventManager.default(this.clone).destroy();\n    }\n  }]);\n  return Overlay;\n}();\nvar _default = Overlay;\nexports.default = _default;","map":{"version":3,"names":["require","exports","__esModule","default","_element","_object","_array","_console","_eventManager","_interopRequireDefault","_core","obj","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","registeredOverlays","Overlay","value","registerOverlay","type","overlayClass","CLONE_TYPES","indexOf","Error","concat","createOverlay","wot","hasOverlay","isOverlayTypeOf","overlay","get","CLONE_TOP","CLONE_BOTTOM","CLONE_LEFT","CLONE_TOP_LEFT_CORNER","CLONE_BOTTOM_LEFT_CORNER","CLONE_DEBUG","wotInstance","defineGetter","_this$wot$wtTable","wtTable","TABLE","hider","spreader","holder","wtRootElement","mainTableScrollableElement","trimmingContainer","getTrimmingContainer","parentNode","areElementSizesAdjusted","updateStateOfRendering","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","_this$wot","rootWindow","getComputedStyle","getPropertyValue","getScrollableElement","getRelativeCellPosition","element","rowIndex","columnIndex","clone","contains","warn","windowScroll","fixedColumn","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","left","offsetLeft","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","cloneSource","wtOverlays","leftOverlay","getScrollPosition","vertical","topOverlay","makeClone","direction","_this$wot2","rootDocument","createElement","clonedTable","className","style","position","overflow","appendChild","preventOverflow","cloneOverlay","table","refresh","fastDraw","arguments","undefined","nextCycleRenderFlag","draw","holderStyle","hidderStyle","rootStyle","arrayEach","width","height","destroy","_default"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/handsontable/commonjs/3rdparty/walkontable/src/overlay/_base.js"],"sourcesContent":["\"use strict\";\n\nrequire(\"core-js/modules/es.array.index-of\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _element = require(\"./../../../../helpers/dom/element\");\n\nvar _object = require(\"./../../../../helpers/object\");\n\nvar _array = require(\"./../../../../helpers/array\");\n\nvar _console = require(\"./../../../../helpers/console\");\n\nvar _eventManager = _interopRequireDefault(require(\"./../../../../eventManager\"));\n\nvar _core = _interopRequireDefault(require(\"./../core\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar registeredOverlays = {};\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nvar Overlay =\n/*#__PURE__*/\nfunction () {\n  _createClass(Overlay, null, [{\n    key: \"registerOverlay\",\n\n    /**\n     * Register overlay class.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Overlay} overlayClass Overlay class extended from base overlay class {@link Overlay}\n     */\n    value: function registerOverlay(type, overlayClass) {\n      if (Overlay.CLONE_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Unsupported overlay (\".concat(type, \").\"));\n      }\n\n      registeredOverlays[type] = overlayClass;\n    }\n    /**\n     * Create new instance of overlay type.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @param {Walkontable} wot Walkontable instance\n     */\n\n  }, {\n    key: \"createOverlay\",\n    value: function createOverlay(type, wot) {\n      return new registeredOverlays[type](wot);\n    }\n    /**\n     * Check if specified overlay was registered.\n     *\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasOverlay\",\n    value: function hasOverlay(type) {\n      return registeredOverlays[type] !== void 0;\n    }\n    /**\n     * Checks if overlay object (`overlay`) is instance of overlay type (`type`).\n     *\n     * @param {Overlay} overlay Overlay object\n     * @param {String} type Overlay type, one of the CLONE_TYPES value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isOverlayTypeOf\",\n    value: function isOverlayTypeOf(overlay, type) {\n      if (!overlay || !registeredOverlays[type]) {\n        return false;\n      }\n\n      return overlay instanceof registeredOverlays[type];\n    }\n    /**\n     * @param {Walkontable} wotInstance\n     */\n\n  }, {\n    key: \"CLONE_TOP\",\n\n    /**\n     * @type {String}\n     */\n    get: function get() {\n      return 'top';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM\",\n    get: function get() {\n      return 'bottom';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_LEFT\",\n    get: function get() {\n      return 'left';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_TOP_LEFT_CORNER\",\n    get: function get() {\n      return 'top_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_BOTTOM_LEFT_CORNER\",\n    get: function get() {\n      return 'bottom_left_corner';\n    }\n    /**\n     * @type {String}\n     */\n\n  }, {\n    key: \"CLONE_DEBUG\",\n    get: function get() {\n      return 'debug';\n    }\n    /**\n     * List of all availables clone types\n     *\n     * @type {Array}\n     */\n\n  }, {\n    key: \"CLONE_TYPES\",\n    get: function get() {\n      return [Overlay.CLONE_TOP, Overlay.CLONE_BOTTOM, Overlay.CLONE_LEFT, Overlay.CLONE_TOP_LEFT_CORNER, Overlay.CLONE_BOTTOM_LEFT_CORNER, Overlay.CLONE_DEBUG];\n    }\n  }]);\n\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n\n    (0, _object.defineGetter)(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n        TABLE = _this$wot$wtTable.TABLE,\n        hider = _this$wot$wtTable.hider,\n        spreader = _this$wot$wtTable.spreader,\n        holder = _this$wot$wtTable.holder,\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = (0, _element.getTrimmingContainer)(this.hider.parentNode.parentNode);\n    this.areElementSizesAdjusted = false;\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {Boolean} Returns `true` if the state has changed since the last check.\n   */\n\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = (0, _element.getTrimmingContainer)(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n          wtTable = _this$wot.wtTable,\n          rootWindow = _this$wot.rootWindow;\n\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {Number} rowIndex Visual row index.\n     * @param {Number} columnIndex Visual column index.\n     * @returns {{top: Number, left: Number}|undefined}\n     */\n\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        (0, _console.warn)(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {Boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {Boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {Boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {Number} elementOffset Offset position of the cell element.\n     * @param {Number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: Number, left: Number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay\n     *\n     * @param {String} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`, `Overlay.CLONE_DEBUG`\n     * @returns {Walkontable}\n     */\n\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (Overlay.CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n\n      var _this$wot2 = this.wot,\n          wtTable = _this$wot2.wtTable,\n          rootDocument = _this$wot2.rootDocument,\n          rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'hidden';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      wtTable.wtRootElement.parentNode.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === Overlay.CLONE_TOP || preventOverflow === 'vertical' && this.type === Overlay.CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);\n      }\n\n      return new _core.default({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay\n     *\n     * @param {Boolean} [fastDraw=false]\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      (0, _array.arrayEach)([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new _eventManager.default(this.clone).destroy();\n    }\n  }]);\n\n  return Overlay;\n}();\n\nvar _default = Overlay;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}