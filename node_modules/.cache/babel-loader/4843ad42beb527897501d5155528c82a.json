{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\nrequire(\"core-js/modules/es.symbol.description\");\nrequire(\"core-js/modules/es.symbol.iterator\");\nrequire(\"core-js/modules/es.array.from\");\nrequire(\"core-js/modules/es.array.includes\");\nrequire(\"core-js/modules/es.array.iterator\");\nrequire(\"core-js/modules/es.object.to-string\");\nrequire(\"core-js/modules/es.regexp.to-string\");\nrequire(\"core-js/modules/es.string.iterator\");\nrequire(\"core-js/modules/web.dom-collections.iterator\");\nexports.__esModule = true;\nexports.default = void 0;\nvar _element = require(\"./../../../helpers/dom/element\");\nvar _function = require(\"./../../../helpers/function\");\nvar _coords = _interopRequireDefault(require(\"./cell/coords\"));\nvar _column = _interopRequireDefault(require(\"./filter/column\"));\nvar _row = _interopRequireDefault(require(\"./filter/row\"));\nvar _renderer = require(\"./renderer\");\nvar _base = _interopRequireDefault(require(\"./overlay/_base\"));\nvar _column2 = _interopRequireDefault(require(\"./utils/column\"));\nvar _row2 = _interopRequireDefault(require(\"./utils/row\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n *\n */\nvar Table = /*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   * @param {HTMLTableElement} table\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. it is NOT an overlay)\n     *\n     * @type {Boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {Boolean}\n     */\n\n    this.isTableVisible = false;\n    (0, _element.removeTextNodes)(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n    this.rowUtils = new _row2.default(this.wot);\n    this.columnUtils = new _column2.default(this.wot);\n    this.tableRenderer = new _renderer.Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {String} overlayTypeName\n   * @returns {Boolean}\n   */\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return _base.default.isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n      this.THEAD = this.TABLE.querySelector('thead');\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param table\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n        spreader.appendChild(table);\n      }\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param spreader\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n        hider.appendChild(spreader);\n      }\n      return hider;\n    }\n    /**\n     *\n     * @param hider\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n        holder.appendChild(hider);\n      }\n      return holder;\n    }\n    /**\n     * Redraws the table\n     *\n     * @param {Boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n        wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n      if (this.isMaster) {\n        this.holderOffset = (0, _element.offset)(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = (0, _element.offset)(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new _row.default(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new _column.default(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n          if (this.is(_base.default.CLONE_BOTTOM) || this.is(_base.default.CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n          this.adjustColumnHeaderHeights();\n          if (this.isMaster || this.is(_base.default.CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = (0, _element.outerWidth)(this.hider);\n            var tableWidth = (0, _element.outerWidth)(this.TABLE);\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(_base.default.CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n      this.refreshSelections(runFastDraw);\n      if (this.isMaster) {\n        wtOverlays.topOverlay.resetFixedPosition();\n        if (wtOverlays.bottomOverlay.clone) {\n          wtOverlays.bottomOverlay.resetFixedPosition();\n        }\n        wtOverlays.leftOverlay.resetFixedPosition();\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n      }\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n      wot.drawn = true;\n      return this;\n    }\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        currentHeaderHeight = (0, _element.innerHeight)(currentHeader);\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n        }\n      }\n    }\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n      if (!this.isMaster && !this.is(_base.default.CLONE_BOTTOM)) {\n        return;\n      }\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        (0, _element.removeClass)(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n      if (!wot.selections) {\n        return;\n      }\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n      if (fastDraw) {\n        var classesToRemove = [];\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n            highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n            highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n            highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n        var classesToRemoveLength = classesToRemove.length;\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords\n     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.getColumnHeader(column, zeroBasedHeaderLevel);\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n      return TD;\n    }\n    /**\n     * getColumnHeader\n     *\n     * @param {Number} col Column index\n     * @param {Number} [level=0] Header level (0 = most distant to the table)\n     * @returns {Object} HTMLElement on success or undefined on error\n     */\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      if (TR) {\n        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n      }\n    }\n    /**\n     * getRowHeader\n     *\n     * @param {Number} row Row index\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`\n     */\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return null;\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      if (TR) {\n        return TR.childNodes[0];\n      }\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = (0, _element.closest)(cellElement, ['TD', 'TH']);\n      }\n      if (cellElement === null) {\n        return null;\n      }\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = (0, _element.index)(TR);\n      var col = cellElement.cellIndex;\n      if ((0, _element.overlayContainsElement)(_base.default.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if ((0, _element.overlayContainsElement)(_base.default.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n      if ((0, _element.overlayContainsElement)(_base.default.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_LEFT, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n      return new _coords.default(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them\n     */\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = (0, _element.innerHeight)(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n        if (rowHeader) {\n          rowInnerHeight = (0, _element.innerHeight)(rowHeader);\n        } else {\n          rowInnerHeight = (0, _element.innerHeight)(currentTr) - 1;\n        }\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * 0-based index of column header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isColumnHeaderLevelRendered\",\n    value: function isColumnHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * 0-based index of row header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isRowHeaderLevelRendered\",\n    value: function isRowHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('rowHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * Check if the given row index is smaller than the index of the first row that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the header cells. As a simplification, it checks negative row index\n     * the same way as a regular row 0. You can interpret this as follows: If the row 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} row\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n      if (row < 0) {\n        row = 0;\n      }\n      if (first === -1) {\n        return true;\n      }\n      return row < first;\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.isColumnHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n      return row > this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n    /**\n     * Check if the given column index is smaller than the index of the first column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells. As a simplification, it checks negative column index\n     * the same way as a regular column 0. You can interpret this as follows: If the column 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n      if (column < 0) {\n        column = 0;\n      }\n      if (first === -1) {\n        return true;\n      }\n      return column < first;\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      if (column < 0) {\n        var rowHeaders = this.wot.getSetting('rowHeaders');\n        var rowHeadersCount = rowHeaders.length;\n        var zeroBasedHeaderLevel = rowHeadersCount + column;\n        return this.isRowHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n     *\n     * @param {Number} sourceRow\n     * @returns {Number}\n     */\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return (0, _element.isVisible)(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     */\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = (0, _function.isFunction)(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     */\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n      return rowHeaderWidth;\n    }\n  }]);\n  return Table;\n}();\nvar _default = Table;\nexports.default = _default;","map":{"version":3,"names":["require","exports","__esModule","default","_element","_function","_coords","_interopRequireDefault","_column","_row","_renderer","_base","_column2","_row2","obj","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","err","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Table","wotInstance","table","_this","isMaster","cloneOverlay","wot","TABLE","TBODY","THEAD","COLGROUP","tableOffset","holderOffset","hasTableHeight","hasTableWidth","isTableVisible","removeTextNodes","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","wtSettings","settings","rowHeaderWidth","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","Renderer","cellRenderer","is","overlayTypeName","isOverlayTypeOf","rootDocument","querySelector","createElement","appendChild","insertBefore","getSetting","childNodes","parent","nodeType","Node","ELEMENT_NODE","hasClass","className","style","position","draw","fastDraw","arguments","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","syncScroll","runFastDraw","offset","createRenderCalculators","leftScrollPos","leftOverlay","getScrollPosition","previousState","prepareOverlays","createVisibleCalculators","refresh","cloneSource","wtTable","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","CLONE_BOTTOM","CLONE_BOTTOM_LEFT_CORNER","resetOversizedRows","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","getWorkspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","applyToDOM","hiderWidth","outerWidth","tableWidth","calculateWidths","renderer","colGroup","adjustElementsSize","refreshSelections","topOverlay","resetFixedPosition","bottomOverlay","clone","topLeftCornerOverlay","bottomLeftCornerOverlay","syncScrollWithMaster","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","innerHeight","oversizedColumnHeaders","isNaN","children","len","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","removeClassFromCells","nodes","querySelectorAll","removeClass","selections","highlights","classesToRemove","_highlights$i$setting","highlightHeaderClassName","highlightRowClassName","highlightColumnClassName","classNames","classNamesLength","j","includes","additionalClassesToRemove","classesToRemoveLength","_i2","_i3","getCell","coords","row","column","hookResult","_hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","zeroBasedHeaderLevel","TR","sourceToRendered","Error","TD","sourceColumnToVisibleRowHeadedColumn","getRowHeader","getCoords","cellElement","nodeName","closest","CONTAINER","index","cellIndex","overlayContainsElement","CLONE_TOP_LEFT_CORNER","CLONE_TOP","visibleColHeadedRowToSourceRow","CLONE_LEFT","offsettedTH","visibleRowHeadedColumnToSourceColumn","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderLevelRendered","isRowHeaderLevelRendered","first","isRowAfterViewport","getLastVisibleRow","getLastRenderedRow","isColumnBeforeViewport","isColumnAfterViewport","getLastVisibleColumn","getLastRenderedColumn","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","isVisible","rowHeaderWidthFactory","widths","isFunction","_correctRowHeaderWidth","width","_default"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/handsontable/commonjs/3rdparty/walkontable/src/table.js"],"sourcesContent":["\"use strict\";\n\nrequire(\"core-js/modules/es.symbol\");\n\nrequire(\"core-js/modules/es.symbol.description\");\n\nrequire(\"core-js/modules/es.symbol.iterator\");\n\nrequire(\"core-js/modules/es.array.from\");\n\nrequire(\"core-js/modules/es.array.includes\");\n\nrequire(\"core-js/modules/es.array.iterator\");\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.regexp.to-string\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _element = require(\"./../../../helpers/dom/element\");\n\nvar _function = require(\"./../../../helpers/function\");\n\nvar _coords = _interopRequireDefault(require(\"./cell/coords\"));\n\nvar _column = _interopRequireDefault(require(\"./filter/column\"));\n\nvar _row = _interopRequireDefault(require(\"./filter/row\"));\n\nvar _renderer = require(\"./renderer\");\n\nvar _base = _interopRequireDefault(require(\"./overlay/_base\"));\n\nvar _column2 = _interopRequireDefault(require(\"./utils/column\"));\n\nvar _row2 = _interopRequireDefault(require(\"./utils/row\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n *\n */\nvar Table =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   * @param {HTMLTableElement} table\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. it is NOT an overlay)\n     *\n     * @type {Boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {Boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {Boolean}\n     */\n\n    this.isTableVisible = false;\n    (0, _element.removeTextNodes)(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n\n    this.rowUtils = new _row2.default(this.wot);\n    this.columnUtils = new _column2.default(this.wot);\n    this.tableRenderer = new _renderer.Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {String} overlayTypeName\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return _base.default.isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n\n      this.THEAD = this.TABLE.querySelector('thead');\n\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param table\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n\n        spreader.appendChild(table);\n      }\n\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param spreader\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n\n        hider.appendChild(spreader);\n      }\n\n      return hider;\n    }\n    /**\n     *\n     * @param hider\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n\n        holder.appendChild(hider);\n      }\n\n      return holder;\n    }\n    /**\n     * Redraws the table\n     *\n     * @param {Boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n          wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n\n      if (this.isMaster) {\n        this.holderOffset = (0, _element.offset)(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = (0, _element.offset)(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new _row.default(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new _column.default(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n\n          if (this.is(_base.default.CLONE_BOTTOM) || this.is(_base.default.CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n\n          this.adjustColumnHeaderHeights();\n\n          if (this.isMaster || this.is(_base.default.CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = (0, _element.outerWidth)(this.hider);\n            var tableWidth = (0, _element.outerWidth)(this.TABLE);\n\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(_base.default.CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n\n      this.refreshSelections(runFastDraw);\n\n      if (this.isMaster) {\n        wtOverlays.topOverlay.resetFixedPosition();\n\n        if (wtOverlays.bottomOverlay.clone) {\n          wtOverlays.bottomOverlay.resetFixedPosition();\n        }\n\n        wtOverlays.leftOverlay.resetFixedPosition();\n\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n      }\n\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n\n      wot.drawn = true;\n      return this;\n    }\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        currentHeaderHeight = (0, _element.innerHeight)(currentHeader);\n\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting;\n        }\n      }\n    }\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n\n      if (!this.isMaster && !this.is(_base.default.CLONE_BOTTOM)) {\n        return;\n      }\n\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        (0, _element.removeClass)(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {Boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n\n      if (!wot.selections) {\n        return;\n      }\n\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n\n      if (fastDraw) {\n        var classesToRemove = [];\n\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n\n        var classesToRemoveLength = classesToRemove.length;\n\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords\n     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.getColumnHeader(column, zeroBasedHeaderLevel);\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n\n      return TD;\n    }\n    /**\n     * getColumnHeader\n     *\n     * @param {Number} col Column index\n     * @param {Number} [level=0] Header level (0 = most distant to the table)\n     * @returns {Object} HTMLElement on success or undefined on error\n     */\n\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n\n      if (TR) {\n        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n      }\n    }\n    /**\n     * getRowHeader\n     *\n     * @param {Number} row Row index\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`\n     */\n\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return null;\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n\n      if (TR) {\n        return TR.childNodes[0];\n      }\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = (0, _element.closest)(cellElement, ['TD', 'TH']);\n      }\n\n      if (cellElement === null) {\n        return null;\n      }\n\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = (0, _element.index)(TR);\n      var col = cellElement.cellIndex;\n\n      if ((0, _element.overlayContainsElement)(_base.default.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if ((0, _element.overlayContainsElement)(_base.default.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n\n      if ((0, _element.overlayContainsElement)(_base.default.CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_LEFT, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_base.default.CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n\n      return new _coords.default(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them\n     */\n\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = (0, _element.innerHeight)(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n\n        if (rowHeader) {\n          rowInnerHeight = (0, _element.innerHeight)(rowHeader);\n        } else {\n          rowInnerHeight = (0, _element.innerHeight)(currentTr) - 1;\n        }\n\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * 0-based index of column header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnHeaderLevelRendered\",\n    value: function isColumnHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * 0-based index of row header\n     *\n     * @param {Number} level\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowHeaderLevelRendered\",\n    value: function isRowHeaderLevelRendered(level) {\n      var columnHeaders = this.wot.getSetting('rowHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return level > columnHeadersCount - 1;\n    }\n    /**\n     * Check if the given row index is smaller than the index of the first row that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the header cells. As a simplification, it checks negative row index\n     * the same way as a regular row 0. You can interpret this as follows: If the row 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} row\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      if (row < 0) {\n        row = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return row < first;\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      if (row < 0) {\n        var columnHeaders = this.wot.getSetting('columnHeaders');\n        var columnHeadersCount = columnHeaders.length;\n        var zeroBasedHeaderLevel = columnHeadersCount + row;\n        return this.isColumnHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return row > this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n    /**\n     * Check if the given column index is smaller than the index of the first column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells. As a simplification, it checks negative column index\n     * the same way as a regular column 0. You can interpret this as follows: If the column 0 is rendered, all header\n     * cells are also rendered.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      if (column < 0) {\n        column = 0;\n      }\n\n      if (first === -1) {\n        return true;\n      }\n\n      return column < first;\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n    /**\n     * Check if the given column index is larger than the index of the last column that is currently redered\n     * and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the header cells.\n     *\n     * @param {Number} column\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      if (column < 0) {\n        var rowHeaders = this.wot.getSetting('rowHeaders');\n        var rowHeadersCount = rowHeaders.length;\n        var zeroBasedHeaderLevel = rowHeadersCount + column;\n        return this.isRowHeaderLevelRendered(zeroBasedHeaderLevel);\n      }\n\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height\n     *\n     * @param {Number} sourceRow\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return (0, _element.isVisible)(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = (0, _function.isFunction)(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n\n      return rowHeaderWidth;\n    }\n  }]);\n\n  return Table;\n}();\n\nvar _default = Table;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}