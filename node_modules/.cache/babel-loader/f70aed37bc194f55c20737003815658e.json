{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenMetadata } from '../modes.js';\nexport function countEOL(text) {\n  var eolCount = 0;\n  var firstLineLength = 0;\n  var lastLineStart = 0;\n  for (var i = 0, len = text.length; i < len; i++) {\n    var chr = text.charCodeAt(i);\n    if (chr === 13 /* CarriageReturn */) {\n      if (eolCount === 0) {\n        firstLineLength = i;\n      }\n      eolCount++;\n      if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n        // \\r\\n... case\n        i++; // skip \\n\n      } else {\n        // \\r... case\n      }\n      lastLineStart = i + 1;\n    } else if (chr === 10 /* LineFeed */) {\n      if (eolCount === 0) {\n        firstLineLength = i;\n      }\n      eolCount++;\n      lastLineStart = i + 1;\n    }\n  }\n  if (eolCount === 0) {\n    firstLineLength = text.length;\n  }\n  return [eolCount, firstLineLength, text.length - lastLineStart];\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */ | 0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */ | 0 /* None */ << 11 /* FONT_STYLE_OFFSET */ | 1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */ | 2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */) >>> 0;\n}\nvar EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\nvar MultilineTokensBuilder = /** @class */function () {\n  function MultilineTokensBuilder() {\n    this.tokens = [];\n  }\n  MultilineTokensBuilder.prototype.add = function (lineNumber, lineTokens) {\n    if (this.tokens.length > 0) {\n      var last = this.tokens[this.tokens.length - 1];\n      var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n      if (lastLineNumber + 1 === lineNumber) {\n        // append\n        last.tokens.push(lineTokens);\n        return;\n      }\n    }\n    this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n  };\n  return MultilineTokensBuilder;\n}();\nexport { MultilineTokensBuilder };\nvar SparseEncodedTokens = /** @class */function () {\n  function SparseEncodedTokens(tokens) {\n    this._tokens = tokens;\n    this._tokenCount = tokens.length / 4;\n  }\n  SparseEncodedTokens.prototype.getMaxDeltaLine = function () {\n    var tokenCount = this.getTokenCount();\n    if (tokenCount === 0) {\n      return -1;\n    }\n    return this.getDeltaLine(tokenCount - 1);\n  };\n  SparseEncodedTokens.prototype.getTokenCount = function () {\n    return this._tokenCount;\n  };\n  SparseEncodedTokens.prototype.getDeltaLine = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex];\n  };\n  SparseEncodedTokens.prototype.getStartCharacter = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex + 1];\n  };\n  SparseEncodedTokens.prototype.getEndCharacter = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex + 2];\n  };\n  SparseEncodedTokens.prototype.getMetadata = function (tokenIndex) {\n    return this._tokens[4 * tokenIndex + 3];\n  };\n  SparseEncodedTokens.prototype.clear = function () {\n    this._tokenCount = 0;\n  };\n  SparseEncodedTokens.prototype.acceptDeleteRange = function (horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n    // This is a bit complex, here are the cases I used to think about this:\n    //\n    // 1. The token starts before the deletion range\n    // 1a. The token is completely before the deletion range\n    //               -----------\n    //                          xxxxxxxxxxx\n    // 1b. The token starts before, the deletion range ends after the token\n    //               -----------\n    //                      xxxxxxxxxxx\n    // 1c. The token starts before, the deletion range ends precisely with the token\n    //               ---------------\n    //                      xxxxxxxx\n    // 1d. The token starts before, the deletion range is inside the token\n    //               ---------------\n    //                    xxxxx\n    //\n    // 2. The token starts at the same position with the deletion range\n    // 2a. The token starts at the same position, and ends inside the deletion range\n    //               -------\n    //               xxxxxxxxxxx\n    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n    //               ----------\n    //               xxxxxxxxxx\n    // 2c. The token starts at the same position, and ends after the deletion range\n    //               -------------\n    //               xxxxxxx\n    //\n    // 3. The token starts inside the deletion range\n    // 3a. The token is inside the deletion range\n    //                -------\n    //             xxxxxxxxxxxxx\n    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n    //                ----------\n    //             xxxxxxxxxxxxx\n    // 3c. The token starts inside the deletion range, and ends after the deletion range\n    //                ------------\n    //             xxxxxxxxxxx\n    //\n    // 4. The token starts after the deletion range\n    //                  -----------\n    //          xxxxxxxx\n    //\n    var tokens = this._tokens;\n    var tokenCount = this._tokenCount;\n    var deletedLineCount = endDeltaLine - startDeltaLine;\n    var newTokenCount = 0;\n    var hasDeletedTokens = false;\n    for (var i = 0; i < tokenCount; i++) {\n      var srcOffset = 4 * i;\n      var tokenDeltaLine = tokens[srcOffset];\n      var tokenStartCharacter = tokens[srcOffset + 1];\n      var tokenEndCharacter = tokens[srcOffset + 2];\n      var tokenMetadata = tokens[srcOffset + 3];\n      if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {\n        // 1a. The token is completely before the deletion range\n        // => nothing to do\n        newTokenCount++;\n        continue;\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n        // 1b, 1c, 1d\n        // => the token survives, but it needs to shrink\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 1d. The token starts before, the deletion range is inside the token\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 1b. The token starts before, the deletion range ends after the token\n          // 1c. The token starts before, the deletion range ends precisely with the token\n          // => the token shrinks its ending to the deletion start\n          tokenEndCharacter = startCharacter;\n        }\n      } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n        // 2a, 2b, 2c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 2c. The token starts at the same position, and ends after the deletion range\n          // => the token shrinks by the deletion character count\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          // 2a. The token starts at the same position, and ends inside the deletion range\n          // 2b. The token starts at the same position, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {\n        // 3a, 3b, 3c\n        if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n          // 3c. The token starts inside the deletion range, and ends after the deletion range\n          // => the token moves left and shrinks\n          if (tokenDeltaLine === startDeltaLine) {\n            // the deletion started on the same line as the token\n            // => the token moves left and shrinks\n            tokenStartCharacter = startCharacter;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          } else {\n            // the deletion started on a line above the token\n            // => the token moves to the beginning of the line\n            tokenStartCharacter = 0;\n            tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n          }\n        } else {\n          // 3a. The token is inside the deletion range\n          // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n          // => the token is deleted\n          hasDeletedTokens = true;\n          continue;\n        }\n      } else if (tokenDeltaLine > endDeltaLine) {\n        // 4. (partial) The token starts after the deletion range, on a line below...\n        if (deletedLineCount === 0 && !hasDeletedTokens) {\n          // early stop, there is no need to walk all the tokens and do nothing...\n          newTokenCount = tokenCount;\n          break;\n        }\n        tokenDeltaLine -= deletedLineCount;\n      } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n        // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n        if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n          tokenStartCharacter += horizontalShiftForFirstLineTokens;\n          tokenEndCharacter += horizontalShiftForFirstLineTokens;\n        }\n        tokenDeltaLine -= deletedLineCount;\n        tokenStartCharacter -= endCharacter - startCharacter;\n        tokenEndCharacter -= endCharacter - startCharacter;\n      } else {\n        throw new Error(\"Not possible!\");\n      }\n      var destOffset = 4 * newTokenCount;\n      tokens[destOffset] = tokenDeltaLine;\n      tokens[destOffset + 1] = tokenStartCharacter;\n      tokens[destOffset + 2] = tokenEndCharacter;\n      tokens[destOffset + 3] = tokenMetadata;\n      newTokenCount++;\n    }\n    this._tokenCount = newTokenCount;\n  };\n  SparseEncodedTokens.prototype.acceptInsertText = function (deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    // Here are the cases I used to think about this:\n    //\n    // 1. The token is completely before the insertion point\n    //            -----------   |\n    // 2. The token ends precisely at the insertion point\n    //            -----------|\n    // 3. The token contains the insertion point\n    //            -----|------\n    // 4. The token starts precisely at the insertion point\n    //            |-----------\n    // 5. The token is completely after the insertion point\n    //            |   -----------\n    //\n    var isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */ || firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */ || firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */);\n    var tokens = this._tokens;\n    var tokenCount = this._tokenCount;\n    for (var i = 0; i < tokenCount; i++) {\n      var offset = 4 * i;\n      var tokenDeltaLine = tokens[offset];\n      var tokenStartCharacter = tokens[offset + 1];\n      var tokenEndCharacter = tokens[offset + 2];\n      if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {\n        // 1. The token is completely before the insertion point\n        // => nothing to do\n        continue;\n      } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n        // 2. The token ends precisely at the insertion point\n        // => expand the end character only if inserting precisely one character that is a word character\n        if (isInsertingPreciselyOneWordCharacter) {\n          tokenEndCharacter += 1;\n        } else {\n          continue;\n        }\n      } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n        // 3. The token contains the insertion point\n        if (eolCount === 0) {\n          // => just expand the end character\n          tokenEndCharacter += firstLineLength;\n        } else {\n          // => cut off the token\n          tokenEndCharacter = character;\n        }\n      } else {\n        // 4. or 5.\n        if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n          // 4. The token starts precisely at the insertion point\n          // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n          // => otherwise behave as in case 5.\n          if (isInsertingPreciselyOneWordCharacter) {\n            continue;\n          }\n        }\n        // => the token must move and keep its size constant\n        if (tokenDeltaLine === deltaLine) {\n          tokenDeltaLine += eolCount;\n          // this token is on the line where the insertion is taking place\n          if (eolCount === 0) {\n            tokenStartCharacter += firstLineLength;\n            tokenEndCharacter += firstLineLength;\n          } else {\n            var tokenLength = tokenEndCharacter - tokenStartCharacter;\n            tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n            tokenEndCharacter = tokenStartCharacter + tokenLength;\n          }\n        } else {\n          tokenDeltaLine += eolCount;\n        }\n      }\n      tokens[offset] = tokenDeltaLine;\n      tokens[offset + 1] = tokenStartCharacter;\n      tokens[offset + 2] = tokenEndCharacter;\n    }\n  };\n  return SparseEncodedTokens;\n}();\nexport { SparseEncodedTokens };\nvar LineTokens2 = /** @class */function () {\n  function LineTokens2(actual, startTokenIndex, endTokenIndex) {\n    this._actual = actual;\n    this._startTokenIndex = startTokenIndex;\n    this._endTokenIndex = endTokenIndex;\n  }\n  LineTokens2.prototype.getCount = function () {\n    return this._endTokenIndex - this._startTokenIndex + 1;\n  };\n  LineTokens2.prototype.getStartCharacter = function (tokenIndex) {\n    return this._actual.getStartCharacter(this._startTokenIndex + tokenIndex);\n  };\n  LineTokens2.prototype.getEndCharacter = function (tokenIndex) {\n    return this._actual.getEndCharacter(this._startTokenIndex + tokenIndex);\n  };\n  LineTokens2.prototype.getMetadata = function (tokenIndex) {\n    return this._actual.getMetadata(this._startTokenIndex + tokenIndex);\n  };\n  return LineTokens2;\n}();\nexport { LineTokens2 };\nvar MultilineTokens2 = /** @class */function () {\n  function MultilineTokens2(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  }\n  MultilineTokens2.prototype._updateEndLineNumber = function () {\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  };\n  MultilineTokens2.prototype.getLineTokens = function (lineNumber) {\n    if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\n      var findResult = MultilineTokens2._findTokensWithLine(this.tokens, lineNumber - this.startLineNumber);\n      if (findResult) {\n        var startTokenIndex = findResult[0],\n          endTokenIndex = findResult[1];\n        return new LineTokens2(this.tokens, startTokenIndex, endTokenIndex);\n      }\n    }\n    return null;\n  };\n  MultilineTokens2._findTokensWithLine = function (tokens, deltaLine) {\n    var low = 0;\n    var high = tokens.getTokenCount() - 1;\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n      var midDeltaLine = tokens.getDeltaLine(mid);\n      if (midDeltaLine < deltaLine) {\n        low = mid + 1;\n      } else if (midDeltaLine > deltaLine) {\n        high = mid - 1;\n      } else {\n        var min = mid;\n        while (min > low && tokens.getDeltaLine(min - 1) === deltaLine) {\n          min--;\n        }\n        var max = mid;\n        while (max < high && tokens.getDeltaLine(max + 1) === deltaLine) {\n          max++;\n        }\n        return [min, max];\n      }\n    }\n    if (tokens.getDeltaLine(low) === deltaLine) {\n      return [low, low];\n    }\n    return null;\n  };\n  MultilineTokens2.prototype.applyEdit = function (range, text) {\n    var _a = countEOL(text),\n      eolCount = _a[0],\n      firstLineLength = _a[1],\n      lastLineLength = _a[2];\n    this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\n  };\n\n  MultilineTokens2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n    this._updateEndLineNumber();\n  };\n  MultilineTokens2.prototype._acceptDeleteRange = function (range) {\n    if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n      // Nothing to delete\n      return;\n    }\n    var firstLineIndex = range.startLineNumber - this.startLineNumber;\n    var lastLineIndex = range.endLineNumber - this.startLineNumber;\n    if (lastLineIndex < 0) {\n      // this deletion occurs entirely before this block, so we only need to adjust line numbers\n      var deletedLinesCount = lastLineIndex - firstLineIndex;\n      this.startLineNumber -= deletedLinesCount;\n      return;\n    }\n    var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n    if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion occurs entirely after this block, so there is nothing to do\n      return;\n    }\n    if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n      // this deletion completely encompasses this block\n      this.startLineNumber = 0;\n      this.tokens.clear();\n      return;\n    }\n    if (firstLineIndex < 0) {\n      var deletedBefore = -firstLineIndex;\n      this.startLineNumber -= deletedBefore;\n      this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n    } else {\n      this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n    }\n  };\n  MultilineTokens2.prototype._acceptInsertText = function (position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n    var lineIndex = position.lineNumber - this.startLineNumber;\n    if (lineIndex < 0) {\n      // this insertion occurs before this block, so we only need to adjust line numbers\n      this.startLineNumber += eolCount;\n      return;\n    }\n    var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n    if (lineIndex >= tokenMaxDeltaLine + 1) {\n      // this insertion occurs after this block, so there is nothing to do\n      return;\n    }\n    this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n  };\n  return MultilineTokens2;\n}();\nexport { MultilineTokens2 };\nvar MultilineTokens = /** @class */function () {\n  function MultilineTokens(startLineNumber, tokens) {\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n  }\n  return MultilineTokens;\n}();\nexport { MultilineTokens };\nfunction toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}\nvar TokensStore2 = /** @class */function () {\n  function TokensStore2() {\n    this._pieces = [];\n  }\n  TokensStore2.prototype.flush = function () {\n    this._pieces = [];\n  };\n  TokensStore2.prototype.set = function (pieces) {\n    this._pieces = pieces || [];\n  };\n  TokensStore2.prototype.addSemanticTokens = function (lineNumber, aTokens) {\n    var pieces = this._pieces;\n    if (pieces.length === 0) {\n      return aTokens;\n    }\n    var pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\n    var bTokens = this._pieces[pieceIndex].getLineTokens(lineNumber);\n    if (!bTokens) {\n      return aTokens;\n    }\n    var aLen = aTokens.getCount();\n    var bLen = bTokens.getCount();\n    var aIndex = 0;\n    var result = [],\n      resultLen = 0;\n    for (var bIndex = 0; bIndex < bLen; bIndex++) {\n      var bStartCharacter = bTokens.getStartCharacter(bIndex);\n      var bEndCharacter = bTokens.getEndCharacter(bIndex);\n      var bMetadata = bTokens.getMetadata(bIndex);\n      var bMask = ((bMetadata & 1 /* SEMANTIC_USE_ITALIC */ ? 2048 /* ITALIC_MASK */ : 0) | (bMetadata & 2 /* SEMANTIC_USE_BOLD */ ? 4096 /* BOLD_MASK */ : 0) | (bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */ ? 8192 /* UNDERLINE_MASK */ : 0) | (bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */ ? 8372224 /* FOREGROUND_MASK */ : 0) | (bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */ ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\n      var aMask = ~bMask >>> 0;\n      // push any token from `a` that is before `b`\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n        result[resultLen++] = aTokens.getEndOffset(aIndex);\n        result[resultLen++] = aTokens.getMetadata(aIndex);\n        aIndex++;\n      }\n      // push the token from `a` if it intersects the token from `b`\n      if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n        result[resultLen++] = bStartCharacter;\n        result[resultLen++] = aTokens.getMetadata(aIndex);\n      }\n      // skip any tokens from `a` that are contained inside `b`\n      while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n        result[resultLen++] = aTokens.getEndOffset(aIndex);\n        result[resultLen++] = aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask;\n        aIndex++;\n      }\n      if (aIndex < aLen && aTokens.getEndOffset(aIndex) === bEndCharacter) {\n        // `a` ends exactly at the same spot as `b`!\n        result[resultLen++] = aTokens.getEndOffset(aIndex);\n        result[resultLen++] = aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask;\n        aIndex++;\n      } else {\n        var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n        // push the token from `b`\n        result[resultLen++] = bEndCharacter;\n        result[resultLen++] = aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask;\n      }\n    }\n    // push the remaining tokens from `a`\n    while (aIndex < aLen) {\n      result[resultLen++] = aTokens.getEndOffset(aIndex);\n      result[resultLen++] = aTokens.getMetadata(aIndex);\n      aIndex++;\n    }\n    return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\n  };\n  TokensStore2._findFirstPieceWithLine = function (pieces, lineNumber) {\n    var low = 0;\n    var high = pieces.length - 1;\n    while (low < high) {\n      var mid = low + Math.floor((high - low) / 2);\n      if (pieces[mid].endLineNumber < lineNumber) {\n        low = mid + 1;\n      } else if (pieces[mid].startLineNumber > lineNumber) {\n        high = mid - 1;\n      } else {\n        while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n          mid--;\n        }\n        return mid;\n      }\n    }\n    return low;\n  };\n  //#region Editing\n  TokensStore2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n    for (var _i = 0, _a = this._pieces; _i < _a.length; _i++) {\n      var piece = _a[_i];\n      piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n  };\n  return TokensStore2;\n}();\nexport { TokensStore2 };\nvar TokensStore = /** @class */function () {\n  function TokensStore() {\n    this._lineTokens = [];\n    this._len = 0;\n  }\n  TokensStore.prototype.flush = function () {\n    this._lineTokens = [];\n    this._len = 0;\n  };\n  TokensStore.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\n    var rawLineTokens = null;\n    if (lineIndex < this._len) {\n      rawLineTokens = this._lineTokens[lineIndex];\n    }\n    if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n      return new LineTokens(toUint32Array(rawLineTokens), lineText);\n    }\n    var lineTokens = new Uint32Array(2);\n    lineTokens[0] = lineText.length;\n    lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n    return new LineTokens(lineTokens, lineText);\n  };\n  TokensStore._massageTokens = function (topLevelLanguageId, lineTextLength, _tokens) {\n    var tokens = _tokens ? toUint32Array(_tokens) : null;\n    if (lineTextLength === 0) {\n      var hasDifferentLanguageId = false;\n      if (tokens && tokens.length > 1) {\n        hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n      }\n      if (!hasDifferentLanguageId) {\n        return EMPTY_LINE_TOKENS;\n      }\n    }\n    if (!tokens || tokens.length === 0) {\n      var tokens_1 = new Uint32Array(2);\n      tokens_1[0] = lineTextLength;\n      tokens_1[1] = getDefaultMetadata(topLevelLanguageId);\n      return tokens_1.buffer;\n    }\n    // Ensure the last token covers the end of the text\n    tokens[tokens.length - 2] = lineTextLength;\n    if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n      // Store directly the ArrayBuffer pointer to save an object\n      return tokens.buffer;\n    }\n    return tokens;\n  };\n  TokensStore.prototype._ensureLine = function (lineIndex) {\n    while (lineIndex >= this._len) {\n      this._lineTokens[this._len] = null;\n      this._len++;\n    }\n  };\n  TokensStore.prototype._deleteLines = function (start, deleteCount) {\n    if (deleteCount === 0) {\n      return;\n    }\n    if (start + deleteCount > this._len) {\n      deleteCount = this._len - start;\n    }\n    this._lineTokens.splice(start, deleteCount);\n    this._len -= deleteCount;\n  };\n  TokensStore.prototype._insertLines = function (insertIndex, insertCount) {\n    if (insertCount === 0) {\n      return;\n    }\n    var lineTokens = [];\n    for (var i = 0; i < insertCount; i++) {\n      lineTokens[i] = null;\n    }\n    this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n    this._len += insertCount;\n  };\n  TokensStore.prototype.setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, _tokens) {\n    var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n    this._ensureLine(lineIndex);\n    this._lineTokens[lineIndex] = tokens;\n  };\n  //#region Editing\n  TokensStore.prototype.acceptEdit = function (range, eolCount, firstLineLength) {\n    this._acceptDeleteRange(range);\n    this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n  };\n  TokensStore.prototype._acceptDeleteRange = function (range) {\n    var firstLineIndex = range.startLineNumber - 1;\n    if (firstLineIndex >= this._len) {\n      return;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      if (range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n      this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n      return;\n    }\n    this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n    var lastLineIndex = range.endLineNumber - 1;\n    var lastLineTokens = null;\n    if (lastLineIndex < this._len) {\n      lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n    }\n    // Take remaining text on last line and append it to remaining text on first line\n    this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\n    // Delete middle lines\n    this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n  };\n  TokensStore.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\n    if (eolCount === 0 && firstLineLength === 0) {\n      // Nothing to insert\n      return;\n    }\n    var lineIndex = position.lineNumber - 1;\n    if (lineIndex >= this._len) {\n      return;\n    }\n    if (eolCount === 0) {\n      // Inserting text on one line\n      this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      return;\n    }\n    this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n    this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n    this._insertLines(position.lineNumber, eolCount);\n  };\n  TokensStore._deleteBeginning = function (lineTokens, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n    return TokensStore._delete(lineTokens, 0, toChIndex);\n  };\n  TokensStore._deleteEnding = function (lineTokens, fromChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n    var tokens = toUint32Array(lineTokens);\n    var lineTextLength = tokens[tokens.length - 2];\n    return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n  };\n  TokensStore._delete = function (lineTokens, fromChIndex, toChIndex) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n      return lineTokens;\n    }\n    var tokens = toUint32Array(lineTokens);\n    var tokensCount = tokens.length >>> 1;\n    // special case: deleting everything\n    if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n      return EMPTY_LINE_TOKENS;\n    }\n    var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n    var fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n    var fromTokenEndOffset = tokens[fromTokenIndex << 1];\n    if (toChIndex < fromTokenEndOffset) {\n      // the delete range is inside a single token\n      var delta_1 = toChIndex - fromChIndex;\n      for (var i = fromTokenIndex; i < tokensCount; i++) {\n        tokens[i << 1] -= delta_1;\n      }\n      return lineTokens;\n    }\n    var dest;\n    var lastEnd;\n    if (fromTokenStartOffset !== fromChIndex) {\n      tokens[fromTokenIndex << 1] = fromChIndex;\n      dest = fromTokenIndex + 1 << 1;\n      lastEnd = fromChIndex;\n    } else {\n      dest = fromTokenIndex << 1;\n      lastEnd = fromTokenStartOffset;\n    }\n    var delta = toChIndex - fromChIndex;\n    for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n      var tokenEndOffset = tokens[tokenIndex << 1] - delta;\n      if (tokenEndOffset > lastEnd) {\n        tokens[dest++] = tokenEndOffset;\n        tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n        lastEnd = tokenEndOffset;\n      }\n    }\n    if (dest === tokens.length) {\n      // nothing to trim\n      return lineTokens;\n    }\n    var tmp = new Uint32Array(dest);\n    tmp.set(tokens.subarray(0, dest), 0);\n    return tmp.buffer;\n  };\n  TokensStore._append = function (lineTokens, _otherTokens) {\n    if (_otherTokens === EMPTY_LINE_TOKENS) {\n      return lineTokens;\n    }\n    if (lineTokens === EMPTY_LINE_TOKENS) {\n      return _otherTokens;\n    }\n    if (lineTokens === null) {\n      return lineTokens;\n    }\n    if (_otherTokens === null) {\n      // cannot determine combined line length...\n      return null;\n    }\n    var myTokens = toUint32Array(lineTokens);\n    var otherTokens = toUint32Array(_otherTokens);\n    var otherTokensCount = otherTokens.length >>> 1;\n    var result = new Uint32Array(myTokens.length + otherTokens.length);\n    result.set(myTokens, 0);\n    var dest = myTokens.length;\n    var delta = myTokens[myTokens.length - 2];\n    for (var i = 0; i < otherTokensCount; i++) {\n      result[dest++] = otherTokens[i << 1] + delta;\n      result[dest++] = otherTokens[(i << 1) + 1];\n    }\n    return result.buffer;\n  };\n  TokensStore._insert = function (lineTokens, chIndex, textLength) {\n    if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n      // nothing to do\n      return lineTokens;\n    }\n    var tokens = toUint32Array(lineTokens);\n    var tokensCount = tokens.length >>> 1;\n    var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n    if (fromTokenIndex > 0) {\n      var fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n      if (fromTokenStartOffset === chIndex) {\n        fromTokenIndex--;\n      }\n    }\n    for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n      tokens[tokenIndex << 1] += textLength;\n    }\n    return lineTokens;\n  };\n  return TokensStore;\n}();\nexport { TokensStore };","map":{"version":3,"names":["arrays","LineTokens","Position","TokenMetadata","countEOL","text","eolCount","firstLineLength","lastLineStart","i","len","length","chr","charCodeAt","getDefaultMetadata","topLevelLanguageId","EMPTY_LINE_TOKENS","Uint32Array","buffer","MultilineTokensBuilder","tokens","prototype","add","lineNumber","lineTokens","last","lastLineNumber","startLineNumber","push","MultilineTokens","SparseEncodedTokens","_tokens","_tokenCount","getMaxDeltaLine","tokenCount","getTokenCount","getDeltaLine","tokenIndex","getStartCharacter","getEndCharacter","getMetadata","clear","acceptDeleteRange","horizontalShiftForFirstLineTokens","startDeltaLine","startCharacter","endDeltaLine","endCharacter","deletedLineCount","newTokenCount","hasDeletedTokens","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","Error","destOffset","acceptInsertText","deltaLine","character","lastLineLength","firstCharCode","isInsertingPreciselyOneWordCharacter","offset","tokenLength","LineTokens2","actual","startTokenIndex","endTokenIndex","_actual","_startTokenIndex","_endTokenIndex","getCount","MultilineTokens2","endLineNumber","_updateEndLineNumber","getLineTokens","findResult","_findTokensWithLine","low","high","mid","Math","floor","midDeltaLine","min","max","applyEdit","range","_a","acceptEdit","_acceptDeleteRange","_acceptInsertText","startColumn","endColumn","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","deletedBefore","position","lineIndex","column","toUint32Array","arr","TokensStore2","_pieces","flush","set","pieces","addSemanticTokens","aTokens","pieceIndex","_findFirstPieceWithLine","bTokens","aLen","bLen","aIndex","result","resultLen","bIndex","bStartCharacter","bEndCharacter","bMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","getLineContent","_i","piece","TokensStore","_lineTokens","_len","getTokens","lineText","rawLineTokens","_massageTokens","lineTextLength","hasDifferentLanguageId","getLanguageId","tokens_1","byteOffset","byteLength","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","arrayInsert","setTokens","_delete","_deleteEnding","lastLineTokens","_deleteBeginning","_append","_insert","toChIndex","fromChIndex","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta_1","dest","lastEnd","delta","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { TokenMetadata } from '../modes.js';\r\nexport function countEOL(text) {\r\n    var eolCount = 0;\r\n    var firstLineLength = 0;\r\n    var lastLineStart = 0;\r\n    for (var i = 0, len = text.length; i < len; i++) {\r\n        var chr = text.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n            }\r\n            lastLineStart = i + 1;\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            lastLineStart = i + 1;\r\n        }\r\n    }\r\n    if (eolCount === 0) {\r\n        firstLineLength = text.length;\r\n    }\r\n    return [eolCount, firstLineLength, text.length - lastLineStart];\r\n}\r\nfunction getDefaultMetadata(topLevelLanguageId) {\r\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\r\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\r\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\r\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\r\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n}\r\nvar EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\r\nvar MultilineTokensBuilder = /** @class */ (function () {\r\n    function MultilineTokensBuilder() {\r\n        this.tokens = [];\r\n    }\r\n    MultilineTokensBuilder.prototype.add = function (lineNumber, lineTokens) {\r\n        if (this.tokens.length > 0) {\r\n            var last = this.tokens[this.tokens.length - 1];\r\n            var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\r\n            if (lastLineNumber + 1 === lineNumber) {\r\n                // append\r\n                last.tokens.push(lineTokens);\r\n                return;\r\n            }\r\n        }\r\n        this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\r\n    };\r\n    return MultilineTokensBuilder;\r\n}());\r\nexport { MultilineTokensBuilder };\r\nvar SparseEncodedTokens = /** @class */ (function () {\r\n    function SparseEncodedTokens(tokens) {\r\n        this._tokens = tokens;\r\n        this._tokenCount = tokens.length / 4;\r\n    }\r\n    SparseEncodedTokens.prototype.getMaxDeltaLine = function () {\r\n        var tokenCount = this.getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return -1;\r\n        }\r\n        return this.getDeltaLine(tokenCount - 1);\r\n    };\r\n    SparseEncodedTokens.prototype.getTokenCount = function () {\r\n        return this._tokenCount;\r\n    };\r\n    SparseEncodedTokens.prototype.getDeltaLine = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex];\r\n    };\r\n    SparseEncodedTokens.prototype.getStartCharacter = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    };\r\n    SparseEncodedTokens.prototype.getEndCharacter = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    };\r\n    SparseEncodedTokens.prototype.getMetadata = function (tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 3];\r\n    };\r\n    SparseEncodedTokens.prototype.clear = function () {\r\n        this._tokenCount = 0;\r\n    };\r\n    SparseEncodedTokens.prototype.acceptDeleteRange = function (horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\r\n        // This is a bit complex, here are the cases I used to think about this:\r\n        //\r\n        // 1. The token starts before the deletion range\r\n        // 1a. The token is completely before the deletion range\r\n        //               -----------\r\n        //                          xxxxxxxxxxx\r\n        // 1b. The token starts before, the deletion range ends after the token\r\n        //               -----------\r\n        //                      xxxxxxxxxxx\r\n        // 1c. The token starts before, the deletion range ends precisely with the token\r\n        //               ---------------\r\n        //                      xxxxxxxx\r\n        // 1d. The token starts before, the deletion range is inside the token\r\n        //               ---------------\r\n        //                    xxxxx\r\n        //\r\n        // 2. The token starts at the same position with the deletion range\r\n        // 2a. The token starts at the same position, and ends inside the deletion range\r\n        //               -------\r\n        //               xxxxxxxxxxx\r\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n        //               ----------\r\n        //               xxxxxxxxxx\r\n        // 2c. The token starts at the same position, and ends after the deletion range\r\n        //               -------------\r\n        //               xxxxxxx\r\n        //\r\n        // 3. The token starts inside the deletion range\r\n        // 3a. The token is inside the deletion range\r\n        //                -------\r\n        //             xxxxxxxxxxxxx\r\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n        //                ----------\r\n        //             xxxxxxxxxxxxx\r\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n        //                ------------\r\n        //             xxxxxxxxxxx\r\n        //\r\n        // 4. The token starts after the deletion range\r\n        //                  -----------\r\n        //          xxxxxxxx\r\n        //\r\n        var tokens = this._tokens;\r\n        var tokenCount = this._tokenCount;\r\n        var deletedLineCount = (endDeltaLine - startDeltaLine);\r\n        var newTokenCount = 0;\r\n        var hasDeletedTokens = false;\r\n        for (var i = 0; i < tokenCount; i++) {\r\n            var srcOffset = 4 * i;\r\n            var tokenDeltaLine = tokens[srcOffset];\r\n            var tokenStartCharacter = tokens[srcOffset + 1];\r\n            var tokenEndCharacter = tokens[srcOffset + 2];\r\n            var tokenMetadata = tokens[srcOffset + 3];\r\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\r\n                // 1a. The token is completely before the deletion range\r\n                // => nothing to do\r\n                newTokenCount++;\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\r\n                // 1b, 1c, 1d\r\n                // => the token survives, but it needs to shrink\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 1d. The token starts before, the deletion range is inside the token\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 1b. The token starts before, the deletion range ends after the token\r\n                    // 1c. The token starts before, the deletion range ends precisely with the token\r\n                    // => the token shrinks its ending to the deletion start\r\n                    tokenEndCharacter = startCharacter;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\r\n                // 2a, 2b, 2c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 2c. The token starts at the same position, and ends after the deletion range\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 2a. The token starts at the same position, and ends inside the deletion range\r\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\r\n                // 3a, 3b, 3c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n                    // => the token moves left and shrinks\r\n                    if (tokenDeltaLine === startDeltaLine) {\r\n                        // the deletion started on the same line as the token\r\n                        // => the token moves left and shrinks\r\n                        tokenStartCharacter = startCharacter;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                    else {\r\n                        // the deletion started on a line above the token\r\n                        // => the token moves to the beginning of the line\r\n                        tokenStartCharacter = 0;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                }\r\n                else {\r\n                    // 3a. The token is inside the deletion range\r\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine > endDeltaLine) {\r\n                // 4. (partial) The token starts after the deletion range, on a line below...\r\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\r\n                    // early stop, there is no need to walk all the tokens and do nothing...\r\n                    newTokenCount = tokenCount;\r\n                    break;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n            }\r\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\r\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\r\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\r\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\r\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n                tokenStartCharacter -= (endCharacter - startCharacter);\r\n                tokenEndCharacter -= (endCharacter - startCharacter);\r\n            }\r\n            else {\r\n                throw new Error(\"Not possible!\");\r\n            }\r\n            var destOffset = 4 * newTokenCount;\r\n            tokens[destOffset] = tokenDeltaLine;\r\n            tokens[destOffset + 1] = tokenStartCharacter;\r\n            tokens[destOffset + 2] = tokenEndCharacter;\r\n            tokens[destOffset + 3] = tokenMetadata;\r\n            newTokenCount++;\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n    };\r\n    SparseEncodedTokens.prototype.acceptInsertText = function (deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        // Here are the cases I used to think about this:\r\n        //\r\n        // 1. The token is completely before the insertion point\r\n        //            -----------   |\r\n        // 2. The token ends precisely at the insertion point\r\n        //            -----------|\r\n        // 3. The token contains the insertion point\r\n        //            -----|------\r\n        // 4. The token starts precisely at the insertion point\r\n        //            |-----------\r\n        // 5. The token is completely after the insertion point\r\n        //            |   -----------\r\n        //\r\n        var isInsertingPreciselyOneWordCharacter = (eolCount === 0\r\n            && firstLineLength === 1\r\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\r\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\r\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\r\n        var tokens = this._tokens;\r\n        var tokenCount = this._tokenCount;\r\n        for (var i = 0; i < tokenCount; i++) {\r\n            var offset = 4 * i;\r\n            var tokenDeltaLine = tokens[offset];\r\n            var tokenStartCharacter = tokens[offset + 1];\r\n            var tokenEndCharacter = tokens[offset + 2];\r\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\r\n                // 1. The token is completely before the insertion point\r\n                // => nothing to do\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\r\n                // 2. The token ends precisely at the insertion point\r\n                // => expand the end character only if inserting precisely one character that is a word character\r\n                if (isInsertingPreciselyOneWordCharacter) {\r\n                    tokenEndCharacter += 1;\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\r\n                // 3. The token contains the insertion point\r\n                if (eolCount === 0) {\r\n                    // => just expand the end character\r\n                    tokenEndCharacter += firstLineLength;\r\n                }\r\n                else {\r\n                    // => cut off the token\r\n                    tokenEndCharacter = character;\r\n                }\r\n            }\r\n            else {\r\n                // 4. or 5.\r\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\r\n                    // 4. The token starts precisely at the insertion point\r\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\r\n                    // => otherwise behave as in case 5.\r\n                    if (isInsertingPreciselyOneWordCharacter) {\r\n                        continue;\r\n                    }\r\n                }\r\n                // => the token must move and keep its size constant\r\n                if (tokenDeltaLine === deltaLine) {\r\n                    tokenDeltaLine += eolCount;\r\n                    // this token is on the line where the insertion is taking place\r\n                    if (eolCount === 0) {\r\n                        tokenStartCharacter += firstLineLength;\r\n                        tokenEndCharacter += firstLineLength;\r\n                    }\r\n                    else {\r\n                        var tokenLength = tokenEndCharacter - tokenStartCharacter;\r\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\r\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\r\n                    }\r\n                }\r\n                else {\r\n                    tokenDeltaLine += eolCount;\r\n                }\r\n            }\r\n            tokens[offset] = tokenDeltaLine;\r\n            tokens[offset + 1] = tokenStartCharacter;\r\n            tokens[offset + 2] = tokenEndCharacter;\r\n        }\r\n    };\r\n    return SparseEncodedTokens;\r\n}());\r\nexport { SparseEncodedTokens };\r\nvar LineTokens2 = /** @class */ (function () {\r\n    function LineTokens2(actual, startTokenIndex, endTokenIndex) {\r\n        this._actual = actual;\r\n        this._startTokenIndex = startTokenIndex;\r\n        this._endTokenIndex = endTokenIndex;\r\n    }\r\n    LineTokens2.prototype.getCount = function () {\r\n        return this._endTokenIndex - this._startTokenIndex + 1;\r\n    };\r\n    LineTokens2.prototype.getStartCharacter = function (tokenIndex) {\r\n        return this._actual.getStartCharacter(this._startTokenIndex + tokenIndex);\r\n    };\r\n    LineTokens2.prototype.getEndCharacter = function (tokenIndex) {\r\n        return this._actual.getEndCharacter(this._startTokenIndex + tokenIndex);\r\n    };\r\n    LineTokens2.prototype.getMetadata = function (tokenIndex) {\r\n        return this._actual.getMetadata(this._startTokenIndex + tokenIndex);\r\n    };\r\n    return LineTokens2;\r\n}());\r\nexport { LineTokens2 };\r\nvar MultilineTokens2 = /** @class */ (function () {\r\n    function MultilineTokens2(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    MultilineTokens2.prototype._updateEndLineNumber = function () {\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    };\r\n    MultilineTokens2.prototype.getLineTokens = function (lineNumber) {\r\n        if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\r\n            var findResult = MultilineTokens2._findTokensWithLine(this.tokens, lineNumber - this.startLineNumber);\r\n            if (findResult) {\r\n                var startTokenIndex = findResult[0], endTokenIndex = findResult[1];\r\n                return new LineTokens2(this.tokens, startTokenIndex, endTokenIndex);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    MultilineTokens2._findTokensWithLine = function (tokens, deltaLine) {\r\n        var low = 0;\r\n        var high = tokens.getTokenCount() - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            var midDeltaLine = tokens.getDeltaLine(mid);\r\n            if (midDeltaLine < deltaLine) {\r\n                low = mid + 1;\r\n            }\r\n            else if (midDeltaLine > deltaLine) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                var min = mid;\r\n                while (min > low && tokens.getDeltaLine(min - 1) === deltaLine) {\r\n                    min--;\r\n                }\r\n                var max = mid;\r\n                while (max < high && tokens.getDeltaLine(max + 1) === deltaLine) {\r\n                    max++;\r\n                }\r\n                return [min, max];\r\n            }\r\n        }\r\n        if (tokens.getDeltaLine(low) === deltaLine) {\r\n            return [low, low];\r\n        }\r\n        return null;\r\n    };\r\n    MultilineTokens2.prototype.applyEdit = function (range, text) {\r\n        var _a = countEOL(text), eolCount = _a[0], firstLineLength = _a[1], lastLineLength = _a[2];\r\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\r\n    };\r\n    MultilineTokens2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        this._updateEndLineNumber();\r\n    };\r\n    MultilineTokens2.prototype._acceptDeleteRange = function (range) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            // Nothing to delete\r\n            return;\r\n        }\r\n        var firstLineIndex = range.startLineNumber - this.startLineNumber;\r\n        var lastLineIndex = range.endLineNumber - this.startLineNumber;\r\n        if (lastLineIndex < 0) {\r\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\r\n            var deletedLinesCount = lastLineIndex - firstLineIndex;\r\n            this.startLineNumber -= deletedLinesCount;\r\n            return;\r\n        }\r\n        var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion occurs entirely after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion completely encompasses this block\r\n            this.startLineNumber = 0;\r\n            this.tokens.clear();\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0) {\r\n            var deletedBefore = -firstLineIndex;\r\n            this.startLineNumber -= deletedBefore;\r\n            this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\r\n        }\r\n        else {\r\n            this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\r\n        }\r\n    };\r\n    MultilineTokens2.prototype._acceptInsertText = function (position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        var lineIndex = position.lineNumber - this.startLineNumber;\r\n        if (lineIndex < 0) {\r\n            // this insertion occurs before this block, so we only need to adjust line numbers\r\n            this.startLineNumber += eolCount;\r\n            return;\r\n        }\r\n        var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this insertion occurs after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n    };\r\n    return MultilineTokens2;\r\n}());\r\nexport { MultilineTokens2 };\r\nvar MultilineTokens = /** @class */ (function () {\r\n    function MultilineTokens(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n    }\r\n    return MultilineTokens;\r\n}());\r\nexport { MultilineTokens };\r\nfunction toUint32Array(arr) {\r\n    if (arr instanceof Uint32Array) {\r\n        return arr;\r\n    }\r\n    else {\r\n        return new Uint32Array(arr);\r\n    }\r\n}\r\nvar TokensStore2 = /** @class */ (function () {\r\n    function TokensStore2() {\r\n        this._pieces = [];\r\n    }\r\n    TokensStore2.prototype.flush = function () {\r\n        this._pieces = [];\r\n    };\r\n    TokensStore2.prototype.set = function (pieces) {\r\n        this._pieces = pieces || [];\r\n    };\r\n    TokensStore2.prototype.addSemanticTokens = function (lineNumber, aTokens) {\r\n        var pieces = this._pieces;\r\n        if (pieces.length === 0) {\r\n            return aTokens;\r\n        }\r\n        var pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\r\n        var bTokens = this._pieces[pieceIndex].getLineTokens(lineNumber);\r\n        if (!bTokens) {\r\n            return aTokens;\r\n        }\r\n        var aLen = aTokens.getCount();\r\n        var bLen = bTokens.getCount();\r\n        var aIndex = 0;\r\n        var result = [], resultLen = 0;\r\n        for (var bIndex = 0; bIndex < bLen; bIndex++) {\r\n            var bStartCharacter = bTokens.getStartCharacter(bIndex);\r\n            var bEndCharacter = bTokens.getEndCharacter(bIndex);\r\n            var bMetadata = bTokens.getMetadata(bIndex);\r\n            var bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 2048 /* ITALIC_MASK */ : 0)\r\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 4096 /* BOLD_MASK */ : 0)\r\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 8192 /* UNDERLINE_MASK */ : 0)\r\n                | ((bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\r\n                | ((bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\r\n            var aMask = (~bMask) >>> 0;\r\n            // push any token from `a` that is before `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = aTokens.getMetadata(aIndex);\r\n                aIndex++;\r\n            }\r\n            // push the token from `a` if it intersects the token from `b`\r\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\r\n                result[resultLen++] = bStartCharacter;\r\n                result[resultLen++] = aTokens.getMetadata(aIndex);\r\n            }\r\n            // skip any tokens from `a` that are contained inside `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask);\r\n                aIndex++;\r\n            }\r\n            if (aIndex < aLen && aTokens.getEndOffset(aIndex) === bEndCharacter) {\r\n                // `a` ends exactly at the same spot as `b`!\r\n                result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n                result[resultLen++] = (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask);\r\n                aIndex++;\r\n            }\r\n            else {\r\n                var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\r\n                // push the token from `b`\r\n                result[resultLen++] = bEndCharacter;\r\n                result[resultLen++] = (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask);\r\n            }\r\n        }\r\n        // push the remaining tokens from `a`\r\n        while (aIndex < aLen) {\r\n            result[resultLen++] = aTokens.getEndOffset(aIndex);\r\n            result[resultLen++] = aTokens.getMetadata(aIndex);\r\n            aIndex++;\r\n        }\r\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\r\n    };\r\n    TokensStore2._findFirstPieceWithLine = function (pieces, lineNumber) {\r\n        var low = 0;\r\n        var high = pieces.length - 1;\r\n        while (low < high) {\r\n            var mid = low + Math.floor((high - low) / 2);\r\n            if (pieces[mid].endLineNumber < lineNumber) {\r\n                low = mid + 1;\r\n            }\r\n            else if (pieces[mid].startLineNumber > lineNumber) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\r\n                    mid--;\r\n                }\r\n                return mid;\r\n            }\r\n        }\r\n        return low;\r\n    };\r\n    //#region Editing\r\n    TokensStore2.prototype.acceptEdit = function (range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        for (var _i = 0, _a = this._pieces; _i < _a.length; _i++) {\r\n            var piece = _a[_i];\r\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        }\r\n    };\r\n    return TokensStore2;\r\n}());\r\nexport { TokensStore2 };\r\nvar TokensStore = /** @class */ (function () {\r\n    function TokensStore() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    TokensStore.prototype.flush = function () {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    };\r\n    TokensStore.prototype.getTokens = function (topLevelLanguageId, lineIndex, lineText) {\r\n        var rawLineTokens = null;\r\n        if (lineIndex < this._len) {\r\n            rawLineTokens = this._lineTokens[lineIndex];\r\n        }\r\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\r\n            return new LineTokens(toUint32Array(rawLineTokens), lineText);\r\n        }\r\n        var lineTokens = new Uint32Array(2);\r\n        lineTokens[0] = lineText.length;\r\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n        return new LineTokens(lineTokens, lineText);\r\n    };\r\n    TokensStore._massageTokens = function (topLevelLanguageId, lineTextLength, _tokens) {\r\n        var tokens = _tokens ? toUint32Array(_tokens) : null;\r\n        if (lineTextLength === 0) {\r\n            var hasDifferentLanguageId = false;\r\n            if (tokens && tokens.length > 1) {\r\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\r\n            }\r\n            if (!hasDifferentLanguageId) {\r\n                return EMPTY_LINE_TOKENS;\r\n            }\r\n        }\r\n        if (!tokens || tokens.length === 0) {\r\n            var tokens_1 = new Uint32Array(2);\r\n            tokens_1[0] = lineTextLength;\r\n            tokens_1[1] = getDefaultMetadata(topLevelLanguageId);\r\n            return tokens_1.buffer;\r\n        }\r\n        // Ensure the last token covers the end of the text\r\n        tokens[tokens.length - 2] = lineTextLength;\r\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\r\n            // Store directly the ArrayBuffer pointer to save an object\r\n            return tokens.buffer;\r\n        }\r\n        return tokens;\r\n    };\r\n    TokensStore.prototype._ensureLine = function (lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._lineTokens[this._len] = null;\r\n            this._len++;\r\n        }\r\n    };\r\n    TokensStore.prototype._deleteLines = function (start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._lineTokens.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    };\r\n    TokensStore.prototype._insertLines = function (insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        var lineTokens = [];\r\n        for (var i = 0; i < insertCount; i++) {\r\n            lineTokens[i] = null;\r\n        }\r\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\r\n        this._len += insertCount;\r\n    };\r\n    TokensStore.prototype.setTokens = function (topLevelLanguageId, lineIndex, lineTextLength, _tokens) {\r\n        var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\r\n        this._ensureLine(lineIndex);\r\n        this._lineTokens[lineIndex] = tokens;\r\n    };\r\n    //#region Editing\r\n    TokensStore.prototype.acceptEdit = function (range, eolCount, firstLineLength) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\r\n    };\r\n    TokensStore.prototype._acceptDeleteRange = function (range) {\r\n        var firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\r\n            return;\r\n        }\r\n        this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\r\n        var lastLineIndex = range.endLineNumber - 1;\r\n        var lastLineTokens = null;\r\n        if (lastLineIndex < this._len) {\r\n            lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\r\n        // Delete middle lines\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    };\r\n    TokensStore.prototype._acceptInsertText = function (position, eolCount, firstLineLength) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        var lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (eolCount === 0) {\r\n            // Inserting text on one line\r\n            this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n            return;\r\n        }\r\n        this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\r\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    };\r\n    TokensStore._deleteBeginning = function (lineTokens, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        return TokensStore._delete(lineTokens, 0, toChIndex);\r\n    };\r\n    TokensStore._deleteEnding = function (lineTokens, fromChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var lineTextLength = tokens[tokens.length - 2];\r\n        return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\r\n    };\r\n    TokensStore._delete = function (lineTokens, fromChIndex, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var tokensCount = (tokens.length >>> 1);\r\n        // special case: deleting everything\r\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\r\n            return EMPTY_LINE_TOKENS;\r\n        }\r\n        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\r\n        var fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\r\n        var fromTokenEndOffset = tokens[fromTokenIndex << 1];\r\n        if (toChIndex < fromTokenEndOffset) {\r\n            // the delete range is inside a single token\r\n            var delta_1 = (toChIndex - fromChIndex);\r\n            for (var i = fromTokenIndex; i < tokensCount; i++) {\r\n                tokens[i << 1] -= delta_1;\r\n            }\r\n            return lineTokens;\r\n        }\r\n        var dest;\r\n        var lastEnd;\r\n        if (fromTokenStartOffset !== fromChIndex) {\r\n            tokens[fromTokenIndex << 1] = fromChIndex;\r\n            dest = ((fromTokenIndex + 1) << 1);\r\n            lastEnd = fromChIndex;\r\n        }\r\n        else {\r\n            dest = (fromTokenIndex << 1);\r\n            lastEnd = fromTokenStartOffset;\r\n        }\r\n        var delta = (toChIndex - fromChIndex);\r\n        for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\r\n            var tokenEndOffset = tokens[tokenIndex << 1] - delta;\r\n            if (tokenEndOffset > lastEnd) {\r\n                tokens[dest++] = tokenEndOffset;\r\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\r\n                lastEnd = tokenEndOffset;\r\n            }\r\n        }\r\n        if (dest === tokens.length) {\r\n            // nothing to trim\r\n            return lineTokens;\r\n        }\r\n        var tmp = new Uint32Array(dest);\r\n        tmp.set(tokens.subarray(0, dest), 0);\r\n        return tmp.buffer;\r\n    };\r\n    TokensStore._append = function (lineTokens, _otherTokens) {\r\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        if (lineTokens === EMPTY_LINE_TOKENS) {\r\n            return _otherTokens;\r\n        }\r\n        if (lineTokens === null) {\r\n            return lineTokens;\r\n        }\r\n        if (_otherTokens === null) {\r\n            // cannot determine combined line length...\r\n            return null;\r\n        }\r\n        var myTokens = toUint32Array(lineTokens);\r\n        var otherTokens = toUint32Array(_otherTokens);\r\n        var otherTokensCount = (otherTokens.length >>> 1);\r\n        var result = new Uint32Array(myTokens.length + otherTokens.length);\r\n        result.set(myTokens, 0);\r\n        var dest = myTokens.length;\r\n        var delta = myTokens[myTokens.length - 2];\r\n        for (var i = 0; i < otherTokensCount; i++) {\r\n            result[dest++] = otherTokens[(i << 1)] + delta;\r\n            result[dest++] = otherTokens[(i << 1) + 1];\r\n        }\r\n        return result.buffer;\r\n    };\r\n    TokensStore._insert = function (lineTokens, chIndex, textLength) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            // nothing to do\r\n            return lineTokens;\r\n        }\r\n        var tokens = toUint32Array(lineTokens);\r\n        var tokensCount = (tokens.length >>> 1);\r\n        var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\r\n        if (fromTokenIndex > 0) {\r\n            var fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\r\n            if (fromTokenStartOffset === chIndex) {\r\n                fromTokenIndex--;\r\n            }\r\n        }\r\n        for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\r\n            tokens[tokenIndex << 1] += textLength;\r\n        }\r\n        return lineTokens;\r\n    };\r\n    return TokensStore;\r\n}());\r\nexport { TokensStore };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}