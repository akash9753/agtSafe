{"ast":null,"code":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n'use strict';\n\nvar FullTextDocument = /** @class */function () {\n  function FullTextDocument(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = undefined;\n  }\n  Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n    get: function get() {\n      return this._uri;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n    get: function get() {\n      return this._languageId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument.prototype, \"version\", {\n    get: function get() {\n      return this._version;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FullTextDocument.prototype.getText = function (range) {\n    if (range) {\n      var start = this.offsetAt(range.start);\n      var end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  };\n  FullTextDocument.prototype.update = function (changes, version) {\n    for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n      var change = changes_1[_i];\n      if (FullTextDocument.isIncremental(change)) {\n        // makes sure start is before end\n        var range = getWellformedRange(change.range);\n        // update content\n        var startOffset = this.offsetAt(range.start);\n        var endOffset = this.offsetAt(range.end);\n        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n        // update the offsets\n        var startLine = Math.max(range.start.line, 0);\n        var endLine = Math.max(range.end.line, 0);\n        var lineOffsets = this._lineOffsets;\n        var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n        if (endLine - startLine === addedLineOffsets.length) {\n          for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n          }\n        } else {\n          if (addedLineOffsets.length < 10000) {\n            lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\n          } else {\n            // avoid too many arguments for splice\n            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n          }\n        }\n        var diff = change.text.length - (endOffset - startOffset);\n        if (diff !== 0) {\n          for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n            lineOffsets[i] = lineOffsets[i] + diff;\n          }\n        }\n      } else if (FullTextDocument.isFull(change)) {\n        this._content = change.text;\n        this._lineOffsets = undefined;\n      } else {\n        throw new Error('Unknown change event received');\n      }\n    }\n    this._version = version;\n  };\n  FullTextDocument.prototype.getLineOffsets = function () {\n    if (this._lineOffsets === undefined) {\n      this._lineOffsets = computeLineOffsets(this._content, true);\n    }\n    return this._lineOffsets;\n  };\n  FullTextDocument.prototype.positionAt = function (offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    var lineOffsets = this.getLineOffsets();\n    var low = 0,\n      high = lineOffsets.length;\n    if (high === 0) {\n      return {\n        line: 0,\n        character: offset\n      };\n    }\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    // low is the least x for which the line offset is larger than the current offset\n    // or array.length if no line offset is larger than the current offset\n    var line = low - 1;\n    return {\n      line: line,\n      character: offset - lineOffsets[line]\n    };\n  };\n  FullTextDocument.prototype.offsetAt = function (position) {\n    var lineOffsets = this.getLineOffsets();\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n    var lineOffset = lineOffsets[position.line];\n    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  };\n  Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n    get: function get() {\n      return this.getLineOffsets().length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FullTextDocument.isIncremental = function (event) {\n    var candidate = event;\n    return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n  };\n  FullTextDocument.isFull = function (event) {\n    var candidate = event;\n    return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n  };\n  return FullTextDocument;\n}();\nexport var TextDocument;\n(function (TextDocument) {\n  /**\r\n   * Creates a new text document.\r\n   *\r\n   * @param uri The document's uri.\r\n   * @param languageId  The document's language Id.\r\n   * @param version The document's initial version number.\r\n   * @param content The document's content.\r\n   */\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument(uri, languageId, version, content);\n  }\n  TextDocument.create = create;\n  /**\r\n   * Updates a TextDocument by modifing its content.\r\n   *\r\n   * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\r\n   * @param changes the changes to apply to the document.\r\n   * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\r\n   *\r\n   */\n  function update(document, changes, version) {\n    if (document instanceof FullTextDocument) {\n      document.update(changes, version);\n      return document;\n    } else {\n      throw new Error('TextDocument.update: document must be created by TextDocument.create');\n    }\n  }\n  TextDocument.update = update;\n  function applyEdits(document, edits) {\n    var text = document.getText();\n    var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n      var diff = a.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    var lastModifiedOffset = text.length;\n    for (var i = sortedEdits.length - 1; i >= 0; i--) {\n      var e = sortedEdits[i];\n      var startOffset = document.offsetAt(e.range.start);\n      var endOffset = document.offsetAt(e.range.end);\n      if (endOffset <= lastModifiedOffset) {\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n      } else {\n        throw new Error('Overlapping edit');\n      }\n      lastModifiedOffset = startOffset;\n    }\n    return text;\n  }\n  TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n  if (data.length <= 1) {\n    // sorted\n    return data;\n  }\n  var p = data.length / 2 | 0;\n  var left = data.slice(0, p);\n  var right = data.slice(p);\n  mergeSort(left, compare);\n  mergeSort(right, compare);\n  var leftIdx = 0;\n  var rightIdx = 0;\n  var i = 0;\n  while (leftIdx < left.length && rightIdx < right.length) {\n    var ret = compare(left[leftIdx], right[rightIdx]);\n    if (ret <= 0) {\n      // smaller_equal -> take left to preserve order\n      data[i++] = left[leftIdx++];\n    } else {\n      // greater -> take right\n      data[i++] = right[rightIdx++];\n    }\n  }\n  while (leftIdx < left.length) {\n    data[i++] = left[leftIdx++];\n  }\n  while (rightIdx < right.length) {\n    data[i++] = right[rightIdx++];\n  }\n  return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n  if (textOffset === void 0) {\n    textOffset = 0;\n  }\n  var result = isAtLineStart ? [textOffset] : [];\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charCodeAt(i);\n    if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\n      if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n        i++;\n      }\n      result.push(textOffset + i + 1);\n    }\n  }\n  return result;\n}\nfunction getWellformedRange(range) {\n  var start = range.start;\n  var end = range.end;\n  if (start.line > end.line || start.line === end.line && start.character > end.character) {\n    return {\n      start: end,\n      end: start\n    };\n  }\n  return range;\n}\nfunction getWellformedEdit(textEdit) {\n  var range = getWellformedRange(textEdit.range);\n  if (range !== textEdit.range) {\n    return {\n      newText: textEdit.newText,\n      range: range\n    };\n  }\n  return textEdit;\n}","map":{"version":3,"names":["FullTextDocument","uri","languageId","version","content","_uri","_languageId","_version","_content","_lineOffsets","undefined","Object","defineProperty","prototype","get","enumerable","configurable","getText","range","start","offsetAt","end","substring","update","changes","_i","changes_1","length","change","isIncremental","getWellformedRange","startOffset","endOffset","text","startLine","Math","max","line","endLine","lineOffsets","addedLineOffsets","computeLineOffsets","i","len","splice","apply","concat","slice","diff","isFull","Error","getLineOffsets","positionAt","offset","min","low","high","character","mid","floor","position","lineOffset","nextLineOffset","event","candidate","rangeLength","TextDocument","create","document","applyEdits","edits","sortedEdits","mergeSort","map","getWellformedEdit","a","b","lastModifiedOffset","e","newText","data","compare","p","left","right","leftIdx","rightIdx","ret","isAtLineStart","textOffset","result","ch","charCodeAt","push","textEdit"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-languageserver-textdocument/lib/esm/main.js"],"sourcesContent":["/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nvar FullTextDocument = /** @class */ (function () {\r\n    function FullTextDocument(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n        get: function () {\r\n            return this._uri;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n        get: function () {\r\n            return this._languageId;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n        get: function () {\r\n            return this._version;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.prototype.getText = function (range) {\r\n        if (range) {\r\n            var start = this.offsetAt(range.start);\r\n            var end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    };\r\n    FullTextDocument.prototype.update = function (changes, version) {\r\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\r\n            var change = changes_1[_i];\r\n            if (FullTextDocument.isIncremental(change)) {\r\n                // makes sure start is before end\r\n                var range = getWellformedRange(change.range);\r\n                // update content\r\n                var startOffset = this.offsetAt(range.start);\r\n                var endOffset = this.offsetAt(range.end);\r\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\r\n                // update the offsets\r\n                var startLine = Math.max(range.start.line, 0);\r\n                var endLine = Math.max(range.end.line, 0);\r\n                var lineOffsets = this._lineOffsets;\r\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\r\n                if (endLine - startLine === addedLineOffsets.length) {\r\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\r\n                    }\r\n                }\r\n                else {\r\n                    if (addedLineOffsets.length < 10000) {\r\n                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\r\n                    }\r\n                    else { // avoid too many arguments for splice\r\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\r\n                    }\r\n                }\r\n                var diff = change.text.length - (endOffset - startOffset);\r\n                if (diff !== 0) {\r\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i] = lineOffsets[i] + diff;\r\n                    }\r\n                }\r\n            }\r\n            else if (FullTextDocument.isFull(change)) {\r\n                this._content = change.text;\r\n                this._lineOffsets = undefined;\r\n            }\r\n            else {\r\n                throw new Error('Unknown change event received');\r\n            }\r\n        }\r\n        this._version = version;\r\n    };\r\n    FullTextDocument.prototype.getLineOffsets = function () {\r\n        if (this._lineOffsets === undefined) {\r\n            this._lineOffsets = computeLineOffsets(this._content, true);\r\n        }\r\n        return this._lineOffsets;\r\n    };\r\n    FullTextDocument.prototype.positionAt = function (offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        var lineOffsets = this.getLineOffsets();\r\n        var low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return { line: 0, character: offset };\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        var line = low - 1;\r\n        return { line: line, character: offset - lineOffsets[line] };\r\n    };\r\n    FullTextDocument.prototype.offsetAt = function (position) {\r\n        var lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        var lineOffset = lineOffsets[position.line];\r\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    };\r\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n        get: function () {\r\n            return this.getLineOffsets().length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FullTextDocument.isIncremental = function (event) {\r\n        var candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\r\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\r\n    };\r\n    FullTextDocument.isFull = function (event) {\r\n        var candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\r\n    };\r\n    return FullTextDocument;\r\n}());\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new text document.\r\n     *\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param version The document's initial version number.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Updates a TextDocument by modifing its content.\r\n     *\r\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\r\n     * @param changes the changes to apply to the document.\r\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\r\n     *\r\n     */\r\n    function update(document, changes, version) {\r\n        if (document instanceof FullTextDocument) {\r\n            document.update(changes, version);\r\n            return document;\r\n        }\r\n        else {\r\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\r\n        }\r\n    }\r\n    TextDocument.update = update;\r\n    function applyEdits(document, edits) {\r\n        var text = document.getText();\r\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\r\n            var diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        var lastModifiedOffset = text.length;\r\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n            var e = sortedEdits[i];\r\n            var startOffset = document.offsetAt(e.range.start);\r\n            var endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n})(TextDocument || (TextDocument = {}));\r\nfunction mergeSort(data, compare) {\r\n    if (data.length <= 1) {\r\n        // sorted\r\n        return data;\r\n    }\r\n    var p = (data.length / 2) | 0;\r\n    var left = data.slice(0, p);\r\n    var right = data.slice(p);\r\n    mergeSort(left, compare);\r\n    mergeSort(right, compare);\r\n    var leftIdx = 0;\r\n    var rightIdx = 0;\r\n    var i = 0;\r\n    while (leftIdx < left.length && rightIdx < right.length) {\r\n        var ret = compare(left[leftIdx], right[rightIdx]);\r\n        if (ret <= 0) {\r\n            // smaller_equal -> take left to preserve order\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        else {\r\n            // greater -> take right\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n    }\r\n    while (leftIdx < left.length) {\r\n        data[i++] = left[leftIdx++];\r\n    }\r\n    while (rightIdx < right.length) {\r\n        data[i++] = right[rightIdx++];\r\n    }\r\n    return data;\r\n}\r\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\r\n    if (textOffset === void 0) { textOffset = 0; }\r\n    var result = isAtLineStart ? [textOffset] : [];\r\n    for (var i = 0; i < text.length; i++) {\r\n        var ch = text.charCodeAt(i);\r\n        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\r\n            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                i++;\r\n            }\r\n            result.push(textOffset + i + 1);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getWellformedRange(range) {\r\n    var start = range.start;\r\n    var end = range.end;\r\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\r\n        return { start: end, end: start };\r\n    }\r\n    return range;\r\n}\r\nfunction getWellformedEdit(textEdit) {\r\n    var range = getWellformedRange(textEdit.range);\r\n    if (range !== textEdit.range) {\r\n        return { newText: textEdit.newText, range: range };\r\n    }\r\n    return textEdit;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AACZ,IAAIA,gBAAgB,GAAG,aAAe,YAAY;EAC9C,SAASA,gBAAgB,CAACC,GAAG,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,EAAE;IACzD,IAAI,CAACC,IAAI,GAAGJ,GAAG;IACf,IAAI,CAACK,WAAW,GAAGJ,UAAU;IAC7B,IAAI,CAACK,QAAQ,GAAGJ,OAAO;IACvB,IAAI,CAACK,QAAQ,GAAGJ,OAAO;IACvB,IAAI,CAACK,YAAY,GAAGC,SAAS;EACjC;EACAC,MAAM,CAACC,cAAc,CAACZ,gBAAgB,CAACa,SAAS,EAAE,KAAK,EAAE;IACrDC,GAAG,EAAE,eAAY;MACb,OAAO,IAAI,CAACT,IAAI;IACpB,CAAC;IACDU,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFL,MAAM,CAACC,cAAc,CAACZ,gBAAgB,CAACa,SAAS,EAAE,YAAY,EAAE;IAC5DC,GAAG,EAAE,eAAY;MACb,OAAO,IAAI,CAACR,WAAW;IAC3B,CAAC;IACDS,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFL,MAAM,CAACC,cAAc,CAACZ,gBAAgB,CAACa,SAAS,EAAE,SAAS,EAAE;IACzDC,GAAG,EAAE,eAAY;MACb,OAAO,IAAI,CAACP,QAAQ;IACxB,CAAC;IACDQ,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFhB,gBAAgB,CAACa,SAAS,CAACI,OAAO,GAAG,UAAUC,KAAK,EAAE;IAClD,IAAIA,KAAK,EAAE;MACP,IAAIC,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACF,KAAK,CAACC,KAAK,CAAC;MACtC,IAAIE,GAAG,GAAG,IAAI,CAACD,QAAQ,CAACF,KAAK,CAACG,GAAG,CAAC;MAClC,OAAO,IAAI,CAACb,QAAQ,CAACc,SAAS,CAACH,KAAK,EAAEE,GAAG,CAAC;IAC9C;IACA,OAAO,IAAI,CAACb,QAAQ;EACxB,CAAC;EACDR,gBAAgB,CAACa,SAAS,CAACU,MAAM,GAAG,UAAUC,OAAO,EAAErB,OAAO,EAAE;IAC5D,KAAK,IAAIsB,EAAE,GAAG,CAAC,EAAEC,SAAS,GAAGF,OAAO,EAAEC,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC/D,IAAIG,MAAM,GAAGF,SAAS,CAACD,EAAE,CAAC;MAC1B,IAAIzB,gBAAgB,CAAC6B,aAAa,CAACD,MAAM,CAAC,EAAE;QACxC;QACA,IAAIV,KAAK,GAAGY,kBAAkB,CAACF,MAAM,CAACV,KAAK,CAAC;QAC5C;QACA,IAAIa,WAAW,GAAG,IAAI,CAACX,QAAQ,CAACF,KAAK,CAACC,KAAK,CAAC;QAC5C,IAAIa,SAAS,GAAG,IAAI,CAACZ,QAAQ,CAACF,KAAK,CAACG,GAAG,CAAC;QACxC,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACc,SAAS,CAAC,CAAC,EAAES,WAAW,CAAC,GAAGH,MAAM,CAACK,IAAI,GAAG,IAAI,CAACzB,QAAQ,CAACc,SAAS,CAACU,SAAS,EAAE,IAAI,CAACxB,QAAQ,CAACmB,MAAM,CAAC;QAChI;QACA,IAAIO,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAClB,KAAK,CAACC,KAAK,CAACkB,IAAI,EAAE,CAAC,CAAC;QAC7C,IAAIC,OAAO,GAAGH,IAAI,CAACC,GAAG,CAAClB,KAAK,CAACG,GAAG,CAACgB,IAAI,EAAE,CAAC,CAAC;QACzC,IAAIE,WAAW,GAAG,IAAI,CAAC9B,YAAY;QACnC,IAAI+B,gBAAgB,GAAGC,kBAAkB,CAACb,MAAM,CAACK,IAAI,EAAE,KAAK,EAAEF,WAAW,CAAC;QAC1E,IAAIO,OAAO,GAAGJ,SAAS,KAAKM,gBAAgB,CAACb,MAAM,EAAE;UACjD,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,gBAAgB,CAACb,MAAM,EAAEe,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;YACzDH,WAAW,CAACG,CAAC,GAAGR,SAAS,GAAG,CAAC,CAAC,GAAGM,gBAAgB,CAACE,CAAC,CAAC;UACxD;QACJ,CAAC,MACI;UACD,IAAIF,gBAAgB,CAACb,MAAM,GAAG,KAAK,EAAE;YACjCY,WAAW,CAACK,MAAM,CAACC,KAAK,CAACN,WAAW,EAAE,CAACL,SAAS,GAAG,CAAC,EAAEI,OAAO,GAAGJ,SAAS,CAAC,CAACY,MAAM,CAACN,gBAAgB,CAAC,CAAC;UACxG,CAAC,MACI;YAAE;YACH,IAAI,CAAC/B,YAAY,GAAG8B,WAAW,GAAGA,WAAW,CAACQ,KAAK,CAAC,CAAC,EAAEb,SAAS,GAAG,CAAC,CAAC,CAACY,MAAM,CAACN,gBAAgB,EAAED,WAAW,CAACQ,KAAK,CAACT,OAAO,GAAG,CAAC,CAAC,CAAC;UAClI;QACJ;QACA,IAAIU,IAAI,GAAGpB,MAAM,CAACK,IAAI,CAACN,MAAM,IAAIK,SAAS,GAAGD,WAAW,CAAC;QACzD,IAAIiB,IAAI,KAAK,CAAC,EAAE;UACZ,KAAK,IAAIN,CAAC,GAAGR,SAAS,GAAG,CAAC,GAAGM,gBAAgB,CAACb,MAAM,EAAEgB,GAAG,GAAGJ,WAAW,CAACZ,MAAM,EAAEe,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;YAC1FH,WAAW,CAACG,CAAC,CAAC,GAAGH,WAAW,CAACG,CAAC,CAAC,GAAGM,IAAI;UAC1C;QACJ;MACJ,CAAC,MACI,IAAIhD,gBAAgB,CAACiD,MAAM,CAACrB,MAAM,CAAC,EAAE;QACtC,IAAI,CAACpB,QAAQ,GAAGoB,MAAM,CAACK,IAAI;QAC3B,IAAI,CAACxB,YAAY,GAAGC,SAAS;MACjC,CAAC,MACI;QACD,MAAM,IAAIwC,KAAK,CAAC,+BAA+B,CAAC;MACpD;IACJ;IACA,IAAI,CAAC3C,QAAQ,GAAGJ,OAAO;EAC3B,CAAC;EACDH,gBAAgB,CAACa,SAAS,CAACsC,cAAc,GAAG,YAAY;IACpD,IAAI,IAAI,CAAC1C,YAAY,KAAKC,SAAS,EAAE;MACjC,IAAI,CAACD,YAAY,GAAGgC,kBAAkB,CAAC,IAAI,CAACjC,QAAQ,EAAE,IAAI,CAAC;IAC/D;IACA,OAAO,IAAI,CAACC,YAAY;EAC5B,CAAC;EACDT,gBAAgB,CAACa,SAAS,CAACuC,UAAU,GAAG,UAAUC,MAAM,EAAE;IACtDA,MAAM,GAAGlB,IAAI,CAACC,GAAG,CAACD,IAAI,CAACmB,GAAG,CAACD,MAAM,EAAE,IAAI,CAAC7C,QAAQ,CAACmB,MAAM,CAAC,EAAE,CAAC,CAAC;IAC5D,IAAIY,WAAW,GAAG,IAAI,CAACY,cAAc,EAAE;IACvC,IAAII,GAAG,GAAG,CAAC;MAAEC,IAAI,GAAGjB,WAAW,CAACZ,MAAM;IACtC,IAAI6B,IAAI,KAAK,CAAC,EAAE;MACZ,OAAO;QAAEnB,IAAI,EAAE,CAAC;QAAEoB,SAAS,EAAEJ;MAAO,CAAC;IACzC;IACA,OAAOE,GAAG,GAAGC,IAAI,EAAE;MACf,IAAIE,GAAG,GAAGvB,IAAI,CAACwB,KAAK,CAAC,CAACJ,GAAG,GAAGC,IAAI,IAAI,CAAC,CAAC;MACtC,IAAIjB,WAAW,CAACmB,GAAG,CAAC,GAAGL,MAAM,EAAE;QAC3BG,IAAI,GAAGE,GAAG;MACd,CAAC,MACI;QACDH,GAAG,GAAGG,GAAG,GAAG,CAAC;MACjB;IACJ;IACA;IACA;IACA,IAAIrB,IAAI,GAAGkB,GAAG,GAAG,CAAC;IAClB,OAAO;MAAElB,IAAI,EAAEA,IAAI;MAAEoB,SAAS,EAAEJ,MAAM,GAAGd,WAAW,CAACF,IAAI;IAAE,CAAC;EAChE,CAAC;EACDrC,gBAAgB,CAACa,SAAS,CAACO,QAAQ,GAAG,UAAUwC,QAAQ,EAAE;IACtD,IAAIrB,WAAW,GAAG,IAAI,CAACY,cAAc,EAAE;IACvC,IAAIS,QAAQ,CAACvB,IAAI,IAAIE,WAAW,CAACZ,MAAM,EAAE;MACrC,OAAO,IAAI,CAACnB,QAAQ,CAACmB,MAAM;IAC/B,CAAC,MACI,IAAIiC,QAAQ,CAACvB,IAAI,GAAG,CAAC,EAAE;MACxB,OAAO,CAAC;IACZ;IACA,IAAIwB,UAAU,GAAGtB,WAAW,CAACqB,QAAQ,CAACvB,IAAI,CAAC;IAC3C,IAAIyB,cAAc,GAAIF,QAAQ,CAACvB,IAAI,GAAG,CAAC,GAAGE,WAAW,CAACZ,MAAM,GAAIY,WAAW,CAACqB,QAAQ,CAACvB,IAAI,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC7B,QAAQ,CAACmB,MAAM;IACrH,OAAOQ,IAAI,CAACC,GAAG,CAACD,IAAI,CAACmB,GAAG,CAACO,UAAU,GAAGD,QAAQ,CAACH,SAAS,EAAEK,cAAc,CAAC,EAAED,UAAU,CAAC;EAC1F,CAAC;EACDlD,MAAM,CAACC,cAAc,CAACZ,gBAAgB,CAACa,SAAS,EAAE,WAAW,EAAE;IAC3DC,GAAG,EAAE,eAAY;MACb,OAAO,IAAI,CAACqC,cAAc,EAAE,CAACxB,MAAM;IACvC,CAAC;IACDZ,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFhB,gBAAgB,CAAC6B,aAAa,GAAG,UAAUkC,KAAK,EAAE;IAC9C,IAAIC,SAAS,GAAGD,KAAK;IACrB,OAAOC,SAAS,KAAKtD,SAAS,IAAIsD,SAAS,KAAK,IAAI,IAChD,OAAOA,SAAS,CAAC/B,IAAI,KAAK,QAAQ,IAAI+B,SAAS,CAAC9C,KAAK,KAAKR,SAAS,KAClEsD,SAAS,CAACC,WAAW,KAAKvD,SAAS,IAAI,OAAOsD,SAAS,CAACC,WAAW,KAAK,QAAQ,CAAC;EAC1F,CAAC;EACDjE,gBAAgB,CAACiD,MAAM,GAAG,UAAUc,KAAK,EAAE;IACvC,IAAIC,SAAS,GAAGD,KAAK;IACrB,OAAOC,SAAS,KAAKtD,SAAS,IAAIsD,SAAS,KAAK,IAAI,IAChD,OAAOA,SAAS,CAAC/B,IAAI,KAAK,QAAQ,IAAI+B,SAAS,CAAC9C,KAAK,KAAKR,SAAS,IAAIsD,SAAS,CAACC,WAAW,KAAKvD,SAAS;EAClH,CAAC;EACD,OAAOV,gBAAgB;AAC3B,CAAC,EAAG;AACJ,OAAO,IAAIkE,YAAY;AACvB,CAAC,UAAUA,YAAY,EAAE;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASC,MAAM,CAAClE,GAAG,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC/C,OAAO,IAAIJ,gBAAgB,CAACC,GAAG,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,CAAC;EAClE;EACA8D,YAAY,CAACC,MAAM,GAAGA,MAAM;EAC5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS5C,MAAM,CAAC6C,QAAQ,EAAE5C,OAAO,EAAErB,OAAO,EAAE;IACxC,IAAIiE,QAAQ,YAAYpE,gBAAgB,EAAE;MACtCoE,QAAQ,CAAC7C,MAAM,CAACC,OAAO,EAAErB,OAAO,CAAC;MACjC,OAAOiE,QAAQ;IACnB,CAAC,MACI;MACD,MAAM,IAAIlB,KAAK,CAAC,sEAAsE,CAAC;IAC3F;EACJ;EACAgB,YAAY,CAAC3C,MAAM,GAAGA,MAAM;EAC5B,SAAS8C,UAAU,CAACD,QAAQ,EAAEE,KAAK,EAAE;IACjC,IAAIrC,IAAI,GAAGmC,QAAQ,CAACnD,OAAO,EAAE;IAC7B,IAAIsD,WAAW,GAAGC,SAAS,CAACF,KAAK,CAACG,GAAG,CAACC,iBAAiB,CAAC,EAAE,UAAUC,CAAC,EAAEC,CAAC,EAAE;MACtE,IAAI5B,IAAI,GAAG2B,CAAC,CAACzD,KAAK,CAACC,KAAK,CAACkB,IAAI,GAAGuC,CAAC,CAAC1D,KAAK,CAACC,KAAK,CAACkB,IAAI;MAClD,IAAIW,IAAI,KAAK,CAAC,EAAE;QACZ,OAAO2B,CAAC,CAACzD,KAAK,CAACC,KAAK,CAACsC,SAAS,GAAGmB,CAAC,CAAC1D,KAAK,CAACC,KAAK,CAACsC,SAAS;MAC5D;MACA,OAAOT,IAAI;IACf,CAAC,CAAC;IACF,IAAI6B,kBAAkB,GAAG5C,IAAI,CAACN,MAAM;IACpC,KAAK,IAAIe,CAAC,GAAG6B,WAAW,CAAC5C,MAAM,GAAG,CAAC,EAAEe,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC9C,IAAIoC,CAAC,GAAGP,WAAW,CAAC7B,CAAC,CAAC;MACtB,IAAIX,WAAW,GAAGqC,QAAQ,CAAChD,QAAQ,CAAC0D,CAAC,CAAC5D,KAAK,CAACC,KAAK,CAAC;MAClD,IAAIa,SAAS,GAAGoC,QAAQ,CAAChD,QAAQ,CAAC0D,CAAC,CAAC5D,KAAK,CAACG,GAAG,CAAC;MAC9C,IAAIW,SAAS,IAAI6C,kBAAkB,EAAE;QACjC5C,IAAI,GAAGA,IAAI,CAACX,SAAS,CAAC,CAAC,EAAES,WAAW,CAAC,GAAG+C,CAAC,CAACC,OAAO,GAAG9C,IAAI,CAACX,SAAS,CAACU,SAAS,EAAEC,IAAI,CAACN,MAAM,CAAC;MAC9F,CAAC,MACI;QACD,MAAM,IAAIuB,KAAK,CAAC,kBAAkB,CAAC;MACvC;MACA2B,kBAAkB,GAAG9C,WAAW;IACpC;IACA,OAAOE,IAAI;EACf;EACAiC,YAAY,CAACG,UAAU,GAAGA,UAAU;AACxC,CAAC,EAAEH,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;AACvC,SAASM,SAAS,CAACQ,IAAI,EAAEC,OAAO,EAAE;EAC9B,IAAID,IAAI,CAACrD,MAAM,IAAI,CAAC,EAAE;IAClB;IACA,OAAOqD,IAAI;EACf;EACA,IAAIE,CAAC,GAAIF,IAAI,CAACrD,MAAM,GAAG,CAAC,GAAI,CAAC;EAC7B,IAAIwD,IAAI,GAAGH,IAAI,CAACjC,KAAK,CAAC,CAAC,EAAEmC,CAAC,CAAC;EAC3B,IAAIE,KAAK,GAAGJ,IAAI,CAACjC,KAAK,CAACmC,CAAC,CAAC;EACzBV,SAAS,CAACW,IAAI,EAAEF,OAAO,CAAC;EACxBT,SAAS,CAACY,KAAK,EAAEH,OAAO,CAAC;EACzB,IAAII,OAAO,GAAG,CAAC;EACf,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAI5C,CAAC,GAAG,CAAC;EACT,OAAO2C,OAAO,GAAGF,IAAI,CAACxD,MAAM,IAAI2D,QAAQ,GAAGF,KAAK,CAACzD,MAAM,EAAE;IACrD,IAAI4D,GAAG,GAAGN,OAAO,CAACE,IAAI,CAACE,OAAO,CAAC,EAAED,KAAK,CAACE,QAAQ,CAAC,CAAC;IACjD,IAAIC,GAAG,IAAI,CAAC,EAAE;MACV;MACAP,IAAI,CAACtC,CAAC,EAAE,CAAC,GAAGyC,IAAI,CAACE,OAAO,EAAE,CAAC;IAC/B,CAAC,MACI;MACD;MACAL,IAAI,CAACtC,CAAC,EAAE,CAAC,GAAG0C,KAAK,CAACE,QAAQ,EAAE,CAAC;IACjC;EACJ;EACA,OAAOD,OAAO,GAAGF,IAAI,CAACxD,MAAM,EAAE;IAC1BqD,IAAI,CAACtC,CAAC,EAAE,CAAC,GAAGyC,IAAI,CAACE,OAAO,EAAE,CAAC;EAC/B;EACA,OAAOC,QAAQ,GAAGF,KAAK,CAACzD,MAAM,EAAE;IAC5BqD,IAAI,CAACtC,CAAC,EAAE,CAAC,GAAG0C,KAAK,CAACE,QAAQ,EAAE,CAAC;EACjC;EACA,OAAON,IAAI;AACf;AACA,SAASvC,kBAAkB,CAACR,IAAI,EAAEuD,aAAa,EAAEC,UAAU,EAAE;EACzD,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;IAAEA,UAAU,GAAG,CAAC;EAAE;EAC7C,IAAIC,MAAM,GAAGF,aAAa,GAAG,CAACC,UAAU,CAAC,GAAG,EAAE;EAC9C,KAAK,IAAI/C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAACN,MAAM,EAAEe,CAAC,EAAE,EAAE;IAClC,IAAIiD,EAAE,GAAG1D,IAAI,CAAC2D,UAAU,CAAClD,CAAC,CAAC;IAC3B,IAAIiD,EAAE,KAAK,EAAE,CAAC,wBAAwBA,EAAE,KAAK,EAAE,CAAC,gBAAgB;MAC5D,IAAIA,EAAE,KAAK,EAAE,CAAC,wBAAwBjD,CAAC,GAAG,CAAC,GAAGT,IAAI,CAACN,MAAM,IAAIM,IAAI,CAAC2D,UAAU,CAAClD,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,gBAAgB;QACvGA,CAAC,EAAE;MACP;MACAgD,MAAM,CAACG,IAAI,CAACJ,UAAU,GAAG/C,CAAC,GAAG,CAAC,CAAC;IACnC;EACJ;EACA,OAAOgD,MAAM;AACjB;AACA,SAAS5D,kBAAkB,CAACZ,KAAK,EAAE;EAC/B,IAAIC,KAAK,GAAGD,KAAK,CAACC,KAAK;EACvB,IAAIE,GAAG,GAAGH,KAAK,CAACG,GAAG;EACnB,IAAIF,KAAK,CAACkB,IAAI,GAAGhB,GAAG,CAACgB,IAAI,IAAKlB,KAAK,CAACkB,IAAI,KAAKhB,GAAG,CAACgB,IAAI,IAAIlB,KAAK,CAACsC,SAAS,GAAGpC,GAAG,CAACoC,SAAU,EAAE;IACvF,OAAO;MAAEtC,KAAK,EAAEE,GAAG;MAAEA,GAAG,EAAEF;IAAM,CAAC;EACrC;EACA,OAAOD,KAAK;AAChB;AACA,SAASwD,iBAAiB,CAACoB,QAAQ,EAAE;EACjC,IAAI5E,KAAK,GAAGY,kBAAkB,CAACgE,QAAQ,CAAC5E,KAAK,CAAC;EAC9C,IAAIA,KAAK,KAAK4E,QAAQ,CAAC5E,KAAK,EAAE;IAC1B,OAAO;MAAE6D,OAAO,EAAEe,QAAQ,CAACf,OAAO;MAAE7D,KAAK,EAAEA;IAAM,CAAC;EACtD;EACA,OAAO4E,QAAQ;AACnB"},"metadata":{},"sourceType":"module"}