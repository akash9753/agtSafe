{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\nimport * as process from './process.js';\nvar CHAR_UPPERCASE_A = 65; /* A */\nvar CHAR_LOWERCASE_A = 97; /* a */\nvar CHAR_UPPERCASE_Z = 90; /* Z */\nvar CHAR_LOWERCASE_Z = 122; /* z */\nvar CHAR_DOT = 46; /* . */\nvar CHAR_FORWARD_SLASH = 47; /* / */\nvar CHAR_BACKWARD_SLASH = 92; /* \\ */\nvar CHAR_COLON = 58; /* : */\nvar CHAR_QUESTION_MARK = 63; /* ? */\nvar ErrorInvalidArgType = /** @class */function (_super) {\n  __extends(ErrorInvalidArgType, _super);\n  function ErrorInvalidArgType(name, expected, actual) {\n    var _this = this;\n    // determiner: 'must be' or 'must not be'\n    var determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n    var type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    var msg = \"The \\\"\" + name + \"\\\" \" + type + \" \" + determiner + \" of type \" + expected;\n    msg += \". Received type \" + typeof actual;\n    _this = _super.call(this, msg) || this;\n    _this.code = 'ERR_INVALID_ARG_TYPE';\n    return _this;\n  }\n  return ErrorInvalidArgType;\n}(Error);\nfunction validateString(value, name) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += separator + \"..\";\n          } else {\n            res = '..';\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += separator + path.slice(lastSlash + 1, i);\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\nexport var win32 = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var pathSegments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      pathSegments[_i] = arguments[_i];\n    }\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n    for (var i = pathSegments.length - 1; i >= -1; i--) {\n      var path = void 0;\n      if (i >= 0) {\n        path = pathSegments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env['=' + resolvedDevice] || process.cwd();\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined || path.slice(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n      validateString(path, 'path');\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n      var len = path.length;\n      var rootEnd = 0;\n      var device = '';\n      var isAbsolute = false;\n      var code = path.charCodeAt(0);\n      // Try to match a root\n      if (len > 1) {\n        if (isPathSeparator(code)) {\n          // Possible UNC root\n          // If we started with a separator, we know we at least have an\n          // absolute path of some kind (UNC or otherwise)\n          isAbsolute = true;\n          if (isPathSeparator(path.charCodeAt(1))) {\n            // Matched double path separator at beginning\n            var j = 2;\n            var last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              if (isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n            if (j < len && j !== last) {\n              var firstPart = path.slice(last, j);\n              // Matched!\n              last = j;\n              // Match 1 or more path separators\n              for (; j < len; ++j) {\n                if (!isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n              if (j < len && j !== last) {\n                // Matched!\n                last = j;\n                // Match 1 or more non-path separators\n                for (; j < len; ++j) {\n                  if (isPathSeparator(path.charCodeAt(j))) {\n                    break;\n                  }\n                }\n                if (j === len) {\n                  // We matched a UNC root only\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n                  rootEnd = j;\n                } else if (j !== last) {\n                  // We matched a UNC root with leftovers\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                  rootEnd = j;\n                }\n              }\n            }\n          } else {\n            rootEnd = 1;\n          }\n        } else if (isWindowsDeviceRoot(code)) {\n          // Possible device root\n          if (path.charCodeAt(1) === CHAR_COLON) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2) {\n              if (isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n              }\n            }\n          }\n        }\n      } else if (isPathSeparator(code)) {\n        // `path` contains just a path separator\n        rootEnd = 1;\n        isAbsolute = true;\n      }\n      if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n      if (resolvedDevice.length === 0 && device.length > 0) {\n        resolvedDevice = device;\n      }\n      if (!resolvedAbsolute) {\n        resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n      if (resolvedDevice.length > 0 && resolvedAbsolute) {\n        break;\n      }\n    }\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n    return resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail || '.';\n  },\n  normalize: function normalize(path) {\n    validateString(path, 'path');\n    var len = path.length;\n    if (len === 0) {\n      return '.';\n    }\n    var rootEnd = 0;\n    var device;\n    var isAbsolute = false;\n    var code = path.charCodeAt(0);\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        // If we started with a separator, we know we at least have an absolute\n        // path of some kind (UNC or otherwise)\n        isAbsolute = true;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n          if (j < len && j !== last) {\n            var firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                // Return the normalized version of the UNC root since there\n                // is nothing left to process\n                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid unnecessary\n      // work\n      return '\\\\';\n    }\n    var tail;\n    if (rootEnd < len) {\n      tail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator);\n    } else {\n      tail = '';\n    }\n    if (tail.length === 0 && !isAbsolute) {\n      tail = '.';\n    }\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += '\\\\';\n    }\n    if (device === undefined) {\n      if (isAbsolute) {\n        if (tail.length > 0) {\n          return '\\\\' + tail;\n        } else {\n          return '\\\\';\n        }\n      } else if (tail.length > 0) {\n        return tail;\n      } else {\n        return '';\n      }\n    } else if (isAbsolute) {\n      if (tail.length > 0) {\n        return device + '\\\\' + tail;\n      } else {\n        return device + '\\\\';\n      }\n    } else if (tail.length > 0) {\n      return device + tail;\n    } else {\n      return device;\n    }\n  },\n  isAbsolute: function isAbsolute(path) {\n    validateString(path, 'path');\n    var len = path.length;\n    if (len === 0) {\n      return false;\n    }\n    var code = path.charCodeAt(0);\n    if (isPathSeparator(code)) {\n      return true;\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n      if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n        if (isPathSeparator(path.charCodeAt(2))) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  join: function join() {\n    var paths = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      paths[_i] = arguments[_i];\n    }\n    if (paths.length === 0) {\n      return '.';\n    }\n    var joined;\n    var firstPart;\n    for (var i = 0; i < paths.length; ++i) {\n      var arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = firstPart = arg;\n        } else {\n          joined += '\\\\' + arg;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    var needsReplace = true;\n    var slashCount = 0;\n    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      var firstLen = firstPart.length;\n      if (firstLen > 1) {\n        if (isPathSeparator(firstPart.charCodeAt(1))) {\n          ++slashCount;\n          if (firstLen > 2) {\n            if (isPathSeparator(firstPart.charCodeAt(2))) {\n              ++slashCount;\n            } else {\n              // We matched a UNC path in the first part\n              needsReplace = false;\n            }\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      for (; slashCount < joined.length; ++slashCount) {\n        if (!isPathSeparator(joined.charCodeAt(slashCount))) {\n          break;\n        }\n      }\n      // Replace the slashes if needed\n      if (slashCount >= 2) {\n        joined = '\\\\' + joined.slice(slashCount);\n      }\n    }\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n    if (from === to) {\n      return '';\n    }\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n    if (fromOrig === toOrig) {\n      return '';\n    }\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n    if (from === to) {\n      return '';\n    }\n    // Trim any leading backslashes\n    var fromStart = 0;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var fromEnd = from.length;\n    for (; fromEnd - 1 > fromStart; --fromEnd) {\n      if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n    var fromLen = fromEnd - fromStart;\n    // Trim any leading backslashes\n    var toStart = 0;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var toEnd = to.length;\n    for (; toEnd - 1 > toStart; --toEnd) {\n      if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\n        break;\n      }\n    }\n    var toLen = toEnd - toStart;\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n            return toOrig.slice(toStart + i + 1);\n          } else if (i === 2) {\n            // We get here if `from` is the device root.\n            // For example: from='C:\\\\'; to='C:\\\\foo'\n            return toOrig.slice(toStart + i);\n          }\n        }\n        if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n            lastCommonSep = i;\n          } else if (i === 2) {\n            // We get here if `to` is the device root.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n            lastCommonSep = 3;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length && lastCommonSep === -1) {\n      return toOrig;\n    }\n    var out = '';\n    if (lastCommonSep === -1) {\n      lastCommonSep = 0;\n    }\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        if (out.length === 0) {\n          out += '..';\n        } else {\n          out += '\\\\..';\n        }\n      }\n    }\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) {\n      return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    } else {\n      toStart += lastCommonSep;\n      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n        ++toStart;\n      }\n      return toOrig.slice(toStart, toEnd);\n    }\n  },\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string') {\n      return path;\n    }\n    if (path.length === 0) {\n      return '';\n    }\n    var resolvedPath = win32.resolve(path);\n    if (resolvedPath.length >= 3) {\n      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n        // Possible UNC root\n        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n          var code = resolvedPath.charCodeAt(2);\n          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n            // Matched non-long UNC root, convert the path to a long UNC path\n            return \"\\\\\\\\?\\\\UNC\\\\\" + resolvedPath.slice(2);\n          }\n        }\n      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n        // Possible device root\n        if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          // Matched device root, convert the path to a long UNC path\n          return '\\\\\\\\?\\\\' + resolvedPath;\n        }\n      }\n    }\n    return path;\n  },\n  dirname: function dirname(path) {\n    validateString(path, 'path');\n    var len = path.length;\n    if (len === 0) {\n      return '.';\n    }\n    var rootEnd = -1;\n    var end = -1;\n    var matchedSlash = true;\n    var offset = 0;\n    var code = path.charCodeAt(0);\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        rootEnd = offset = 1;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                return path;\n              }\n              if (j !== last) {\n                // We matched a UNC root with leftovers\n                // Offset by 1 to include the separator after the UNC root to\n                // treat it as a \"normal root\" on top of a (UNC) root\n                rootEnd = offset = j + 1;\n              }\n            }\n          }\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          rootEnd = offset = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              rootEnd = offset = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      return path;\n    }\n    for (var i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return '.';\n      } else {\n        end = rootEnd;\n      }\n    }\n    return path.slice(0, end);\n  },\n  basename: function basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2) {\n      var drive = path.charCodeAt(0);\n      if (isWindowsDeviceRoot(drive)) {\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          start = 2;\n        }\n      }\n    }\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= start; --i) {\n        var code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= start; --i) {\n        if (isPathSeparator(path.charCodeAt(i))) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n      if (end === -1) {\n        return '';\n      }\n      return path.slice(start, end);\n    }\n  },\n  extname: function extname(path) {\n    validateString(path, 'path');\n    var start = 0;\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n    for (var i = path.length - 1; i >= start; --i) {\n      var code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    return _format('\\\\', pathObject);\n  },\n  parse: function parse(path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        rootEnd = 1;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            if (isPathSeparator(path.charCodeAt(j))) {\n              break;\n            }\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              if (!isPathSeparator(path.charCodeAt(j))) {\n                break;\n              }\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                if (isPathSeparator(path.charCodeAt(j))) {\n                  break;\n                }\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                rootEnd = j + 1;\n              }\n            }\n          }\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          rootEnd = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              if (len === 3) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n              }\n              rootEnd = 3;\n            }\n          } else {\n            // `path` contains just a drive root, exit early to avoid\n            // unnecessary work\n            ret.root = ret.dir = path;\n            return ret;\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      ret.root = ret.dir = path;\n      return ret;\n    }\n    if (rootEnd > 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n    var startDot = -1;\n    var startPart = rootEnd;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n      ret.ext = path.slice(startDot, end);\n    }\n    // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n    return ret;\n  },\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\nexport var posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var pathSegments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      pathSegments[_i] = arguments[_i];\n    }\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    for (var i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = void 0;\n      if (i >= 0) {\n        path = pathSegments[i];\n      } else {\n        path = process.cwd();\n      }\n      validateString(path, 'path');\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0) {\n        return '/' + resolvedPath;\n      } else {\n        return '/';\n      }\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n  normalize: function normalize(path) {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n    // Normalize the path\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n    if (path.length === 0 && !isAbsolute) {\n      path = '.';\n    }\n    if (path.length > 0 && trailingSeparator) {\n      path += '/';\n    }\n    if (isAbsolute) {\n      return '/' + path;\n    }\n    return path;\n  },\n  isAbsolute: function isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join: function join() {\n    var paths = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      paths[_i] = arguments[_i];\n    }\n    if (paths.length === 0) {\n      return '.';\n    }\n    var joined;\n    for (var i = 0; i < paths.length; ++i) {\n      var arg = arguments[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += '/' + arg;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n  relative: function relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n    if (from === to) {\n      return '';\n    }\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) {\n      return '';\n    }\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\n        break;\n      }\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\n        break;\n      }\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (out.length === 0) {\n          out += '..';\n        } else {\n          out += '/..';\n        }\n      }\n    }\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) {\n      return out + to.slice(toStart + lastCommonSep);\n    } else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\n        ++toStart;\n      }\n      return to.slice(toStart);\n    }\n  },\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  },\n  dirname: function dirname(path) {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n  basename: function basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n      if (end === -1) {\n        return '';\n      }\n      return path.slice(start, end);\n    }\n  },\n  extname: function extname(path) {\n    validateString(path, 'path');\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n    }\n    return _format('/', pathObject);\n  },\n  parse: function parse(path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    // Get non-dir info\n    for (; i >= start; --i) {\n      var code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) {\n          ret.base = ret.name = path.slice(1, end);\n        } else {\n          ret.base = ret.name = path.slice(startPart, end);\n        }\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport var normalize = process.platform === 'win32' ? win32.normalize : posix.normalize;\nexport var join = process.platform === 'win32' ? win32.join : posix.join;\nexport var relative = process.platform === 'win32' ? win32.relative : posix.relative;\nexport var dirname = process.platform === 'win32' ? win32.dirname : posix.dirname;\nexport var basename = process.platform === 'win32' ? win32.basename : posix.basename;\nexport var extname = process.platform === 'win32' ? win32.extname : posix.extname;\nexport var sep = process.platform === 'win32' ? win32.sep : posix.sep;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","process","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","_super","name","expected","actual","_this","determiner","indexOf","replace","type","msg","call","code","Error","validateString","value","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","ext","win32","resolve","pathSegments","_i","arguments","resolvedDevice","resolvedTail","resolvedAbsolute","cwd","env","undefined","toLowerCase","len","rootEnd","device","isAbsolute","j","last","firstPart","normalize","tail","join","paths","joined","arg","needsReplace","slashCount","firstLen","relative","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","toCode","out","toNamespacedPath","resolvedPath","dirname","end","matchedSlash","offset","basename","start","drive","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","parse","ret","delimiter","posix","trailingSeparator","hasRoot","platform"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/common/path.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\r\n// Copied from: https://github.com/nodejs/node/tree/43dd49c9782848c25e5b03448c8a0f923f13c158\r\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\nimport * as process from './process.js';\r\nvar CHAR_UPPERCASE_A = 65; /* A */\r\nvar CHAR_LOWERCASE_A = 97; /* a */\r\nvar CHAR_UPPERCASE_Z = 90; /* Z */\r\nvar CHAR_LOWERCASE_Z = 122; /* z */\r\nvar CHAR_DOT = 46; /* . */\r\nvar CHAR_FORWARD_SLASH = 47; /* / */\r\nvar CHAR_BACKWARD_SLASH = 92; /* \\ */\r\nvar CHAR_COLON = 58; /* : */\r\nvar CHAR_QUESTION_MARK = 63; /* ? */\r\nvar ErrorInvalidArgType = /** @class */ (function (_super) {\r\n    __extends(ErrorInvalidArgType, _super);\r\n    function ErrorInvalidArgType(name, expected, actual) {\r\n        var _this = this;\r\n        // determiner: 'must be' or 'must not be'\r\n        var determiner;\r\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\r\n            determiner = 'must not be';\r\n            expected = expected.replace(/^not /, '');\r\n        }\r\n        else {\r\n            determiner = 'must be';\r\n        }\r\n        var type = name.indexOf('.') !== -1 ? 'property' : 'argument';\r\n        var msg = \"The \\\"\" + name + \"\\\" \" + type + \" \" + determiner + \" of type \" + expected;\r\n        msg += \". Received type \" + typeof actual;\r\n        _this = _super.call(this, msg) || this;\r\n        _this.code = 'ERR_INVALID_ARG_TYPE';\r\n        return _this;\r\n    }\r\n    return ErrorInvalidArgType;\r\n}(Error));\r\nfunction validateString(value, name) {\r\n    if (typeof value !== 'string') {\r\n        throw new ErrorInvalidArgType(name, 'string', value);\r\n    }\r\n}\r\nfunction isPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\r\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\r\n}\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    var res = '';\r\n    var lastSegmentLength = 0;\r\n    var lastSlash = -1;\r\n    var dots = 0;\r\n    var code;\r\n    for (var i = 0; i <= path.length; ++i) {\r\n        if (i < path.length) {\r\n            code = path.charCodeAt(i);\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            break;\r\n        }\r\n        else {\r\n            code = CHAR_FORWARD_SLASH;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {\r\n                // NOOP\r\n            }\r\n            else if (lastSlash !== i - 1 && dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 ||\r\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\r\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\r\n                    if (res.length > 2) {\r\n                        var lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = '';\r\n                            lastSegmentLength = 0;\r\n                        }\r\n                        else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                    else if (res.length === 2 || res.length === 1) {\r\n                        res = '';\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    if (res.length > 0) {\r\n                        res += separator + \"..\";\r\n                    }\r\n                    else {\r\n                        res = '..';\r\n                    }\r\n                    lastSegmentLength = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (res.length > 0) {\r\n                    res += separator + path.slice(lastSlash + 1, i);\r\n                }\r\n                else {\r\n                    res = path.slice(lastSlash + 1, i);\r\n                }\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        }\r\n        else if (code === CHAR_DOT && dots !== -1) {\r\n            ++dots;\r\n        }\r\n        else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    var dir = pathObject.dir || pathObject.root;\r\n    var base = pathObject.base ||\r\n        ((pathObject.name || '') + (pathObject.ext || ''));\r\n    if (!dir) {\r\n        return base;\r\n    }\r\n    if (dir === pathObject.root) {\r\n        return dir + base;\r\n    }\r\n    return dir + sep + base;\r\n}\r\nexport var win32 = {\r\n    // path.resolve([from ...], to)\r\n    resolve: function () {\r\n        var pathSegments = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            pathSegments[_i] = arguments[_i];\r\n        }\r\n        var resolvedDevice = '';\r\n        var resolvedTail = '';\r\n        var resolvedAbsolute = false;\r\n        for (var i = pathSegments.length - 1; i >= -1; i--) {\r\n            var path = void 0;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n            }\r\n            else if (!resolvedDevice) {\r\n                path = process.cwd();\r\n            }\r\n            else {\r\n                // Windows has the concept of drive-specific current working\r\n                // directories. If we've resolved a drive letter but not yet an\r\n                // absolute path, get cwd for that drive, or the process cwd if\r\n                // the drive cwd is not available. We're sure the device is not\r\n                // a UNC path at this points, because UNC paths are always absolute.\r\n                path = process.env['=' + resolvedDevice] || process.cwd();\r\n                // Verify that a cwd was found and that it actually points\r\n                // to our drive. If not, default to the drive's root.\r\n                if (path === undefined ||\r\n                    path.slice(0, 3).toLowerCase() !==\r\n                        resolvedDevice.toLowerCase() + '\\\\') {\r\n                    path = resolvedDevice + '\\\\';\r\n                }\r\n            }\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            var len = path.length;\r\n            var rootEnd = 0;\r\n            var device = '';\r\n            var isAbsolute = false;\r\n            var code = path.charCodeAt(0);\r\n            // Try to match a root\r\n            if (len > 1) {\r\n                if (isPathSeparator(code)) {\r\n                    // Possible UNC root\r\n                    // If we started with a separator, we know we at least have an\r\n                    // absolute path of some kind (UNC or otherwise)\r\n                    isAbsolute = true;\r\n                    if (isPathSeparator(path.charCodeAt(1))) {\r\n                        // Matched double path separator at beginning\r\n                        var j = 2;\r\n                        var last = j;\r\n                        // Match 1 or more non-path separators\r\n                        for (; j < len; ++j) {\r\n                            if (isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            var firstPart = path.slice(last, j);\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more path separators\r\n                            for (; j < len; ++j) {\r\n                                if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j < len && j !== last) {\r\n                                // Matched!\r\n                                last = j;\r\n                                // Match 1 or more non-path separators\r\n                                for (; j < len; ++j) {\r\n                                    if (isPathSeparator(path.charCodeAt(j))) {\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (j === len) {\r\n                                    // We matched a UNC root only\r\n                                    device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\r\n                                    rootEnd = j;\r\n                                }\r\n                                else if (j !== last) {\r\n                                    // We matched a UNC root with leftovers\r\n                                    device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\r\n                                    rootEnd = j;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        rootEnd = 1;\r\n                    }\r\n                }\r\n                else if (isWindowsDeviceRoot(code)) {\r\n                    // Possible device root\r\n                    if (path.charCodeAt(1) === CHAR_COLON) {\r\n                        device = path.slice(0, 2);\r\n                        rootEnd = 2;\r\n                        if (len > 2) {\r\n                            if (isPathSeparator(path.charCodeAt(2))) {\r\n                                // Treat separator following drive name as an absolute path\r\n                                // indicator\r\n                                isAbsolute = true;\r\n                                rootEnd = 3;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (isPathSeparator(code)) {\r\n                // `path` contains just a path separator\r\n                rootEnd = 1;\r\n                isAbsolute = true;\r\n            }\r\n            if (device.length > 0 &&\r\n                resolvedDevice.length > 0 &&\r\n                device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n                // This path points to another device so it is not applicable\r\n                continue;\r\n            }\r\n            if (resolvedDevice.length === 0 && device.length > 0) {\r\n                resolvedDevice = device;\r\n            }\r\n            if (!resolvedAbsolute) {\r\n                resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\r\n                resolvedAbsolute = isAbsolute;\r\n            }\r\n            if (resolvedDevice.length > 0 && resolvedAbsolute) {\r\n                break;\r\n            }\r\n        }\r\n        // At this point the path should be resolved to a full absolute path,\r\n        // but handle relative paths to be safe (might happen when process.cwd()\r\n        // fails)\r\n        // Normalize the tail path\r\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\r\n        return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n            '.';\r\n    },\r\n    normalize: function (path) {\r\n        validateString(path, 'path');\r\n        var len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        var rootEnd = 0;\r\n        var device;\r\n        var isAbsolute = false;\r\n        var code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                // If we started with a separator, we know we at least have an absolute\r\n                // path of some kind (UNC or otherwise)\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    var j = 2;\r\n                    var last = j;\r\n                    // Match 1 or more non-path separators\r\n                    for (; j < len; ++j) {\r\n                        if (isPathSeparator(path.charCodeAt(j))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        var firstPart = path.slice(last, j);\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        for (; j < len; ++j) {\r\n                            if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            for (; j < len; ++j) {\r\n                                if (isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j === len) {\r\n                                // We matched a UNC root only\r\n                                // Return the normalized version of the UNC root since there\r\n                                // is nothing left to process\r\n                                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\r\n                            }\r\n                            else if (j !== last) {\r\n                                // We matched a UNC root with leftovers\r\n                                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rootEnd = 1;\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code)) {\r\n                // Possible device root\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    device = path.slice(0, 2);\r\n                    rootEnd = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            // Treat separator following drive name as an absolute path\r\n                            // indicator\r\n                            isAbsolute = true;\r\n                            rootEnd = 3;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            // `path` contains just a path separator, exit early to avoid unnecessary\r\n            // work\r\n            return '\\\\';\r\n        }\r\n        var tail;\r\n        if (rootEnd < len) {\r\n            tail = normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator);\r\n        }\r\n        else {\r\n            tail = '';\r\n        }\r\n        if (tail.length === 0 && !isAbsolute) {\r\n            tail = '.';\r\n        }\r\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n            tail += '\\\\';\r\n        }\r\n        if (device === undefined) {\r\n            if (isAbsolute) {\r\n                if (tail.length > 0) {\r\n                    return '\\\\' + tail;\r\n                }\r\n                else {\r\n                    return '\\\\';\r\n                }\r\n            }\r\n            else if (tail.length > 0) {\r\n                return tail;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        }\r\n        else if (isAbsolute) {\r\n            if (tail.length > 0) {\r\n                return device + '\\\\' + tail;\r\n            }\r\n            else {\r\n                return device + '\\\\';\r\n            }\r\n        }\r\n        else if (tail.length > 0) {\r\n            return device + tail;\r\n        }\r\n        else {\r\n            return device;\r\n        }\r\n    },\r\n    isAbsolute: function (path) {\r\n        validateString(path, 'path');\r\n        var len = path.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        var code = path.charCodeAt(0);\r\n        if (isPathSeparator(code)) {\r\n            return true;\r\n        }\r\n        else if (isWindowsDeviceRoot(code)) {\r\n            // Possible device root\r\n            if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\r\n                if (isPathSeparator(path.charCodeAt(2))) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    join: function () {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i] = arguments[_i];\r\n        }\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        var joined;\r\n        var firstPart;\r\n        for (var i = 0; i < paths.length; ++i) {\r\n            var arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = firstPart = arg;\r\n                }\r\n                else {\r\n                    joined += '\\\\' + arg;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        // Make sure that the joined path doesn't start with two slashes, because\r\n        // normalize() will mistake it for an UNC path then.\r\n        //\r\n        // This step is skipped when it is very clear that the user actually\r\n        // intended to point at an UNC path. This is assumed when the first\r\n        // non-empty string arguments starts with exactly two slashes followed by\r\n        // at least one more non-slash character.\r\n        //\r\n        // Note that for normalize() to treat a path as an UNC path it needs to\r\n        // have at least 2 components, so we don't filter for that here.\r\n        // This means that the user can use join to construct UNC paths from\r\n        // a server name and a share name; for example:\r\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\r\n        var needsReplace = true;\r\n        var slashCount = 0;\r\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\r\n            ++slashCount;\r\n            var firstLen = firstPart.length;\r\n            if (firstLen > 1) {\r\n                if (isPathSeparator(firstPart.charCodeAt(1))) {\r\n                    ++slashCount;\r\n                    if (firstLen > 2) {\r\n                        if (isPathSeparator(firstPart.charCodeAt(2))) {\r\n                            ++slashCount;\r\n                        }\r\n                        else {\r\n                            // We matched a UNC path in the first part\r\n                            needsReplace = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (needsReplace) {\r\n            // Find any more consecutive slashes we need to replace\r\n            for (; slashCount < joined.length; ++slashCount) {\r\n                if (!isPathSeparator(joined.charCodeAt(slashCount))) {\r\n                    break;\r\n                }\r\n            }\r\n            // Replace the slashes if needed\r\n            if (slashCount >= 2) {\r\n                joined = '\\\\' + joined.slice(slashCount);\r\n            }\r\n        }\r\n        return win32.normalize(joined);\r\n    },\r\n    // It will solve the relative path from `from` to `to`, for instance:\r\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\n    relative: function (from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        var fromOrig = win32.resolve(from);\r\n        var toOrig = win32.resolve(to);\r\n        if (fromOrig === toOrig) {\r\n            return '';\r\n        }\r\n        from = fromOrig.toLowerCase();\r\n        to = toOrig.toLowerCase();\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        var fromStart = 0;\r\n        for (; fromStart < from.length; ++fromStart) {\r\n            if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        var fromEnd = from.length;\r\n        for (; fromEnd - 1 > fromStart; --fromEnd) {\r\n            if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var fromLen = (fromEnd - fromStart);\r\n        // Trim any leading backslashes\r\n        var toStart = 0;\r\n        for (; toStart < to.length; ++toStart) {\r\n            if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        var toEnd = to.length;\r\n        for (; toEnd - 1 > toStart; --toEnd) {\r\n            if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var toLen = (toEnd - toStart);\r\n        // Compare paths to find the longest common path from root\r\n        var length = (fromLen < toLen ? fromLen : toLen);\r\n        var lastCommonSep = -1;\r\n        var i = 0;\r\n        for (; i <= length; ++i) {\r\n            if (i === length) {\r\n                if (toLen > length) {\r\n                    if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\r\n                        // We get here if `from` is the exact base path for `to`.\r\n                        // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\r\n                        return toOrig.slice(toStart + i + 1);\r\n                    }\r\n                    else if (i === 2) {\r\n                        // We get here if `from` is the device root.\r\n                        // For example: from='C:\\\\'; to='C:\\\\foo'\r\n                        return toOrig.slice(toStart + i);\r\n                    }\r\n                }\r\n                if (fromLen > length) {\r\n                    if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\r\n                        // We get here if `to` is the exact base path for `from`.\r\n                        // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\r\n                        lastCommonSep = i;\r\n                    }\r\n                    else if (i === 2) {\r\n                        // We get here if `to` is the device root.\r\n                        // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\r\n                        lastCommonSep = 3;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            var fromCode = from.charCodeAt(fromStart + i);\r\n            var toCode = to.charCodeAt(toStart + i);\r\n            if (fromCode !== toCode) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        // We found a mismatch before the first common path separator was seen, so\r\n        // return the original `to`.\r\n        if (i !== length && lastCommonSep === -1) {\r\n            return toOrig;\r\n        }\r\n        var out = '';\r\n        if (lastCommonSep === -1) {\r\n            lastCommonSep = 0;\r\n        }\r\n        // Generate the relative path based on the path difference between `to` and\r\n        // `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\r\n                if (out.length === 0) {\r\n                    out += '..';\r\n                }\r\n                else {\r\n                    out += '\\\\..';\r\n                }\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return out + toOrig.slice(toStart + lastCommonSep, toEnd);\r\n        }\r\n        else {\r\n            toStart += lastCommonSep;\r\n            if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n                ++toStart;\r\n            }\r\n            return toOrig.slice(toStart, toEnd);\r\n        }\r\n    },\r\n    toNamespacedPath: function (path) {\r\n        // Note: this will *probably* throw somewhere.\r\n        if (typeof path !== 'string') {\r\n            return path;\r\n        }\r\n        if (path.length === 0) {\r\n            return '';\r\n        }\r\n        var resolvedPath = win32.resolve(path);\r\n        if (resolvedPath.length >= 3) {\r\n            if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\r\n                // Possible UNC root\r\n                if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\r\n                    var code = resolvedPath.charCodeAt(2);\r\n                    if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\r\n                        // Matched non-long UNC root, convert the path to a long UNC path\r\n                        return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\r\n                    }\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\r\n                // Possible device root\r\n                if (resolvedPath.charCodeAt(1) === CHAR_COLON &&\r\n                    resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n                    // Matched device root, convert the path to a long UNC path\r\n                    return '\\\\\\\\?\\\\' + resolvedPath;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    },\r\n    dirname: function (path) {\r\n        validateString(path, 'path');\r\n        var len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        var rootEnd = -1;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var offset = 0;\r\n        var code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                rootEnd = offset = 1;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    var j = 2;\r\n                    var last = j;\r\n                    // Match 1 or more non-path separators\r\n                    for (; j < len; ++j) {\r\n                        if (isPathSeparator(path.charCodeAt(j))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        for (; j < len; ++j) {\r\n                            if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            for (; j < len; ++j) {\r\n                                if (isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j === len) {\r\n                                // We matched a UNC root only\r\n                                return path;\r\n                            }\r\n                            if (j !== last) {\r\n                                // We matched a UNC root with leftovers\r\n                                // Offset by 1 to include the separator after the UNC root to\r\n                                // treat it as a \"normal root\" on top of a (UNC) root\r\n                                rootEnd = offset = j + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code)) {\r\n                // Possible device root\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    rootEnd = offset = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            rootEnd = offset = 3;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work\r\n            return path;\r\n        }\r\n        for (var i = len - 1; i >= offset; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (rootEnd === -1) {\r\n                return '.';\r\n            }\r\n            else {\r\n                end = rootEnd;\r\n            }\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename: function (path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        var start = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2) {\r\n            var drive = path.charCodeAt(0);\r\n            if (isWindowsDeviceRoot(drive)) {\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    start = 2;\r\n                }\r\n            }\r\n        }\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext.length === path.length && ext === path) {\r\n                return '';\r\n            }\r\n            var extIdx = ext.length - 1;\r\n            var firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                var code = path.charCodeAt(i);\r\n                if (isPathSeparator(code)) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        else {\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                if (isPathSeparator(path.charCodeAt(i))) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else if (end === -1) {\r\n                    // We saw the first non-path separator, mark this as the end of our\r\n                    // path component\r\n                    matchedSlash = false;\r\n                    end = i + 1;\r\n                }\r\n            }\r\n            if (end === -1) {\r\n                return '';\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n    },\r\n    extname: function (path) {\r\n        validateString(path, 'path');\r\n        var start = 0;\r\n        var startDot = -1;\r\n        var startPart = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            path.charCodeAt(1) === CHAR_COLON &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n            start = startPart = 2;\r\n        }\r\n        for (var i = path.length - 1; i >= start; --i) {\r\n            var code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: function (pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n        }\r\n        return _format('\\\\', pathObject);\r\n    },\r\n    parse: function (path) {\r\n        validateString(path, 'path');\r\n        var ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        var len = path.length;\r\n        var rootEnd = 0;\r\n        var code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len > 1) {\r\n            if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                rootEnd = 1;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    var j = 2;\r\n                    var last = j;\r\n                    // Match 1 or more non-path separators\r\n                    for (; j < len; ++j) {\r\n                        if (isPathSeparator(path.charCodeAt(j))) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        for (; j < len; ++j) {\r\n                            if (!isPathSeparator(path.charCodeAt(j))) {\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            for (; j < len; ++j) {\r\n                                if (isPathSeparator(path.charCodeAt(j))) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (j === len) {\r\n                                // We matched a UNC root only\r\n                                rootEnd = j;\r\n                            }\r\n                            else if (j !== last) {\r\n                                // We matched a UNC root with leftovers\r\n                                rootEnd = j + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code)) {\r\n                // Possible device root\r\n                if (path.charCodeAt(1) === CHAR_COLON) {\r\n                    rootEnd = 2;\r\n                    if (len > 2) {\r\n                        if (isPathSeparator(path.charCodeAt(2))) {\r\n                            if (len === 3) {\r\n                                // `path` contains just a drive root, exit early to avoid\r\n                                // unnecessary work\r\n                                ret.root = ret.dir = path;\r\n                                return ret;\r\n                            }\r\n                            rootEnd = 3;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // `path` contains just a drive root, exit early to avoid\r\n                        // unnecessary work\r\n                        ret.root = ret.dir = path;\r\n                        return ret;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work\r\n            ret.root = ret.dir = path;\r\n            return ret;\r\n        }\r\n        if (rootEnd > 0) {\r\n            ret.root = path.slice(0, rootEnd);\r\n        }\r\n        var startDot = -1;\r\n        var startPart = rootEnd;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= rootEnd; --i) {\r\n            code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            if (end !== -1) {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n        }\r\n        else {\r\n            ret.name = path.slice(startPart, startDot);\r\n            ret.base = path.slice(startPart, end);\r\n            ret.ext = path.slice(startDot, end);\r\n        }\r\n        // If the directory is the root, use the entire root as the `dir` including\r\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\r\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\r\n        if (startPart > 0 && startPart !== rootEnd) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else {\r\n            ret.dir = ret.root;\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '\\\\',\r\n    delimiter: ';',\r\n    win32: null,\r\n    posix: null\r\n};\r\nexport var posix = {\r\n    // path.resolve([from ...], to)\r\n    resolve: function () {\r\n        var pathSegments = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            pathSegments[_i] = arguments[_i];\r\n        }\r\n        var resolvedPath = '';\r\n        var resolvedAbsolute = false;\r\n        for (var i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n            var path = void 0;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n            }\r\n            else {\r\n                path = process.cwd();\r\n            }\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            resolvedPath = path + '/' + resolvedPath;\r\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        // Normalize the path\r\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\r\n        if (resolvedAbsolute) {\r\n            if (resolvedPath.length > 0) {\r\n                return '/' + resolvedPath;\r\n            }\r\n            else {\r\n                return '/';\r\n            }\r\n        }\r\n        else if (resolvedPath.length > 0) {\r\n            return resolvedPath;\r\n        }\r\n        else {\r\n            return '.';\r\n        }\r\n    },\r\n    normalize: function (path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\r\n        // Normalize the path\r\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\r\n        if (path.length === 0 && !isAbsolute) {\r\n            path = '.';\r\n        }\r\n        if (path.length > 0 && trailingSeparator) {\r\n            path += '/';\r\n        }\r\n        if (isAbsolute) {\r\n            return '/' + path;\r\n        }\r\n        return path;\r\n    },\r\n    isAbsolute: function (path) {\r\n        validateString(path, 'path');\r\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n    },\r\n    join: function () {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i] = arguments[_i];\r\n        }\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        var joined;\r\n        for (var i = 0; i < paths.length; ++i) {\r\n            var arg = arguments[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = arg;\r\n                }\r\n                else {\r\n                    joined += '/' + arg;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        return posix.normalize(joined);\r\n    },\r\n    relative: function (from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        from = posix.resolve(from);\r\n        to = posix.resolve(to);\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        var fromStart = 1;\r\n        for (; fromStart < from.length; ++fromStart) {\r\n            if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var fromEnd = from.length;\r\n        var fromLen = (fromEnd - fromStart);\r\n        // Trim any leading backslashes\r\n        var toStart = 1;\r\n        for (; toStart < to.length; ++toStart) {\r\n            if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH) {\r\n                break;\r\n            }\r\n        }\r\n        var toEnd = to.length;\r\n        var toLen = (toEnd - toStart);\r\n        // Compare paths to find the longest common path from root\r\n        var length = (fromLen < toLen ? fromLen : toLen);\r\n        var lastCommonSep = -1;\r\n        var i = 0;\r\n        for (; i <= length; ++i) {\r\n            if (i === length) {\r\n                if (toLen > length) {\r\n                    if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\r\n                        // We get here if `from` is the exact base path for `to`.\r\n                        // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n                        return to.slice(toStart + i + 1);\r\n                    }\r\n                    else if (i === 0) {\r\n                        // We get here if `from` is the root\r\n                        // For example: from='/'; to='/foo'\r\n                        return to.slice(toStart + i);\r\n                    }\r\n                }\r\n                else if (fromLen > length) {\r\n                    if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\r\n                        // We get here if `to` is the exact base path for `from`.\r\n                        // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n                        lastCommonSep = i;\r\n                    }\r\n                    else if (i === 0) {\r\n                        // We get here if `to` is the root.\r\n                        // For example: from='/foo'; to='/'\r\n                        lastCommonSep = 0;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            var fromCode = from.charCodeAt(fromStart + i);\r\n            var toCode = to.charCodeAt(toStart + i);\r\n            if (fromCode !== toCode) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_FORWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        var out = '';\r\n        // Generate the relative path based on the path difference between `to`\r\n        // and `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (out.length === 0) {\r\n                    out += '..';\r\n                }\r\n                else {\r\n                    out += '/..';\r\n                }\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return out + to.slice(toStart + lastCommonSep);\r\n        }\r\n        else {\r\n            toStart += lastCommonSep;\r\n            if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH) {\r\n                ++toStart;\r\n            }\r\n            return to.slice(toStart);\r\n        }\r\n    },\r\n    toNamespacedPath: function (path) {\r\n        // Non-op on posix systems\r\n        return path;\r\n    },\r\n    dirname: function (path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        for (var i = path.length - 1; i >= 1; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return hasRoot ? '/' : '.';\r\n        }\r\n        if (hasRoot && end === 1) {\r\n            return '//';\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename: function (path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        var start = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i;\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext.length === path.length && ext === path) {\r\n                return '';\r\n            }\r\n            var extIdx = ext.length - 1;\r\n            var firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                var code = path.charCodeAt(i);\r\n                if (code === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        else {\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else if (end === -1) {\r\n                    // We saw the first non-path separator, mark this as the end of our\r\n                    // path component\r\n                    matchedSlash = false;\r\n                    end = i + 1;\r\n                }\r\n            }\r\n            if (end === -1) {\r\n                return '';\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n    },\r\n    extname: function (path) {\r\n        validateString(path, 'path');\r\n        var startDot = -1;\r\n        var startPart = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        for (var i = path.length - 1; i >= 0; --i) {\r\n            var code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: function (pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n        }\r\n        return _format('/', pathObject);\r\n    },\r\n    parse: function (path) {\r\n        validateString(path, 'path');\r\n        var ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        var start;\r\n        if (isAbsolute) {\r\n            ret.root = '/';\r\n            start = 1;\r\n        }\r\n        else {\r\n            start = 0;\r\n        }\r\n        var startDot = -1;\r\n        var startPart = 0;\r\n        var end = -1;\r\n        var matchedSlash = true;\r\n        var i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        var preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= start; --i) {\r\n            var code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            if (end !== -1) {\r\n                if (startPart === 0 && isAbsolute) {\r\n                    ret.base = ret.name = path.slice(1, end);\r\n                }\r\n                else {\r\n                    ret.base = ret.name = path.slice(startPart, end);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (startPart === 0 && isAbsolute) {\r\n                ret.name = path.slice(1, startDot);\r\n                ret.base = path.slice(1, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(startPart, startDot);\r\n                ret.base = path.slice(startPart, end);\r\n            }\r\n            ret.ext = path.slice(startDot, end);\r\n        }\r\n        if (startPart > 0) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else if (isAbsolute) {\r\n            ret.dir = '/';\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '/',\r\n    delimiter: ':',\r\n    win32: null,\r\n    posix: null\r\n};\r\nposix.win32 = win32.win32 = win32;\r\nposix.posix = win32.posix = posix;\r\nexport var normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\r\nexport var join = (process.platform === 'win32' ? win32.join : posix.join);\r\nexport var relative = (process.platform === 'win32' ? win32.relative : posix.relative);\r\nexport var dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\r\nexport var basename = (process.platform === 'win32' ? win32.basename : posix.basename);\r\nexport var extname = (process.platform === 'win32' ? win32.extname : posix.extname);\r\nexport var sep = (process.platform === 'win32' ? win32.sep : posix.sep);\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,cAAa,GAAG,uBAAUC,CAAC,EAAEC,CAAC,EAAE;IAChCF,cAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;MAAEC,SAAS,EAAE;IAAG,CAAC,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;MAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;IAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;MAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC;QAAE,IAAIA,CAAC,CAACM,cAAc,CAACD,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;MAAC;IAAC,CAAC;IAC9E,OAAOP,cAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC9B,CAAC;EACD,OAAO,UAAUD,CAAC,EAAEC,CAAC,EAAE;IACnBF,cAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASO,EAAE,GAAG;MAAE,IAAI,CAACC,WAAW,GAAGT,CAAC;IAAE;IACtCA,CAAC,CAACU,SAAS,GAAGT,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACS,MAAM,CAACV,CAAC,CAAC,IAAIO,EAAE,CAACE,SAAS,GAAGT,CAAC,CAACS,SAAS,EAAE,IAAIF,EAAE,EAAE,CAAC;EACxF,CAAC;AACL,CAAC,EAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,KAAKI,OAAO,MAAM,cAAc;AACvC,IAAIC,gBAAgB,GAAG,EAAE,CAAC,CAAC;AAC3B,IAAIC,gBAAgB,GAAG,EAAE,CAAC,CAAC;AAC3B,IAAIC,gBAAgB,GAAG,EAAE,CAAC,CAAC;AAC3B,IAAIC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAC5B,IAAIC,QAAQ,GAAG,EAAE,CAAC,CAAC;AACnB,IAAIC,kBAAkB,GAAG,EAAE,CAAC,CAAC;AAC7B,IAAIC,mBAAmB,GAAG,EAAE,CAAC,CAAC;AAC9B,IAAIC,UAAU,GAAG,EAAE,CAAC,CAAC;AACrB,IAAIC,kBAAkB,GAAG,EAAE,CAAC,CAAC;AAC7B,IAAIC,mBAAmB,GAAG,aAAe,UAAUC,MAAM,EAAE;EACvDzB,SAAS,CAACwB,mBAAmB,EAAEC,MAAM,CAAC;EACtC,SAASD,mBAAmB,CAACE,IAAI,EAAEC,QAAQ,EAAEC,MAAM,EAAE;IACjD,IAAIC,KAAK,GAAG,IAAI;IAChB;IACA,IAAIC,UAAU;IACd,IAAI,OAAOH,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;MAChED,UAAU,GAAG,aAAa;MAC1BH,QAAQ,GAAGA,QAAQ,CAACK,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;IAC5C,CAAC,MACI;MACDF,UAAU,GAAG,SAAS;IAC1B;IACA,IAAIG,IAAI,GAAGP,IAAI,CAACK,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,UAAU,GAAG,UAAU;IAC7D,IAAIG,GAAG,GAAG,QAAQ,GAAGR,IAAI,GAAG,KAAK,GAAGO,IAAI,GAAG,GAAG,GAAGH,UAAU,GAAG,WAAW,GAAGH,QAAQ;IACpFO,GAAG,IAAI,kBAAkB,GAAG,OAAON,MAAM;IACzCC,KAAK,GAAGJ,MAAM,CAACU,IAAI,CAAC,IAAI,EAAED,GAAG,CAAC,IAAI,IAAI;IACtCL,KAAK,CAACO,IAAI,GAAG,sBAAsB;IACnC,OAAOP,KAAK;EAChB;EACA,OAAOL,mBAAmB;AAC9B,CAAC,CAACa,KAAK,CAAE;AACT,SAASC,cAAc,CAACC,KAAK,EAAEb,IAAI,EAAE;EACjC,IAAI,OAAOa,KAAK,KAAK,QAAQ,EAAE;IAC3B,MAAM,IAAIf,mBAAmB,CAACE,IAAI,EAAE,QAAQ,EAAEa,KAAK,CAAC;EACxD;AACJ;AACA,SAASC,eAAe,CAACJ,IAAI,EAAE;EAC3B,OAAOA,IAAI,KAAKhB,kBAAkB,IAAIgB,IAAI,KAAKf,mBAAmB;AACtE;AACA,SAASoB,oBAAoB,CAACL,IAAI,EAAE;EAChC,OAAOA,IAAI,KAAKhB,kBAAkB;AACtC;AACA,SAASsB,mBAAmB,CAACN,IAAI,EAAE;EAC/B,OAAOA,IAAI,IAAIrB,gBAAgB,IAAIqB,IAAI,IAAInB,gBAAgB,IACvDmB,IAAI,IAAIpB,gBAAgB,IAAIoB,IAAI,IAAIlB,gBAAgB;AAC5D;AACA;AACA,SAASyB,eAAe,CAACC,IAAI,EAAEC,cAAc,EAAEC,SAAS,EAAEN,eAAe,EAAE;EACvE,IAAIO,GAAG,GAAG,EAAE;EACZ,IAAIC,iBAAiB,GAAG,CAAC;EACzB,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAId,IAAI;EACR,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIP,IAAI,CAACQ,MAAM,EAAE,EAAED,CAAC,EAAE;IACnC,IAAIA,CAAC,GAAGP,IAAI,CAACQ,MAAM,EAAE;MACjBhB,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;IAC7B,CAAC,MACI,IAAIX,eAAe,CAACJ,IAAI,CAAC,EAAE;MAC5B;IACJ,CAAC,MACI;MACDA,IAAI,GAAGhB,kBAAkB;IAC7B;IACA,IAAIoB,eAAe,CAACJ,IAAI,CAAC,EAAE;MACvB,IAAIa,SAAS,KAAKE,CAAC,GAAG,CAAC,IAAID,IAAI,KAAK,CAAC,EAAE;QACnC;MAAA,CACH,MACI,IAAID,SAAS,KAAKE,CAAC,GAAG,CAAC,IAAID,IAAI,KAAK,CAAC,EAAE;QACxC,IAAIH,GAAG,CAACK,MAAM,GAAG,CAAC,IAAIJ,iBAAiB,KAAK,CAAC,IACzCD,GAAG,CAACM,UAAU,CAACN,GAAG,CAACK,MAAM,GAAG,CAAC,CAAC,KAAKjC,QAAQ,IAC3C4B,GAAG,CAACM,UAAU,CAACN,GAAG,CAACK,MAAM,GAAG,CAAC,CAAC,KAAKjC,QAAQ,EAAE;UAC7C,IAAI4B,GAAG,CAACK,MAAM,GAAG,CAAC,EAAE;YAChB,IAAIE,cAAc,GAAGP,GAAG,CAACQ,WAAW,CAACT,SAAS,CAAC;YAC/C,IAAIQ,cAAc,KAAK,CAAC,CAAC,EAAE;cACvBP,GAAG,GAAG,EAAE;cACRC,iBAAiB,GAAG,CAAC;YACzB,CAAC,MACI;cACDD,GAAG,GAAGA,GAAG,CAACS,KAAK,CAAC,CAAC,EAAEF,cAAc,CAAC;cAClCN,iBAAiB,GAAGD,GAAG,CAACK,MAAM,GAAG,CAAC,GAAGL,GAAG,CAACQ,WAAW,CAACT,SAAS,CAAC;YACnE;YACAG,SAAS,GAAGE,CAAC;YACbD,IAAI,GAAG,CAAC;YACR;UACJ,CAAC,MACI,IAAIH,GAAG,CAACK,MAAM,KAAK,CAAC,IAAIL,GAAG,CAACK,MAAM,KAAK,CAAC,EAAE;YAC3CL,GAAG,GAAG,EAAE;YACRC,iBAAiB,GAAG,CAAC;YACrBC,SAAS,GAAGE,CAAC;YACbD,IAAI,GAAG,CAAC;YACR;UACJ;QACJ;QACA,IAAIL,cAAc,EAAE;UAChB,IAAIE,GAAG,CAACK,MAAM,GAAG,CAAC,EAAE;YAChBL,GAAG,IAAID,SAAS,GAAG,IAAI;UAC3B,CAAC,MACI;YACDC,GAAG,GAAG,IAAI;UACd;UACAC,iBAAiB,GAAG,CAAC;QACzB;MACJ,CAAC,MACI;QACD,IAAID,GAAG,CAACK,MAAM,GAAG,CAAC,EAAE;UAChBL,GAAG,IAAID,SAAS,GAAGF,IAAI,CAACY,KAAK,CAACP,SAAS,GAAG,CAAC,EAAEE,CAAC,CAAC;QACnD,CAAC,MACI;UACDJ,GAAG,GAAGH,IAAI,CAACY,KAAK,CAACP,SAAS,GAAG,CAAC,EAAEE,CAAC,CAAC;QACtC;QACAH,iBAAiB,GAAGG,CAAC,GAAGF,SAAS,GAAG,CAAC;MACzC;MACAA,SAAS,GAAGE,CAAC;MACbD,IAAI,GAAG,CAAC;IACZ,CAAC,MACI,IAAId,IAAI,KAAKjB,QAAQ,IAAI+B,IAAI,KAAK,CAAC,CAAC,EAAE;MACvC,EAAEA,IAAI;IACV,CAAC,MACI;MACDA,IAAI,GAAG,CAAC,CAAC;IACb;EACJ;EACA,OAAOH,GAAG;AACd;AACA,SAASU,OAAO,CAACC,GAAG,EAAEC,UAAU,EAAE;EAC9B,IAAIC,GAAG,GAAGD,UAAU,CAACC,GAAG,IAAID,UAAU,CAACE,IAAI;EAC3C,IAAIC,IAAI,GAAGH,UAAU,CAACG,IAAI,IACrB,CAACH,UAAU,CAACjC,IAAI,IAAI,EAAE,KAAKiC,UAAU,CAACI,GAAG,IAAI,EAAE,CAAE;EACtD,IAAI,CAACH,GAAG,EAAE;IACN,OAAOE,IAAI;EACf;EACA,IAAIF,GAAG,KAAKD,UAAU,CAACE,IAAI,EAAE;IACzB,OAAOD,GAAG,GAAGE,IAAI;EACrB;EACA,OAAOF,GAAG,GAAGF,GAAG,GAAGI,IAAI;AAC3B;AACA,OAAO,IAAIE,KAAK,GAAG;EACf;EACAC,OAAO,EAAE,mBAAY;IACjB,IAAIC,YAAY,GAAG,EAAE;IACrB,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAAChB,MAAM,EAAEe,EAAE,EAAE,EAAE;MAC1CD,YAAY,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IACpC;IACA,IAAIE,cAAc,GAAG,EAAE;IACvB,IAAIC,YAAY,GAAG,EAAE;IACrB,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,KAAK,IAAIpB,CAAC,GAAGe,YAAY,CAACd,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE;MAChD,IAAIP,IAAI,GAAG,KAAK,CAAC;MACjB,IAAIO,CAAC,IAAI,CAAC,EAAE;QACRP,IAAI,GAAGsB,YAAY,CAACf,CAAC,CAAC;MAC1B,CAAC,MACI,IAAI,CAACkB,cAAc,EAAE;QACtBzB,IAAI,GAAG9B,OAAO,CAAC0D,GAAG,EAAE;MACxB,CAAC,MACI;QACD;QACA;QACA;QACA;QACA;QACA5B,IAAI,GAAG9B,OAAO,CAAC2D,GAAG,CAAC,GAAG,GAAGJ,cAAc,CAAC,IAAIvD,OAAO,CAAC0D,GAAG,EAAE;QACzD;QACA;QACA,IAAI5B,IAAI,KAAK8B,SAAS,IAClB9B,IAAI,CAACY,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAACmB,WAAW,EAAE,KAC1BN,cAAc,CAACM,WAAW,EAAE,GAAG,IAAI,EAAE;UACzC/B,IAAI,GAAGyB,cAAc,GAAG,IAAI;QAChC;MACJ;MACA/B,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;MAC5B;MACA,IAAIA,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;QACnB;MACJ;MACA,IAAIwB,GAAG,GAAGhC,IAAI,CAACQ,MAAM;MACrB,IAAIyB,OAAO,GAAG,CAAC;MACf,IAAIC,MAAM,GAAG,EAAE;MACf,IAAIC,UAAU,GAAG,KAAK;MACtB,IAAI3C,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC;MAC7B;MACA,IAAIuB,GAAG,GAAG,CAAC,EAAE;QACT,IAAIpC,eAAe,CAACJ,IAAI,CAAC,EAAE;UACvB;UACA;UACA;UACA2C,UAAU,GAAG,IAAI;UACjB,IAAIvC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;YACrC;YACA,IAAI2B,CAAC,GAAG,CAAC;YACT,IAAIC,IAAI,GAAGD,CAAC;YACZ;YACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;cACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;gBACrC;cACJ;YACJ;YACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;cACvB,IAAIC,SAAS,GAAGtC,IAAI,CAACY,KAAK,CAACyB,IAAI,EAAED,CAAC,CAAC;cACnC;cACAC,IAAI,GAAGD,CAAC;cACR;cACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;gBACjB,IAAI,CAACxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;kBACtC;gBACJ;cACJ;cACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;gBACvB;gBACAA,IAAI,GAAGD,CAAC;gBACR;gBACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;kBACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;oBACrC;kBACJ;gBACJ;gBACA,IAAIA,CAAC,KAAKJ,GAAG,EAAE;kBACX;kBACAE,MAAM,GAAG,MAAM,GAAGI,SAAS,GAAG,IAAI,GAAGtC,IAAI,CAACY,KAAK,CAACyB,IAAI,CAAC;kBACrDJ,OAAO,GAAGG,CAAC;gBACf,CAAC,MACI,IAAIA,CAAC,KAAKC,IAAI,EAAE;kBACjB;kBACAH,MAAM,GAAG,MAAM,GAAGI,SAAS,GAAG,IAAI,GAAGtC,IAAI,CAACY,KAAK,CAACyB,IAAI,EAAED,CAAC,CAAC;kBACxDH,OAAO,GAAGG,CAAC;gBACf;cACJ;YACJ;UACJ,CAAC,MACI;YACDH,OAAO,GAAG,CAAC;UACf;QACJ,CAAC,MACI,IAAInC,mBAAmB,CAACN,IAAI,CAAC,EAAE;UAChC;UACA,IAAIQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,EAAE;YACnCwD,MAAM,GAAGlC,IAAI,CAACY,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;YACzBqB,OAAO,GAAG,CAAC;YACX,IAAID,GAAG,GAAG,CAAC,EAAE;cACT,IAAIpC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;gBACrC;gBACA;gBACA0B,UAAU,GAAG,IAAI;gBACjBF,OAAO,GAAG,CAAC;cACf;YACJ;UACJ;QACJ;MACJ,CAAC,MACI,IAAIrC,eAAe,CAACJ,IAAI,CAAC,EAAE;QAC5B;QACAyC,OAAO,GAAG,CAAC;QACXE,UAAU,GAAG,IAAI;MACrB;MACA,IAAID,MAAM,CAAC1B,MAAM,GAAG,CAAC,IACjBiB,cAAc,CAACjB,MAAM,GAAG,CAAC,IACzB0B,MAAM,CAACH,WAAW,EAAE,KAAKN,cAAc,CAACM,WAAW,EAAE,EAAE;QACvD;QACA;MACJ;MACA,IAAIN,cAAc,CAACjB,MAAM,KAAK,CAAC,IAAI0B,MAAM,CAAC1B,MAAM,GAAG,CAAC,EAAE;QAClDiB,cAAc,GAAGS,MAAM;MAC3B;MACA,IAAI,CAACP,gBAAgB,EAAE;QACnBD,YAAY,GAAG1B,IAAI,CAACY,KAAK,CAACqB,OAAO,CAAC,GAAG,IAAI,GAAGP,YAAY;QACxDC,gBAAgB,GAAGQ,UAAU;MACjC;MACA,IAAIV,cAAc,CAACjB,MAAM,GAAG,CAAC,IAAImB,gBAAgB,EAAE;QAC/C;MACJ;IACJ;IACA;IACA;IACA;IACA;IACAD,YAAY,GAAG3B,eAAe,CAAC2B,YAAY,EAAE,CAACC,gBAAgB,EAAE,IAAI,EAAE/B,eAAe,CAAC;IACtF,OAAQ6B,cAAc,IAAIE,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAC,GAAGD,YAAY,IAClE,GAAG;EACX,CAAC;EACDa,SAAS,EAAE,mBAAUvC,IAAI,EAAE;IACvBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIgC,GAAG,GAAGhC,IAAI,CAACQ,MAAM;IACrB,IAAIwB,GAAG,KAAK,CAAC,EAAE;MACX,OAAO,GAAG;IACd;IACA,IAAIC,OAAO,GAAG,CAAC;IACf,IAAIC,MAAM;IACV,IAAIC,UAAU,GAAG,KAAK;IACtB,IAAI3C,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC;IAC7B;IACA,IAAIuB,GAAG,GAAG,CAAC,EAAE;MACT,IAAIpC,eAAe,CAACJ,IAAI,CAAC,EAAE;QACvB;QACA;QACA;QACA2C,UAAU,GAAG,IAAI;QACjB,IAAIvC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;UACrC;UACA,IAAI2B,CAAC,GAAG,CAAC;UACT,IAAIC,IAAI,GAAGD,CAAC;UACZ;UACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;YACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;cACrC;YACJ;UACJ;UACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;YACvB,IAAIC,SAAS,GAAGtC,IAAI,CAACY,KAAK,CAACyB,IAAI,EAAED,CAAC,CAAC;YACnC;YACAC,IAAI,GAAGD,CAAC;YACR;YACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;cACjB,IAAI,CAACxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;gBACtC;cACJ;YACJ;YACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;cACvB;cACAA,IAAI,GAAGD,CAAC;cACR;cACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;gBACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;kBACrC;gBACJ;cACJ;cACA,IAAIA,CAAC,KAAKJ,GAAG,EAAE;gBACX;gBACA;gBACA;gBACA,OAAO,MAAM,GAAGM,SAAS,GAAG,IAAI,GAAGtC,IAAI,CAACY,KAAK,CAACyB,IAAI,CAAC,GAAG,IAAI;cAC9D,CAAC,MACI,IAAID,CAAC,KAAKC,IAAI,EAAE;gBACjB;gBACAH,MAAM,GAAG,MAAM,GAAGI,SAAS,GAAG,IAAI,GAAGtC,IAAI,CAACY,KAAK,CAACyB,IAAI,EAAED,CAAC,CAAC;gBACxDH,OAAO,GAAGG,CAAC;cACf;YACJ;UACJ;QACJ,CAAC,MACI;UACDH,OAAO,GAAG,CAAC;QACf;MACJ,CAAC,MACI,IAAInC,mBAAmB,CAACN,IAAI,CAAC,EAAE;QAChC;QACA,IAAIQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,EAAE;UACnCwD,MAAM,GAAGlC,IAAI,CAACY,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;UACzBqB,OAAO,GAAG,CAAC;UACX,IAAID,GAAG,GAAG,CAAC,EAAE;YACT,IAAIpC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;cACrC;cACA;cACA0B,UAAU,GAAG,IAAI;cACjBF,OAAO,GAAG,CAAC;YACf;UACJ;QACJ;MACJ;IACJ,CAAC,MACI,IAAIrC,eAAe,CAACJ,IAAI,CAAC,EAAE;MAC5B;MACA;MACA,OAAO,IAAI;IACf;IACA,IAAIgD,IAAI;IACR,IAAIP,OAAO,GAAGD,GAAG,EAAE;MACfQ,IAAI,GAAGzC,eAAe,CAACC,IAAI,CAACY,KAAK,CAACqB,OAAO,CAAC,EAAE,CAACE,UAAU,EAAE,IAAI,EAAEvC,eAAe,CAAC;IACnF,CAAC,MACI;MACD4C,IAAI,GAAG,EAAE;IACb;IACA,IAAIA,IAAI,CAAChC,MAAM,KAAK,CAAC,IAAI,CAAC2B,UAAU,EAAE;MAClCK,IAAI,GAAG,GAAG;IACd;IACA,IAAIA,IAAI,CAAChC,MAAM,GAAG,CAAC,IAAIZ,eAAe,CAACI,IAAI,CAACS,UAAU,CAACuB,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE;MAC9DQ,IAAI,IAAI,IAAI;IAChB;IACA,IAAIN,MAAM,KAAKJ,SAAS,EAAE;MACtB,IAAIK,UAAU,EAAE;QACZ,IAAIK,IAAI,CAAChC,MAAM,GAAG,CAAC,EAAE;UACjB,OAAO,IAAI,GAAGgC,IAAI;QACtB,CAAC,MACI;UACD,OAAO,IAAI;QACf;MACJ,CAAC,MACI,IAAIA,IAAI,CAAChC,MAAM,GAAG,CAAC,EAAE;QACtB,OAAOgC,IAAI;MACf,CAAC,MACI;QACD,OAAO,EAAE;MACb;IACJ,CAAC,MACI,IAAIL,UAAU,EAAE;MACjB,IAAIK,IAAI,CAAChC,MAAM,GAAG,CAAC,EAAE;QACjB,OAAO0B,MAAM,GAAG,IAAI,GAAGM,IAAI;MAC/B,CAAC,MACI;QACD,OAAON,MAAM,GAAG,IAAI;MACxB;IACJ,CAAC,MACI,IAAIM,IAAI,CAAChC,MAAM,GAAG,CAAC,EAAE;MACtB,OAAO0B,MAAM,GAAGM,IAAI;IACxB,CAAC,MACI;MACD,OAAON,MAAM;IACjB;EACJ,CAAC;EACDC,UAAU,EAAE,oBAAUnC,IAAI,EAAE;IACxBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIgC,GAAG,GAAGhC,IAAI,CAACQ,MAAM;IACrB,IAAIwB,GAAG,KAAK,CAAC,EAAE;MACX,OAAO,KAAK;IAChB;IACA,IAAIxC,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC;IAC7B,IAAIb,eAAe,CAACJ,IAAI,CAAC,EAAE;MACvB,OAAO,IAAI;IACf,CAAC,MACI,IAAIM,mBAAmB,CAACN,IAAI,CAAC,EAAE;MAChC;MACA,IAAIwC,GAAG,GAAG,CAAC,IAAIhC,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,EAAE;QAC9C,IAAIkB,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;UACrC,OAAO,IAAI;QACf;MACJ;IACJ;IACA,OAAO,KAAK;EAChB,CAAC;EACDgC,IAAI,EAAE,gBAAY;IACd,IAAIC,KAAK,GAAG,EAAE;IACd,KAAK,IAAInB,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAAChB,MAAM,EAAEe,EAAE,EAAE,EAAE;MAC1CmB,KAAK,CAACnB,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC7B;IACA,IAAImB,KAAK,CAAClC,MAAM,KAAK,CAAC,EAAE;MACpB,OAAO,GAAG;IACd;IACA,IAAImC,MAAM;IACV,IAAIL,SAAS;IACb,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,KAAK,CAAClC,MAAM,EAAE,EAAED,CAAC,EAAE;MACnC,IAAIqC,GAAG,GAAGF,KAAK,CAACnC,CAAC,CAAC;MAClBb,cAAc,CAACkD,GAAG,EAAE,MAAM,CAAC;MAC3B,IAAIA,GAAG,CAACpC,MAAM,GAAG,CAAC,EAAE;QAChB,IAAImC,MAAM,KAAKb,SAAS,EAAE;UACtBa,MAAM,GAAGL,SAAS,GAAGM,GAAG;QAC5B,CAAC,MACI;UACDD,MAAM,IAAI,IAAI,GAAGC,GAAG;QACxB;MACJ;IACJ;IACA,IAAID,MAAM,KAAKb,SAAS,EAAE;MACtB,OAAO,GAAG;IACd;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIe,YAAY,GAAG,IAAI;IACvB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAI,OAAOR,SAAS,KAAK,QAAQ,IAAI1C,eAAe,CAAC0C,SAAS,CAAC7B,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MAC3E,EAAEqC,UAAU;MACZ,IAAIC,QAAQ,GAAGT,SAAS,CAAC9B,MAAM;MAC/B,IAAIuC,QAAQ,GAAG,CAAC,EAAE;QACd,IAAInD,eAAe,CAAC0C,SAAS,CAAC7B,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;UAC1C,EAAEqC,UAAU;UACZ,IAAIC,QAAQ,GAAG,CAAC,EAAE;YACd,IAAInD,eAAe,CAAC0C,SAAS,CAAC7B,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;cAC1C,EAAEqC,UAAU;YAChB,CAAC,MACI;cACD;cACAD,YAAY,GAAG,KAAK;YACxB;UACJ;QACJ;MACJ;IACJ;IACA,IAAIA,YAAY,EAAE;MACd;MACA,OAAOC,UAAU,GAAGH,MAAM,CAACnC,MAAM,EAAE,EAAEsC,UAAU,EAAE;QAC7C,IAAI,CAAClD,eAAe,CAAC+C,MAAM,CAAClC,UAAU,CAACqC,UAAU,CAAC,CAAC,EAAE;UACjD;QACJ;MACJ;MACA;MACA,IAAIA,UAAU,IAAI,CAAC,EAAE;QACjBH,MAAM,GAAG,IAAI,GAAGA,MAAM,CAAC/B,KAAK,CAACkC,UAAU,CAAC;MAC5C;IACJ;IACA,OAAO1B,KAAK,CAACmB,SAAS,CAACI,MAAM,CAAC;EAClC,CAAC;EACD;EACA;EACA;EACA;EACAK,QAAQ,EAAE,kBAAUC,IAAI,EAAEC,EAAE,EAAE;IAC1BxD,cAAc,CAACuD,IAAI,EAAE,MAAM,CAAC;IAC5BvD,cAAc,CAACwD,EAAE,EAAE,IAAI,CAAC;IACxB,IAAID,IAAI,KAAKC,EAAE,EAAE;MACb,OAAO,EAAE;IACb;IACA,IAAIC,QAAQ,GAAG/B,KAAK,CAACC,OAAO,CAAC4B,IAAI,CAAC;IAClC,IAAIG,MAAM,GAAGhC,KAAK,CAACC,OAAO,CAAC6B,EAAE,CAAC;IAC9B,IAAIC,QAAQ,KAAKC,MAAM,EAAE;MACrB,OAAO,EAAE;IACb;IACAH,IAAI,GAAGE,QAAQ,CAACpB,WAAW,EAAE;IAC7BmB,EAAE,GAAGE,MAAM,CAACrB,WAAW,EAAE;IACzB,IAAIkB,IAAI,KAAKC,EAAE,EAAE;MACb,OAAO,EAAE;IACb;IACA;IACA,IAAIG,SAAS,GAAG,CAAC;IACjB,OAAOA,SAAS,GAAGJ,IAAI,CAACzC,MAAM,EAAE,EAAE6C,SAAS,EAAE;MACzC,IAAIJ,IAAI,CAACxC,UAAU,CAAC4C,SAAS,CAAC,KAAK5E,mBAAmB,EAAE;QACpD;MACJ;IACJ;IACA;IACA,IAAI6E,OAAO,GAAGL,IAAI,CAACzC,MAAM;IACzB,OAAO8C,OAAO,GAAG,CAAC,GAAGD,SAAS,EAAE,EAAEC,OAAO,EAAE;MACvC,IAAIL,IAAI,CAACxC,UAAU,CAAC6C,OAAO,GAAG,CAAC,CAAC,KAAK7E,mBAAmB,EAAE;QACtD;MACJ;IACJ;IACA,IAAI8E,OAAO,GAAID,OAAO,GAAGD,SAAU;IACnC;IACA,IAAIG,OAAO,GAAG,CAAC;IACf,OAAOA,OAAO,GAAGN,EAAE,CAAC1C,MAAM,EAAE,EAAEgD,OAAO,EAAE;MACnC,IAAIN,EAAE,CAACzC,UAAU,CAAC+C,OAAO,CAAC,KAAK/E,mBAAmB,EAAE;QAChD;MACJ;IACJ;IACA;IACA,IAAIgF,KAAK,GAAGP,EAAE,CAAC1C,MAAM;IACrB,OAAOiD,KAAK,GAAG,CAAC,GAAGD,OAAO,EAAE,EAAEC,KAAK,EAAE;MACjC,IAAIP,EAAE,CAACzC,UAAU,CAACgD,KAAK,GAAG,CAAC,CAAC,KAAKhF,mBAAmB,EAAE;QAClD;MACJ;IACJ;IACA,IAAIiF,KAAK,GAAID,KAAK,GAAGD,OAAQ;IAC7B;IACA,IAAIhD,MAAM,GAAI+C,OAAO,GAAGG,KAAK,GAAGH,OAAO,GAAGG,KAAM;IAChD,IAAIC,aAAa,GAAG,CAAC,CAAC;IACtB,IAAIpD,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,IAAIC,MAAM,EAAE,EAAED,CAAC,EAAE;MACrB,IAAIA,CAAC,KAAKC,MAAM,EAAE;QACd,IAAIkD,KAAK,GAAGlD,MAAM,EAAE;UAChB,IAAI0C,EAAE,CAACzC,UAAU,CAAC+C,OAAO,GAAGjD,CAAC,CAAC,KAAK9B,mBAAmB,EAAE;YACpD;YACA;YACA,OAAO2E,MAAM,CAACxC,KAAK,CAAC4C,OAAO,GAAGjD,CAAC,GAAG,CAAC,CAAC;UACxC,CAAC,MACI,IAAIA,CAAC,KAAK,CAAC,EAAE;YACd;YACA;YACA,OAAO6C,MAAM,CAACxC,KAAK,CAAC4C,OAAO,GAAGjD,CAAC,CAAC;UACpC;QACJ;QACA,IAAIgD,OAAO,GAAG/C,MAAM,EAAE;UAClB,IAAIyC,IAAI,CAACxC,UAAU,CAAC4C,SAAS,GAAG9C,CAAC,CAAC,KAAK9B,mBAAmB,EAAE;YACxD;YACA;YACAkF,aAAa,GAAGpD,CAAC;UACrB,CAAC,MACI,IAAIA,CAAC,KAAK,CAAC,EAAE;YACd;YACA;YACAoD,aAAa,GAAG,CAAC;UACrB;QACJ;QACA;MACJ;MACA,IAAIC,QAAQ,GAAGX,IAAI,CAACxC,UAAU,CAAC4C,SAAS,GAAG9C,CAAC,CAAC;MAC7C,IAAIsD,MAAM,GAAGX,EAAE,CAACzC,UAAU,CAAC+C,OAAO,GAAGjD,CAAC,CAAC;MACvC,IAAIqD,QAAQ,KAAKC,MAAM,EAAE;QACrB;MACJ,CAAC,MACI,IAAID,QAAQ,KAAKnF,mBAAmB,EAAE;QACvCkF,aAAa,GAAGpD,CAAC;MACrB;IACJ;IACA;IACA;IACA,IAAIA,CAAC,KAAKC,MAAM,IAAImD,aAAa,KAAK,CAAC,CAAC,EAAE;MACtC,OAAOP,MAAM;IACjB;IACA,IAAIU,GAAG,GAAG,EAAE;IACZ,IAAIH,aAAa,KAAK,CAAC,CAAC,EAAE;MACtBA,aAAa,GAAG,CAAC;IACrB;IACA;IACA;IACA,KAAKpD,CAAC,GAAG8C,SAAS,GAAGM,aAAa,GAAG,CAAC,EAAEpD,CAAC,IAAI+C,OAAO,EAAE,EAAE/C,CAAC,EAAE;MACvD,IAAIA,CAAC,KAAK+C,OAAO,IAAIL,IAAI,CAACxC,UAAU,CAACF,CAAC,CAAC,KAAK9B,mBAAmB,EAAE;QAC7D,IAAIqF,GAAG,CAACtD,MAAM,KAAK,CAAC,EAAE;UAClBsD,GAAG,IAAI,IAAI;QACf,CAAC,MACI;UACDA,GAAG,IAAI,MAAM;QACjB;MACJ;IACJ;IACA;IACA;IACA,IAAIA,GAAG,CAACtD,MAAM,GAAG,CAAC,EAAE;MAChB,OAAOsD,GAAG,GAAGV,MAAM,CAACxC,KAAK,CAAC4C,OAAO,GAAGG,aAAa,EAAEF,KAAK,CAAC;IAC7D,CAAC,MACI;MACDD,OAAO,IAAIG,aAAa;MACxB,IAAIP,MAAM,CAAC3C,UAAU,CAAC+C,OAAO,CAAC,KAAK/E,mBAAmB,EAAE;QACpD,EAAE+E,OAAO;MACb;MACA,OAAOJ,MAAM,CAACxC,KAAK,CAAC4C,OAAO,EAAEC,KAAK,CAAC;IACvC;EACJ,CAAC;EACDM,gBAAgB,EAAE,0BAAU/D,IAAI,EAAE;IAC9B;IACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC1B,OAAOA,IAAI;IACf;IACA,IAAIA,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,EAAE;IACb;IACA,IAAIwD,YAAY,GAAG5C,KAAK,CAACC,OAAO,CAACrB,IAAI,CAAC;IACtC,IAAIgE,YAAY,CAACxD,MAAM,IAAI,CAAC,EAAE;MAC1B,IAAIwD,YAAY,CAACvD,UAAU,CAAC,CAAC,CAAC,KAAKhC,mBAAmB,EAAE;QACpD;QACA,IAAIuF,YAAY,CAACvD,UAAU,CAAC,CAAC,CAAC,KAAKhC,mBAAmB,EAAE;UACpD,IAAIe,IAAI,GAAGwE,YAAY,CAACvD,UAAU,CAAC,CAAC,CAAC;UACrC,IAAIjB,IAAI,KAAKb,kBAAkB,IAAIa,IAAI,KAAKjB,QAAQ,EAAE;YAClD;YACA,OAAO,cAAc,GAAGyF,YAAY,CAACpD,KAAK,CAAC,CAAC,CAAC;UACjD;QACJ;MACJ,CAAC,MACI,IAAId,mBAAmB,CAACkE,YAAY,CAACvD,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;QACtD;QACA,IAAIuD,YAAY,CAACvD,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,IACzCsF,YAAY,CAACvD,UAAU,CAAC,CAAC,CAAC,KAAKhC,mBAAmB,EAAE;UACpD;UACA,OAAO,SAAS,GAAGuF,YAAY;QACnC;MACJ;IACJ;IACA,OAAOhE,IAAI;EACf,CAAC;EACDiE,OAAO,EAAE,iBAAUjE,IAAI,EAAE;IACrBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIgC,GAAG,GAAGhC,IAAI,CAACQ,MAAM;IACrB,IAAIwB,GAAG,KAAK,CAAC,EAAE;MACX,OAAO,GAAG;IACd;IACA,IAAIC,OAAO,GAAG,CAAC,CAAC;IAChB,IAAIiC,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAIC,MAAM,GAAG,CAAC;IACd,IAAI5E,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC;IAC7B;IACA,IAAIuB,GAAG,GAAG,CAAC,EAAE;MACT,IAAIpC,eAAe,CAACJ,IAAI,CAAC,EAAE;QACvB;QACAyC,OAAO,GAAGmC,MAAM,GAAG,CAAC;QACpB,IAAIxE,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;UACrC;UACA,IAAI2B,CAAC,GAAG,CAAC;UACT,IAAIC,IAAI,GAAGD,CAAC;UACZ;UACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;YACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;cACrC;YACJ;UACJ;UACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;YACvB;YACAA,IAAI,GAAGD,CAAC;YACR;YACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;cACjB,IAAI,CAACxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;gBACtC;cACJ;YACJ;YACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;cACvB;cACAA,IAAI,GAAGD,CAAC;cACR;cACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;gBACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;kBACrC;gBACJ;cACJ;cACA,IAAIA,CAAC,KAAKJ,GAAG,EAAE;gBACX;gBACA,OAAOhC,IAAI;cACf;cACA,IAAIoC,CAAC,KAAKC,IAAI,EAAE;gBACZ;gBACA;gBACA;gBACAJ,OAAO,GAAGmC,MAAM,GAAGhC,CAAC,GAAG,CAAC;cAC5B;YACJ;UACJ;QACJ;MACJ,CAAC,MACI,IAAItC,mBAAmB,CAACN,IAAI,CAAC,EAAE;QAChC;QACA,IAAIQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,EAAE;UACnCuD,OAAO,GAAGmC,MAAM,GAAG,CAAC;UACpB,IAAIpC,GAAG,GAAG,CAAC,EAAE;YACT,IAAIpC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;cACrCwB,OAAO,GAAGmC,MAAM,GAAG,CAAC;YACxB;UACJ;QACJ;MACJ;IACJ,CAAC,MACI,IAAIxE,eAAe,CAACJ,IAAI,CAAC,EAAE;MAC5B;MACA;MACA,OAAOQ,IAAI;IACf;IACA,KAAK,IAAIO,CAAC,GAAGyB,GAAG,GAAG,CAAC,EAAEzB,CAAC,IAAI6D,MAAM,EAAE,EAAE7D,CAAC,EAAE;MACpC,IAAIX,eAAe,CAACI,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC,CAAC,EAAE;QACrC,IAAI,CAAC4D,YAAY,EAAE;UACfD,GAAG,GAAG3D,CAAC;UACP;QACJ;MACJ,CAAC,MACI;QACD;QACA4D,YAAY,GAAG,KAAK;MACxB;IACJ;IACA,IAAID,GAAG,KAAK,CAAC,CAAC,EAAE;MACZ,IAAIjC,OAAO,KAAK,CAAC,CAAC,EAAE;QAChB,OAAO,GAAG;MACd,CAAC,MACI;QACDiC,GAAG,GAAGjC,OAAO;MACjB;IACJ;IACA,OAAOjC,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEsD,GAAG,CAAC;EAC7B,CAAC;EACDG,QAAQ,EAAE,kBAAUrE,IAAI,EAAEmB,GAAG,EAAE;IAC3B,IAAIA,GAAG,KAAKW,SAAS,EAAE;MACnBpC,cAAc,CAACyB,GAAG,EAAE,KAAK,CAAC;IAC9B;IACAzB,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIsE,KAAK,GAAG,CAAC;IACb,IAAIJ,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAI5D,CAAC;IACL;IACA;IACA;IACA,IAAIP,IAAI,CAACQ,MAAM,IAAI,CAAC,EAAE;MAClB,IAAI+D,KAAK,GAAGvE,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC;MAC9B,IAAIX,mBAAmB,CAACyE,KAAK,CAAC,EAAE;QAC5B,IAAIvE,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,EAAE;UACnC4F,KAAK,GAAG,CAAC;QACb;MACJ;IACJ;IACA,IAAInD,GAAG,KAAKW,SAAS,IAAIX,GAAG,CAACX,MAAM,GAAG,CAAC,IAAIW,GAAG,CAACX,MAAM,IAAIR,IAAI,CAACQ,MAAM,EAAE;MAClE,IAAIW,GAAG,CAACX,MAAM,KAAKR,IAAI,CAACQ,MAAM,IAAIW,GAAG,KAAKnB,IAAI,EAAE;QAC5C,OAAO,EAAE;MACb;MACA,IAAIwE,MAAM,GAAGrD,GAAG,CAACX,MAAM,GAAG,CAAC;MAC3B,IAAIiE,gBAAgB,GAAG,CAAC,CAAC;MACzB,KAAKlE,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI+D,KAAK,EAAE,EAAE/D,CAAC,EAAE;QACvC,IAAIf,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;QAC7B,IAAIX,eAAe,CAACJ,IAAI,CAAC,EAAE;UACvB;UACA;UACA,IAAI,CAAC2E,YAAY,EAAE;YACfG,KAAK,GAAG/D,CAAC,GAAG,CAAC;YACb;UACJ;QACJ,CAAC,MACI;UACD,IAAIkE,gBAAgB,KAAK,CAAC,CAAC,EAAE;YACzB;YACA;YACAN,YAAY,GAAG,KAAK;YACpBM,gBAAgB,GAAGlE,CAAC,GAAG,CAAC;UAC5B;UACA,IAAIiE,MAAM,IAAI,CAAC,EAAE;YACb;YACA,IAAIhF,IAAI,KAAK2B,GAAG,CAACV,UAAU,CAAC+D,MAAM,CAAC,EAAE;cACjC,IAAI,EAAEA,MAAM,KAAK,CAAC,CAAC,EAAE;gBACjB;gBACA;gBACAN,GAAG,GAAG3D,CAAC;cACX;YACJ,CAAC,MACI;cACD;cACA;cACAiE,MAAM,GAAG,CAAC,CAAC;cACXN,GAAG,GAAGO,gBAAgB;YAC1B;UACJ;QACJ;MACJ;MACA,IAAIH,KAAK,KAAKJ,GAAG,EAAE;QACfA,GAAG,GAAGO,gBAAgB;MAC1B,CAAC,MACI,IAAIP,GAAG,KAAK,CAAC,CAAC,EAAE;QACjBA,GAAG,GAAGlE,IAAI,CAACQ,MAAM;MACrB;MACA,OAAOR,IAAI,CAACY,KAAK,CAAC0D,KAAK,EAAEJ,GAAG,CAAC;IACjC,CAAC,MACI;MACD,KAAK3D,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI+D,KAAK,EAAE,EAAE/D,CAAC,EAAE;QACvC,IAAIX,eAAe,CAACI,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC,CAAC,EAAE;UACrC;UACA;UACA,IAAI,CAAC4D,YAAY,EAAE;YACfG,KAAK,GAAG/D,CAAC,GAAG,CAAC;YACb;UACJ;QACJ,CAAC,MACI,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;UACjB;UACA;UACAC,YAAY,GAAG,KAAK;UACpBD,GAAG,GAAG3D,CAAC,GAAG,CAAC;QACf;MACJ;MACA,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ,OAAO,EAAE;MACb;MACA,OAAOlE,IAAI,CAACY,KAAK,CAAC0D,KAAK,EAAEJ,GAAG,CAAC;IACjC;EACJ,CAAC;EACDQ,OAAO,EAAE,iBAAU1E,IAAI,EAAE;IACrBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIsE,KAAK,GAAG,CAAC;IACb,IAAIK,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIV,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB;IACA;IACA,IAAIU,WAAW,GAAG,CAAC;IACnB;IACA;IACA;IACA,IAAI7E,IAAI,CAACQ,MAAM,IAAI,CAAC,IAChBR,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,IACjCoB,mBAAmB,CAACE,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MACzC6D,KAAK,GAAGM,SAAS,GAAG,CAAC;IACzB;IACA,KAAK,IAAIrE,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI+D,KAAK,EAAE,EAAE/D,CAAC,EAAE;MAC3C,IAAIf,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;MAC7B,IAAIX,eAAe,CAACJ,IAAI,CAAC,EAAE;QACvB;QACA;QACA,IAAI,CAAC2E,YAAY,EAAE;UACfS,SAAS,GAAGrE,CAAC,GAAG,CAAC;UACjB;QACJ;QACA;MACJ;MACA,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ;QACA;QACAC,YAAY,GAAG,KAAK;QACpBD,GAAG,GAAG3D,CAAC,GAAG,CAAC;MACf;MACA,IAAIf,IAAI,KAAKjB,QAAQ,EAAE;QACnB;QACA,IAAIoG,QAAQ,KAAK,CAAC,CAAC,EAAE;UACjBA,QAAQ,GAAGpE,CAAC;QAChB,CAAC,MACI,IAAIsE,WAAW,KAAK,CAAC,EAAE;UACxBA,WAAW,GAAG,CAAC;QACnB;MACJ,CAAC,MACI,IAAIF,QAAQ,KAAK,CAAC,CAAC,EAAE;QACtB;QACA;QACAE,WAAW,GAAG,CAAC,CAAC;MACpB;IACJ;IACA,IAAIF,QAAQ,KAAK,CAAC,CAAC,IACfT,GAAG,KAAK,CAAC,CAAC;IACV;IACAW,WAAW,KAAK,CAAC;IACjB;IACCA,WAAW,KAAK,CAAC,IACdF,QAAQ,KAAKT,GAAG,GAAG,CAAC,IACpBS,QAAQ,KAAKC,SAAS,GAAG,CAAE,EAAE;MACjC,OAAO,EAAE;IACb;IACA,OAAO5E,IAAI,CAACY,KAAK,CAAC+D,QAAQ,EAAET,GAAG,CAAC;EACpC,CAAC;EACDY,MAAM,EAAE,gBAAU/D,UAAU,EAAE;IAC1B,IAAIA,UAAU,KAAK,IAAI,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;MACvD,MAAM,IAAInC,mBAAmB,CAAC,YAAY,EAAE,QAAQ,EAAEmC,UAAU,CAAC;IACrE;IACA,OAAOF,OAAO,CAAC,IAAI,EAAEE,UAAU,CAAC;EACpC,CAAC;EACDgE,KAAK,EAAE,eAAU/E,IAAI,EAAE;IACnBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIgF,GAAG,GAAG;MAAE/D,IAAI,EAAE,EAAE;MAAED,GAAG,EAAE,EAAE;MAAEE,IAAI,EAAE,EAAE;MAAEC,GAAG,EAAE,EAAE;MAAErC,IAAI,EAAE;IAAG,CAAC;IAC5D,IAAIkB,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;MACnB,OAAOwE,GAAG;IACd;IACA,IAAIhD,GAAG,GAAGhC,IAAI,CAACQ,MAAM;IACrB,IAAIyB,OAAO,GAAG,CAAC;IACf,IAAIzC,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC;IAC7B;IACA,IAAIuB,GAAG,GAAG,CAAC,EAAE;MACT,IAAIpC,eAAe,CAACJ,IAAI,CAAC,EAAE;QACvB;QACAyC,OAAO,GAAG,CAAC;QACX,IAAIrC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;UACrC;UACA,IAAI2B,CAAC,GAAG,CAAC;UACT,IAAIC,IAAI,GAAGD,CAAC;UACZ;UACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;YACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;cACrC;YACJ;UACJ;UACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;YACvB;YACAA,IAAI,GAAGD,CAAC;YACR;YACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;cACjB,IAAI,CAACxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;gBACtC;cACJ;YACJ;YACA,IAAIA,CAAC,GAAGJ,GAAG,IAAII,CAAC,KAAKC,IAAI,EAAE;cACvB;cACAA,IAAI,GAAGD,CAAC;cACR;cACA,OAAOA,CAAC,GAAGJ,GAAG,EAAE,EAAEI,CAAC,EAAE;gBACjB,IAAIxC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC2B,CAAC,CAAC,CAAC,EAAE;kBACrC;gBACJ;cACJ;cACA,IAAIA,CAAC,KAAKJ,GAAG,EAAE;gBACX;gBACAC,OAAO,GAAGG,CAAC;cACf,CAAC,MACI,IAAIA,CAAC,KAAKC,IAAI,EAAE;gBACjB;gBACAJ,OAAO,GAAGG,CAAC,GAAG,CAAC;cACnB;YACJ;UACJ;QACJ;MACJ,CAAC,MACI,IAAItC,mBAAmB,CAACN,IAAI,CAAC,EAAE;QAChC;QACA,IAAIQ,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAK/B,UAAU,EAAE;UACnCuD,OAAO,GAAG,CAAC;UACX,IAAID,GAAG,GAAG,CAAC,EAAE;YACT,IAAIpC,eAAe,CAACI,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;cACrC,IAAIuB,GAAG,KAAK,CAAC,EAAE;gBACX;gBACA;gBACAgD,GAAG,CAAC/D,IAAI,GAAG+D,GAAG,CAAChE,GAAG,GAAGhB,IAAI;gBACzB,OAAOgF,GAAG;cACd;cACA/C,OAAO,GAAG,CAAC;YACf;UACJ,CAAC,MACI;YACD;YACA;YACA+C,GAAG,CAAC/D,IAAI,GAAG+D,GAAG,CAAChE,GAAG,GAAGhB,IAAI;YACzB,OAAOgF,GAAG;UACd;QACJ;MACJ;IACJ,CAAC,MACI,IAAIpF,eAAe,CAACJ,IAAI,CAAC,EAAE;MAC5B;MACA;MACAwF,GAAG,CAAC/D,IAAI,GAAG+D,GAAG,CAAChE,GAAG,GAAGhB,IAAI;MACzB,OAAOgF,GAAG;IACd;IACA,IAAI/C,OAAO,GAAG,CAAC,EAAE;MACb+C,GAAG,CAAC/D,IAAI,GAAGjB,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEqB,OAAO,CAAC;IACrC;IACA,IAAI0C,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAIC,SAAS,GAAG3C,OAAO;IACvB,IAAIiC,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAI5D,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC;IACvB;IACA;IACA,IAAIqE,WAAW,GAAG,CAAC;IACnB;IACA,OAAOtE,CAAC,IAAI0B,OAAO,EAAE,EAAE1B,CAAC,EAAE;MACtBf,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;MACzB,IAAIX,eAAe,CAACJ,IAAI,CAAC,EAAE;QACvB;QACA;QACA,IAAI,CAAC2E,YAAY,EAAE;UACfS,SAAS,GAAGrE,CAAC,GAAG,CAAC;UACjB;QACJ;QACA;MACJ;MACA,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ;QACA;QACAC,YAAY,GAAG,KAAK;QACpBD,GAAG,GAAG3D,CAAC,GAAG,CAAC;MACf;MACA,IAAIf,IAAI,KAAKjB,QAAQ,EAAE;QACnB;QACA,IAAIoG,QAAQ,KAAK,CAAC,CAAC,EAAE;UACjBA,QAAQ,GAAGpE,CAAC;QAChB,CAAC,MACI,IAAIsE,WAAW,KAAK,CAAC,EAAE;UACxBA,WAAW,GAAG,CAAC;QACnB;MACJ,CAAC,MACI,IAAIF,QAAQ,KAAK,CAAC,CAAC,EAAE;QACtB;QACA;QACAE,WAAW,GAAG,CAAC,CAAC;MACpB;IACJ;IACA,IAAIF,QAAQ,KAAK,CAAC,CAAC,IACfT,GAAG,KAAK,CAAC,CAAC;IACV;IACAW,WAAW,KAAK,CAAC;IACjB;IACCA,WAAW,KAAK,CAAC,IACdF,QAAQ,KAAKT,GAAG,GAAG,CAAC,IACpBS,QAAQ,KAAKC,SAAS,GAAG,CAAE,EAAE;MACjC,IAAIV,GAAG,KAAK,CAAC,CAAC,EAAE;QACZc,GAAG,CAAC9D,IAAI,GAAG8D,GAAG,CAAClG,IAAI,GAAGkB,IAAI,CAACY,KAAK,CAACgE,SAAS,EAAEV,GAAG,CAAC;MACpD;IACJ,CAAC,MACI;MACDc,GAAG,CAAClG,IAAI,GAAGkB,IAAI,CAACY,KAAK,CAACgE,SAAS,EAAED,QAAQ,CAAC;MAC1CK,GAAG,CAAC9D,IAAI,GAAGlB,IAAI,CAACY,KAAK,CAACgE,SAAS,EAAEV,GAAG,CAAC;MACrCc,GAAG,CAAC7D,GAAG,GAAGnB,IAAI,CAACY,KAAK,CAAC+D,QAAQ,EAAET,GAAG,CAAC;IACvC;IACA;IACA;IACA;IACA,IAAIU,SAAS,GAAG,CAAC,IAAIA,SAAS,KAAK3C,OAAO,EAAE;MACxC+C,GAAG,CAAChE,GAAG,GAAGhB,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEgE,SAAS,GAAG,CAAC,CAAC;IAC1C,CAAC,MACI;MACDI,GAAG,CAAChE,GAAG,GAAGgE,GAAG,CAAC/D,IAAI;IACtB;IACA,OAAO+D,GAAG;EACd,CAAC;EACDlE,GAAG,EAAE,IAAI;EACTmE,SAAS,EAAE,GAAG;EACd7D,KAAK,EAAE,IAAI;EACX8D,KAAK,EAAE;AACX,CAAC;AACD,OAAO,IAAIA,KAAK,GAAG;EACf;EACA7D,OAAO,EAAE,mBAAY;IACjB,IAAIC,YAAY,GAAG,EAAE;IACrB,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAAChB,MAAM,EAAEe,EAAE,EAAE,EAAE;MAC1CD,YAAY,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IACpC;IACA,IAAIyC,YAAY,GAAG,EAAE;IACrB,IAAIrC,gBAAgB,GAAG,KAAK;IAC5B,KAAK,IAAIpB,CAAC,GAAGe,YAAY,CAACd,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,CAAC,IAAI,CAACoB,gBAAgB,EAAEpB,CAAC,EAAE,EAAE;MACrE,IAAIP,IAAI,GAAG,KAAK,CAAC;MACjB,IAAIO,CAAC,IAAI,CAAC,EAAE;QACRP,IAAI,GAAGsB,YAAY,CAACf,CAAC,CAAC;MAC1B,CAAC,MACI;QACDP,IAAI,GAAG9B,OAAO,CAAC0D,GAAG,EAAE;MACxB;MACAlC,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;MAC5B;MACA,IAAIA,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;QACnB;MACJ;MACAwD,YAAY,GAAGhE,IAAI,GAAG,GAAG,GAAGgE,YAAY;MACxCrC,gBAAgB,GAAG3B,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAKjC,kBAAkB;IAChE;IACA;IACA;IACA;IACAwF,YAAY,GAAGjE,eAAe,CAACiE,YAAY,EAAE,CAACrC,gBAAgB,EAAE,GAAG,EAAE9B,oBAAoB,CAAC;IAC1F,IAAI8B,gBAAgB,EAAE;MAClB,IAAIqC,YAAY,CAACxD,MAAM,GAAG,CAAC,EAAE;QACzB,OAAO,GAAG,GAAGwD,YAAY;MAC7B,CAAC,MACI;QACD,OAAO,GAAG;MACd;IACJ,CAAC,MACI,IAAIA,YAAY,CAACxD,MAAM,GAAG,CAAC,EAAE;MAC9B,OAAOwD,YAAY;IACvB,CAAC,MACI;MACD,OAAO,GAAG;IACd;EACJ,CAAC;EACDzB,SAAS,EAAE,mBAAUvC,IAAI,EAAE;IACvBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIA,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,GAAG;IACd;IACA,IAAI2B,UAAU,GAAGnC,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAKjC,kBAAkB;IAC1D,IAAI2G,iBAAiB,GAAGnF,IAAI,CAACS,UAAU,CAACT,IAAI,CAACQ,MAAM,GAAG,CAAC,CAAC,KAAKhC,kBAAkB;IAC/E;IACAwB,IAAI,GAAGD,eAAe,CAACC,IAAI,EAAE,CAACmC,UAAU,EAAE,GAAG,EAAEtC,oBAAoB,CAAC;IACpE,IAAIG,IAAI,CAACQ,MAAM,KAAK,CAAC,IAAI,CAAC2B,UAAU,EAAE;MAClCnC,IAAI,GAAG,GAAG;IACd;IACA,IAAIA,IAAI,CAACQ,MAAM,GAAG,CAAC,IAAI2E,iBAAiB,EAAE;MACtCnF,IAAI,IAAI,GAAG;IACf;IACA,IAAImC,UAAU,EAAE;MACZ,OAAO,GAAG,GAAGnC,IAAI;IACrB;IACA,OAAOA,IAAI;EACf,CAAC;EACDmC,UAAU,EAAE,oBAAUnC,IAAI,EAAE;IACxBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,OAAOA,IAAI,CAACQ,MAAM,GAAG,CAAC,IAAIR,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAKjC,kBAAkB;EACvE,CAAC;EACDiE,IAAI,EAAE,gBAAY;IACd,IAAIC,KAAK,GAAG,EAAE;IACd,KAAK,IAAInB,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAAChB,MAAM,EAAEe,EAAE,EAAE,EAAE;MAC1CmB,KAAK,CAACnB,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IAC7B;IACA,IAAImB,KAAK,CAAClC,MAAM,KAAK,CAAC,EAAE;MACpB,OAAO,GAAG;IACd;IACA,IAAImC,MAAM;IACV,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,KAAK,CAAClC,MAAM,EAAE,EAAED,CAAC,EAAE;MACnC,IAAIqC,GAAG,GAAGpB,SAAS,CAACjB,CAAC,CAAC;MACtBb,cAAc,CAACkD,GAAG,EAAE,MAAM,CAAC;MAC3B,IAAIA,GAAG,CAACpC,MAAM,GAAG,CAAC,EAAE;QAChB,IAAImC,MAAM,KAAKb,SAAS,EAAE;UACtBa,MAAM,GAAGC,GAAG;QAChB,CAAC,MACI;UACDD,MAAM,IAAI,GAAG,GAAGC,GAAG;QACvB;MACJ;IACJ;IACA,IAAID,MAAM,KAAKb,SAAS,EAAE;MACtB,OAAO,GAAG;IACd;IACA,OAAOoD,KAAK,CAAC3C,SAAS,CAACI,MAAM,CAAC;EAClC,CAAC;EACDK,QAAQ,EAAE,kBAAUC,IAAI,EAAEC,EAAE,EAAE;IAC1BxD,cAAc,CAACuD,IAAI,EAAE,MAAM,CAAC;IAC5BvD,cAAc,CAACwD,EAAE,EAAE,IAAI,CAAC;IACxB,IAAID,IAAI,KAAKC,EAAE,EAAE;MACb,OAAO,EAAE;IACb;IACAD,IAAI,GAAGiC,KAAK,CAAC7D,OAAO,CAAC4B,IAAI,CAAC;IAC1BC,EAAE,GAAGgC,KAAK,CAAC7D,OAAO,CAAC6B,EAAE,CAAC;IACtB,IAAID,IAAI,KAAKC,EAAE,EAAE;MACb,OAAO,EAAE;IACb;IACA;IACA,IAAIG,SAAS,GAAG,CAAC;IACjB,OAAOA,SAAS,GAAGJ,IAAI,CAACzC,MAAM,EAAE,EAAE6C,SAAS,EAAE;MACzC,IAAIJ,IAAI,CAACxC,UAAU,CAAC4C,SAAS,CAAC,KAAK7E,kBAAkB,EAAE;QACnD;MACJ;IACJ;IACA,IAAI8E,OAAO,GAAGL,IAAI,CAACzC,MAAM;IACzB,IAAI+C,OAAO,GAAID,OAAO,GAAGD,SAAU;IACnC;IACA,IAAIG,OAAO,GAAG,CAAC;IACf,OAAOA,OAAO,GAAGN,EAAE,CAAC1C,MAAM,EAAE,EAAEgD,OAAO,EAAE;MACnC,IAAIN,EAAE,CAACzC,UAAU,CAAC+C,OAAO,CAAC,KAAKhF,kBAAkB,EAAE;QAC/C;MACJ;IACJ;IACA,IAAIiF,KAAK,GAAGP,EAAE,CAAC1C,MAAM;IACrB,IAAIkD,KAAK,GAAID,KAAK,GAAGD,OAAQ;IAC7B;IACA,IAAIhD,MAAM,GAAI+C,OAAO,GAAGG,KAAK,GAAGH,OAAO,GAAGG,KAAM;IAChD,IAAIC,aAAa,GAAG,CAAC,CAAC;IACtB,IAAIpD,CAAC,GAAG,CAAC;IACT,OAAOA,CAAC,IAAIC,MAAM,EAAE,EAAED,CAAC,EAAE;MACrB,IAAIA,CAAC,KAAKC,MAAM,EAAE;QACd,IAAIkD,KAAK,GAAGlD,MAAM,EAAE;UAChB,IAAI0C,EAAE,CAACzC,UAAU,CAAC+C,OAAO,GAAGjD,CAAC,CAAC,KAAK/B,kBAAkB,EAAE;YACnD;YACA;YACA,OAAO0E,EAAE,CAACtC,KAAK,CAAC4C,OAAO,GAAGjD,CAAC,GAAG,CAAC,CAAC;UACpC,CAAC,MACI,IAAIA,CAAC,KAAK,CAAC,EAAE;YACd;YACA;YACA,OAAO2C,EAAE,CAACtC,KAAK,CAAC4C,OAAO,GAAGjD,CAAC,CAAC;UAChC;QACJ,CAAC,MACI,IAAIgD,OAAO,GAAG/C,MAAM,EAAE;UACvB,IAAIyC,IAAI,CAACxC,UAAU,CAAC4C,SAAS,GAAG9C,CAAC,CAAC,KAAK/B,kBAAkB,EAAE;YACvD;YACA;YACAmF,aAAa,GAAGpD,CAAC;UACrB,CAAC,MACI,IAAIA,CAAC,KAAK,CAAC,EAAE;YACd;YACA;YACAoD,aAAa,GAAG,CAAC;UACrB;QACJ;QACA;MACJ;MACA,IAAIC,QAAQ,GAAGX,IAAI,CAACxC,UAAU,CAAC4C,SAAS,GAAG9C,CAAC,CAAC;MAC7C,IAAIsD,MAAM,GAAGX,EAAE,CAACzC,UAAU,CAAC+C,OAAO,GAAGjD,CAAC,CAAC;MACvC,IAAIqD,QAAQ,KAAKC,MAAM,EAAE;QACrB;MACJ,CAAC,MACI,IAAID,QAAQ,KAAKpF,kBAAkB,EAAE;QACtCmF,aAAa,GAAGpD,CAAC;MACrB;IACJ;IACA,IAAIuD,GAAG,GAAG,EAAE;IACZ;IACA;IACA,KAAKvD,CAAC,GAAG8C,SAAS,GAAGM,aAAa,GAAG,CAAC,EAAEpD,CAAC,IAAI+C,OAAO,EAAE,EAAE/C,CAAC,EAAE;MACvD,IAAIA,CAAC,KAAK+C,OAAO,IAAIL,IAAI,CAACxC,UAAU,CAACF,CAAC,CAAC,KAAK/B,kBAAkB,EAAE;QAC5D,IAAIsF,GAAG,CAACtD,MAAM,KAAK,CAAC,EAAE;UAClBsD,GAAG,IAAI,IAAI;QACf,CAAC,MACI;UACDA,GAAG,IAAI,KAAK;QAChB;MACJ;IACJ;IACA;IACA;IACA,IAAIA,GAAG,CAACtD,MAAM,GAAG,CAAC,EAAE;MAChB,OAAOsD,GAAG,GAAGZ,EAAE,CAACtC,KAAK,CAAC4C,OAAO,GAAGG,aAAa,CAAC;IAClD,CAAC,MACI;MACDH,OAAO,IAAIG,aAAa;MACxB,IAAIT,EAAE,CAACzC,UAAU,CAAC+C,OAAO,CAAC,KAAKhF,kBAAkB,EAAE;QAC/C,EAAEgF,OAAO;MACb;MACA,OAAON,EAAE,CAACtC,KAAK,CAAC4C,OAAO,CAAC;IAC5B;EACJ,CAAC;EACDO,gBAAgB,EAAE,0BAAU/D,IAAI,EAAE;IAC9B;IACA,OAAOA,IAAI;EACf,CAAC;EACDiE,OAAO,EAAE,iBAAUjE,IAAI,EAAE;IACrBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIA,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,GAAG;IACd;IACA,IAAI4E,OAAO,GAAGpF,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAKjC,kBAAkB;IACvD,IAAI0F,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB,KAAK,IAAI5D,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACvC,IAAIP,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC,KAAK/B,kBAAkB,EAAE;QAC3C,IAAI,CAAC2F,YAAY,EAAE;UACfD,GAAG,GAAG3D,CAAC;UACP;QACJ;MACJ,CAAC,MACI;QACD;QACA4D,YAAY,GAAG,KAAK;MACxB;IACJ;IACA,IAAID,GAAG,KAAK,CAAC,CAAC,EAAE;MACZ,OAAOkB,OAAO,GAAG,GAAG,GAAG,GAAG;IAC9B;IACA,IAAIA,OAAO,IAAIlB,GAAG,KAAK,CAAC,EAAE;MACtB,OAAO,IAAI;IACf;IACA,OAAOlE,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEsD,GAAG,CAAC;EAC7B,CAAC;EACDG,QAAQ,EAAE,kBAAUrE,IAAI,EAAEmB,GAAG,EAAE;IAC3B,IAAIA,GAAG,KAAKW,SAAS,EAAE;MACnBpC,cAAc,CAACyB,GAAG,EAAE,KAAK,CAAC;IAC9B;IACAzB,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIsE,KAAK,GAAG,CAAC;IACb,IAAIJ,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAI5D,CAAC;IACL,IAAIY,GAAG,KAAKW,SAAS,IAAIX,GAAG,CAACX,MAAM,GAAG,CAAC,IAAIW,GAAG,CAACX,MAAM,IAAIR,IAAI,CAACQ,MAAM,EAAE;MAClE,IAAIW,GAAG,CAACX,MAAM,KAAKR,IAAI,CAACQ,MAAM,IAAIW,GAAG,KAAKnB,IAAI,EAAE;QAC5C,OAAO,EAAE;MACb;MACA,IAAIwE,MAAM,GAAGrD,GAAG,CAACX,MAAM,GAAG,CAAC;MAC3B,IAAIiE,gBAAgB,GAAG,CAAC,CAAC;MACzB,KAAKlE,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QACnC,IAAIf,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;QAC7B,IAAIf,IAAI,KAAKhB,kBAAkB,EAAE;UAC7B;UACA;UACA,IAAI,CAAC2F,YAAY,EAAE;YACfG,KAAK,GAAG/D,CAAC,GAAG,CAAC;YACb;UACJ;QACJ,CAAC,MACI;UACD,IAAIkE,gBAAgB,KAAK,CAAC,CAAC,EAAE;YACzB;YACA;YACAN,YAAY,GAAG,KAAK;YACpBM,gBAAgB,GAAGlE,CAAC,GAAG,CAAC;UAC5B;UACA,IAAIiE,MAAM,IAAI,CAAC,EAAE;YACb;YACA,IAAIhF,IAAI,KAAK2B,GAAG,CAACV,UAAU,CAAC+D,MAAM,CAAC,EAAE;cACjC,IAAI,EAAEA,MAAM,KAAK,CAAC,CAAC,EAAE;gBACjB;gBACA;gBACAN,GAAG,GAAG3D,CAAC;cACX;YACJ,CAAC,MACI;cACD;cACA;cACAiE,MAAM,GAAG,CAAC,CAAC;cACXN,GAAG,GAAGO,gBAAgB;YAC1B;UACJ;QACJ;MACJ;MACA,IAAIH,KAAK,KAAKJ,GAAG,EAAE;QACfA,GAAG,GAAGO,gBAAgB;MAC1B,CAAC,MACI,IAAIP,GAAG,KAAK,CAAC,CAAC,EAAE;QACjBA,GAAG,GAAGlE,IAAI,CAACQ,MAAM;MACrB;MACA,OAAOR,IAAI,CAACY,KAAK,CAAC0D,KAAK,EAAEJ,GAAG,CAAC;IACjC,CAAC,MACI;MACD,KAAK3D,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QACnC,IAAIP,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC,KAAK/B,kBAAkB,EAAE;UAC3C;UACA;UACA,IAAI,CAAC2F,YAAY,EAAE;YACfG,KAAK,GAAG/D,CAAC,GAAG,CAAC;YACb;UACJ;QACJ,CAAC,MACI,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;UACjB;UACA;UACAC,YAAY,GAAG,KAAK;UACpBD,GAAG,GAAG3D,CAAC,GAAG,CAAC;QACf;MACJ;MACA,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ,OAAO,EAAE;MACb;MACA,OAAOlE,IAAI,CAACY,KAAK,CAAC0D,KAAK,EAAEJ,GAAG,CAAC;IACjC;EACJ,CAAC;EACDQ,OAAO,EAAE,iBAAU1E,IAAI,EAAE;IACrBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAI2E,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIV,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB;IACA;IACA,IAAIU,WAAW,GAAG,CAAC;IACnB,KAAK,IAAItE,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MACvC,IAAIf,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;MAC7B,IAAIf,IAAI,KAAKhB,kBAAkB,EAAE;QAC7B;QACA;QACA,IAAI,CAAC2F,YAAY,EAAE;UACfS,SAAS,GAAGrE,CAAC,GAAG,CAAC;UACjB;QACJ;QACA;MACJ;MACA,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ;QACA;QACAC,YAAY,GAAG,KAAK;QACpBD,GAAG,GAAG3D,CAAC,GAAG,CAAC;MACf;MACA,IAAIf,IAAI,KAAKjB,QAAQ,EAAE;QACnB;QACA,IAAIoG,QAAQ,KAAK,CAAC,CAAC,EAAE;UACjBA,QAAQ,GAAGpE,CAAC;QAChB,CAAC,MACI,IAAIsE,WAAW,KAAK,CAAC,EAAE;UACxBA,WAAW,GAAG,CAAC;QACnB;MACJ,CAAC,MACI,IAAIF,QAAQ,KAAK,CAAC,CAAC,EAAE;QACtB;QACA;QACAE,WAAW,GAAG,CAAC,CAAC;MACpB;IACJ;IACA,IAAIF,QAAQ,KAAK,CAAC,CAAC,IACfT,GAAG,KAAK,CAAC,CAAC;IACV;IACAW,WAAW,KAAK,CAAC;IACjB;IACCA,WAAW,KAAK,CAAC,IACdF,QAAQ,KAAKT,GAAG,GAAG,CAAC,IACpBS,QAAQ,KAAKC,SAAS,GAAG,CAAE,EAAE;MACjC,OAAO,EAAE;IACb;IACA,OAAO5E,IAAI,CAACY,KAAK,CAAC+D,QAAQ,EAAET,GAAG,CAAC;EACpC,CAAC;EACDY,MAAM,EAAE,gBAAU/D,UAAU,EAAE;IAC1B,IAAIA,UAAU,KAAK,IAAI,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;MACvD,MAAM,IAAInC,mBAAmB,CAAC,YAAY,EAAE,QAAQ,EAAEmC,UAAU,CAAC;IACrE;IACA,OAAOF,OAAO,CAAC,GAAG,EAAEE,UAAU,CAAC;EACnC,CAAC;EACDgE,KAAK,EAAE,eAAU/E,IAAI,EAAE;IACnBN,cAAc,CAACM,IAAI,EAAE,MAAM,CAAC;IAC5B,IAAIgF,GAAG,GAAG;MAAE/D,IAAI,EAAE,EAAE;MAAED,GAAG,EAAE,EAAE;MAAEE,IAAI,EAAE,EAAE;MAAEC,GAAG,EAAE,EAAE;MAAErC,IAAI,EAAE;IAAG,CAAC;IAC5D,IAAIkB,IAAI,CAACQ,MAAM,KAAK,CAAC,EAAE;MACnB,OAAOwE,GAAG;IACd;IACA,IAAI7C,UAAU,GAAGnC,IAAI,CAACS,UAAU,CAAC,CAAC,CAAC,KAAKjC,kBAAkB;IAC1D,IAAI8F,KAAK;IACT,IAAInC,UAAU,EAAE;MACZ6C,GAAG,CAAC/D,IAAI,GAAG,GAAG;MACdqD,KAAK,GAAG,CAAC;IACb,CAAC,MACI;MACDA,KAAK,GAAG,CAAC;IACb;IACA,IAAIK,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIV,GAAG,GAAG,CAAC,CAAC;IACZ,IAAIC,YAAY,GAAG,IAAI;IACvB,IAAI5D,CAAC,GAAGP,IAAI,CAACQ,MAAM,GAAG,CAAC;IACvB;IACA;IACA,IAAIqE,WAAW,GAAG,CAAC;IACnB;IACA,OAAOtE,CAAC,IAAI+D,KAAK,EAAE,EAAE/D,CAAC,EAAE;MACpB,IAAIf,IAAI,GAAGQ,IAAI,CAACS,UAAU,CAACF,CAAC,CAAC;MAC7B,IAAIf,IAAI,KAAKhB,kBAAkB,EAAE;QAC7B;QACA;QACA,IAAI,CAAC2F,YAAY,EAAE;UACfS,SAAS,GAAGrE,CAAC,GAAG,CAAC;UACjB;QACJ;QACA;MACJ;MACA,IAAI2D,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ;QACA;QACAC,YAAY,GAAG,KAAK;QACpBD,GAAG,GAAG3D,CAAC,GAAG,CAAC;MACf;MACA,IAAIf,IAAI,KAAKjB,QAAQ,EAAE;QACnB;QACA,IAAIoG,QAAQ,KAAK,CAAC,CAAC,EAAE;UACjBA,QAAQ,GAAGpE,CAAC;QAChB,CAAC,MACI,IAAIsE,WAAW,KAAK,CAAC,EAAE;UACxBA,WAAW,GAAG,CAAC;QACnB;MACJ,CAAC,MACI,IAAIF,QAAQ,KAAK,CAAC,CAAC,EAAE;QACtB;QACA;QACAE,WAAW,GAAG,CAAC,CAAC;MACpB;IACJ;IACA,IAAIF,QAAQ,KAAK,CAAC,CAAC,IACfT,GAAG,KAAK,CAAC,CAAC;IACV;IACAW,WAAW,KAAK,CAAC;IACjB;IACCA,WAAW,KAAK,CAAC,IACdF,QAAQ,KAAKT,GAAG,GAAG,CAAC,IACpBS,QAAQ,KAAKC,SAAS,GAAG,CAAE,EAAE;MACjC,IAAIV,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ,IAAIU,SAAS,KAAK,CAAC,IAAIzC,UAAU,EAAE;UAC/B6C,GAAG,CAAC9D,IAAI,GAAG8D,GAAG,CAAClG,IAAI,GAAGkB,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEsD,GAAG,CAAC;QAC5C,CAAC,MACI;UACDc,GAAG,CAAC9D,IAAI,GAAG8D,GAAG,CAAClG,IAAI,GAAGkB,IAAI,CAACY,KAAK,CAACgE,SAAS,EAAEV,GAAG,CAAC;QACpD;MACJ;IACJ,CAAC,MACI;MACD,IAAIU,SAAS,KAAK,CAAC,IAAIzC,UAAU,EAAE;QAC/B6C,GAAG,CAAClG,IAAI,GAAGkB,IAAI,CAACY,KAAK,CAAC,CAAC,EAAE+D,QAAQ,CAAC;QAClCK,GAAG,CAAC9D,IAAI,GAAGlB,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEsD,GAAG,CAAC;MACjC,CAAC,MACI;QACDc,GAAG,CAAClG,IAAI,GAAGkB,IAAI,CAACY,KAAK,CAACgE,SAAS,EAAED,QAAQ,CAAC;QAC1CK,GAAG,CAAC9D,IAAI,GAAGlB,IAAI,CAACY,KAAK,CAACgE,SAAS,EAAEV,GAAG,CAAC;MACzC;MACAc,GAAG,CAAC7D,GAAG,GAAGnB,IAAI,CAACY,KAAK,CAAC+D,QAAQ,EAAET,GAAG,CAAC;IACvC;IACA,IAAIU,SAAS,GAAG,CAAC,EAAE;MACfI,GAAG,CAAChE,GAAG,GAAGhB,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEgE,SAAS,GAAG,CAAC,CAAC;IAC1C,CAAC,MACI,IAAIzC,UAAU,EAAE;MACjB6C,GAAG,CAAChE,GAAG,GAAG,GAAG;IACjB;IACA,OAAOgE,GAAG;EACd,CAAC;EACDlE,GAAG,EAAE,GAAG;EACRmE,SAAS,EAAE,GAAG;EACd7D,KAAK,EAAE,IAAI;EACX8D,KAAK,EAAE;AACX,CAAC;AACDA,KAAK,CAAC9D,KAAK,GAAGA,KAAK,CAACA,KAAK,GAAGA,KAAK;AACjC8D,KAAK,CAACA,KAAK,GAAG9D,KAAK,CAAC8D,KAAK,GAAGA,KAAK;AACjC,OAAO,IAAI3C,SAAS,GAAIrE,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAACmB,SAAS,GAAG2C,KAAK,CAAC3C,SAAU;AACzF,OAAO,IAAIE,IAAI,GAAIvE,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAACqB,IAAI,GAAGyC,KAAK,CAACzC,IAAK;AAC1E,OAAO,IAAIO,QAAQ,GAAI9E,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAAC4B,QAAQ,GAAGkC,KAAK,CAAClC,QAAS;AACtF,OAAO,IAAIiB,OAAO,GAAI/F,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAAC6C,OAAO,GAAGiB,KAAK,CAACjB,OAAQ;AACnF,OAAO,IAAII,QAAQ,GAAInG,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAACiD,QAAQ,GAAGa,KAAK,CAACb,QAAS;AACtF,OAAO,IAAIK,OAAO,GAAIxG,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAACsD,OAAO,GAAGQ,KAAK,CAACR,OAAQ;AACnF,OAAO,IAAI5D,GAAG,GAAI5C,OAAO,CAACmH,QAAQ,KAAK,OAAO,GAAGjE,KAAK,CAACN,GAAG,GAAGoE,KAAK,CAACpE,GAAI"},"metadata":{},"sourceType":"module"}