{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nvar PieceTreeTextBuffer = /** @class */function () {\n  function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\n    this._BOM = BOM;\n    this._mightContainNonBasicASCII = !isBasicASCII;\n    this._mightContainRTL = containsRTL;\n    this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n  }\n  PieceTreeTextBuffer.prototype.mightContainRTL = function () {\n    return this._mightContainRTL;\n  };\n  PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {\n    return this._mightContainNonBasicASCII;\n  };\n  PieceTreeTextBuffer.prototype.getBOM = function () {\n    return this._BOM;\n  };\n  PieceTreeTextBuffer.prototype.getEOL = function () {\n    return this._pieceTree.getEOL();\n  };\n  PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {\n    return this._pieceTree.getOffsetAt(lineNumber, column);\n  };\n  PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {\n    return this._pieceTree.getPositionAt(offset);\n  };\n  PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {\n    var end = start + length;\n    var startPosition = this.getPositionAt(start);\n    var endPosition = this.getPositionAt(end);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  };\n  PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0 /* TextDefined */;\n    }\n    if (range.isEmpty()) {\n      return '';\n    }\n    var lineEnding = this._getEndOfLine(eol);\n    return this._pieceTree.getValueInRange(range, lineEnding);\n  };\n  PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0 /* TextDefined */;\n    }\n    if (range.isEmpty()) {\n      return 0;\n    }\n    if (range.startLineNumber === range.endLineNumber) {\n      return range.endColumn - range.startColumn;\n    }\n    var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n    var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n    return endOffset - startOffset;\n  };\n  PieceTreeTextBuffer.prototype.getCharacterCountInRange = function (range, eol) {\n    if (eol === void 0) {\n      eol = 0 /* TextDefined */;\n    }\n    if (this._mightContainNonBasicASCII) {\n      // we must count by iterating\n      var result = 0;\n      var fromLineNumber = range.startLineNumber;\n      var toLineNumber = range.endLineNumber;\n      for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        var lineContent = this.getLineContent(lineNumber);\n        var fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n        var toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n        for (var offset = fromOffset; offset < toOffset; offset++) {\n          if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n            result = result + 1;\n            offset = offset + 1;\n          } else {\n            result = result + 1;\n          }\n        }\n      }\n      result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n      return result;\n    }\n    return this.getValueLengthInRange(range, eol);\n  };\n  PieceTreeTextBuffer.prototype.getLength = function () {\n    return this._pieceTree.getLength();\n  };\n  PieceTreeTextBuffer.prototype.getLineCount = function () {\n    return this._pieceTree.getLineCount();\n  };\n  PieceTreeTextBuffer.prototype.getLinesContent = function () {\n    return this._pieceTree.getLinesContent();\n  };\n  PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {\n    return this._pieceTree.getLineContent(lineNumber);\n  };\n  PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {\n    return this._pieceTree.getLineCharCode(lineNumber, index);\n  };\n  PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {\n    return this._pieceTree.getLineLength(lineNumber);\n  };\n  PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  };\n  PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\n    var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  };\n  PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {\n    switch (eol) {\n      case 1 /* LF */:\n        return '\\n';\n      case 2 /* CRLF */:\n        return '\\r\\n';\n      case 0 /* TextDefined */:\n        return this.getEOL();\n    }\n    throw new Error('Unknown EOL preference');\n  };\n  PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {\n    this._pieceTree.setEOL(newEOL);\n  };\n  PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {\n    var mightContainRTL = this._mightContainRTL;\n    var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n    var canReduceOperations = true;\n    var operations = [];\n    for (var i = 0; i < rawOperations.length; i++) {\n      var op = rawOperations[i];\n      if (canReduceOperations && op._isTracked) {\n        canReduceOperations = false;\n      }\n      var validatedRange = op.range;\n      if (!mightContainRTL && op.text) {\n        // check if the new inserted text contains RTL\n        mightContainRTL = strings.containsRTL(op.text);\n      }\n      if (!mightContainNonBasicASCII && op.text) {\n        mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n      }\n      operations[i] = {\n        sortIndex: i,\n        identifier: op.identifier || null,\n        range: validatedRange,\n        rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n        rangeLength: this.getValueLengthInRange(validatedRange),\n        lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\n        forceMoveMarkers: Boolean(op.forceMoveMarkers),\n        isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n      };\n    }\n    // Sort operations ascending\n    operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n    var hasTouchingRanges = false;\n    for (var i = 0, count = operations.length - 1; i < count; i++) {\n      var rangeEnd = operations[i].range.getEndPosition();\n      var nextRangeStart = operations[i + 1].range.getStartPosition();\n      if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n        if (nextRangeStart.isBefore(rangeEnd)) {\n          // overlapping ranges\n          throw new Error('Overlapping ranges are not allowed!');\n        }\n        hasTouchingRanges = true;\n      }\n    }\n    if (canReduceOperations) {\n      operations = this._reduceOperations(operations);\n    }\n    // Delta encode operations\n    var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\n    var newTrimAutoWhitespaceCandidates = [];\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var reverseRange = reverseRanges[i];\n      if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n        // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n        for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n          var currentLineContent = '';\n          if (lineNumber === reverseRange.startLineNumber) {\n            currentLineContent = this.getLineContent(op.range.startLineNumber);\n            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n              continue;\n            }\n          }\n          newTrimAutoWhitespaceCandidates.push({\n            lineNumber: lineNumber,\n            oldContent: currentLineContent\n          });\n        }\n      }\n    }\n    var reverseOperations = [];\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var reverseRange = reverseRanges[i];\n      reverseOperations[i] = {\n        sortIndex: op.sortIndex,\n        identifier: op.identifier,\n        range: reverseRange,\n        text: this.getValueInRange(op.range),\n        forceMoveMarkers: op.forceMoveMarkers\n      };\n    }\n    // Can only sort reverse operations when the order is not significant\n    if (!hasTouchingRanges) {\n      reverseOperations.sort(function (a, b) {\n        return a.sortIndex - b.sortIndex;\n      });\n    }\n    this._mightContainRTL = mightContainRTL;\n    this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n    var contentChanges = this._doApplyEdits(operations);\n    var trimAutoWhitespaceLineNumbers = null;\n    if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n      // sort line numbers auto whitespace removal candidates for next edit descending\n      newTrimAutoWhitespaceCandidates.sort(function (a, b) {\n        return b.lineNumber - a.lineNumber;\n      });\n      trimAutoWhitespaceLineNumbers = [];\n      for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n        var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n        if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n          // Do not have the same line number twice\n          continue;\n        }\n        var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n        var lineContent = this.getLineContent(lineNumber);\n        if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n          continue;\n        }\n        trimAutoWhitespaceLineNumbers.push(lineNumber);\n      }\n    }\n    return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n  };\n  /**\r\n   * Transform operations such that they represent the same logic edit,\r\n   * but that they also do not cause OOM crashes.\r\n   */\n  PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {\n    if (operations.length < 1000) {\n      // We know from empirical testing that a thousand edits work fine regardless of their shape.\n      return operations;\n    }\n    // At one point, due to how events are emitted and how each operation is handled,\n    // some operations can trigger a high amount of temporary string allocations,\n    // that will immediately get edited again.\n    // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n    // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n    return [this._toSingleEditOperation(operations)];\n  };\n  PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {\n    var forceMoveMarkers = false,\n      firstEditRange = operations[0].range,\n      lastEditRange = operations[operations.length - 1].range,\n      entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn),\n      lastEndLineNumber = firstEditRange.startLineNumber,\n      lastEndColumn = firstEditRange.startColumn,\n      result = [];\n    for (var i = 0, len = operations.length; i < len; i++) {\n      var operation = operations[i],\n        range = operation.range;\n      forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n      // (1) -- Push old text\n      for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\n        if (lineNumber === lastEndLineNumber) {\n          result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\n        } else {\n          result.push('\\n');\n          result.push(this.getLineContent(lineNumber));\n        }\n      }\n      if (range.startLineNumber === lastEndLineNumber) {\n        result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\n      } else {\n        result.push('\\n');\n        result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\n      }\n      // (2) -- Push new text\n      if (operation.lines) {\n        for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\n          if (j !== 0) {\n            result.push('\\n');\n          }\n          result.push(operation.lines[j]);\n        }\n      }\n      lastEndLineNumber = operation.range.endLineNumber;\n      lastEndColumn = operation.range.endColumn;\n    }\n    return {\n      sortIndex: 0,\n      identifier: operations[0].identifier,\n      range: entireEditRange,\n      rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n      rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\n      lines: result.join('').split('\\n'),\n      forceMoveMarkers: forceMoveMarkers,\n      isAutoWhitespaceEdit: false\n    };\n  };\n  PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {\n    operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n    var contentChanges = [];\n    // operations are from bottom to top\n    for (var i = 0; i < operations.length; i++) {\n      var op = operations[i];\n      var startLineNumber = op.range.startLineNumber;\n      var startColumn = op.range.startColumn;\n      var endLineNumber = op.range.endLineNumber;\n      var endColumn = op.range.endColumn;\n      if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\n        // no-op\n        continue;\n      }\n      var deletingLinesCnt = endLineNumber - startLineNumber;\n      var insertingLinesCnt = op.lines ? op.lines.length - 1 : 0;\n      var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n      var text = op.lines ? op.lines.join(this.getEOL()) : '';\n      if (text) {\n        // replacement\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n        this._pieceTree.insert(op.rangeOffset, text, true);\n      } else {\n        // deletion\n        this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n      }\n      if (editingLinesCnt < insertingLinesCnt) {\n        var newLinesContent = [];\n        for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\n          newLinesContent.push(op.lines[j]);\n        }\n        newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\n      }\n      var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n      contentChanges.push({\n        range: contentChangeRange,\n        rangeLength: op.rangeLength,\n        text: text,\n        rangeOffset: op.rangeOffset,\n        forceMoveMarkers: op.forceMoveMarkers\n      });\n    }\n    return contentChanges;\n  };\n  PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n    return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n  };\n  /**\r\n   * Assumes `operations` are validated and sorted ascending\r\n   */\n  PieceTreeTextBuffer._getInverseEditRanges = function (operations) {\n    var result = [];\n    var prevOpEndLineNumber = 0;\n    var prevOpEndColumn = 0;\n    var prevOp = null;\n    for (var i = 0, len = operations.length; i < len; i++) {\n      var op = operations[i];\n      var startLineNumber = void 0;\n      var startColumn = void 0;\n      if (prevOp) {\n        if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n          startLineNumber = prevOpEndLineNumber;\n          startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n        } else {\n          startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n          startColumn = op.range.startColumn;\n        }\n      } else {\n        startLineNumber = op.range.startLineNumber;\n        startColumn = op.range.startColumn;\n      }\n      var resultRange = void 0;\n      if (op.lines && op.lines.length > 0) {\n        // the operation inserts something\n        var lineCount = op.lines.length;\n        var firstLine = op.lines[0];\n        var lastLine = op.lines[lineCount - 1];\n        if (lineCount === 1) {\n          // single line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\n        } else {\n          // multi line insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\n        }\n      } else {\n        // There is nothing to insert\n        resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n      }\n      prevOpEndLineNumber = resultRange.endLineNumber;\n      prevOpEndColumn = resultRange.endColumn;\n      result.push(resultRange);\n      prevOp = op;\n    }\n    return result;\n  };\n  PieceTreeTextBuffer._sortOpsAscending = function (a, b) {\n    var r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return a.sortIndex - b.sortIndex;\n    }\n    return r;\n  };\n  PieceTreeTextBuffer._sortOpsDescending = function (a, b) {\n    var r = Range.compareRangesUsingEnds(a.range, b.range);\n    if (r === 0) {\n      return b.sortIndex - a.sortIndex;\n    }\n    return -r;\n  };\n  return PieceTreeTextBuffer;\n}();\nexport { PieceTreeTextBuffer };","map":{"version":3,"names":["strings","Range","ApplyEditsResult","PieceTreeBase","PieceTreeTextBuffer","chunks","BOM","eol","containsRTL","isBasicASCII","eolNormalized","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_pieceTree","prototype","mightContainRTL","mightContainNonBasicASCII","getBOM","getEOL","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","sortIndex","identifier","rangeOffset","rangeLength","lines","split","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","substring","j","lenJ","join","_sortOpsDescending","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","Math","min","delete","insert","newLinesContent","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","firstLine","lastLine","r","compareRangesUsingEnds"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { ApplyEditsResult } from '../../model.js';\r\nimport { PieceTreeBase } from './pieceTreeBase.js';\r\nvar PieceTreeTextBuffer = /** @class */ (function () {\r\n    function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, isBasicASCII, eolNormalized) {\r\n        this._BOM = BOM;\r\n        this._mightContainNonBasicASCII = !isBasicASCII;\r\n        this._mightContainRTL = containsRTL;\r\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\r\n    }\r\n    PieceTreeTextBuffer.prototype.mightContainRTL = function () {\r\n        return this._mightContainRTL;\r\n    };\r\n    PieceTreeTextBuffer.prototype.mightContainNonBasicASCII = function () {\r\n        return this._mightContainNonBasicASCII;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getBOM = function () {\r\n        return this._BOM;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getEOL = function () {\r\n        return this._pieceTree.getEOL();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getOffsetAt = function (lineNumber, column) {\r\n        return this._pieceTree.getOffsetAt(lineNumber, column);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getPositionAt = function (offset) {\r\n        return this._pieceTree.getPositionAt(offset);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getRangeAt = function (start, length) {\r\n        var end = start + length;\r\n        var startPosition = this.getPositionAt(start);\r\n        var endPosition = this.getPositionAt(end);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getValueInRange = function (range, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        if (range.isEmpty()) {\r\n            return '';\r\n        }\r\n        var lineEnding = this._getEndOfLine(eol);\r\n        return this._pieceTree.getValueInRange(range, lineEnding);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getValueLengthInRange = function (range, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        if (range.isEmpty()) {\r\n            return 0;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return (range.endColumn - range.startColumn);\r\n        }\r\n        var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        return endOffset - startOffset;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getCharacterCountInRange = function (range, eol) {\r\n        if (eol === void 0) { eol = 0 /* TextDefined */; }\r\n        if (this._mightContainNonBasicASCII) {\r\n            // we must count by iterating\r\n            var result = 0;\r\n            var fromLineNumber = range.startLineNumber;\r\n            var toLineNumber = range.endLineNumber;\r\n            for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\r\n                var lineContent = this.getLineContent(lineNumber);\r\n                var fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\r\n                var toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\r\n                for (var offset = fromOffset; offset < toOffset; offset++) {\r\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\r\n                        result = result + 1;\r\n                        offset = offset + 1;\r\n                    }\r\n                    else {\r\n                        result = result + 1;\r\n                    }\r\n                }\r\n            }\r\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\r\n            return result;\r\n        }\r\n        return this.getValueLengthInRange(range, eol);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLength = function () {\r\n        return this._pieceTree.getLength();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineCount = function () {\r\n        return this._pieceTree.getLineCount();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLinesContent = function () {\r\n        return this._pieceTree.getLinesContent();\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineContent = function (lineNumber) {\r\n        return this._pieceTree.getLineContent(lineNumber);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineCharCode = function (lineNumber, index) {\r\n        return this._pieceTree.getLineCharCode(lineNumber, index);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineLength = function (lineNumber) {\r\n        return this._pieceTree.getLineLength(lineNumber);\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {\r\n        var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 1;\r\n    };\r\n    PieceTreeTextBuffer.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {\r\n        var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 2;\r\n    };\r\n    PieceTreeTextBuffer.prototype._getEndOfLine = function (eol) {\r\n        switch (eol) {\r\n            case 1 /* LF */:\r\n                return '\\n';\r\n            case 2 /* CRLF */:\r\n                return '\\r\\n';\r\n            case 0 /* TextDefined */:\r\n                return this.getEOL();\r\n        }\r\n        throw new Error('Unknown EOL preference');\r\n    };\r\n    PieceTreeTextBuffer.prototype.setEOL = function (newEOL) {\r\n        this._pieceTree.setEOL(newEOL);\r\n    };\r\n    PieceTreeTextBuffer.prototype.applyEdits = function (rawOperations, recordTrimAutoWhitespace) {\r\n        var mightContainRTL = this._mightContainRTL;\r\n        var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\r\n        var canReduceOperations = true;\r\n        var operations = [];\r\n        for (var i = 0; i < rawOperations.length; i++) {\r\n            var op = rawOperations[i];\r\n            if (canReduceOperations && op._isTracked) {\r\n                canReduceOperations = false;\r\n            }\r\n            var validatedRange = op.range;\r\n            if (!mightContainRTL && op.text) {\r\n                // check if the new inserted text contains RTL\r\n                mightContainRTL = strings.containsRTL(op.text);\r\n            }\r\n            if (!mightContainNonBasicASCII && op.text) {\r\n                mightContainNonBasicASCII = !strings.isBasicASCII(op.text);\r\n            }\r\n            operations[i] = {\r\n                sortIndex: i,\r\n                identifier: op.identifier || null,\r\n                range: validatedRange,\r\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\r\n                rangeLength: this.getValueLengthInRange(validatedRange),\r\n                lines: op.text ? op.text.split(/\\r\\n|\\r|\\n/) : null,\r\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\r\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\r\n            };\r\n        }\r\n        // Sort operations ascending\r\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\r\n        var hasTouchingRanges = false;\r\n        for (var i = 0, count = operations.length - 1; i < count; i++) {\r\n            var rangeEnd = operations[i].range.getEndPosition();\r\n            var nextRangeStart = operations[i + 1].range.getStartPosition();\r\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\r\n                if (nextRangeStart.isBefore(rangeEnd)) {\r\n                    // overlapping ranges\r\n                    throw new Error('Overlapping ranges are not allowed!');\r\n                }\r\n                hasTouchingRanges = true;\r\n            }\r\n        }\r\n        if (canReduceOperations) {\r\n            operations = this._reduceOperations(operations);\r\n        }\r\n        // Delta encode operations\r\n        var reverseRanges = PieceTreeTextBuffer._getInverseEditRanges(operations);\r\n        var newTrimAutoWhitespaceCandidates = [];\r\n        for (var i = 0; i < operations.length; i++) {\r\n            var op = operations[i];\r\n            var reverseRange = reverseRanges[i];\r\n            if (recordTrimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {\r\n                // Record already the future line numbers that might be auto whitespace removal candidates on next edit\r\n                for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\r\n                    var currentLineContent = '';\r\n                    if (lineNumber === reverseRange.startLineNumber) {\r\n                        currentLineContent = this.getLineContent(op.range.startLineNumber);\r\n                        if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\r\n                }\r\n            }\r\n        }\r\n        var reverseOperations = [];\r\n        for (var i = 0; i < operations.length; i++) {\r\n            var op = operations[i];\r\n            var reverseRange = reverseRanges[i];\r\n            reverseOperations[i] = {\r\n                sortIndex: op.sortIndex,\r\n                identifier: op.identifier,\r\n                range: reverseRange,\r\n                text: this.getValueInRange(op.range),\r\n                forceMoveMarkers: op.forceMoveMarkers\r\n            };\r\n        }\r\n        // Can only sort reverse operations when the order is not significant\r\n        if (!hasTouchingRanges) {\r\n            reverseOperations.sort(function (a, b) { return a.sortIndex - b.sortIndex; });\r\n        }\r\n        this._mightContainRTL = mightContainRTL;\r\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\r\n        var contentChanges = this._doApplyEdits(operations);\r\n        var trimAutoWhitespaceLineNumbers = null;\r\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\r\n            // sort line numbers auto whitespace removal candidates for next edit descending\r\n            newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });\r\n            trimAutoWhitespaceLineNumbers = [];\r\n            for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\r\n                var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\r\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\r\n                    // Do not have the same line number twice\r\n                    continue;\r\n                }\r\n                var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\r\n                var lineContent = this.getLineContent(lineNumber);\r\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\r\n                    continue;\r\n                }\r\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\r\n            }\r\n        }\r\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\r\n    };\r\n    /**\r\n     * Transform operations such that they represent the same logic edit,\r\n     * but that they also do not cause OOM crashes.\r\n     */\r\n    PieceTreeTextBuffer.prototype._reduceOperations = function (operations) {\r\n        if (operations.length < 1000) {\r\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\r\n            return operations;\r\n        }\r\n        // At one point, due to how events are emitted and how each operation is handled,\r\n        // some operations can trigger a high amount of temporary string allocations,\r\n        // that will immediately get edited again.\r\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\r\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\r\n        return [this._toSingleEditOperation(operations)];\r\n    };\r\n    PieceTreeTextBuffer.prototype._toSingleEditOperation = function (operations) {\r\n        var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];\r\n        for (var i = 0, len = operations.length; i < len; i++) {\r\n            var operation = operations[i], range = operation.range;\r\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\r\n            // (1) -- Push old text\r\n            for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {\r\n                if (lineNumber === lastEndLineNumber) {\r\n                    result.push(this.getLineContent(lineNumber).substring(lastEndColumn - 1));\r\n                }\r\n                else {\r\n                    result.push('\\n');\r\n                    result.push(this.getLineContent(lineNumber));\r\n                }\r\n            }\r\n            if (range.startLineNumber === lastEndLineNumber) {\r\n                result.push(this.getLineContent(range.startLineNumber).substring(lastEndColumn - 1, range.startColumn - 1));\r\n            }\r\n            else {\r\n                result.push('\\n');\r\n                result.push(this.getLineContent(range.startLineNumber).substring(0, range.startColumn - 1));\r\n            }\r\n            // (2) -- Push new text\r\n            if (operation.lines) {\r\n                for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {\r\n                    if (j !== 0) {\r\n                        result.push('\\n');\r\n                    }\r\n                    result.push(operation.lines[j]);\r\n                }\r\n            }\r\n            lastEndLineNumber = operation.range.endLineNumber;\r\n            lastEndColumn = operation.range.endColumn;\r\n        }\r\n        return {\r\n            sortIndex: 0,\r\n            identifier: operations[0].identifier,\r\n            range: entireEditRange,\r\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\r\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\r\n            lines: result.join('').split('\\n'),\r\n            forceMoveMarkers: forceMoveMarkers,\r\n            isAutoWhitespaceEdit: false\r\n        };\r\n    };\r\n    PieceTreeTextBuffer.prototype._doApplyEdits = function (operations) {\r\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\r\n        var contentChanges = [];\r\n        // operations are from bottom to top\r\n        for (var i = 0; i < operations.length; i++) {\r\n            var op = operations[i];\r\n            var startLineNumber = op.range.startLineNumber;\r\n            var startColumn = op.range.startColumn;\r\n            var endLineNumber = op.range.endLineNumber;\r\n            var endColumn = op.range.endColumn;\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {\r\n                // no-op\r\n                continue;\r\n            }\r\n            var deletingLinesCnt = endLineNumber - startLineNumber;\r\n            var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);\r\n            var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n            var text = (op.lines ? op.lines.join(this.getEOL()) : '');\r\n            if (text) {\r\n                // replacement\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n                this._pieceTree.insert(op.rangeOffset, text, true);\r\n            }\r\n            else {\r\n                // deletion\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n            }\r\n            if (editingLinesCnt < insertingLinesCnt) {\r\n                var newLinesContent = [];\r\n                for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {\r\n                    newLinesContent.push(op.lines[j]);\r\n                }\r\n                newLinesContent[newLinesContent.length - 1] = this.getLineContent(startLineNumber + insertingLinesCnt - 1);\r\n            }\r\n            var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            contentChanges.push({\r\n                range: contentChangeRange,\r\n                rangeLength: op.rangeLength,\r\n                text: text,\r\n                rangeOffset: op.rangeOffset,\r\n                forceMoveMarkers: op.forceMoveMarkers\r\n            });\r\n        }\r\n        return contentChanges;\r\n    };\r\n    PieceTreeTextBuffer.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    };\r\n    /**\r\n     * Assumes `operations` are validated and sorted ascending\r\n     */\r\n    PieceTreeTextBuffer._getInverseEditRanges = function (operations) {\r\n        var result = [];\r\n        var prevOpEndLineNumber = 0;\r\n        var prevOpEndColumn = 0;\r\n        var prevOp = null;\r\n        for (var i = 0, len = operations.length; i < len; i++) {\r\n            var op = operations[i];\r\n            var startLineNumber = void 0;\r\n            var startColumn = void 0;\r\n            if (prevOp) {\r\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\r\n                    startLineNumber = prevOpEndLineNumber;\r\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\r\n                }\r\n                else {\r\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\r\n                    startColumn = op.range.startColumn;\r\n                }\r\n            }\r\n            else {\r\n                startLineNumber = op.range.startLineNumber;\r\n                startColumn = op.range.startColumn;\r\n            }\r\n            var resultRange = void 0;\r\n            if (op.lines && op.lines.length > 0) {\r\n                // the operation inserts something\r\n                var lineCount = op.lines.length;\r\n                var firstLine = op.lines[0];\r\n                var lastLine = op.lines[lineCount - 1];\r\n                if (lineCount === 1) {\r\n                    // single line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);\r\n                }\r\n                else {\r\n                    // multi line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);\r\n                }\r\n            }\r\n            else {\r\n                // There is nothing to insert\r\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\r\n            }\r\n            prevOpEndLineNumber = resultRange.endLineNumber;\r\n            prevOpEndColumn = resultRange.endColumn;\r\n            result.push(resultRange);\r\n            prevOp = op;\r\n        }\r\n        return result;\r\n    };\r\n    PieceTreeTextBuffer._sortOpsAscending = function (a, b) {\r\n        var r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return a.sortIndex - b.sortIndex;\r\n        }\r\n        return r;\r\n    };\r\n    PieceTreeTextBuffer._sortOpsDescending = function (a, b) {\r\n        var r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return b.sortIndex - a.sortIndex;\r\n        }\r\n        return -r;\r\n    };\r\n    return PieceTreeTextBuffer;\r\n}());\r\nexport { PieceTreeTextBuffer };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}