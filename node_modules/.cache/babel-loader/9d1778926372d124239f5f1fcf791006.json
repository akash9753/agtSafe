{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { onUnexpectedError } from './errors.js';\nimport { once as onceFn } from './functional.js';\nimport { Disposable, toDisposable, combinedDisposable, DisposableStore } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nexport var Event;\n(function (Event) {\n  Event.None = function () {\n    return Disposable.None;\n  };\n  /**\r\n   * Given an event, returns another event which only fires once.\r\n   */\n  function once(event) {\n    return function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n      // we need this, in case the event fires during the listener call\n      var didFire = false;\n      var result;\n      result = event(function (e) {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  /**\r\n   * Given an event and a `map` function, returns another event which maps each element\r\n   * through the mapping function.\r\n   */\n  function map(event, map) {\n    return snapshot(function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n      return event(function (i) {\n        return listener.call(thisArgs, map(i));\n      }, null, disposables);\n    });\n  }\n  Event.map = map;\n  /**\r\n   * Given an event and an `each` function, returns another identical event and calls\r\n   * the `each` function per each element.\r\n   */\n  function forEach(event, each) {\n    return snapshot(function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n      return event(function (i) {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    });\n  }\n  Event.forEach = forEach;\n  function filter(event, filter) {\n    return snapshot(function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n      return event(function (e) {\n        return filter(e) && listener.call(thisArgs, e);\n      }, null, disposables);\n    });\n  }\n  Event.filter = filter;\n  /**\r\n   * Given an event, returns the same event but typed as `Event<void>`.\r\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  /**\r\n   * Given a collection of events, returns a single event which emits\r\n   * whenever any of the provided events emit.\r\n   */\n  function any() {\n    var events = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      events[_i] = arguments[_i];\n    }\n    return function (listener, thisArgs, disposables) {\n      if (thisArgs === void 0) {\n        thisArgs = null;\n      }\n      return combinedDisposable.apply(void 0, events.map(function (event) {\n        return event(function (e) {\n          return listener.call(thisArgs, e);\n        }, null, disposables);\n      }));\n    };\n  }\n  Event.any = any;\n  /**\r\n   * Given an event and a `merge` function, returns another event which maps each element\r\n   * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n   */\n  function reduce(event, merge, initial) {\n    var output = initial;\n    return map(event, function (e) {\n      output = merge(output, e);\n      return output;\n    });\n  }\n  Event.reduce = reduce;\n  /**\r\n   * Given a chain of event processing functions (filter, map, etc), each\r\n   * function will be invoked per event & per listener. Snapshotting an event\r\n   * chain allows each function to be invoked just once per event.\r\n   */\n  function snapshot(event) {\n    var listener;\n    var emitter = new Emitter({\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        listener = event(emitter.fire, emitter);\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        listener.dispose();\n      }\n    });\n    return emitter.event;\n  }\n  Event.snapshot = snapshot;\n  function debounce(event, merge, delay, leading, leakWarningThreshold) {\n    if (delay === void 0) {\n      delay = 100;\n    }\n    if (leading === void 0) {\n      leading = false;\n    }\n    var subscription;\n    var output = undefined;\n    var handle = undefined;\n    var numDebouncedCalls = 0;\n    var emitter = new Emitter({\n      leakWarningThreshold: leakWarningThreshold,\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        subscription = event(function (cur) {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          clearTimeout(handle);\n          handle = setTimeout(function () {\n            var _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        subscription.dispose();\n      }\n    });\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  /**\r\n   * Given an event, it returns another event which fires only once and as soon as\r\n   * the input event emits. The event data is the number of millis it took for the\r\n   * event to fire.\r\n   */\n  function stopwatch(event) {\n    var start = new Date().getTime();\n    return map(once(event), function (_) {\n      return new Date().getTime() - start;\n    });\n  }\n  Event.stopwatch = stopwatch;\n  /**\r\n   * Given an event, it returns another event which fires only when the event\r\n   * element changes.\r\n   */\n  function latch(event) {\n    var firstCall = true;\n    var cache;\n    return filter(event, function (value) {\n      var shouldEmit = firstCall || value !== cache;\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    });\n  }\n  Event.latch = latch;\n  /**\r\n   * Buffers the provided event until a first listener comes\r\n   * along, at which point fire all the events at once and\r\n   * pipe the event from then on.\r\n   *\r\n   * ```typescript\r\n   * const emitter = new Emitter<number>();\r\n   * const event = emitter.event;\r\n   * const bufferedEvent = buffer(event);\r\n   *\r\n   * emitter.fire(1);\r\n   * emitter.fire(2);\r\n   * emitter.fire(3);\r\n   * // nothing...\r\n   *\r\n   * const listener = bufferedEvent(num => console.log(num));\r\n   * // 1, 2, 3\r\n   *\r\n   * emitter.fire(4);\r\n   * // 4\r\n   * ```\r\n   */\n  function buffer(event, nextTick, _buffer) {\n    if (nextTick === void 0) {\n      nextTick = false;\n    }\n    if (_buffer === void 0) {\n      _buffer = [];\n    }\n    var buffer = _buffer.slice();\n    var listener = event(function (e) {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    var flush = function flush() {\n      if (buffer) {\n        buffer.forEach(function (e) {\n          return emitter.fire(e);\n        });\n      }\n      buffer = null;\n    };\n    var emitter = new Emitter({\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        if (!listener) {\n          listener = event(function (e) {\n            return emitter.fire(e);\n          });\n        }\n      },\n      onFirstListenerDidAdd: function onFirstListenerDidAdd() {\n        if (buffer) {\n          if (nextTick) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  var ChainableEvent = /** @class */function () {\n    function ChainableEvent(event) {\n      this.event = event;\n    }\n    ChainableEvent.prototype.map = function (fn) {\n      return new ChainableEvent(map(this.event, fn));\n    };\n    ChainableEvent.prototype.forEach = function (fn) {\n      return new ChainableEvent(forEach(this.event, fn));\n    };\n    ChainableEvent.prototype.filter = function (fn) {\n      return new ChainableEvent(filter(this.event, fn));\n    };\n    ChainableEvent.prototype.reduce = function (merge, initial) {\n      return new ChainableEvent(reduce(this.event, merge, initial));\n    };\n    ChainableEvent.prototype.latch = function () {\n      return new ChainableEvent(latch(this.event));\n    };\n    ChainableEvent.prototype.debounce = function (merge, delay, leading, leakWarningThreshold) {\n      if (delay === void 0) {\n        delay = 100;\n      }\n      if (leading === void 0) {\n        leading = false;\n      }\n      return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n    };\n    ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {\n      return this.event(listener, thisArgs, disposables);\n    };\n    ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {\n      return once(this.event)(listener, thisArgs, disposables);\n    };\n    return ChainableEvent;\n  }();\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n  Event.chain = chain;\n  function fromNodeEventEmitter(emitter, eventName, map) {\n    if (map === void 0) {\n      map = function map(id) {\n        return id;\n      };\n    }\n    var fn = function fn() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return result.fire(map.apply(void 0, args));\n    };\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.on(eventName, fn);\n    };\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeListener(eventName, fn);\n    };\n    var result = new Emitter({\n      onFirstListenerAdd: onFirstListenerAdd,\n      onLastListenerRemove: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName, map) {\n    if (map === void 0) {\n      map = function map(id) {\n        return id;\n      };\n    }\n    var fn = function fn() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return result.fire(map.apply(void 0, args));\n    };\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.addEventListener(eventName, fn);\n    };\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeEventListener(eventName, fn);\n    };\n    var result = new Emitter({\n      onFirstListenerAdd: onFirstListenerAdd,\n      onLastListenerRemove: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  function fromPromise(promise) {\n    var emitter = new Emitter();\n    var shouldEmit = false;\n    promise.then(undefined, function () {\n      return null;\n    }).then(function () {\n      if (!shouldEmit) {\n        setTimeout(function () {\n          return emitter.fire(undefined);\n        }, 0);\n      } else {\n        emitter.fire(undefined);\n      }\n    });\n    shouldEmit = true;\n    return emitter.event;\n  }\n  Event.fromPromise = fromPromise;\n  function toPromise(event) {\n    return new Promise(function (c) {\n      return once(event)(c);\n    });\n  }\n  Event.toPromise = toPromise;\n})(Event || (Event = {}));\nvar _globalLeakWarningThreshold = -1;\nvar LeakageMonitor = /** @class */function () {\n  function LeakageMonitor(customThreshold, name) {\n    if (name === void 0) {\n      name = Math.random().toString(18).slice(2, 5);\n    }\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  LeakageMonitor.prototype.dispose = function () {\n    if (this._stacks) {\n      this._stacks.clear();\n    }\n  };\n  LeakageMonitor.prototype.check = function (listenerCount) {\n    var _this = this;\n    var threshold = _globalLeakWarningThreshold;\n    if (typeof this.customThreshold === 'number') {\n      threshold = this.customThreshold;\n    }\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n    var stack = new Error().stack.split('\\n').slice(3).join('\\n');\n    var count = this._stacks.get(stack) || 0;\n    this._stacks.set(stack, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._warnCountdown = threshold * 0.5;\n      // find most frequent listener and print warning\n      var topStack_1;\n      var topCount_1 = 0;\n      this._stacks.forEach(function (count, stack) {\n        if (!topStack_1 || topCount_1 < count) {\n          topStack_1 = stack;\n          topCount_1 = count;\n        }\n      });\n      console.warn(\"[\" + this.name + \"] potential listener LEAK detected, having \" + listenerCount + \" listeners already. MOST frequent listener (\" + topCount_1 + \"):\");\n      console.warn(topStack_1);\n    }\n    return function () {\n      var count = _this._stacks.get(stack) || 0;\n      _this._stacks.set(stack, count - 1);\n    };\n  };\n  return LeakageMonitor;\n}();\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\nvar Emitter = /** @class */function () {\n  function Emitter(options) {\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n  }\n  Object.defineProperty(Emitter.prototype, \"event\", {\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\n    get: function get() {\n      var _this = this;\n      if (!this._event) {\n        this._event = function (listener, thisArgs, disposables) {\n          if (!_this._listeners) {\n            _this._listeners = new LinkedList();\n          }\n          var firstListener = _this._listeners.isEmpty();\n          if (firstListener && _this._options && _this._options.onFirstListenerAdd) {\n            _this._options.onFirstListenerAdd(_this);\n          }\n          var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n          if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {\n            _this._options.onFirstListenerDidAdd(_this);\n          }\n          if (_this._options && _this._options.onListenerDidAdd) {\n            _this._options.onListenerDidAdd(_this, listener, thisArgs);\n          }\n          // check and record this emitter for potential leakage\n          var removeMonitor;\n          if (_this._leakageMon) {\n            removeMonitor = _this._leakageMon.check(_this._listeners.size);\n          }\n          var result;\n          result = {\n            dispose: function dispose() {\n              if (removeMonitor) {\n                removeMonitor();\n              }\n              result.dispose = Emitter._noop;\n              if (!_this._disposed) {\n                remove();\n                if (_this._options && _this._options.onLastListenerRemove) {\n                  var hasListeners = _this._listeners && !_this._listeners.isEmpty();\n                  if (!hasListeners) {\n                    _this._options.onLastListenerRemove(_this);\n                  }\n                }\n              }\n            }\n          };\n          if (disposables instanceof DisposableStore) {\n            disposables.add(result);\n          } else if (Array.isArray(disposables)) {\n            disposables.push(result);\n          }\n          return result;\n        };\n      }\n      return this._event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * To be kept private to fire an event to\r\n   * subscribers\r\n   */\n  Emitter.prototype.fire = function (event) {\n    if (this._listeners) {\n      // put all [listener,event]-pairs into delivery queue\n      // then emit all event. an inner/nested event might be\n      // the driver of this\n      if (!this._deliveryQueue) {\n        this._deliveryQueue = new LinkedList();\n      }\n      for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\n        this._deliveryQueue.push([e.value, event]);\n      }\n      while (this._deliveryQueue.size > 0) {\n        var _a = this._deliveryQueue.shift(),\n          listener = _a[0],\n          event_1 = _a[1];\n        try {\n          if (typeof listener === 'function') {\n            listener.call(undefined, event_1);\n          } else {\n            listener[0].call(listener[1], event_1);\n          }\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n      }\n    }\n  };\n  Emitter.prototype.dispose = function () {\n    if (this._listeners) {\n      this._listeners.clear();\n    }\n    if (this._deliveryQueue) {\n      this._deliveryQueue.clear();\n    }\n    if (this._leakageMon) {\n      this._leakageMon.dispose();\n    }\n    this._disposed = true;\n  };\n  Emitter._noop = function () {};\n  return Emitter;\n}();\nexport { Emitter };\nvar PauseableEmitter = /** @class */function (_super) {\n  __extends(PauseableEmitter, _super);\n  function PauseableEmitter(options) {\n    var _this = _super.call(this, options) || this;\n    _this._isPaused = 0;\n    _this._eventQueue = new LinkedList();\n    _this._mergeFn = options && options.merge;\n    return _this;\n  }\n  PauseableEmitter.prototype.pause = function () {\n    this._isPaused++;\n  };\n  PauseableEmitter.prototype.resume = function () {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        // use the merge function to create a single composite\n        // event. make a copy in case firing pauses this emitter\n        var events = this._eventQueue.toArray();\n        this._eventQueue.clear();\n        _super.prototype.fire.call(this, this._mergeFn(events));\n      } else {\n        // no merging, fire each event individually and test\n        // that this emitter isn't paused halfway through\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          _super.prototype.fire.call(this, this._eventQueue.shift());\n        }\n      }\n    }\n  };\n  PauseableEmitter.prototype.fire = function (event) {\n    if (this._listeners) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        _super.prototype.fire.call(this, event);\n      }\n    }\n  };\n  return PauseableEmitter;\n}(Emitter);\nexport { PauseableEmitter };\nvar EventMultiplexer = /** @class */function () {\n  function EventMultiplexer() {\n    var _this = this;\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        return _this.onFirstListenerAdd();\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        return _this.onLastListenerRemove();\n      }\n    });\n  }\n  Object.defineProperty(EventMultiplexer.prototype, \"event\", {\n    get: function get() {\n      return this.emitter.event;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  EventMultiplexer.prototype.add = function (event) {\n    var _this = this;\n    var e = {\n      event: event,\n      listener: null\n    };\n    this.events.push(e);\n    if (this.hasListeners) {\n      this.hook(e);\n    }\n    var dispose = function dispose() {\n      if (_this.hasListeners) {\n        _this.unhook(e);\n      }\n      var idx = _this.events.indexOf(e);\n      _this.events.splice(idx, 1);\n    };\n    return toDisposable(onceFn(dispose));\n  };\n  EventMultiplexer.prototype.onFirstListenerAdd = function () {\n    var _this = this;\n    this.hasListeners = true;\n    this.events.forEach(function (e) {\n      return _this.hook(e);\n    });\n  };\n  EventMultiplexer.prototype.onLastListenerRemove = function () {\n    var _this = this;\n    this.hasListeners = false;\n    this.events.forEach(function (e) {\n      return _this.unhook(e);\n    });\n  };\n  EventMultiplexer.prototype.hook = function (e) {\n    var _this = this;\n    e.listener = e.event(function (r) {\n      return _this.emitter.fire(r);\n    });\n  };\n  EventMultiplexer.prototype.unhook = function (e) {\n    if (e.listener) {\n      e.listener.dispose();\n    }\n    e.listener = null;\n  };\n  EventMultiplexer.prototype.dispose = function () {\n    this.emitter.dispose();\n  };\n  return EventMultiplexer;\n}();\nexport { EventMultiplexer };\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\nvar EventBufferer = /** @class */function () {\n  function EventBufferer() {\n    this.buffers = [];\n  }\n  EventBufferer.prototype.wrapEvent = function (event) {\n    var _this = this;\n    return function (listener, thisArgs, disposables) {\n      return event(function (i) {\n        var buffer = _this.buffers[_this.buffers.length - 1];\n        if (buffer) {\n          buffer.push(function () {\n            return listener.call(thisArgs, i);\n          });\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  };\n  EventBufferer.prototype.bufferEvents = function (fn) {\n    var buffer = [];\n    this.buffers.push(buffer);\n    var r = fn();\n    this.buffers.pop();\n    buffer.forEach(function (flush) {\n      return flush();\n    });\n    return r;\n  };\n  return EventBufferer;\n}();\nexport { EventBufferer };\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\nvar Relay = /** @class */function () {\n  function Relay() {\n    var _this = this;\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: function onFirstListenerDidAdd() {\n        _this.listening = true;\n        _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        _this.listening = false;\n        _this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  Object.defineProperty(Relay.prototype, \"input\", {\n    set: function set(event) {\n      this.inputEvent = event;\n      if (this.listening) {\n        this.inputEventListener.dispose();\n        this.inputEventListener = event(this.emitter.fire, this.emitter);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Relay.prototype.dispose = function () {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  };\n  return Relay;\n}();\nexport { Relay };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","onUnexpectedError","once","onceFn","Disposable","toDisposable","combinedDisposable","DisposableStore","LinkedList","Event","None","event","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","_i","arguments","length","apply","reduce","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","debounce","delay","leading","leakWarningThreshold","subscription","undefined","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","stopwatch","start","Date","getTime","_","latch","firstCall","cache","value","shouldEmit","buffer","nextTick","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","fn","on","chain","fromNodeEventEmitter","eventName","id","args","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","fromPromise","promise","then","toPromise","Promise","c","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","name","Math","random","toString","_warnCountdown","_stacks","clear","check","listenerCount","_this","threshold","Map","stack","Error","split","join","count","get","set","topStack_1","topCount_1","console","warn","options","_disposed","_options","_leakageMon","defineProperty","_event","_listeners","firstListener","isEmpty","remove","onListenerDidAdd","removeMonitor","size","_noop","hasListeners","add","isArray","enumerable","configurable","_deliveryQueue","iter","iterator","next","done","_a","shift","event_1","PauseableEmitter","_super","_isPaused","_eventQueue","_mergeFn","pause","resume","toArray","EventMultiplexer","hook","unhook","idx","indexOf","splice","r","EventBufferer","buffers","wrapEvent","bufferEvents","pop","Relay","listening","inputEvent","inputEventListener"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { onUnexpectedError } from './errors.js';\r\nimport { once as onceFn } from './functional.js';\r\nimport { Disposable, toDisposable, combinedDisposable, DisposableStore } from './lifecycle.js';\r\nimport { LinkedList } from './linkedList.js';\r\nexport var Event;\r\n(function (Event) {\r\n    Event.None = function () { return Disposable.None; };\r\n    /**\r\n     * Given an event, returns another event which only fires once.\r\n     */\r\n    function once(event) {\r\n        return function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            // we need this, in case the event fires during the listener call\r\n            var didFire = false;\r\n            var result;\r\n            result = event(function (e) {\r\n                if (didFire) {\r\n                    return;\r\n                }\r\n                else if (result) {\r\n                    result.dispose();\r\n                }\r\n                else {\r\n                    didFire = true;\r\n                }\r\n                return listener.call(thisArgs, e);\r\n            }, null, disposables);\r\n            if (didFire) {\r\n                result.dispose();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    Event.once = once;\r\n    /**\r\n     * Given an event and a `map` function, returns another event which maps each element\r\n     * through the mapping function.\r\n     */\r\n    function map(event, map) {\r\n        return snapshot(function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);\r\n        });\r\n    }\r\n    Event.map = map;\r\n    /**\r\n     * Given an event and an `each` function, returns another identical event and calls\r\n     * the `each` function per each element.\r\n     */\r\n    function forEach(event, each) {\r\n        return snapshot(function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);\r\n        });\r\n    }\r\n    Event.forEach = forEach;\r\n    function filter(event, filter) {\r\n        return snapshot(function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);\r\n        });\r\n    }\r\n    Event.filter = filter;\r\n    /**\r\n     * Given an event, returns the same event but typed as `Event<void>`.\r\n     */\r\n    function signal(event) {\r\n        return event;\r\n    }\r\n    Event.signal = signal;\r\n    /**\r\n     * Given a collection of events, returns a single event which emits\r\n     * whenever any of the provided events emit.\r\n     */\r\n    function any() {\r\n        var events = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            events[_i] = arguments[_i];\r\n        }\r\n        return function (listener, thisArgs, disposables) {\r\n            if (thisArgs === void 0) { thisArgs = null; }\r\n            return combinedDisposable.apply(void 0, events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));\r\n        };\r\n    }\r\n    Event.any = any;\r\n    /**\r\n     * Given an event and a `merge` function, returns another event which maps each element\r\n     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n     */\r\n    function reduce(event, merge, initial) {\r\n        var output = initial;\r\n        return map(event, function (e) {\r\n            output = merge(output, e);\r\n            return output;\r\n        });\r\n    }\r\n    Event.reduce = reduce;\r\n    /**\r\n     * Given a chain of event processing functions (filter, map, etc), each\r\n     * function will be invoked per event & per listener. Snapshotting an event\r\n     * chain allows each function to be invoked just once per event.\r\n     */\r\n    function snapshot(event) {\r\n        var listener;\r\n        var emitter = new Emitter({\r\n            onFirstListenerAdd: function () {\r\n                listener = event(emitter.fire, emitter);\r\n            },\r\n            onLastListenerRemove: function () {\r\n                listener.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.snapshot = snapshot;\r\n    function debounce(event, merge, delay, leading, leakWarningThreshold) {\r\n        if (delay === void 0) { delay = 100; }\r\n        if (leading === void 0) { leading = false; }\r\n        var subscription;\r\n        var output = undefined;\r\n        var handle = undefined;\r\n        var numDebouncedCalls = 0;\r\n        var emitter = new Emitter({\r\n            leakWarningThreshold: leakWarningThreshold,\r\n            onFirstListenerAdd: function () {\r\n                subscription = event(function (cur) {\r\n                    numDebouncedCalls++;\r\n                    output = merge(output, cur);\r\n                    if (leading && !handle) {\r\n                        emitter.fire(output);\r\n                        output = undefined;\r\n                    }\r\n                    clearTimeout(handle);\r\n                    handle = setTimeout(function () {\r\n                        var _output = output;\r\n                        output = undefined;\r\n                        handle = undefined;\r\n                        if (!leading || numDebouncedCalls > 1) {\r\n                            emitter.fire(_output);\r\n                        }\r\n                        numDebouncedCalls = 0;\r\n                    }, delay);\r\n                });\r\n            },\r\n            onLastListenerRemove: function () {\r\n                subscription.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.debounce = debounce;\r\n    /**\r\n     * Given an event, it returns another event which fires only once and as soon as\r\n     * the input event emits. The event data is the number of millis it took for the\r\n     * event to fire.\r\n     */\r\n    function stopwatch(event) {\r\n        var start = new Date().getTime();\r\n        return map(once(event), function (_) { return new Date().getTime() - start; });\r\n    }\r\n    Event.stopwatch = stopwatch;\r\n    /**\r\n     * Given an event, it returns another event which fires only when the event\r\n     * element changes.\r\n     */\r\n    function latch(event) {\r\n        var firstCall = true;\r\n        var cache;\r\n        return filter(event, function (value) {\r\n            var shouldEmit = firstCall || value !== cache;\r\n            firstCall = false;\r\n            cache = value;\r\n            return shouldEmit;\r\n        });\r\n    }\r\n    Event.latch = latch;\r\n    /**\r\n     * Buffers the provided event until a first listener comes\r\n     * along, at which point fire all the events at once and\r\n     * pipe the event from then on.\r\n     *\r\n     * ```typescript\r\n     * const emitter = new Emitter<number>();\r\n     * const event = emitter.event;\r\n     * const bufferedEvent = buffer(event);\r\n     *\r\n     * emitter.fire(1);\r\n     * emitter.fire(2);\r\n     * emitter.fire(3);\r\n     * // nothing...\r\n     *\r\n     * const listener = bufferedEvent(num => console.log(num));\r\n     * // 1, 2, 3\r\n     *\r\n     * emitter.fire(4);\r\n     * // 4\r\n     * ```\r\n     */\r\n    function buffer(event, nextTick, _buffer) {\r\n        if (nextTick === void 0) { nextTick = false; }\r\n        if (_buffer === void 0) { _buffer = []; }\r\n        var buffer = _buffer.slice();\r\n        var listener = event(function (e) {\r\n            if (buffer) {\r\n                buffer.push(e);\r\n            }\r\n            else {\r\n                emitter.fire(e);\r\n            }\r\n        });\r\n        var flush = function () {\r\n            if (buffer) {\r\n                buffer.forEach(function (e) { return emitter.fire(e); });\r\n            }\r\n            buffer = null;\r\n        };\r\n        var emitter = new Emitter({\r\n            onFirstListenerAdd: function () {\r\n                if (!listener) {\r\n                    listener = event(function (e) { return emitter.fire(e); });\r\n                }\r\n            },\r\n            onFirstListenerDidAdd: function () {\r\n                if (buffer) {\r\n                    if (nextTick) {\r\n                        setTimeout(flush);\r\n                    }\r\n                    else {\r\n                        flush();\r\n                    }\r\n                }\r\n            },\r\n            onLastListenerRemove: function () {\r\n                if (listener) {\r\n                    listener.dispose();\r\n                }\r\n                listener = null;\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.buffer = buffer;\r\n    var ChainableEvent = /** @class */ (function () {\r\n        function ChainableEvent(event) {\r\n            this.event = event;\r\n        }\r\n        ChainableEvent.prototype.map = function (fn) {\r\n            return new ChainableEvent(map(this.event, fn));\r\n        };\r\n        ChainableEvent.prototype.forEach = function (fn) {\r\n            return new ChainableEvent(forEach(this.event, fn));\r\n        };\r\n        ChainableEvent.prototype.filter = function (fn) {\r\n            return new ChainableEvent(filter(this.event, fn));\r\n        };\r\n        ChainableEvent.prototype.reduce = function (merge, initial) {\r\n            return new ChainableEvent(reduce(this.event, merge, initial));\r\n        };\r\n        ChainableEvent.prototype.latch = function () {\r\n            return new ChainableEvent(latch(this.event));\r\n        };\r\n        ChainableEvent.prototype.debounce = function (merge, delay, leading, leakWarningThreshold) {\r\n            if (delay === void 0) { delay = 100; }\r\n            if (leading === void 0) { leading = false; }\r\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\r\n        };\r\n        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {\r\n            return this.event(listener, thisArgs, disposables);\r\n        };\r\n        ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {\r\n            return once(this.event)(listener, thisArgs, disposables);\r\n        };\r\n        return ChainableEvent;\r\n    }());\r\n    function chain(event) {\r\n        return new ChainableEvent(event);\r\n    }\r\n    Event.chain = chain;\r\n    function fromNodeEventEmitter(emitter, eventName, map) {\r\n        if (map === void 0) { map = function (id) { return id; }; }\r\n        var fn = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return result.fire(map.apply(void 0, args));\r\n        };\r\n        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };\r\n        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };\r\n        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\r\n    function fromDOMEventEmitter(emitter, eventName, map) {\r\n        if (map === void 0) { map = function (id) { return id; }; }\r\n        var fn = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return result.fire(map.apply(void 0, args));\r\n        };\r\n        var onFirstListenerAdd = function () { return emitter.addEventListener(eventName, fn); };\r\n        var onLastListenerRemove = function () { return emitter.removeEventListener(eventName, fn); };\r\n        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\r\n    function fromPromise(promise) {\r\n        var emitter = new Emitter();\r\n        var shouldEmit = false;\r\n        promise\r\n            .then(undefined, function () { return null; })\r\n            .then(function () {\r\n            if (!shouldEmit) {\r\n                setTimeout(function () { return emitter.fire(undefined); }, 0);\r\n            }\r\n            else {\r\n                emitter.fire(undefined);\r\n            }\r\n        });\r\n        shouldEmit = true;\r\n        return emitter.event;\r\n    }\r\n    Event.fromPromise = fromPromise;\r\n    function toPromise(event) {\r\n        return new Promise(function (c) { return once(event)(c); });\r\n    }\r\n    Event.toPromise = toPromise;\r\n})(Event || (Event = {}));\r\nvar _globalLeakWarningThreshold = -1;\r\nvar LeakageMonitor = /** @class */ (function () {\r\n    function LeakageMonitor(customThreshold, name) {\r\n        if (name === void 0) { name = Math.random().toString(18).slice(2, 5); }\r\n        this.customThreshold = customThreshold;\r\n        this.name = name;\r\n        this._warnCountdown = 0;\r\n    }\r\n    LeakageMonitor.prototype.dispose = function () {\r\n        if (this._stacks) {\r\n            this._stacks.clear();\r\n        }\r\n    };\r\n    LeakageMonitor.prototype.check = function (listenerCount) {\r\n        var _this = this;\r\n        var threshold = _globalLeakWarningThreshold;\r\n        if (typeof this.customThreshold === 'number') {\r\n            threshold = this.customThreshold;\r\n        }\r\n        if (threshold <= 0 || listenerCount < threshold) {\r\n            return undefined;\r\n        }\r\n        if (!this._stacks) {\r\n            this._stacks = new Map();\r\n        }\r\n        var stack = new Error().stack.split('\\n').slice(3).join('\\n');\r\n        var count = (this._stacks.get(stack) || 0);\r\n        this._stacks.set(stack, count + 1);\r\n        this._warnCountdown -= 1;\r\n        if (this._warnCountdown <= 0) {\r\n            // only warn on first exceed and then every time the limit\r\n            // is exceeded by 50% again\r\n            this._warnCountdown = threshold * 0.5;\r\n            // find most frequent listener and print warning\r\n            var topStack_1;\r\n            var topCount_1 = 0;\r\n            this._stacks.forEach(function (count, stack) {\r\n                if (!topStack_1 || topCount_1 < count) {\r\n                    topStack_1 = stack;\r\n                    topCount_1 = count;\r\n                }\r\n            });\r\n            console.warn(\"[\" + this.name + \"] potential listener LEAK detected, having \" + listenerCount + \" listeners already. MOST frequent listener (\" + topCount_1 + \"):\");\r\n            console.warn(topStack_1);\r\n        }\r\n        return function () {\r\n            var count = (_this._stacks.get(stack) || 0);\r\n            _this._stacks.set(stack, count - 1);\r\n        };\r\n    };\r\n    return LeakageMonitor;\r\n}());\r\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\r\nvar Emitter = /** @class */ (function () {\r\n    function Emitter(options) {\r\n        this._disposed = false;\r\n        this._options = options;\r\n        this._leakageMon = _globalLeakWarningThreshold > 0\r\n            ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)\r\n            : undefined;\r\n    }\r\n    Object.defineProperty(Emitter.prototype, \"event\", {\r\n        /**\r\n         * For the public to allow to subscribe\r\n         * to events from this Emitter\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            if (!this._event) {\r\n                this._event = function (listener, thisArgs, disposables) {\r\n                    if (!_this._listeners) {\r\n                        _this._listeners = new LinkedList();\r\n                    }\r\n                    var firstListener = _this._listeners.isEmpty();\r\n                    if (firstListener && _this._options && _this._options.onFirstListenerAdd) {\r\n                        _this._options.onFirstListenerAdd(_this);\r\n                    }\r\n                    var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\r\n                    if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {\r\n                        _this._options.onFirstListenerDidAdd(_this);\r\n                    }\r\n                    if (_this._options && _this._options.onListenerDidAdd) {\r\n                        _this._options.onListenerDidAdd(_this, listener, thisArgs);\r\n                    }\r\n                    // check and record this emitter for potential leakage\r\n                    var removeMonitor;\r\n                    if (_this._leakageMon) {\r\n                        removeMonitor = _this._leakageMon.check(_this._listeners.size);\r\n                    }\r\n                    var result;\r\n                    result = {\r\n                        dispose: function () {\r\n                            if (removeMonitor) {\r\n                                removeMonitor();\r\n                            }\r\n                            result.dispose = Emitter._noop;\r\n                            if (!_this._disposed) {\r\n                                remove();\r\n                                if (_this._options && _this._options.onLastListenerRemove) {\r\n                                    var hasListeners = (_this._listeners && !_this._listeners.isEmpty());\r\n                                    if (!hasListeners) {\r\n                                        _this._options.onLastListenerRemove(_this);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    };\r\n                    if (disposables instanceof DisposableStore) {\r\n                        disposables.add(result);\r\n                    }\r\n                    else if (Array.isArray(disposables)) {\r\n                        disposables.push(result);\r\n                    }\r\n                    return result;\r\n                };\r\n            }\r\n            return this._event;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    Emitter.prototype.fire = function (event) {\r\n        if (this._listeners) {\r\n            // put all [listener,event]-pairs into delivery queue\r\n            // then emit all event. an inner/nested event might be\r\n            // the driver of this\r\n            if (!this._deliveryQueue) {\r\n                this._deliveryQueue = new LinkedList();\r\n            }\r\n            for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {\r\n                this._deliveryQueue.push([e.value, event]);\r\n            }\r\n            while (this._deliveryQueue.size > 0) {\r\n                var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];\r\n                try {\r\n                    if (typeof listener === 'function') {\r\n                        listener.call(undefined, event_1);\r\n                    }\r\n                    else {\r\n                        listener[0].call(listener[1], event_1);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    onUnexpectedError(e);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Emitter.prototype.dispose = function () {\r\n        if (this._listeners) {\r\n            this._listeners.clear();\r\n        }\r\n        if (this._deliveryQueue) {\r\n            this._deliveryQueue.clear();\r\n        }\r\n        if (this._leakageMon) {\r\n            this._leakageMon.dispose();\r\n        }\r\n        this._disposed = true;\r\n    };\r\n    Emitter._noop = function () { };\r\n    return Emitter;\r\n}());\r\nexport { Emitter };\r\nvar PauseableEmitter = /** @class */ (function (_super) {\r\n    __extends(PauseableEmitter, _super);\r\n    function PauseableEmitter(options) {\r\n        var _this = _super.call(this, options) || this;\r\n        _this._isPaused = 0;\r\n        _this._eventQueue = new LinkedList();\r\n        _this._mergeFn = options && options.merge;\r\n        return _this;\r\n    }\r\n    PauseableEmitter.prototype.pause = function () {\r\n        this._isPaused++;\r\n    };\r\n    PauseableEmitter.prototype.resume = function () {\r\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\r\n            if (this._mergeFn) {\r\n                // use the merge function to create a single composite\r\n                // event. make a copy in case firing pauses this emitter\r\n                var events = this._eventQueue.toArray();\r\n                this._eventQueue.clear();\r\n                _super.prototype.fire.call(this, this._mergeFn(events));\r\n            }\r\n            else {\r\n                // no merging, fire each event individually and test\r\n                // that this emitter isn't paused halfway through\r\n                while (!this._isPaused && this._eventQueue.size !== 0) {\r\n                    _super.prototype.fire.call(this, this._eventQueue.shift());\r\n                }\r\n            }\r\n        }\r\n    };\r\n    PauseableEmitter.prototype.fire = function (event) {\r\n        if (this._listeners) {\r\n            if (this._isPaused !== 0) {\r\n                this._eventQueue.push(event);\r\n            }\r\n            else {\r\n                _super.prototype.fire.call(this, event);\r\n            }\r\n        }\r\n    };\r\n    return PauseableEmitter;\r\n}(Emitter));\r\nexport { PauseableEmitter };\r\nvar EventMultiplexer = /** @class */ (function () {\r\n    function EventMultiplexer() {\r\n        var _this = this;\r\n        this.hasListeners = false;\r\n        this.events = [];\r\n        this.emitter = new Emitter({\r\n            onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },\r\n            onLastListenerRemove: function () { return _this.onLastListenerRemove(); }\r\n        });\r\n    }\r\n    Object.defineProperty(EventMultiplexer.prototype, \"event\", {\r\n        get: function () {\r\n            return this.emitter.event;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    EventMultiplexer.prototype.add = function (event) {\r\n        var _this = this;\r\n        var e = { event: event, listener: null };\r\n        this.events.push(e);\r\n        if (this.hasListeners) {\r\n            this.hook(e);\r\n        }\r\n        var dispose = function () {\r\n            if (_this.hasListeners) {\r\n                _this.unhook(e);\r\n            }\r\n            var idx = _this.events.indexOf(e);\r\n            _this.events.splice(idx, 1);\r\n        };\r\n        return toDisposable(onceFn(dispose));\r\n    };\r\n    EventMultiplexer.prototype.onFirstListenerAdd = function () {\r\n        var _this = this;\r\n        this.hasListeners = true;\r\n        this.events.forEach(function (e) { return _this.hook(e); });\r\n    };\r\n    EventMultiplexer.prototype.onLastListenerRemove = function () {\r\n        var _this = this;\r\n        this.hasListeners = false;\r\n        this.events.forEach(function (e) { return _this.unhook(e); });\r\n    };\r\n    EventMultiplexer.prototype.hook = function (e) {\r\n        var _this = this;\r\n        e.listener = e.event(function (r) { return _this.emitter.fire(r); });\r\n    };\r\n    EventMultiplexer.prototype.unhook = function (e) {\r\n        if (e.listener) {\r\n            e.listener.dispose();\r\n        }\r\n        e.listener = null;\r\n    };\r\n    EventMultiplexer.prototype.dispose = function () {\r\n        this.emitter.dispose();\r\n    };\r\n    return EventMultiplexer;\r\n}());\r\nexport { EventMultiplexer };\r\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\r\nvar EventBufferer = /** @class */ (function () {\r\n    function EventBufferer() {\r\n        this.buffers = [];\r\n    }\r\n    EventBufferer.prototype.wrapEvent = function (event) {\r\n        var _this = this;\r\n        return function (listener, thisArgs, disposables) {\r\n            return event(function (i) {\r\n                var buffer = _this.buffers[_this.buffers.length - 1];\r\n                if (buffer) {\r\n                    buffer.push(function () { return listener.call(thisArgs, i); });\r\n                }\r\n                else {\r\n                    listener.call(thisArgs, i);\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n    };\r\n    EventBufferer.prototype.bufferEvents = function (fn) {\r\n        var buffer = [];\r\n        this.buffers.push(buffer);\r\n        var r = fn();\r\n        this.buffers.pop();\r\n        buffer.forEach(function (flush) { return flush(); });\r\n        return r;\r\n    };\r\n    return EventBufferer;\r\n}());\r\nexport { EventBufferer };\r\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\r\nvar Relay = /** @class */ (function () {\r\n    function Relay() {\r\n        var _this = this;\r\n        this.listening = false;\r\n        this.inputEvent = Event.None;\r\n        this.inputEventListener = Disposable.None;\r\n        this.emitter = new Emitter({\r\n            onFirstListenerDidAdd: function () {\r\n                _this.listening = true;\r\n                _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);\r\n            },\r\n            onLastListenerRemove: function () {\r\n                _this.listening = false;\r\n                _this.inputEventListener.dispose();\r\n            }\r\n        });\r\n        this.event = this.emitter.event;\r\n    }\r\n    Object.defineProperty(Relay.prototype, \"input\", {\r\n        set: function (event) {\r\n            this.inputEvent = event;\r\n            if (this.listening) {\r\n                this.inputEventListener.dispose();\r\n                this.inputEventListener = event(this.emitter.fire, this.emitter);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Relay.prototype.dispose = function () {\r\n        this.inputEventListener.dispose();\r\n        this.emitter.dispose();\r\n    };\r\n    return Relay;\r\n}());\r\nexport { Relay };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}