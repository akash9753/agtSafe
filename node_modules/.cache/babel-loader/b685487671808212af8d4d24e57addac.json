{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254 /* ColorMaskInverse */ | color << 0 /* ColorOffset */;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */ === 1;\n}\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253 /* IsVisitedMaskInverse */ | (value ? 1 : 0) << 1 /* IsVisitedOffset */;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */ === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251 /* IsForValidationMaskInverse */ | (value ? 1 : 0) << 2 /* IsForValidationOffset */;\n}\n\nexport function getNodeIsInOverviewRuler(node) {\n  return (node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */ === 1;\n}\nfunction setNodeIsInOverviewRuler(node, value) {\n  node.metadata = node.metadata & 247 /* IsInOverviewRulerMaskInverse */ | (value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 207 /* StickinessMaskInverse */ | stickiness << 4 /* StickinessOffset */;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */ === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */ | (value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */;\n}\n\nvar IntervalNode = /** @class */function () {\n  function IntervalNode(id, start, end) {\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1 /* Red */);\n    this.start = start;\n    this.end = end;\n    // FORCE_OVERFLOWING_TEST: this.delta = start;\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n    _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\n    setNodeIsInOverviewRuler(this, false);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n  IntervalNode.prototype.reset = function (versionId, start, end, range) {\n    this.start = start;\n    this.end = end;\n    this.maxEnd = end;\n    this.cachedVersionId = versionId;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = range;\n  };\n  IntervalNode.prototype.setOptions = function (options) {\n    this.options = options;\n    var className = this.options.className;\n    setNodeIsForValidation(this, className === \"squiggly-error\" /* EditorErrorDecoration */ || className === \"squiggly-warning\" /* EditorWarningDecoration */ || className === \"squiggly-info\" /* EditorInfoDecoration */);\n    _setNodeStickiness(this, this.options.stickiness);\n    setNodeIsInOverviewRuler(this, this.options.overviewRuler && this.options.overviewRuler.color ? true : false);\n    setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n  };\n  IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {\n    if (this.cachedVersionId !== cachedVersionId) {\n      this.range = null;\n    }\n    this.cachedVersionId = cachedVersionId;\n    this.cachedAbsoluteStart = absoluteStart;\n    this.cachedAbsoluteEnd = absoluteEnd;\n  };\n  IntervalNode.prototype.detach = function () {\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  };\n  return IntervalNode;\n}();\nexport { IntervalNode };\nexport var SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* Black */);\nvar IntervalTree = /** @class */function () {\n  function IntervalTree() {\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n  IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n  };\n  IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {\n    if (this.root === SENTINEL) {\n      return [];\n    }\n    return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n  };\n  /**\r\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n   */\n  IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {\n    return collectNodesFromOwner(this, ownerId);\n  };\n  /**\r\n   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n   */\n  IntervalTree.prototype.collectNodesPostOrder = function () {\n    return collectNodesPostOrder(this);\n  };\n  IntervalTree.prototype.insert = function (node) {\n    rbTreeInsert(this, node);\n    this._normalizeDeltaIfNecessary();\n  };\n  IntervalTree.prototype.delete = function (node) {\n    rbTreeDelete(this, node);\n    this._normalizeDeltaIfNecessary();\n  };\n  IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {\n    var initialNode = node;\n    var delta = 0;\n    while (node !== this.root) {\n      if (node === node.parent.right) {\n        delta += node.parent.delta;\n      }\n      node = node.parent;\n    }\n    var nodeStart = initialNode.start + delta;\n    var nodeEnd = initialNode.end + delta;\n    initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n  };\n  IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\n    // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n    // (1) collect all nodes that are intersecting this edit as nodes of interest\n    var nodesOfInterest = searchForEditing(this, offset, offset + length);\n    // (2) remove all nodes that are intersecting this edit\n    for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n      var node = nodesOfInterest[i];\n      rbTreeDelete(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n    // (3) edit all tree nodes except the nodes of interest\n    noOverlapReplace(this, offset, offset + length, textLength);\n    this._normalizeDeltaIfNecessary();\n    // (4) edit the nodes of interest and insert them back in the tree\n    for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n      var node = nodesOfInterest[i];\n      node.start = node.cachedAbsoluteStart;\n      node.end = node.cachedAbsoluteEnd;\n      nodeAcceptEdit(node, offset, offset + length, textLength, forceMoveMarkers);\n      node.maxEnd = node.end;\n      rbTreeInsert(this, node);\n    }\n    this._normalizeDeltaIfNecessary();\n  };\n  IntervalTree.prototype._normalizeDeltaIfNecessary = function () {\n    if (!this.requestNormalizeDelta) {\n      return;\n    }\n    this.requestNormalizeDelta = false;\n    normalizeDelta(this);\n  };\n  return IntervalTree;\n}();\nexport { IntervalTree };\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n  var node = T.root;\n  var delta = 0;\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true);\n    // going up from this node\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n    node = node.parent;\n  }\n  setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n  if (moveSemantics === 1 /* ForceMove */) {\n    return false;\n  }\n  if (moveSemantics === 2 /* ForceStay */) {\n    return true;\n  }\n  return markerStickToPreviousCharacter;\n}\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  var nodeStickiness = getNodeStickiness(node);\n  var startStickToPreviousCharacter = nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */;\n  var endStickToPreviousCharacter = nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */;\n  var deletingCnt = end - start;\n  var insertingCnt = textLength;\n  var commonLength = Math.min(deletingCnt, insertingCnt);\n  var nodeStart = node.start;\n  var startDone = false;\n  var nodeEnd = node.end;\n  var endDone = false;\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n  {\n    var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  if (commonLength > 0 && !forceMoveMarkers) {\n    var moveSemantics = deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  {\n    var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  }\n  // Finish\n  var deltaColumn = insertingCnt - deletingCnt;\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var editDelta = textLength - (end - start);\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n      if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n      }\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction collectNodesPostOrder(T) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  var node = T.root;\n  var delta = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    var include = true;\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n    if (include) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      var include = true;\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0 /* Black */);\n    T.root = newNode;\n    return T.root;\n  }\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent);\n  // repair tree\n  var x = newNode;\n  while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\n    if (x.parent === x.parent.parent.left) {\n      var y = x.parent.parent.right;\n      if (getNodeColor(y) === 1 /* Red */) {\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(y, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      var y = x.parent.parent.left;\n      if (getNodeColor(y) === 1 /* Red */) {\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(y, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(x.parent.parent, 1 /* Red */);\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n  setNodeColor(T.root, 0 /* Black */);\n  return newNode;\n}\nfunction treeInsert(T, z) {\n  var delta = 0;\n  var x = T.root;\n  var zAbsoluteStart = z.start;\n  var zAbsoluteEnd = z.end;\n  while (true) {\n    var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1 /* Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n  var x;\n  var y;\n  // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z;\n    // x's delta is no longer influenced by z's delta\n    x.delta += z.delta;\n    if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n    // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n    if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n  }\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0 /* Black */);\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n  var yWasRed = getNodeColor(y) === 1 /* Red */;\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n  z.detach();\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n    resetSentinel();\n    return;\n  }\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  }\n  // RB-DELETE-FIXUP\n  var w;\n  while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n      if (getNodeColor(w) === 1 /* Red */) {\n        setNodeColor(w, 0 /* Black */);\n        setNodeColor(x.parent, 1 /* Red */);\n        leftRotate(T, x.parent);\n        w = x.parent.right;\n      }\n      if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n        setNodeColor(w, 1 /* Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.right) === 0 /* Black */) {\n          setNodeColor(w.left, 0 /* Black */);\n          setNodeColor(w, 1 /* Red */);\n          rightRotate(T, w);\n          w = x.parent.right;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(w.right, 0 /* Black */);\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n      if (getNodeColor(w) === 1 /* Red */) {\n        setNodeColor(w, 0 /* Black */);\n        setNodeColor(x.parent, 1 /* Red */);\n        rightRotate(T, x.parent);\n        w = x.parent.left;\n      }\n      if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\n        setNodeColor(w, 1 /* Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.left) === 0 /* Black */) {\n          setNodeColor(w.right, 0 /* Black */);\n          setNodeColor(w, 1 /* Red */);\n          leftRotate(T, w);\n          w = x.parent.left;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* Black */);\n        setNodeColor(w.left, 0 /* Black */);\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n  setNodeColor(x, 0 /* Black */);\n  resetSentinel();\n}\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n  return node;\n}\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n  SENTINEL.start = 0; // optional\n  SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n  var y = x.right; // set y.\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n  if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n  y.parent = x.parent; // link x's parent to y.\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n  y.left = x; // put x on y's left.\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n  var x = y.left;\n  y.delta -= x.delta;\n  if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n  x.parent = y.parent;\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n  var maxEnd = node.end;\n  if (node.left !== SENTINEL) {\n    var leftMaxEnd = node.left.maxEnd;\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n  if (node.right !== SENTINEL) {\n    var rightMaxEnd = node.right.maxEnd + node.delta;\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n  return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    var maxEnd = computeMaxEnd(node);\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n  return aStart - bStart;\n}\n//#endregion","map":{"version":3,"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInOverviewRuler","setNodeIsInOverviewRuler","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","prototype","reset","versionId","setOptions","className","overviewRuler","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport function getNodeColor(node) {\r\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\r\n}\r\nfunction setNodeColor(node, color) {\r\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\r\n}\r\nfunction getNodeIsVisited(node) {\r\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\r\n}\r\nfunction setNodeIsVisited(node, value) {\r\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\r\n}\r\nfunction getNodeIsForValidation(node) {\r\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\r\n}\r\nfunction setNodeIsForValidation(node, value) {\r\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\r\n}\r\nexport function getNodeIsInOverviewRuler(node) {\r\n    return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;\r\n}\r\nfunction setNodeIsInOverviewRuler(node, value) {\r\n    node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));\r\n}\r\nfunction getNodeStickiness(node) {\r\n    return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);\r\n}\r\nfunction _setNodeStickiness(node, stickiness) {\r\n    node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));\r\n}\r\nfunction getCollapseOnReplaceEdit(node) {\r\n    return ((node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */) === 1;\r\n}\r\nfunction setCollapseOnReplaceEdit(node, value) {\r\n    node.metadata = ((node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */));\r\n}\r\nvar IntervalNode = /** @class */ (function () {\r\n    function IntervalNode(id, start, end) {\r\n        this.metadata = 0;\r\n        this.parent = this;\r\n        this.left = this;\r\n        this.right = this;\r\n        setNodeColor(this, 1 /* Red */);\r\n        this.start = start;\r\n        this.end = end;\r\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\r\n        this.delta = 0;\r\n        this.maxEnd = end;\r\n        this.id = id;\r\n        this.ownerId = 0;\r\n        this.options = null;\r\n        setNodeIsForValidation(this, false);\r\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\r\n        setNodeIsInOverviewRuler(this, false);\r\n        setCollapseOnReplaceEdit(this, false);\r\n        this.cachedVersionId = 0;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = null;\r\n        setNodeIsVisited(this, false);\r\n    }\r\n    IntervalNode.prototype.reset = function (versionId, start, end, range) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.maxEnd = end;\r\n        this.cachedVersionId = versionId;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = range;\r\n    };\r\n    IntervalNode.prototype.setOptions = function (options) {\r\n        this.options = options;\r\n        var className = this.options.className;\r\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\r\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\r\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\r\n        _setNodeStickiness(this, this.options.stickiness);\r\n        setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\r\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\r\n    };\r\n    IntervalNode.prototype.setCachedOffsets = function (absoluteStart, absoluteEnd, cachedVersionId) {\r\n        if (this.cachedVersionId !== cachedVersionId) {\r\n            this.range = null;\r\n        }\r\n        this.cachedVersionId = cachedVersionId;\r\n        this.cachedAbsoluteStart = absoluteStart;\r\n        this.cachedAbsoluteEnd = absoluteEnd;\r\n    };\r\n    IntervalNode.prototype.detach = function () {\r\n        this.parent = null;\r\n        this.left = null;\r\n        this.right = null;\r\n    };\r\n    return IntervalNode;\r\n}());\r\nexport { IntervalNode };\r\nexport var SENTINEL = new IntervalNode(null, 0, 0);\r\nSENTINEL.parent = SENTINEL;\r\nSENTINEL.left = SENTINEL;\r\nSENTINEL.right = SENTINEL;\r\nsetNodeColor(SENTINEL, 0 /* Black */);\r\nvar IntervalTree = /** @class */ (function () {\r\n    function IntervalTree() {\r\n        this.root = SENTINEL;\r\n        this.requestNormalizeDelta = false;\r\n    }\r\n    IntervalTree.prototype.intervalSearch = function (start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    };\r\n    IntervalTree.prototype.search = function (filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    };\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    IntervalTree.prototype.collectNodesFromOwner = function (ownerId) {\r\n        return collectNodesFromOwner(this, ownerId);\r\n    };\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    IntervalTree.prototype.collectNodesPostOrder = function () {\r\n        return collectNodesPostOrder(this);\r\n    };\r\n    IntervalTree.prototype.insert = function (node) {\r\n        rbTreeInsert(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    };\r\n    IntervalTree.prototype.delete = function (node) {\r\n        rbTreeDelete(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    };\r\n    IntervalTree.prototype.resolveNode = function (node, cachedVersionId) {\r\n        var initialNode = node;\r\n        var delta = 0;\r\n        while (node !== this.root) {\r\n            if (node === node.parent.right) {\r\n                delta += node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        var nodeStart = initialNode.start + delta;\r\n        var nodeEnd = initialNode.end + delta;\r\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n    };\r\n    IntervalTree.prototype.acceptReplace = function (offset, length, textLength, forceMoveMarkers) {\r\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\r\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\r\n        var nodesOfInterest = searchForEditing(this, offset, offset + length);\r\n        // (2) remove all nodes that are intersecting this edit\r\n        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            var node = nodesOfInterest[i];\r\n            rbTreeDelete(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n        // (3) edit all tree nodes except the nodes of interest\r\n        noOverlapReplace(this, offset, offset + length, textLength);\r\n        this._normalizeDeltaIfNecessary();\r\n        // (4) edit the nodes of interest and insert them back in the tree\r\n        for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            var node = nodesOfInterest[i];\r\n            node.start = node.cachedAbsoluteStart;\r\n            node.end = node.cachedAbsoluteEnd;\r\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\r\n            node.maxEnd = node.end;\r\n            rbTreeInsert(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n    };\r\n    IntervalTree.prototype._normalizeDeltaIfNecessary = function () {\r\n        if (!this.requestNormalizeDelta) {\r\n            return;\r\n        }\r\n        this.requestNormalizeDelta = false;\r\n        normalizeDelta(this);\r\n    };\r\n    return IntervalTree;\r\n}());\r\nexport { IntervalTree };\r\n//#region Delta Normalization\r\nfunction normalizeDelta(T) {\r\n    var node = T.root;\r\n    var delta = 0;\r\n    while (node !== SENTINEL) {\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        node.start = delta + node.start;\r\n        node.end = delta + node.end;\r\n        node.delta = 0;\r\n        recomputeMaxEnd(node);\r\n        setNodeIsVisited(node, true);\r\n        // going up from this node\r\n        setNodeIsVisited(node.left, false);\r\n        setNodeIsVisited(node.right, false);\r\n        if (node === node.parent.right) {\r\n            delta -= node.parent.delta;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\r\n    if (markerOffset < checkOffset) {\r\n        return true;\r\n    }\r\n    if (markerOffset > checkOffset) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 1 /* ForceMove */) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 2 /* ForceStay */) {\r\n        return true;\r\n    }\r\n    return markerStickToPreviousCharacter;\r\n}\r\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\r\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\r\n    var nodeStickiness = getNodeStickiness(node);\r\n    var startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    var endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    var deletingCnt = (end - start);\r\n    var insertingCnt = textLength;\r\n    var commonLength = Math.min(deletingCnt, insertingCnt);\r\n    var nodeStart = node.start;\r\n    var startDone = false;\r\n    var nodeEnd = node.end;\r\n    var endDone = false;\r\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\r\n        // This edit encompasses the entire decoration range\r\n        // and the decoration has asked to become collapsed\r\n        node.start = start;\r\n        startDone = true;\r\n        node.end = start;\r\n        endDone = true;\r\n    }\r\n    {\r\n        var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    if (commonLength > 0 && !forceMoveMarkers) {\r\n        var moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    {\r\n        var moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.start = start + insertingCnt;\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.end = start + insertingCnt;\r\n            endDone = true;\r\n        }\r\n    }\r\n    // Finish\r\n    var deltaColumn = (insertingCnt - deletingCnt);\r\n    if (!startDone) {\r\n        node.start = Math.max(0, nodeStart + deltaColumn);\r\n    }\r\n    if (!endDone) {\r\n        node.end = Math.max(0, nodeEnd + deltaColumn);\r\n    }\r\n    if (node.start > node.end) {\r\n        node.end = node.start;\r\n    }\r\n}\r\nfunction searchForEditing(T, start, end) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeMaxEnd = 0;\r\n    var nodeStart = 0;\r\n    var nodeEnd = 0;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= start) {\r\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction noOverlapReplace(T, start, end, textLength) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeMaxEnd = 0;\r\n    var nodeStart = 0;\r\n    var editDelta = (textLength - (end - start));\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            recomputeMaxEnd(node);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            node.start += editDelta;\r\n            node.end += editDelta;\r\n            node.delta += editDelta;\r\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n                T.requestNormalizeDelta = true;\r\n            }\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\n//#endregion\r\n//#region Searching\r\nfunction collectNodesFromOwner(T, ownerId) {\r\n    var node = T.root;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        if (node.ownerId === ownerId) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction collectNodesPostOrder(T) {\r\n    var node = T.root;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        result[resultLen++] = node;\r\n        setNodeIsVisited(node, true);\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeStart = 0;\r\n    var nodeEnd = 0;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        nodeEnd = delta + node.end;\r\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n        var include = true;\r\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n            include = false;\r\n        }\r\n        if (filterOutValidation && getNodeIsForValidation(node)) {\r\n            include = false;\r\n        }\r\n        if (include) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    var node = T.root;\r\n    var delta = 0;\r\n    var nodeMaxEnd = 0;\r\n    var nodeStart = 0;\r\n    var nodeEnd = 0;\r\n    var result = [];\r\n    var resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < intervalStart) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > intervalEnd) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= intervalStart) {\r\n            // There is overlap\r\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n            var include = true;\r\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n                include = false;\r\n            }\r\n            if (filterOutValidation && getNodeIsForValidation(node)) {\r\n                include = false;\r\n            }\r\n            if (include) {\r\n                result[resultLen++] = node;\r\n            }\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\n//#endregion\r\n//#region Insertion\r\nfunction rbTreeInsert(T, newNode) {\r\n    if (T.root === SENTINEL) {\r\n        newNode.parent = SENTINEL;\r\n        newNode.left = SENTINEL;\r\n        newNode.right = SENTINEL;\r\n        setNodeColor(newNode, 0 /* Black */);\r\n        T.root = newNode;\r\n        return T.root;\r\n    }\r\n    treeInsert(T, newNode);\r\n    recomputeMaxEndWalkToRoot(newNode.parent);\r\n    // repair tree\r\n    var x = newNode;\r\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\r\n        if (x.parent === x.parent.parent.left) {\r\n            var y = x.parent.parent.right;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.right) {\r\n                    x = x.parent;\r\n                    leftRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n        else {\r\n            var y = x.parent.parent.left;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.left) {\r\n                    x = x.parent;\r\n                    rightRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(T.root, 0 /* Black */);\r\n    return newNode;\r\n}\r\nfunction treeInsert(T, z) {\r\n    var delta = 0;\r\n    var x = T.root;\r\n    var zAbsoluteStart = z.start;\r\n    var zAbsoluteEnd = z.end;\r\n    while (true) {\r\n        var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\r\n        if (cmp < 0) {\r\n            // this node should be inserted to the left\r\n            // => it is not affected by the node's delta\r\n            if (x.left === SENTINEL) {\r\n                z.start -= delta;\r\n                z.end -= delta;\r\n                z.maxEnd -= delta;\r\n                x.left = z;\r\n                break;\r\n            }\r\n            else {\r\n                x = x.left;\r\n            }\r\n        }\r\n        else {\r\n            // this node should be inserted to the right\r\n            // => it is not affected by the node's delta\r\n            if (x.right === SENTINEL) {\r\n                z.start -= (delta + x.delta);\r\n                z.end -= (delta + x.delta);\r\n                z.maxEnd -= (delta + x.delta);\r\n                x.right = z;\r\n                break;\r\n            }\r\n            else {\r\n                delta += x.delta;\r\n                x = x.right;\r\n            }\r\n        }\r\n    }\r\n    z.parent = x;\r\n    z.left = SENTINEL;\r\n    z.right = SENTINEL;\r\n    setNodeColor(z, 1 /* Red */);\r\n}\r\n//#endregion\r\n//#region Deletion\r\nfunction rbTreeDelete(T, z) {\r\n    var x;\r\n    var y;\r\n    // RB-DELETE except we don't swap z and y in case c)\r\n    // i.e. we always delete what's pointed at by z.\r\n    if (z.left === SENTINEL) {\r\n        x = z.right;\r\n        y = z;\r\n        // x's delta is no longer influenced by z's delta\r\n        x.delta += z.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        x.start += z.delta;\r\n        x.end += z.delta;\r\n    }\r\n    else if (z.right === SENTINEL) {\r\n        x = z.left;\r\n        y = z;\r\n    }\r\n    else {\r\n        y = leftest(z.right);\r\n        x = y.right;\r\n        // y's delta is no longer influenced by z's delta,\r\n        // but we don't want to walk the entire right-hand-side subtree of x.\r\n        // we therefore maintain z's delta in y, and adjust only x\r\n        x.start += y.delta;\r\n        x.end += y.delta;\r\n        x.delta += y.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        y.start += z.delta;\r\n        y.end += z.delta;\r\n        y.delta = z.delta;\r\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n    }\r\n    if (y === T.root) {\r\n        T.root = x;\r\n        setNodeColor(x, 0 /* Black */);\r\n        z.detach();\r\n        resetSentinel();\r\n        recomputeMaxEnd(x);\r\n        T.root.parent = SENTINEL;\r\n        return;\r\n    }\r\n    var yWasRed = (getNodeColor(y) === 1 /* Red */);\r\n    if (y === y.parent.left) {\r\n        y.parent.left = x;\r\n    }\r\n    else {\r\n        y.parent.right = x;\r\n    }\r\n    if (y === z) {\r\n        x.parent = y.parent;\r\n    }\r\n    else {\r\n        if (y.parent === z) {\r\n            x.parent = y;\r\n        }\r\n        else {\r\n            x.parent = y.parent;\r\n        }\r\n        y.left = z.left;\r\n        y.right = z.right;\r\n        y.parent = z.parent;\r\n        setNodeColor(y, getNodeColor(z));\r\n        if (z === T.root) {\r\n            T.root = y;\r\n        }\r\n        else {\r\n            if (z === z.parent.left) {\r\n                z.parent.left = y;\r\n            }\r\n            else {\r\n                z.parent.right = y;\r\n            }\r\n        }\r\n        if (y.left !== SENTINEL) {\r\n            y.left.parent = y;\r\n        }\r\n        if (y.right !== SENTINEL) {\r\n            y.right.parent = y;\r\n        }\r\n    }\r\n    z.detach();\r\n    if (yWasRed) {\r\n        recomputeMaxEndWalkToRoot(x.parent);\r\n        if (y !== z) {\r\n            recomputeMaxEndWalkToRoot(y);\r\n            recomputeMaxEndWalkToRoot(y.parent);\r\n        }\r\n        resetSentinel();\r\n        return;\r\n    }\r\n    recomputeMaxEndWalkToRoot(x);\r\n    recomputeMaxEndWalkToRoot(x.parent);\r\n    if (y !== z) {\r\n        recomputeMaxEndWalkToRoot(y);\r\n        recomputeMaxEndWalkToRoot(y.parent);\r\n    }\r\n    // RB-DELETE-FIXUP\r\n    var w;\r\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\r\n        if (x === x.parent.left) {\r\n            w = x.parent.right;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent);\r\n                w = x.parent.right;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.right) === 0 /* Black */) {\r\n                    setNodeColor(w.left, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    rightRotate(T, w);\r\n                    w = x.parent.right;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.right, 0 /* Black */);\r\n                leftRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n        else {\r\n            w = x.parent.left;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent);\r\n                w = x.parent.left;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.left) === 0 /* Black */) {\r\n                    setNodeColor(w.right, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    leftRotate(T, w);\r\n                    w = x.parent.left;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.left, 0 /* Black */);\r\n                rightRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(x, 0 /* Black */);\r\n    resetSentinel();\r\n}\r\nfunction leftest(node) {\r\n    while (node.left !== SENTINEL) {\r\n        node = node.left;\r\n    }\r\n    return node;\r\n}\r\nfunction resetSentinel() {\r\n    SENTINEL.parent = SENTINEL;\r\n    SENTINEL.delta = 0; // optional\r\n    SENTINEL.start = 0; // optional\r\n    SENTINEL.end = 0; // optional\r\n}\r\n//#endregion\r\n//#region Rotations\r\nfunction leftRotate(T, x) {\r\n    var y = x.right; // set y.\r\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start += x.delta;\r\n    y.end += x.delta;\r\n    x.right = y.left; // turn y's left subtree into x's right subtree.\r\n    if (y.left !== SENTINEL) {\r\n        y.left.parent = x;\r\n    }\r\n    y.parent = x.parent; // link x's parent to y.\r\n    if (x.parent === SENTINEL) {\r\n        T.root = y;\r\n    }\r\n    else if (x === x.parent.left) {\r\n        x.parent.left = y;\r\n    }\r\n    else {\r\n        x.parent.right = y;\r\n    }\r\n    y.left = x; // put x on y's left.\r\n    x.parent = y;\r\n    recomputeMaxEnd(x);\r\n    recomputeMaxEnd(y);\r\n}\r\nfunction rightRotate(T, y) {\r\n    var x = y.left;\r\n    y.delta -= x.delta;\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start -= x.delta;\r\n    y.end -= x.delta;\r\n    y.left = x.right;\r\n    if (x.right !== SENTINEL) {\r\n        x.right.parent = y;\r\n    }\r\n    x.parent = y.parent;\r\n    if (y.parent === SENTINEL) {\r\n        T.root = x;\r\n    }\r\n    else if (y === y.parent.right) {\r\n        y.parent.right = x;\r\n    }\r\n    else {\r\n        y.parent.left = x;\r\n    }\r\n    x.right = y;\r\n    y.parent = x;\r\n    recomputeMaxEnd(y);\r\n    recomputeMaxEnd(x);\r\n}\r\n//#endregion\r\n//#region max end computation\r\nfunction computeMaxEnd(node) {\r\n    var maxEnd = node.end;\r\n    if (node.left !== SENTINEL) {\r\n        var leftMaxEnd = node.left.maxEnd;\r\n        if (leftMaxEnd > maxEnd) {\r\n            maxEnd = leftMaxEnd;\r\n        }\r\n    }\r\n    if (node.right !== SENTINEL) {\r\n        var rightMaxEnd = node.right.maxEnd + node.delta;\r\n        if (rightMaxEnd > maxEnd) {\r\n            maxEnd = rightMaxEnd;\r\n        }\r\n    }\r\n    return maxEnd;\r\n}\r\nexport function recomputeMaxEnd(node) {\r\n    node.maxEnd = computeMaxEnd(node);\r\n}\r\nfunction recomputeMaxEndWalkToRoot(node) {\r\n    while (node !== SENTINEL) {\r\n        var maxEnd = computeMaxEnd(node);\r\n        if (node.maxEnd === maxEnd) {\r\n            // no need to go further\r\n            return;\r\n        }\r\n        node.maxEnd = maxEnd;\r\n        node = node.parent;\r\n    }\r\n}\r\n//#endregion\r\n//#region utils\r\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\r\n    if (aStart === bStart) {\r\n        return aEnd - bEnd;\r\n    }\r\n    return aStart - bStart;\r\n}\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}