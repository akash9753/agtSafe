{"ast":null,"code":"/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\nvar TRACK_DISPOSABLES = false;\nvar __is_disposable_tracked__ = '__is_disposable_tracked__';\nfunction markTracked(x) {\n  if (!TRACK_DISPOSABLES) {\n    return;\n  }\n  if (x && x !== Disposable.None) {\n    try {\n      x[__is_disposable_tracked__] = true;\n    } catch (_a) {\n      // noop\n    }\n  }\n}\nfunction trackDisposable(x) {\n  if (!TRACK_DISPOSABLES) {\n    return x;\n  }\n  var stack = new Error('Potentially leaked disposable').stack;\n  setTimeout(function () {\n    if (!x[__is_disposable_tracked__]) {\n      console.log(stack);\n    }\n  }, 3000);\n  return x;\n}\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction _dispose(disposables) {\n  if (Array.isArray(disposables)) {\n    disposables.forEach(function (d) {\n      if (d) {\n        markTracked(d);\n        d.dispose();\n      }\n    });\n    return [];\n  } else if (disposables) {\n    markTracked(disposables);\n    disposables.dispose();\n    return disposables;\n  } else {\n    return undefined;\n  }\n}\nexport { _dispose as dispose };\nexport function combinedDisposable() {\n  var disposables = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    disposables[_i] = arguments[_i];\n  }\n  disposables.forEach(markTracked);\n  return trackDisposable({\n    dispose: function dispose() {\n      return _dispose(disposables);\n    }\n  });\n}\nexport function toDisposable(fn) {\n  var self = trackDisposable({\n    dispose: function dispose() {\n      markTracked(self);\n      fn();\n    }\n  });\n  return self;\n}\nvar DisposableStore = /** @class */function () {\n  function DisposableStore() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n  }\n  /**\r\n   * Dispose of all registered disposables and mark this object as disposed.\r\n   *\r\n   * Any future disposables added to this object will be disposed of on `add`.\r\n   */\n  DisposableStore.prototype.dispose = function () {\n    if (this._isDisposed) {\n      return;\n    }\n    markTracked(this);\n    this._isDisposed = true;\n    this.clear();\n  };\n  /**\r\n   * Dispose of all registered disposables but do not mark this object as disposed.\r\n   */\n  DisposableStore.prototype.clear = function () {\n    this._toDispose.forEach(function (item) {\n      return item.dispose();\n    });\n    this._toDispose.clear();\n  };\n  DisposableStore.prototype.add = function (t) {\n    if (!t) {\n      return t;\n    }\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    markTracked(t);\n    if (this._isDisposed) {\n      console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n    } else {\n      this._toDispose.add(t);\n    }\n    return t;\n  };\n  return DisposableStore;\n}();\nexport { DisposableStore };\nvar Disposable = /** @class */function () {\n  function Disposable() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n  }\n  Disposable.prototype.dispose = function () {\n    markTracked(this);\n    this._store.dispose();\n  };\n  Disposable.prototype._register = function (t) {\n    if (t === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    return this._store.add(t);\n  };\n  Disposable.None = Object.freeze({\n    dispose: function dispose() {}\n  });\n  return Disposable;\n}();\nexport { Disposable };\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\nvar MutableDisposable = /** @class */function () {\n  function MutableDisposable() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  Object.defineProperty(MutableDisposable.prototype, \"value\", {\n    get: function get() {\n      return this._isDisposed ? undefined : this._value;\n    },\n    set: function set(value) {\n      if (this._isDisposed || value === this._value) {\n        return;\n      }\n      if (this._value) {\n        this._value.dispose();\n      }\n      if (value) {\n        markTracked(value);\n      }\n      this._value = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  MutableDisposable.prototype.clear = function () {\n    this.value = undefined;\n  };\n  MutableDisposable.prototype.dispose = function () {\n    this._isDisposed = true;\n    markTracked(this);\n    if (this._value) {\n      this._value.dispose();\n    }\n    this._value = undefined;\n  };\n  return MutableDisposable;\n}();\nexport { MutableDisposable };\nvar ImmortalReference = /** @class */function () {\n  function ImmortalReference(object) {\n    this.object = object;\n  }\n  ImmortalReference.prototype.dispose = function () {};\n  return ImmortalReference;\n}();\nexport { ImmortalReference };","map":{"version":3,"names":["TRACK_DISPOSABLES","__is_disposable_tracked__","markTracked","x","Disposable","None","_a","trackDisposable","stack","Error","setTimeout","console","log","isDisposable","thing","dispose","length","disposables","Array","isArray","forEach","d","undefined","combinedDisposable","_i","arguments","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","prototype","clear","item","add","t","warn","_store","_register","Object","freeze","MutableDisposable","defineProperty","get","_value","set","value","enumerable","configurable","ImmortalReference","object"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"sourcesContent":["/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\r\nvar TRACK_DISPOSABLES = false;\r\nvar __is_disposable_tracked__ = '__is_disposable_tracked__';\r\nfunction markTracked(x) {\r\n    if (!TRACK_DISPOSABLES) {\r\n        return;\r\n    }\r\n    if (x && x !== Disposable.None) {\r\n        try {\r\n            x[__is_disposable_tracked__] = true;\r\n        }\r\n        catch (_a) {\r\n            // noop\r\n        }\r\n    }\r\n}\r\nfunction trackDisposable(x) {\r\n    if (!TRACK_DISPOSABLES) {\r\n        return x;\r\n    }\r\n    var stack = new Error('Potentially leaked disposable').stack;\r\n    setTimeout(function () {\r\n        if (!x[__is_disposable_tracked__]) {\r\n            console.log(stack);\r\n        }\r\n    }, 3000);\r\n    return x;\r\n}\r\nexport function isDisposable(thing) {\r\n    return typeof thing.dispose === 'function'\r\n        && thing.dispose.length === 0;\r\n}\r\nexport function dispose(disposables) {\r\n    if (Array.isArray(disposables)) {\r\n        disposables.forEach(function (d) {\r\n            if (d) {\r\n                markTracked(d);\r\n                d.dispose();\r\n            }\r\n        });\r\n        return [];\r\n    }\r\n    else if (disposables) {\r\n        markTracked(disposables);\r\n        disposables.dispose();\r\n        return disposables;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nexport function combinedDisposable() {\r\n    var disposables = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        disposables[_i] = arguments[_i];\r\n    }\r\n    disposables.forEach(markTracked);\r\n    return trackDisposable({ dispose: function () { return dispose(disposables); } });\r\n}\r\nexport function toDisposable(fn) {\r\n    var self = trackDisposable({\r\n        dispose: function () {\r\n            markTracked(self);\r\n            fn();\r\n        }\r\n    });\r\n    return self;\r\n}\r\nvar DisposableStore = /** @class */ (function () {\r\n    function DisposableStore() {\r\n        this._toDispose = new Set();\r\n        this._isDisposed = false;\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables and mark this object as disposed.\r\n     *\r\n     * Any future disposables added to this object will be disposed of on `add`.\r\n     */\r\n    DisposableStore.prototype.dispose = function () {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        markTracked(this);\r\n        this._isDisposed = true;\r\n        this.clear();\r\n    };\r\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\r\n    DisposableStore.prototype.clear = function () {\r\n        this._toDispose.forEach(function (item) { return item.dispose(); });\r\n        this._toDispose.clear();\r\n    };\r\n    DisposableStore.prototype.add = function (t) {\r\n        if (!t) {\r\n            return t;\r\n        }\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        markTracked(t);\r\n        if (this._isDisposed) {\r\n            console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\r\n        }\r\n        else {\r\n            this._toDispose.add(t);\r\n        }\r\n        return t;\r\n    };\r\n    return DisposableStore;\r\n}());\r\nexport { DisposableStore };\r\nvar Disposable = /** @class */ (function () {\r\n    function Disposable() {\r\n        this._store = new DisposableStore();\r\n        trackDisposable(this);\r\n    }\r\n    Disposable.prototype.dispose = function () {\r\n        markTracked(this);\r\n        this._store.dispose();\r\n    };\r\n    Disposable.prototype._register = function (t) {\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        return this._store.add(t);\r\n    };\r\n    Disposable.None = Object.freeze({ dispose: function () { } });\r\n    return Disposable;\r\n}());\r\nexport { Disposable };\r\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\r\nvar MutableDisposable = /** @class */ (function () {\r\n    function MutableDisposable() {\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    Object.defineProperty(MutableDisposable.prototype, \"value\", {\r\n        get: function () {\r\n            return this._isDisposed ? undefined : this._value;\r\n        },\r\n        set: function (value) {\r\n            if (this._isDisposed || value === this._value) {\r\n                return;\r\n            }\r\n            if (this._value) {\r\n                this._value.dispose();\r\n            }\r\n            if (value) {\r\n                markTracked(value);\r\n            }\r\n            this._value = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MutableDisposable.prototype.clear = function () {\r\n        this.value = undefined;\r\n    };\r\n    MutableDisposable.prototype.dispose = function () {\r\n        this._isDisposed = true;\r\n        markTracked(this);\r\n        if (this._value) {\r\n            this._value.dispose();\r\n        }\r\n        this._value = undefined;\r\n    };\r\n    return MutableDisposable;\r\n}());\r\nexport { MutableDisposable };\r\nvar ImmortalReference = /** @class */ (function () {\r\n    function ImmortalReference(object) {\r\n        this.object = object;\r\n    }\r\n    ImmortalReference.prototype.dispose = function () { };\r\n    return ImmortalReference;\r\n}());\r\nexport { ImmortalReference };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}