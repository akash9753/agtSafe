{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch } from '../model.js';\nvar LIMIT_FIND_COUNT = 999;\nvar SearchParams = /** @class */function () {\n  function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\n    this.searchString = searchString;\n    this.isRegex = isRegex;\n    this.matchCase = matchCase;\n    this.wordSeparators = wordSeparators;\n  }\n  SearchParams.prototype.parseSearchRequest = function () {\n    if (this.searchString === '') {\n      return null;\n    }\n    // Try to create a RegExp out of the params\n    var multiline;\n    if (this.isRegex) {\n      multiline = isMultilineRegexSource(this.searchString);\n    } else {\n      multiline = this.searchString.indexOf('\\n') >= 0;\n    }\n    var regex = null;\n    try {\n      regex = strings.createRegExp(this.searchString, this.isRegex, {\n        matchCase: this.matchCase,\n        wholeWord: false,\n        multiline: multiline,\n        global: true,\n        unicode: true\n      });\n    } catch (err) {\n      return null;\n    }\n    if (!regex) {\n      return null;\n    }\n    var canUseSimpleSearch = !this.isRegex && !multiline;\n    if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n      // casing might make a difference\n      canUseSimpleSearch = this.matchCase;\n    }\n    return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n  };\n  return SearchParams;\n}();\nexport { SearchParams };\nexport function isMultilineRegexSource(searchString) {\n  if (!searchString || searchString.length === 0) {\n    return false;\n  }\n  for (var i = 0, len = searchString.length; i < len; i++) {\n    var chCode = searchString.charCodeAt(i);\n    if (chCode === 92 /* Backslash */) {\n      // move to next char\n      i++;\n      if (i >= len) {\n        // string ends with a \\\n        break;\n      }\n      var nextChCode = searchString.charCodeAt(i);\n      if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */ || nextChCode === 119 /* w */) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nvar SearchData = /** @class */function () {\n  function SearchData(regex, wordSeparators, simpleSearch) {\n    this.regex = regex;\n    this.wordSeparators = wordSeparators;\n    this.simpleSearch = simpleSearch;\n  }\n  return SearchData;\n}();\nexport { SearchData };\nexport function createFindMatch(range, rawMatches, captureMatches) {\n  if (!captureMatches) {\n    return new FindMatch(range, null);\n  }\n  var matches = [];\n  for (var i = 0, len = rawMatches.length; i < len; i++) {\n    matches[i] = rawMatches[i];\n  }\n  return new FindMatch(range, matches);\n}\nvar LineFeedCounter = /** @class */function () {\n  function LineFeedCounter(text) {\n    var lineFeedsOffsets = [];\n    var lineFeedsOffsetsLen = 0;\n    for (var i = 0, textLen = text.length; i < textLen; i++) {\n      if (text.charCodeAt(i) === 10 /* LineFeed */) {\n        lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n      }\n    }\n    this._lineFeedsOffsets = lineFeedsOffsets;\n  }\n  LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\n    var lineFeedsOffsets = this._lineFeedsOffsets;\n    var min = 0;\n    var max = lineFeedsOffsets.length - 1;\n    if (max === -1) {\n      // no line feeds\n      return 0;\n    }\n    if (offset <= lineFeedsOffsets[0]) {\n      // before first line feed\n      return 0;\n    }\n    while (min < max) {\n      var mid = min + ((max - min) / 2 >> 0);\n      if (lineFeedsOffsets[mid] >= offset) {\n        max = mid - 1;\n      } else {\n        if (lineFeedsOffsets[mid + 1] >= offset) {\n          // bingo!\n          min = mid;\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n    }\n    return min + 1;\n  };\n  return LineFeedCounter;\n}();\nvar TextModelSearch = /** @class */function () {\n  function TextModelSearch() {}\n  TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\n    var searchData = searchParams.parseSearchRequest();\n    if (!searchData) {\n      return [];\n    }\n    if (searchData.regex.multiline) {\n      return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n    }\n    return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n  };\n  /**\r\n   * Multiline search always executes on the lines concatenated with \\n.\r\n   * We must therefore compensate for the count of \\n in case the model is CRLF\r\n   */\n  TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\n    var startOffset;\n    var lineFeedCountBeforeMatch = 0;\n    if (lfCounter) {\n      lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n      startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n    } else {\n      startOffset = deltaOffset + matchIndex;\n    }\n    var endOffset;\n    if (lfCounter) {\n      var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n      var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n      endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n    } else {\n      endOffset = startOffset + match0.length;\n    }\n    var startPosition = model.getPositionAt(startOffset);\n    var endPosition = model.getPositionAt(endOffset);\n    return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n  };\n  TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\n    var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n    // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n    var text = model.getValueInRange(searchRange, 1 /* LF */);\n    var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    var result = [];\n    var counter = 0;\n    var m;\n    searcher.reset(0);\n    while (m = searcher.next(text)) {\n      result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n      if (counter >= limitResultCount) {\n        return result;\n      }\n    }\n    return result;\n  };\n  TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\n    var result = [];\n    var resultLen = 0;\n    // Early case for a search range that starts & stops on the same line number\n    if (searchRange.startLineNumber === searchRange.endLineNumber) {\n      var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n      return result;\n    }\n    // Collect results from first line\n    var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n    resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n    // Collect results from middle lines\n    for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n      resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    }\n    // Collect results from last line\n    if (resultLen < limitResultCount) {\n      var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n    }\n    return result;\n  };\n  TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n    var wordSeparators = searchData.wordSeparators;\n    if (!captureMatches && searchData.simpleSearch) {\n      var searchString = searchData.simpleSearch;\n      var searchStringLen = searchString.length;\n      var textLength = text.length;\n      var lastMatchIndex = -searchStringLen;\n      while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n        if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n          result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      }\n      return resultLen;\n    }\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    var m;\n    // Reset regex to search from the beginning\n    searcher.reset(0);\n    do {\n      m = searcher.next(text);\n      if (m) {\n        result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n        if (resultLen >= limitResultCount) {\n          return resultLen;\n        }\n      }\n    } while (m);\n    return resultLen;\n  };\n  TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\n    var searchData = searchParams.parseSearchRequest();\n    if (!searchData) {\n      return null;\n    }\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    if (searchData.regex.multiline) {\n      return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n    return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n  };\n  TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n    var searchTextStart = new Position(searchStart.lineNumber, 1);\n    var deltaOffset = model.getOffsetAt(searchTextStart);\n    var lineCount = model.getLineCount();\n    // We always execute multiline search over the lines joined with \\n\n    // This makes it that \\n will match the EOL for both CRLF and LF models\n    // We compensate for offset errors in `_getMultilineMatchRange`\n    var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\n    var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n    searcher.reset(searchStart.column - 1);\n    var m = searcher.next(text);\n    if (m) {\n      return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n    }\n    if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n      // Try again from the top\n      return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n    }\n    return null;\n  };\n  TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n    var lineCount = model.getLineCount();\n    var startLineNumber = searchStart.lineNumber;\n    // Look in first line\n    var text = model.getLineContent(startLineNumber);\n    var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n    if (r) {\n      return r;\n    }\n    for (var i = 1; i <= lineCount; i++) {\n      var lineIndex = (startLineNumber + i - 1) % lineCount;\n      var text_3 = model.getLineContent(lineIndex + 1);\n      var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\n      if (r_1) {\n        return r_1;\n      }\n    }\n    return null;\n  };\n  TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\n    // Set regex to search from column\n    searcher.reset(fromColumn - 1);\n    var m = searcher.next(text);\n    if (m) {\n      return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n    return null;\n  };\n  TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\n    var searchData = searchParams.parseSearchRequest();\n    if (!searchData) {\n      return null;\n    }\n    var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n    if (searchData.regex.multiline) {\n      return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n    }\n    return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n  };\n  TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\n    var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n    if (matches.length > 0) {\n      return matches[matches.length - 1];\n    }\n    var lineCount = model.getLineCount();\n    if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n      // Try again with all content\n      return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n    }\n    return null;\n  };\n  TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\n    var lineCount = model.getLineCount();\n    var startLineNumber = searchStart.lineNumber;\n    // Look in first line\n    var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n    var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n    if (r) {\n      return r;\n    }\n    for (var i = 1; i <= lineCount; i++) {\n      var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n      var text_4 = model.getLineContent(lineIndex + 1);\n      var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\n      if (r_2) {\n        return r_2;\n      }\n    }\n    return null;\n  };\n  TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\n    var bestResult = null;\n    var m;\n    searcher.reset(0);\n    while (m = searcher.next(text)) {\n      bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n    }\n    return bestResult;\n  };\n  return TextModelSearch;\n}();\nexport { TextModelSearch };\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    // Match starts at start of string\n    return true;\n  }\n  var charBefore = text.charCodeAt(matchStartIndex - 1);\n  if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\n    // The character before the match is a word separator\n    return true;\n  }\n  if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\n    // The character before the match is line break or carriage return.\n    return true;\n  }\n  if (matchLength > 0) {\n    var firstCharInMatch = text.charCodeAt(matchStartIndex);\n    if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\n      // The first character inside the match is a word separator\n      return true;\n    }\n  }\n  return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    // Match ends at end of string\n    return true;\n  }\n  var charAfter = text.charCodeAt(matchStartIndex + matchLength);\n  if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\n    // The character after the match is a word separator\n    return true;\n  }\n  if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\n    // The character after the match is line break or carriage return.\n    return true;\n  }\n  if (matchLength > 0) {\n    var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n    if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\n      // The last character in the match is a word separator\n      return true;\n    }\n  }\n  return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\nvar Searcher = /** @class */function () {\n  function Searcher(wordSeparators, searchRegex) {\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n  Searcher.prototype.reset = function (lastIndex) {\n    this._searchRegex.lastIndex = lastIndex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  };\n  Searcher.prototype.next = function (text) {\n    var textLength = text.length;\n    var m;\n    do {\n      if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n        // Reached the end of the line\n        return null;\n      }\n      m = this._searchRegex.exec(text);\n      if (!m) {\n        return null;\n      }\n      var matchStartIndex = m.index;\n      var matchLength = m[0].length;\n      if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n        if (matchLength === 0) {\n          // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n          // we attempt to recover from that by advancing by one\n          this._searchRegex.lastIndex += 1;\n          continue;\n        }\n        // Exit early if the regex matches the same range twice\n        return null;\n      }\n      this._prevMatchStartIndex = matchStartIndex;\n      this._prevMatchLength = matchLength;\n      if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n        return m;\n      }\n    } while (m);\n    return null;\n  };\n  return Searcher;\n}();\nexport { Searcher };","map":{"version":3,"names":["strings","getMapForWordSeparators","Position","Range","FindMatch","LIMIT_FIND_COUNT","SearchParams","searchString","isRegex","matchCase","wordSeparators","prototype","parseSearchRequest","multiline","isMultilineRegexSource","indexOf","regex","createRegExp","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","length","i","len","chCode","charCodeAt","nextChCode","simpleSearch","createFindMatch","range","rawMatches","captureMatches","matches","LineFeedCounter","text","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","offset","min","max","mid","TextModelSearch","findMatches","model","searchParams","searchRange","limitResultCount","searchData","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","_getMultilineMatchRange","deltaOffset","lfCounter","matchIndex","match0","startOffset","lineFeedCountBeforeMatch","endOffset","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","startPosition","getPositionAt","endPosition","lineNumber","column","searcher","getOffsetAt","getStartPosition","getValueInRange","getEOL","result","counter","m","reset","next","index","resultLen","startLineNumber","endLineNumber","text_1","getLineContent","substring","startColumn","endColumn","_findMatchesInLine","text_2","searchStringLen","textLength","lastMatchIndex","isValidMatch","findNextMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","lineCount","getLineCount","getLineMaxColumn","r","_findFirstMatchInLine","lineIndex","text_3","r_1","fromColumn","findPreviousMatch","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","text_4","r_2","bestResult","leftIsWordBounday","matchStartIndex","matchLength","charBefore","get","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { FindMatch } from '../model.js';\r\nvar LIMIT_FIND_COUNT = 999;\r\nvar SearchParams = /** @class */ (function () {\r\n    function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\r\n        this.searchString = searchString;\r\n        this.isRegex = isRegex;\r\n        this.matchCase = matchCase;\r\n        this.wordSeparators = wordSeparators;\r\n    }\r\n    SearchParams.prototype.parseSearchRequest = function () {\r\n        if (this.searchString === '') {\r\n            return null;\r\n        }\r\n        // Try to create a RegExp out of the params\r\n        var multiline;\r\n        if (this.isRegex) {\r\n            multiline = isMultilineRegexSource(this.searchString);\r\n        }\r\n        else {\r\n            multiline = (this.searchString.indexOf('\\n') >= 0);\r\n        }\r\n        var regex = null;\r\n        try {\r\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\r\n                matchCase: this.matchCase,\r\n                wholeWord: false,\r\n                multiline: multiline,\r\n                global: true,\r\n                unicode: true\r\n            });\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        if (!regex) {\r\n            return null;\r\n        }\r\n        var canUseSimpleSearch = (!this.isRegex && !multiline);\r\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\r\n            // casing might make a difference\r\n            canUseSimpleSearch = this.matchCase;\r\n        }\r\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\r\n    };\r\n    return SearchParams;\r\n}());\r\nexport { SearchParams };\r\nexport function isMultilineRegexSource(searchString) {\r\n    if (!searchString || searchString.length === 0) {\r\n        return false;\r\n    }\r\n    for (var i = 0, len = searchString.length; i < len; i++) {\r\n        var chCode = searchString.charCodeAt(i);\r\n        if (chCode === 92 /* Backslash */) {\r\n            // move to next char\r\n            i++;\r\n            if (i >= len) {\r\n                // string ends with a \\\r\n                break;\r\n            }\r\n            var nextChCode = searchString.charCodeAt(i);\r\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */ || nextChCode === 119 /* w */) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nvar SearchData = /** @class */ (function () {\r\n    function SearchData(regex, wordSeparators, simpleSearch) {\r\n        this.regex = regex;\r\n        this.wordSeparators = wordSeparators;\r\n        this.simpleSearch = simpleSearch;\r\n    }\r\n    return SearchData;\r\n}());\r\nexport { SearchData };\r\nexport function createFindMatch(range, rawMatches, captureMatches) {\r\n    if (!captureMatches) {\r\n        return new FindMatch(range, null);\r\n    }\r\n    var matches = [];\r\n    for (var i = 0, len = rawMatches.length; i < len; i++) {\r\n        matches[i] = rawMatches[i];\r\n    }\r\n    return new FindMatch(range, matches);\r\n}\r\nvar LineFeedCounter = /** @class */ (function () {\r\n    function LineFeedCounter(text) {\r\n        var lineFeedsOffsets = [];\r\n        var lineFeedsOffsetsLen = 0;\r\n        for (var i = 0, textLen = text.length; i < textLen; i++) {\r\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\r\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\r\n            }\r\n        }\r\n        this._lineFeedsOffsets = lineFeedsOffsets;\r\n    }\r\n    LineFeedCounter.prototype.findLineFeedCountBeforeOffset = function (offset) {\r\n        var lineFeedsOffsets = this._lineFeedsOffsets;\r\n        var min = 0;\r\n        var max = lineFeedsOffsets.length - 1;\r\n        if (max === -1) {\r\n            // no line feeds\r\n            return 0;\r\n        }\r\n        if (offset <= lineFeedsOffsets[0]) {\r\n            // before first line feed\r\n            return 0;\r\n        }\r\n        while (min < max) {\r\n            var mid = min + ((max - min) / 2 >> 0);\r\n            if (lineFeedsOffsets[mid] >= offset) {\r\n                max = mid - 1;\r\n            }\r\n            else {\r\n                if (lineFeedsOffsets[mid + 1] >= offset) {\r\n                    // bingo!\r\n                    min = mid;\r\n                    max = mid;\r\n                }\r\n                else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n        }\r\n        return min + 1;\r\n    };\r\n    return LineFeedCounter;\r\n}());\r\nvar TextModelSearch = /** @class */ (function () {\r\n    function TextModelSearch() {\r\n    }\r\n    TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return [];\r\n        }\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\r\n        }\r\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\r\n    };\r\n    /**\r\n     * Multiline search always executes on the lines concatenated with \\n.\r\n     * We must therefore compensate for the count of \\n in case the model is CRLF\r\n     */\r\n    TextModelSearch._getMultilineMatchRange = function (model, deltaOffset, text, lfCounter, matchIndex, match0) {\r\n        var startOffset;\r\n        var lineFeedCountBeforeMatch = 0;\r\n        if (lfCounter) {\r\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\r\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            startOffset = deltaOffset + matchIndex;\r\n        }\r\n        var endOffset;\r\n        if (lfCounter) {\r\n            var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\r\n            var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\r\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            endOffset = startOffset + match0.length;\r\n        }\r\n        var startPosition = model.getPositionAt(startOffset);\r\n        var endPosition = model.getPositionAt(endOffset);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    };\r\n    TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searcher, captureMatches, limitResultCount) {\r\n        var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        var text = model.getValueInRange(searchRange, 1 /* LF */);\r\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        var result = [];\r\n        var counter = 0;\r\n        var m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n            if (counter >= limitResultCount) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchData, captureMatches, limitResultCount) {\r\n        var result = [];\r\n        var resultLen = 0;\r\n        // Early case for a search range that starts & stops on the same line number\r\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\r\n            var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        // Collect results from first line\r\n        var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\r\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n        // Collect results from middle lines\r\n        for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\r\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        // Collect results from last line\r\n        if (resultLen < limitResultCount) {\r\n            var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text_2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        return result;\r\n    };\r\n    TextModelSearch._findMatchesInLine = function (searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        var wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            var searchString = searchData.simpleSearch;\r\n            var searchStringLen = searchString.length;\r\n            var textLength = text.length;\r\n            var lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        var m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    };\r\n    TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    };\r\n    TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searcher, captureMatches) {\r\n        var searchTextStart = new Position(searchStart.lineNumber, 1);\r\n        var deltaOffset = model.getOffsetAt(searchTextStart);\r\n        var lineCount = model.getLineCount();\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\r\n        var lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        searcher.reset(searchStart.column - 1);\r\n        var m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n        }\r\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\r\n            // Try again from the top\r\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\r\n        var lineCount = model.getLineCount();\r\n        var startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        var text = model.getLineContent(startLineNumber);\r\n        var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (var i = 1; i <= lineCount; i++) {\r\n            var lineIndex = (startLineNumber + i - 1) % lineCount;\r\n            var text_3 = model.getLineContent(lineIndex + 1);\r\n            var r_1 = this._findFirstMatchInLine(searcher, text_3, lineIndex + 1, 1, captureMatches);\r\n            if (r_1) {\r\n                return r_1;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._findFirstMatchInLine = function (searcher, text, lineNumber, fromColumn, captureMatches) {\r\n        // Set regex to search from column\r\n        searcher.reset(fromColumn - 1);\r\n        var m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {\r\n        var searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    };\r\n    TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searcher, captureMatches) {\r\n        var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\r\n        if (matches.length > 0) {\r\n            return matches[matches.length - 1];\r\n        }\r\n        var lineCount = model.getLineCount();\r\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\r\n            // Try again with all content\r\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searcher, captureMatches) {\r\n        var lineCount = model.getLineCount();\r\n        var startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\r\n        var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (var i = 1; i <= lineCount; i++) {\r\n            var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\r\n            var text_4 = model.getLineContent(lineIndex + 1);\r\n            var r_2 = this._findLastMatchInLine(searcher, text_4, lineIndex + 1, captureMatches);\r\n            if (r_2) {\r\n                return r_2;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    TextModelSearch._findLastMatchInLine = function (searcher, text, lineNumber, captureMatches) {\r\n        var bestResult = null;\r\n        var m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return bestResult;\r\n    };\r\n    return TextModelSearch;\r\n}());\r\nexport { TextModelSearch };\r\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex === 0) {\r\n        // Match starts at start of string\r\n        return true;\r\n    }\r\n    var charBefore = text.charCodeAt(matchStartIndex - 1);\r\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\r\n        // The character before the match is a word separator\r\n        return true;\r\n    }\r\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\r\n        // The character before the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        var firstCharInMatch = text.charCodeAt(matchStartIndex);\r\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\r\n            // The first character inside the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex + matchLength === textLength) {\r\n        // Match ends at end of string\r\n        return true;\r\n    }\r\n    var charAfter = text.charCodeAt(matchStartIndex + matchLength);\r\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\r\n        // The character after the match is a word separator\r\n        return true;\r\n    }\r\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\r\n        // The character after the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\r\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\r\n            // The last character in the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\r\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\r\n}\r\nvar Searcher = /** @class */ (function () {\r\n    function Searcher(wordSeparators, searchRegex) {\r\n        this._wordSeparators = wordSeparators;\r\n        this._searchRegex = searchRegex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    Searcher.prototype.reset = function (lastIndex) {\r\n        this._searchRegex.lastIndex = lastIndex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    };\r\n    Searcher.prototype.next = function (text) {\r\n        var textLength = text.length;\r\n        var m;\r\n        do {\r\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\r\n                // Reached the end of the line\r\n                return null;\r\n            }\r\n            m = this._searchRegex.exec(text);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            var matchStartIndex = m.index;\r\n            var matchLength = m[0].length;\r\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\r\n                if (matchLength === 0) {\r\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\r\n                    // we attempt to recover from that by advancing by one\r\n                    this._searchRegex.lastIndex += 1;\r\n                    continue;\r\n                }\r\n                // Exit early if the regex matches the same range twice\r\n                return null;\r\n            }\r\n            this._prevMatchStartIndex = matchStartIndex;\r\n            this._prevMatchLength = matchLength;\r\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\r\n                return m;\r\n            }\r\n        } while (m);\r\n        return null;\r\n    };\r\n    return Searcher;\r\n}());\r\nexport { Searcher };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}