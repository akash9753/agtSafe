{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _element = require(\"./../../../helpers/dom/element\");\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * @class Scroll\n */\nvar Scroll = /*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   */\n  function Scroll(wotInstance) {\n    _classCallCheck(this, Scroll);\n    this.wot = wotInstance;\n  }\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords\n   * @param {Boolean} [snapToTop]\n   * @param {Boolean} [snapToRight]\n   * @param {Boolean} [snapToBottom]\n   * @param {Boolean} [snapToLeft]\n   * @returns {Boolean}\n   */\n\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n    /**\n     * Scrolls viewport to a column.\n     *\n     * @param {Number} column Visual column index.\n     * @param {Boolean} [snapToRight]\n     * @param {Boolean} [snapToLeft]\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n      var _this$_getVariables = this._getVariables(),\n        fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft,\n        leftOverlay = _this$_getVariables.leftOverlay,\n        totalColumns = _this$_getVariables.totalColumns;\n      var result = false;\n      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {\n        var firstVisibleColumn = this.getFirstVisibleColumn();\n        var lastVisibleColumn = this.getLastVisibleColumn();\n        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {\n          result = leftOverlay.scrollTo(column);\n        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {\n          result = leftOverlay.scrollTo(column, true);\n        }\n      }\n      return result;\n    }\n    /**\n     * Scrolls viewport to a row.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Boolean} [snapToTop]\n     * @param {Boolean} [snapToBottom]\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n      var _this$_getVariables2 = this._getVariables(),\n        fixedRowsBottom = _this$_getVariables2.fixedRowsBottom,\n        fixedRowsTop = _this$_getVariables2.fixedRowsTop,\n        topOverlay = _this$_getVariables2.topOverlay,\n        totalRows = _this$_getVariables2.totalRows;\n      var result = false;\n      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {\n        var firstVisibleRow = this.getFirstVisibleRow();\n        var lastVisibleRow = this.getLastVisibleRow();\n        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {\n          result = topOverlay.scrollTo(row);\n        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {\n          result = topOverlay.scrollTo(row, true);\n        }\n      }\n      return result;\n    }\n    /**\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$_getVariables3 = this._getVariables(),\n        topOverlay = _this$_getVariables3.topOverlay,\n        wtTable = _this$_getVariables3.wtTable,\n        wtViewport = _this$_getVariables3.wtViewport,\n        totalRows = _this$_getVariables3.totalRows,\n        fixedRowsTop = _this$_getVariables3.fixedRowsTop;\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var totalTableHeight = (0, _element.innerHeight)(wtTable.hider);\n        var windowHeight = (0, _element.innerHeight)(rootWindow);\n        var windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleRow;\n    }\n    /**\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$_getVariables4 = this._getVariables(),\n        topOverlay = _this$_getVariables4.topOverlay,\n        wtTable = _this$_getVariables4.wtTable,\n        wtViewport = _this$_getVariables4.wtViewport,\n        totalRows = _this$_getVariables4.totalRows;\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = (0, _element.innerHeight)(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleRow;\n    }\n    /**\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$_getVariables5 = this._getVariables(),\n        leftOverlay = _this$_getVariables5.leftOverlay,\n        wtTable = _this$_getVariables5.wtTable,\n        wtViewport = _this$_getVariables5.wtViewport,\n        totalColumns = _this$_getVariables5.totalColumns;\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var totalTableWidth = (0, _element.innerWidth)(wtTable.hider);\n        var windowWidth = (0, _element.innerWidth)(rootWindow);\n        var windowScrollLeft = (0, _element.getScrollLeft)(rootWindow, rootWindow); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleColumn;\n    }\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$_getVariables6 = this._getVariables(),\n        leftOverlay = _this$_getVariables6.leftOverlay,\n        wtTable = _this$_getVariables6.wtTable,\n        wtViewport = _this$_getVariables6.wtViewport,\n        totalColumns = _this$_getVariables6.totalColumns;\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var windowScrollLeft = (0, _element.getScrollLeft)(rootWindow, rootWindow); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = (0, _element.innerWidth)(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleColumn;\n    }\n    /**\n     * Returns collection of variables used to rows and columns visibility calculations.\n     *\n     * @returns {Object}\n     * @private\n     */\n  }, {\n    key: \"_getVariables\",\n    value: function _getVariables() {\n      var wot = this.wot;\n      var topOverlay = wot.wtOverlays.topOverlay;\n      var leftOverlay = wot.wtOverlays.leftOverlay;\n      var wtTable = wot.wtTable;\n      var wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n      return {\n        topOverlay: topOverlay,\n        leftOverlay: leftOverlay,\n        wtTable: wtTable,\n        wtViewport: wtViewport,\n        totalRows: totalRows,\n        totalColumns: totalColumns,\n        fixedRowsTop: fixedRowsTop,\n        fixedRowsBottom: fixedRowsBottom,\n        fixedColumnsLeft: fixedColumnsLeft\n      };\n    }\n  }]);\n  return Scroll;\n}();\nvar _default = Scroll;\nexports.default = _default;","map":{"version":3,"names":["exports","__esModule","default","_element","require","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Scroll","wotInstance","wot","value","scrollViewport","coords","snapToTop","snapToRight","snapToBottom","snapToLeft","col","row","scrolledHorizontally","scrollViewportHorizontally","scrolledVertically","scrollViewportVertically","column","drawn","_this$_getVariables","_getVariables","fixedColumnsLeft","leftOverlay","totalColumns","result","Math","max","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","scrollTo","_this$_getVariables2","fixedRowsBottom","fixedRowsTop","topOverlay","totalRows","firstVisibleRow","getFirstVisibleRow","lastVisibleRow","getLastVisibleRow","_this$_getVariables3","wtTable","wtViewport","rootWindow","mainTableScrollableElement","rootElementOffset","offset","wtRootElement","totalTableHeight","innerHeight","hider","windowHeight","windowScrollTop","getScrollTop","top","rowsHeight","getColumnHeaderHeight","sumCellSizes","_this$_getVariables4","_this$_getVariables5","totalTableWidth","innerWidth","windowWidth","windowScrollLeft","getScrollLeft","left","columnsWidth","getRowHeaderWidth","_this$_getVariables6","wtOverlays","getSetting","_default"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/handsontable/commonjs/3rdparty/walkontable/src/scroll.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _element = require(\"./../../../helpers/dom/element\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @class Scroll\n */\nvar Scroll =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Walkontable} wotInstance\n   */\n  function Scroll(wotInstance) {\n    _classCallCheck(this, Scroll);\n\n    this.wot = wotInstance;\n  }\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords\n   * @param {Boolean} [snapToTop]\n   * @param {Boolean} [snapToRight]\n   * @param {Boolean} [snapToBottom]\n   * @param {Boolean} [snapToLeft]\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n    /**\n     * Scrolls viewport to a column.\n     *\n     * @param {Number} column Visual column index.\n     * @param {Boolean} [snapToRight]\n     * @param {Boolean} [snapToLeft]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n\n      var _this$_getVariables = this._getVariables(),\n          fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft,\n          leftOverlay = _this$_getVariables.leftOverlay,\n          totalColumns = _this$_getVariables.totalColumns;\n\n      var result = false;\n\n      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {\n        var firstVisibleColumn = this.getFirstVisibleColumn();\n        var lastVisibleColumn = this.getLastVisibleColumn();\n\n        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {\n          result = leftOverlay.scrollTo(column);\n        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {\n          result = leftOverlay.scrollTo(column, true);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Scrolls viewport to a row.\n     *\n     * @param {Number} row Visual row index.\n     * @param {Boolean} [snapToTop]\n     * @param {Boolean} [snapToBottom]\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n\n      var _this$_getVariables2 = this._getVariables(),\n          fixedRowsBottom = _this$_getVariables2.fixedRowsBottom,\n          fixedRowsTop = _this$_getVariables2.fixedRowsTop,\n          topOverlay = _this$_getVariables2.topOverlay,\n          totalRows = _this$_getVariables2.totalRows;\n\n      var result = false;\n\n      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {\n        var firstVisibleRow = this.getFirstVisibleRow();\n        var lastVisibleRow = this.getLastVisibleRow();\n\n        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {\n          result = topOverlay.scrollTo(row);\n        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {\n          result = topOverlay.scrollTo(row, true);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$_getVariables3 = this._getVariables(),\n          topOverlay = _this$_getVariables3.topOverlay,\n          wtTable = _this$_getVariables3.wtTable,\n          wtViewport = _this$_getVariables3.wtViewport,\n          totalRows = _this$_getVariables3.totalRows,\n          fixedRowsTop = _this$_getVariables3.fixedRowsTop;\n\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var totalTableHeight = (0, _element.innerHeight)(wtTable.hider);\n        var windowHeight = (0, _element.innerHeight)(rootWindow);\n        var windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n\n      return firstVisibleRow;\n    }\n    /**\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$_getVariables4 = this._getVariables(),\n          topOverlay = _this$_getVariables4.topOverlay,\n          wtTable = _this$_getVariables4.wtTable,\n          wtViewport = _this$_getVariables4.wtViewport,\n          totalRows = _this$_getVariables4.totalRows;\n\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = (0, _element.innerHeight)(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n\n      return lastVisibleRow;\n    }\n    /**\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$_getVariables5 = this._getVariables(),\n          leftOverlay = _this$_getVariables5.leftOverlay,\n          wtTable = _this$_getVariables5.wtTable,\n          wtViewport = _this$_getVariables5.wtViewport,\n          totalColumns = _this$_getVariables5.totalColumns;\n\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var totalTableWidth = (0, _element.innerWidth)(wtTable.hider);\n        var windowWidth = (0, _element.innerWidth)(rootWindow);\n        var windowScrollLeft = (0, _element.getScrollLeft)(rootWindow, rootWindow); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n\n      return firstVisibleColumn;\n    }\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {Number}\n     */\n\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$_getVariables6 = this._getVariables(),\n          leftOverlay = _this$_getVariables6.leftOverlay,\n          wtTable = _this$_getVariables6.wtTable,\n          wtViewport = _this$_getVariables6.wtViewport,\n          totalColumns = _this$_getVariables6.totalColumns;\n\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);\n        var windowScrollLeft = (0, _element.getScrollLeft)(rootWindow, rootWindow); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = (0, _element.innerWidth)(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n\n      return lastVisibleColumn;\n    }\n    /**\n     * Returns collection of variables used to rows and columns visibility calculations.\n     *\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"_getVariables\",\n    value: function _getVariables() {\n      var wot = this.wot;\n      var topOverlay = wot.wtOverlays.topOverlay;\n      var leftOverlay = wot.wtOverlays.leftOverlay;\n      var wtTable = wot.wtTable;\n      var wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n      return {\n        topOverlay: topOverlay,\n        leftOverlay: leftOverlay,\n        wtTable: wtTable,\n        wtViewport: wtViewport,\n        totalRows: totalRows,\n        totalColumns: totalColumns,\n        fixedRowsTop: fixedRowsTop,\n        fixedRowsBottom: fixedRowsBottom,\n        fixedColumnsLeft: fixedColumnsLeft\n      };\n    }\n  }]);\n\n  return Scroll;\n}();\n\nvar _default = Scroll;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}