{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\nfunction createWordRegExp(allowInWords) {\n  if (allowInWords === void 0) {\n    allowInWords = '';\n  }\n  var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n  for (var _i = 0, USUAL_WORD_SEPARATORS_1 = USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {\n    var sep = USUAL_WORD_SEPARATORS_1[_i];\n    if (allowInWords.indexOf(sep) >= 0) {\n      continue;\n    }\n    source += '\\\\' + sep;\n  }\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  var result = DEFAULT_WORD_REGEXP;\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      var flags = 'g';\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n  result.lastIndex = 0;\n  return result;\n}\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\n  // find whitespace enclosed text around column and match from there\n  var pos = column - 1 - textOffset;\n  var start = text.lastIndexOf(' ', pos - 1) + 1;\n  wordDefinition.lastIndex = start;\n  var match;\n  while (match = wordDefinition.exec(text)) {\n    var matchIndex = match.index || 0;\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return {\n        word: match[0],\n        startColumn: textOffset + 1 + matchIndex,\n        endColumn: textOffset + 1 + wordDefinition.lastIndex\n      };\n    }\n  }\n  return null;\n}\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\n  // matches all words starting at the beginning\n  // of the input until it finds a match that encloses\n  // the desired column. slow but correct\n  var pos = column - 1 - textOffset;\n  wordDefinition.lastIndex = 0;\n  var match;\n  while (match = wordDefinition.exec(text)) {\n    var matchIndex = match.index || 0;\n    if (matchIndex > pos) {\n      // |nW -> matched only after the pos\n      return null;\n    } else if (wordDefinition.lastIndex >= pos) {\n      // W|W -> match encloses pos\n      return {\n        word: match[0],\n        startColumn: textOffset + 1 + matchIndex,\n        endColumn: textOffset + 1 + wordDefinition.lastIndex\n      };\n    }\n  }\n  return null;\n}\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\n  // if `words` can contain whitespace character we have to use the slow variant\n  // otherwise we use the fast variant of finding a word\n  wordDefinition.lastIndex = 0;\n  var match = wordDefinition.exec(text);\n  if (!match) {\n    return null;\n  }\n  // todo@joh the `match` could already be the (first) word\n  var ret = match[0].indexOf(' ') >= 0\n  // did match a word which contains a space character -> use slow word find\n  ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\n  // sane word definition -> use fast word find\n  : getWordAtPosFast(column, wordDefinition, text, textOffset);\n  // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\n  // in an undefined state and to not confuse other users of the wordDefinition\n  // we reset the lastIndex\n  wordDefinition.lastIndex = 0;\n  return ret;\n}","map":{"version":3,"names":["USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","source","_i","USUAL_WORD_SEPARATORS_1","length","sep","indexOf","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","getWordAtPosFast","column","text","textOffset","pos","start","lastIndexOf","match","exec","matchIndex","index","word","startColumn","endColumn","getWordAtPosSlow","getWordAtText","ret"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords) {\r\n    if (allowInWords === void 0) { allowInWords = ''; }\r\n    var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (var _i = 0, USUAL_WORD_SEPARATORS_1 = USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {\r\n        var sep = USUAL_WORD_SEPARATORS_1[_i];\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\r\nexport function ensureValidWordDefinition(wordDefinition) {\r\n    var result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            var flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nfunction getWordAtPosFast(column, wordDefinition, text, textOffset) {\r\n    // find whitespace enclosed text around column and match from there\r\n    var pos = column - 1 - textOffset;\r\n    var start = text.lastIndexOf(' ', pos - 1) + 1;\r\n    wordDefinition.lastIndex = start;\r\n    var match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        var matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return {\r\n                word: match[0],\r\n                startColumn: textOffset + 1 + matchIndex,\r\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getWordAtPosSlow(column, wordDefinition, text, textOffset) {\r\n    // matches all words starting at the beginning\r\n    // of the input until it finds a match that encloses\r\n    // the desired column. slow but correct\r\n    var pos = column - 1 - textOffset;\r\n    wordDefinition.lastIndex = 0;\r\n    var match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        var matchIndex = match.index || 0;\r\n        if (matchIndex > pos) {\r\n            // |nW -> matched only after the pos\r\n            return null;\r\n        }\r\n        else if (wordDefinition.lastIndex >= pos) {\r\n            // W|W -> match encloses pos\r\n            return {\r\n                word: match[0],\r\n                startColumn: textOffset + 1 + matchIndex,\r\n                endColumn: textOffset + 1 + wordDefinition.lastIndex\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\r\n    // if `words` can contain whitespace character we have to use the slow variant\r\n    // otherwise we use the fast variant of finding a word\r\n    wordDefinition.lastIndex = 0;\r\n    var match = wordDefinition.exec(text);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    // todo@joh the `match` could already be the (first) word\r\n    var ret = match[0].indexOf(' ') >= 0\r\n        // did match a word which contains a space character -> use slow word find\r\n        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)\r\n        // sane word definition -> use fast word find\r\n        : getWordAtPosFast(column, wordDefinition, text, textOffset);\r\n    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp\r\n    // in an undefined state and to not confuse other users of the wordDefinition\r\n    // we reset the lastIndex\r\n    wordDefinition.lastIndex = 0;\r\n    return ret;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}