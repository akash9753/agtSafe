{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineBreakData } from './splitLinesCollection.js';\nvar WrappingCharacterClassifier = /** @class */function (_super) {\n  __extends(WrappingCharacterClassifier, _super);\n  function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER) {\n    var _this = _super.call(this, 0 /* NONE */) || this;\n    for (var i = 0; i < BREAK_BEFORE.length; i++) {\n      _this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\n    }\n\n    for (var i = 0; i < BREAK_AFTER.length; i++) {\n      _this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\n    }\n\n    return _this;\n  }\n  WrappingCharacterClassifier.prototype.get = function (charCode) {\n    if (charCode >= 0 && charCode < 256) {\n      return this._asciiMap[charCode];\n    } else {\n      // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n      // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n      // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n      // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n      if (charCode >= 0x3040 && charCode <= 0x30FF || charCode >= 0x3400 && charCode <= 0x4DBF || charCode >= 0x4E00 && charCode <= 0x9FFF) {\n        return 3 /* BREAK_IDEOGRAPHIC */;\n      }\n\n      return this._map.get(charCode) || this._defaultValue;\n    }\n  };\n  return WrappingCharacterClassifier;\n}(CharacterClassifier);\nvar arrPool1 = [];\nvar arrPool2 = [];\nvar MonospaceLineBreaksComputerFactory = /** @class */function () {\n  function MonospaceLineBreaksComputerFactory(breakBeforeChars, breakAfterChars) {\n    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n  }\n  MonospaceLineBreaksComputerFactory.create = function (options) {\n    return new MonospaceLineBreaksComputerFactory(options.get(99 /* wordWrapBreakBeforeCharacters */), options.get(98 /* wordWrapBreakAfterCharacters */));\n  };\n\n  MonospaceLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    var _this = this;\n    tabSize = tabSize | 0; //@perf\n    wrappingColumn = +wrappingColumn; //@perf\n    var requests = [];\n    var previousBreakingData = [];\n    return {\n      addRequest: function addRequest(lineText, previousLineBreakData) {\n        requests.push(lineText);\n        previousBreakingData.push(previousLineBreakData);\n      },\n      finalize: function finalize() {\n        var columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth; //@perf\n        var result = [];\n        for (var i = 0, len = requests.length; i < len; i++) {\n          var previousLineBreakData = previousBreakingData[i];\n          if (previousLineBreakData) {\n            result[i] = createLineBreaksFromPreviousLineBreaks(_this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n          } else {\n            result[i] = createLineBreaks(_this.classifier, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n          }\n        }\n        arrPool1.length = 0;\n        arrPool2.length = 0;\n        return result;\n      }\n    };\n  };\n  return MonospaceLineBreaksComputerFactory;\n}();\nexport { MonospaceLineBreaksComputerFactory };\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n  var len = lineText.length;\n  if (len <= 1) {\n    return null;\n  }\n  var prevBreakingOffsets = previousBreakingData.breakOffsets;\n  var prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n  var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  var breakingOffsets = arrPool1;\n  var breakingOffsetsVisibleColumn = arrPool2;\n  var breakingOffsetsCount = 0;\n  var breakingColumn = firstLineBreakColumn;\n  var prevLen = prevBreakingOffsets.length;\n  var prevIndex = 0;\n  if (prevIndex >= 0) {\n    var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n    while (prevIndex + 1 < prevLen) {\n      var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n      if (distance >= bestDistance) {\n        break;\n      }\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n  while (prevIndex < prevLen) {\n    // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n    var prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n    var prevBreakoffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n    var breakOffset = 0;\n    var breakOffsetVisibleColumn = 0;\n    var forcedBreakOffset = 0;\n    var forcedBreakOffsetVisibleColumn = 0;\n    // initially, we search as much as possible to the right (if it fits)\n    if (prevBreakoffsetVisibleColumn <= breakingColumn) {\n      var visibleColumn = prevBreakoffsetVisibleColumn;\n      var prevCharCode = lineText.charCodeAt(prevBreakOffset - 1);\n      var prevCharCodeClass = classifier.get(prevCharCode);\n      var entireLineFits = true;\n      for (var i = prevBreakOffset; i < len; i++) {\n        var charStartOffset = i;\n        var charCode = lineText.charCodeAt(i);\n        var charCodeClass = void 0;\n        var charWidth = void 0;\n        if (strings.isHighSurrogate(charCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i++;\n          charCodeClass = 0 /* NONE */;\n          charWidth = 2;\n        } else {\n          charCodeClass = classifier.get(charCode);\n          charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n          breakOffset = charStartOffset;\n          breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n          // We need to break at least before character at `i`:\n          forcedBreakOffset = charStartOffset;\n          forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n          if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n            // Cannot break at `breakOffset` => reset it if it was set\n            breakOffset = 0;\n          }\n          entireLineFits = false;\n          break;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n      }\n      if (entireLineFits) {\n        // there is no more need to break => stop the outer loop!\n        if (breakingOffsetsCount > 0) {\n          // Add last segment\n          breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n          breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n          breakingOffsetsCount++;\n        }\n        break;\n      }\n    }\n    if (breakOffset === 0) {\n      // must search left\n      var visibleColumn = prevBreakoffsetVisibleColumn;\n      var charCode = lineText.charCodeAt(prevBreakOffset);\n      var charCodeClass = classifier.get(charCode);\n      var hitATabCharacter = false;\n      for (var i = prevBreakOffset - 1; i >= 0; i--) {\n        var charStartOffset = i + 1;\n        var prevCharCode = lineText.charCodeAt(i);\n        if (prevCharCode === 9 /* Tab */) {\n          // cannot determine the width of a tab when going backwards, so we must go forwards\n          hitATabCharacter = true;\n          break;\n        }\n        var prevCharCodeClass = void 0;\n        var prevCharWidth = void 0;\n        if (strings.isLowSurrogate(prevCharCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i--;\n          prevCharCodeClass = 0 /* NONE */;\n          prevCharWidth = 2;\n        } else {\n          prevCharCodeClass = classifier.get(prevCharCode);\n          prevCharWidth = strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1;\n        }\n        if (visibleColumn <= breakingColumn) {\n          if (forcedBreakOffset === 0) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n          if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n            // went too far!\n            break;\n          }\n          if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n            break;\n          }\n        }\n        visibleColumn -= prevCharWidth;\n        charCode = prevCharCode;\n        charCodeClass = prevCharCodeClass;\n      }\n      if (breakOffset !== 0) {\n        var remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n        if (remainingWidthOfNextLine <= tabSize) {\n          var charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n          var charWidth = void 0;\n          if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            charWidth = 2;\n          } else {\n            charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n          }\n          if (remainingWidthOfNextLine - charWidth < 0) {\n            // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n            breakOffset = 0;\n          }\n        }\n      }\n      if (hitATabCharacter) {\n        // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n        prevIndex--;\n        continue;\n      }\n    }\n    if (breakOffset === 0) {\n      // Could not find a good breaking point\n      breakOffset = forcedBreakOffset;\n      breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n    }\n    breakingOffsets[breakingOffsetsCount] = breakOffset;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n    breakingOffsetsCount++;\n    breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n    while (prevIndex < 0 || prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn) {\n      prevIndex++;\n    }\n    var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n    while (prevIndex + 1 < prevLen) {\n      var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n      if (distance >= bestDistance) {\n        break;\n      }\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n  if (breakingOffsetsCount === 0) {\n    return null;\n  }\n  // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n  breakingOffsets.length = breakingOffsetsCount;\n  breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n  arrPool1 = previousBreakingData.breakOffsets;\n  arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n  previousBreakingData.breakOffsets = breakingOffsets;\n  previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n  previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n  return previousBreakingData;\n}\nfunction createLineBreaks(classifier, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n  var len = lineText.length;\n  if (len <= 1) {\n    return null;\n  }\n  var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  var breakingOffsets = [];\n  var breakingOffsetsVisibleColumn = [];\n  var breakingOffsetsCount = 0;\n  var breakOffset = 0;\n  var breakOffsetVisibleColumn = 0;\n  var breakingColumn = firstLineBreakColumn;\n  var prevCharCode = lineText.charCodeAt(0);\n  var prevCharCodeClass = classifier.get(prevCharCode);\n  var visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n  var startOffset = 1;\n  if (strings.isHighSurrogate(prevCharCode)) {\n    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n    visibleColumn += 1;\n    prevCharCode = lineText.charCodeAt(1);\n    prevCharCodeClass = classifier.get(prevCharCode);\n    startOffset++;\n  }\n  for (var i = startOffset; i < len; i++) {\n    var charStartOffset = i;\n    var charCode = lineText.charCodeAt(i);\n    var charCodeClass = void 0;\n    var charWidth = void 0;\n    if (strings.isHighSurrogate(charCode)) {\n      // A surrogate pair must always be considered as a single unit, so it is never to be broken\n      i++;\n      charCodeClass = 0 /* NONE */;\n      charWidth = 2;\n    } else {\n      charCodeClass = classifier.get(charCode);\n      charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n    }\n    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n      breakOffset = charStartOffset;\n      breakOffsetVisibleColumn = visibleColumn;\n    }\n    visibleColumn += charWidth;\n    // check if adding character at `i` will go over the breaking column\n    if (visibleColumn > breakingColumn) {\n      // We need to break at least before character at `i`:\n      if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n        // Cannot break at `breakOffset`, must break at `i`\n        breakOffset = charStartOffset;\n        breakOffsetVisibleColumn = visibleColumn - charWidth;\n      }\n      breakingOffsets[breakingOffsetsCount] = breakOffset;\n      breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n      breakingOffsetsCount++;\n      breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n      breakOffset = 0;\n    }\n    prevCharCode = charCode;\n    prevCharCodeClass = charCodeClass;\n  }\n  if (breakingOffsetsCount === 0) {\n    return null;\n  }\n  // Add last segment\n  breakingOffsets[breakingOffsetsCount] = len;\n  breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n  return new LineBreakData(breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n  if (charCode === 9 /* Tab */) {\n    return tabSize - visibleColumn % tabSize;\n  }\n  if (strings.isFullWidthCharacter(charCode)) {\n    return columnsForFullWidthChar;\n  }\n  return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n  return tabSize - visibleColumn % tabSize;\n}\n/**\r\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\r\n * Kinsoku Shori : Don't break before a trailing character, like a period\r\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n  return charCode !== 32 /* Space */ && (prevCharCodeClass === 2 /* BREAK_AFTER */ || prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */ || charCodeClass === 1 /* BREAK_BEFORE */ || charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */);\n}\n\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  var wrappedTextIndentLength = 0;\n  if (wrappingIndent !== 0 /* None */) {\n    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n    if (firstNonWhitespaceIndex !== -1) {\n      // Track existing indent\n      for (var i = 0; i < firstNonWhitespaceIndex; i++) {\n        var charWidth = lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1;\n        wrappedTextIndentLength += charWidth;\n      }\n      // Increase indent of continuation lines, if desired\n      var numberOfAdditionalTabs = wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0;\n      for (var i = 0; i < numberOfAdditionalTabs; i++) {\n        var charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n        wrappedTextIndentLength += charWidth;\n      }\n      // Force sticking to beginning of line if no character would fit except for the indentation\n      if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n        wrappedTextIndentLength = 0;\n      }\n    }\n  }\n  return wrappedTextIndentLength;\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","strings","CharacterClassifier","LineBreakData","WrappingCharacterClassifier","_super","BREAK_BEFORE","BREAK_AFTER","_this","call","i","length","set","charCodeAt","get","charCode","_asciiMap","_map","_defaultValue","arrPool1","arrPool2","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","options","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","previousBreakingData","addRequest","lineText","previousLineBreakData","push","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","result","len","createLineBreaksFromPreviousLineBreaks","createLineBreaks","firstLineBreakColumn","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","breakingColumn","prevLen","prevIndex","bestDistance","Math","abs","distance","prevBreakOffset","prevBreakoffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","visibleColumn","prevCharCode","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","charWidth","isHighSurrogate","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","isLowSurrogate","isFullWidthCharacter","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","startOffset","tabCharacterWidth","firstNonWhitespaceIndex","numberOfAdditionalTabs"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CharacterClassifier } from '../core/characterClassifier.js';\r\nimport { LineBreakData } from './splitLinesCollection.js';\r\nvar WrappingCharacterClassifier = /** @class */ (function (_super) {\r\n    __extends(WrappingCharacterClassifier, _super);\r\n    function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER) {\r\n        var _this = _super.call(this, 0 /* NONE */) || this;\r\n        for (var i = 0; i < BREAK_BEFORE.length; i++) {\r\n            _this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\r\n        }\r\n        for (var i = 0; i < BREAK_AFTER.length; i++) {\r\n            _this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\r\n        }\r\n        return _this;\r\n    }\r\n    WrappingCharacterClassifier.prototype.get = function (charCode) {\r\n        if (charCode >= 0 && charCode < 256) {\r\n            return this._asciiMap[charCode];\r\n        }\r\n        else {\r\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\r\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\r\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\r\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\r\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\r\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\r\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\r\n                return 3 /* BREAK_IDEOGRAPHIC */;\r\n            }\r\n            return (this._map.get(charCode) || this._defaultValue);\r\n        }\r\n    };\r\n    return WrappingCharacterClassifier;\r\n}(CharacterClassifier));\r\nvar arrPool1 = [];\r\nvar arrPool2 = [];\r\nvar MonospaceLineBreaksComputerFactory = /** @class */ (function () {\r\n    function MonospaceLineBreaksComputerFactory(breakBeforeChars, breakAfterChars) {\r\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\r\n    }\r\n    MonospaceLineBreaksComputerFactory.create = function (options) {\r\n        return new MonospaceLineBreaksComputerFactory(options.get(99 /* wordWrapBreakBeforeCharacters */), options.get(98 /* wordWrapBreakAfterCharacters */));\r\n    };\r\n    MonospaceLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\r\n        var _this = this;\r\n        tabSize = tabSize | 0; //@perf\r\n        wrappingColumn = +wrappingColumn; //@perf\r\n        var requests = [];\r\n        var previousBreakingData = [];\r\n        return {\r\n            addRequest: function (lineText, previousLineBreakData) {\r\n                requests.push(lineText);\r\n                previousBreakingData.push(previousLineBreakData);\r\n            },\r\n            finalize: function () {\r\n                var columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth; //@perf\r\n                var result = [];\r\n                for (var i = 0, len = requests.length; i < len; i++) {\r\n                    var previousLineBreakData = previousBreakingData[i];\r\n                    if (previousLineBreakData) {\r\n                        result[i] = createLineBreaksFromPreviousLineBreaks(_this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\r\n                    }\r\n                    else {\r\n                        result[i] = createLineBreaks(_this.classifier, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\r\n                    }\r\n                }\r\n                arrPool1.length = 0;\r\n                arrPool2.length = 0;\r\n                return result;\r\n            }\r\n        };\r\n    };\r\n    return MonospaceLineBreaksComputerFactory;\r\n}());\r\nexport { MonospaceLineBreaksComputerFactory };\r\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\r\n    if (firstLineBreakColumn === -1) {\r\n        return null;\r\n    }\r\n    var len = lineText.length;\r\n    if (len <= 1) {\r\n        return null;\r\n    }\r\n    var prevBreakingOffsets = previousBreakingData.breakOffsets;\r\n    var prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\r\n    var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\r\n    var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\r\n    var breakingOffsets = arrPool1;\r\n    var breakingOffsetsVisibleColumn = arrPool2;\r\n    var breakingOffsetsCount = 0;\r\n    var breakingColumn = firstLineBreakColumn;\r\n    var prevLen = prevBreakingOffsets.length;\r\n    var prevIndex = 0;\r\n    if (prevIndex >= 0) {\r\n        var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\r\n        while (prevIndex + 1 < prevLen) {\r\n            var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\r\n            if (distance >= bestDistance) {\r\n                break;\r\n            }\r\n            bestDistance = distance;\r\n            prevIndex++;\r\n        }\r\n    }\r\n    while (prevIndex < prevLen) {\r\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\r\n        var prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\r\n        var prevBreakoffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\r\n        var breakOffset = 0;\r\n        var breakOffsetVisibleColumn = 0;\r\n        var forcedBreakOffset = 0;\r\n        var forcedBreakOffsetVisibleColumn = 0;\r\n        // initially, we search as much as possible to the right (if it fits)\r\n        if (prevBreakoffsetVisibleColumn <= breakingColumn) {\r\n            var visibleColumn = prevBreakoffsetVisibleColumn;\r\n            var prevCharCode = lineText.charCodeAt(prevBreakOffset - 1);\r\n            var prevCharCodeClass = classifier.get(prevCharCode);\r\n            var entireLineFits = true;\r\n            for (var i = prevBreakOffset; i < len; i++) {\r\n                var charStartOffset = i;\r\n                var charCode = lineText.charCodeAt(i);\r\n                var charCodeClass = void 0;\r\n                var charWidth = void 0;\r\n                if (strings.isHighSurrogate(charCode)) {\r\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n                    i++;\r\n                    charCodeClass = 0 /* NONE */;\r\n                    charWidth = 2;\r\n                }\r\n                else {\r\n                    charCodeClass = classifier.get(charCode);\r\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\r\n                }\r\n                if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\r\n                    breakOffset = charStartOffset;\r\n                    breakOffsetVisibleColumn = visibleColumn;\r\n                }\r\n                visibleColumn += charWidth;\r\n                // check if adding character at `i` will go over the breaking column\r\n                if (visibleColumn > breakingColumn) {\r\n                    // We need to break at least before character at `i`:\r\n                    forcedBreakOffset = charStartOffset;\r\n                    forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\r\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\r\n                        // Cannot break at `breakOffset` => reset it if it was set\r\n                        breakOffset = 0;\r\n                    }\r\n                    entireLineFits = false;\r\n                    break;\r\n                }\r\n                prevCharCode = charCode;\r\n                prevCharCodeClass = charCodeClass;\r\n            }\r\n            if (entireLineFits) {\r\n                // there is no more need to break => stop the outer loop!\r\n                if (breakingOffsetsCount > 0) {\r\n                    // Add last segment\r\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\r\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\r\n                    breakingOffsetsCount++;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (breakOffset === 0) {\r\n            // must search left\r\n            var visibleColumn = prevBreakoffsetVisibleColumn;\r\n            var charCode = lineText.charCodeAt(prevBreakOffset);\r\n            var charCodeClass = classifier.get(charCode);\r\n            var hitATabCharacter = false;\r\n            for (var i = prevBreakOffset - 1; i >= 0; i--) {\r\n                var charStartOffset = i + 1;\r\n                var prevCharCode = lineText.charCodeAt(i);\r\n                if (prevCharCode === 9 /* Tab */) {\r\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\r\n                    hitATabCharacter = true;\r\n                    break;\r\n                }\r\n                var prevCharCodeClass = void 0;\r\n                var prevCharWidth = void 0;\r\n                if (strings.isLowSurrogate(prevCharCode)) {\r\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n                    i--;\r\n                    prevCharCodeClass = 0 /* NONE */;\r\n                    prevCharWidth = 2;\r\n                }\r\n                else {\r\n                    prevCharCodeClass = classifier.get(prevCharCode);\r\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\r\n                }\r\n                if (visibleColumn <= breakingColumn) {\r\n                    if (forcedBreakOffset === 0) {\r\n                        forcedBreakOffset = charStartOffset;\r\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\r\n                    }\r\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\r\n                        // went too far!\r\n                        break;\r\n                    }\r\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\r\n                        breakOffset = charStartOffset;\r\n                        breakOffsetVisibleColumn = visibleColumn;\r\n                        break;\r\n                    }\r\n                }\r\n                visibleColumn -= prevCharWidth;\r\n                charCode = prevCharCode;\r\n                charCodeClass = prevCharCodeClass;\r\n            }\r\n            if (breakOffset !== 0) {\r\n                var remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\r\n                if (remainingWidthOfNextLine <= tabSize) {\r\n                    var charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\r\n                    var charWidth = void 0;\r\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\r\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n                        charWidth = 2;\r\n                    }\r\n                    else {\r\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\r\n                    }\r\n                    if (remainingWidthOfNextLine - charWidth < 0) {\r\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\r\n                        breakOffset = 0;\r\n                    }\r\n                }\r\n            }\r\n            if (hitATabCharacter) {\r\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\r\n                prevIndex--;\r\n                continue;\r\n            }\r\n        }\r\n        if (breakOffset === 0) {\r\n            // Could not find a good breaking point\r\n            breakOffset = forcedBreakOffset;\r\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\r\n        }\r\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\r\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\r\n        breakingOffsetsCount++;\r\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\r\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\r\n            prevIndex++;\r\n        }\r\n        var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\r\n        while (prevIndex + 1 < prevLen) {\r\n            var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\r\n            if (distance >= bestDistance) {\r\n                break;\r\n            }\r\n            bestDistance = distance;\r\n            prevIndex++;\r\n        }\r\n    }\r\n    if (breakingOffsetsCount === 0) {\r\n        return null;\r\n    }\r\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\r\n    breakingOffsets.length = breakingOffsetsCount;\r\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\r\n    arrPool1 = previousBreakingData.breakOffsets;\r\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\r\n    previousBreakingData.breakOffsets = breakingOffsets;\r\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\r\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\r\n    return previousBreakingData;\r\n}\r\nfunction createLineBreaks(classifier, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\r\n    if (firstLineBreakColumn === -1) {\r\n        return null;\r\n    }\r\n    var len = lineText.length;\r\n    if (len <= 1) {\r\n        return null;\r\n    }\r\n    var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\r\n    var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\r\n    var breakingOffsets = [];\r\n    var breakingOffsetsVisibleColumn = [];\r\n    var breakingOffsetsCount = 0;\r\n    var breakOffset = 0;\r\n    var breakOffsetVisibleColumn = 0;\r\n    var breakingColumn = firstLineBreakColumn;\r\n    var prevCharCode = lineText.charCodeAt(0);\r\n    var prevCharCodeClass = classifier.get(prevCharCode);\r\n    var visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\r\n    var startOffset = 1;\r\n    if (strings.isHighSurrogate(prevCharCode)) {\r\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n        visibleColumn += 1;\r\n        prevCharCode = lineText.charCodeAt(1);\r\n        prevCharCodeClass = classifier.get(prevCharCode);\r\n        startOffset++;\r\n    }\r\n    for (var i = startOffset; i < len; i++) {\r\n        var charStartOffset = i;\r\n        var charCode = lineText.charCodeAt(i);\r\n        var charCodeClass = void 0;\r\n        var charWidth = void 0;\r\n        if (strings.isHighSurrogate(charCode)) {\r\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\r\n            i++;\r\n            charCodeClass = 0 /* NONE */;\r\n            charWidth = 2;\r\n        }\r\n        else {\r\n            charCodeClass = classifier.get(charCode);\r\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\r\n        }\r\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\r\n            breakOffset = charStartOffset;\r\n            breakOffsetVisibleColumn = visibleColumn;\r\n        }\r\n        visibleColumn += charWidth;\r\n        // check if adding character at `i` will go over the breaking column\r\n        if (visibleColumn > breakingColumn) {\r\n            // We need to break at least before character at `i`:\r\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\r\n                // Cannot break at `breakOffset`, must break at `i`\r\n                breakOffset = charStartOffset;\r\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\r\n            }\r\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\r\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\r\n            breakingOffsetsCount++;\r\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\r\n            breakOffset = 0;\r\n        }\r\n        prevCharCode = charCode;\r\n        prevCharCodeClass = charCodeClass;\r\n    }\r\n    if (breakingOffsetsCount === 0) {\r\n        return null;\r\n    }\r\n    // Add last segment\r\n    breakingOffsets[breakingOffsetsCount] = len;\r\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\r\n    return new LineBreakData(breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\r\n}\r\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\r\n    if (charCode === 9 /* Tab */) {\r\n        return (tabSize - (visibleColumn % tabSize));\r\n    }\r\n    if (strings.isFullWidthCharacter(charCode)) {\r\n        return columnsForFullWidthChar;\r\n    }\r\n    return 1;\r\n}\r\nfunction tabCharacterWidth(visibleColumn, tabSize) {\r\n    return (tabSize - (visibleColumn % tabSize));\r\n}\r\n/**\r\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\r\n * Kinsoku Shori : Don't break before a trailing character, like a period\r\n */\r\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\r\n    return (charCode !== 32 /* Space */\r\n        && ((prevCharCodeClass === 2 /* BREAK_AFTER */)\r\n            || (prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */)\r\n            || (charCodeClass === 1 /* BREAK_BEFORE */)\r\n            || (charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */)));\r\n}\r\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\r\n    var wrappedTextIndentLength = 0;\r\n    if (wrappingIndent !== 0 /* None */) {\r\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\r\n        if (firstNonWhitespaceIndex !== -1) {\r\n            // Track existing indent\r\n            for (var i = 0; i < firstNonWhitespaceIndex; i++) {\r\n                var charWidth = (lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\r\n                wrappedTextIndentLength += charWidth;\r\n            }\r\n            // Increase indent of continuation lines, if desired\r\n            var numberOfAdditionalTabs = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\r\n            for (var i = 0; i < numberOfAdditionalTabs; i++) {\r\n                var charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\r\n                wrappedTextIndentLength += charWidth;\r\n            }\r\n            // Force sticking to beginning of line if no character would fit except for the indentation\r\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\r\n                wrappedTextIndentLength = 0;\r\n            }\r\n        }\r\n    }\r\n    return wrappedTextIndentLength;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}