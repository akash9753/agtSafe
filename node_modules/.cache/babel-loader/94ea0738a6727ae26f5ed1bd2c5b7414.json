{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as formatter from './impl/format.js';\nimport * as edit from './impl/edit.js';\nimport * as scanner from './impl/scanner.js';\nimport * as parser from './impl/parser.js';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport var stripComments = parser.stripComments;\nexport function printParseErrorCode(code) {\n  switch (code) {\n    case 1 /* InvalidSymbol */:\n      return 'InvalidSymbol';\n    case 2 /* InvalidNumberFormat */:\n      return 'InvalidNumberFormat';\n    case 3 /* PropertyNameExpected */:\n      return 'PropertyNameExpected';\n    case 4 /* ValueExpected */:\n      return 'ValueExpected';\n    case 5 /* ColonExpected */:\n      return 'ColonExpected';\n    case 6 /* CommaExpected */:\n      return 'CommaExpected';\n    case 7 /* CloseBraceExpected */:\n      return 'CloseBraceExpected';\n    case 8 /* CloseBracketExpected */:\n      return 'CloseBracketExpected';\n    case 9 /* EndOfFileExpected */:\n      return 'EndOfFileExpected';\n    case 10 /* InvalidCommentToken */:\n      return 'InvalidCommentToken';\n    case 11 /* UnexpectedEndOfComment */:\n      return 'UnexpectedEndOfComment';\n    case 12 /* UnexpectedEndOfString */:\n      return 'UnexpectedEndOfString';\n    case 13 /* UnexpectedEndOfNumber */:\n      return 'UnexpectedEndOfNumber';\n    case 14 /* InvalidUnicode */:\n      return 'InvalidUnicode';\n    case 15 /* InvalidEscapeCharacter */:\n      return 'InvalidEscapeCharacter';\n    case 16 /* InvalidCharacter */:\n      return 'InvalidCharacter';\n  }\n  return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function format(documentText, range, options) {\n  return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function modify(text, path, value, options) {\n  return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text, edits) {\n  for (var i = edits.length - 1; i >= 0; i--) {\n    text = edit.applyEdit(text, edits[i]);\n  }\n  return text;\n}","map":{"version":3,"names":["formatter","edit","scanner","parser","createScanner","getLocation","parse","parseTree","findNodeAtLocation","findNodeAtOffset","getNodePath","getNodeValue","visit","stripComments","printParseErrorCode","code","format","documentText","range","options","modify","text","path","value","setProperty","formattingOptions","getInsertionIndex","applyEdits","edits","i","length","applyEdit"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/main.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format.js';\nimport * as edit from './impl/edit.js';\nimport * as scanner from './impl/scanner.js';\nimport * as parser from './impl/parser.js';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport var stripComments = parser.stripComments;\nexport function printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ValueExpected */: return 'ValueExpected';\n        case 5 /* ColonExpected */: return 'ColonExpected';\n        case 6 /* CommaExpected */: return 'CommaExpected';\n        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = edit.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}