{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nvar FoldingModel = /** @class */function () {\n  function FoldingModel(textModel, decorationProvider) {\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n    this._isInitialized = false;\n  }\n  Object.defineProperty(FoldingModel.prototype, \"regions\", {\n    get: function get() {\n      return this._regions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FoldingModel.prototype, \"textModel\", {\n    get: function get() {\n      return this._textModel;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FoldingModel.prototype, \"isInitialized\", {\n    get: function get() {\n      return this._isInitialized;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FoldingModel.prototype.toggleCollapseState = function (regions) {\n    var _this = this;\n    if (!regions.length) {\n      return;\n    }\n    var processed = {};\n    this._decorationProvider.changeDecorations(function (accessor) {\n      for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n        var region = regions_1[_i];\n        var index = region.regionIndex;\n        var editorDecorationId = _this._editorDecorationIds[index];\n        if (editorDecorationId && !processed[editorDecorationId]) {\n          processed[editorDecorationId] = true;\n          var newCollapseState = !_this._regions.isCollapsed(index);\n          _this._regions.setCollapsed(index, newCollapseState);\n          accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));\n        }\n      }\n    });\n    this._updateEventEmitter.fire({\n      model: this,\n      collapseStateChanged: regions\n    });\n  };\n  FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {\n    var _this = this;\n    if (blockedLineNumers === void 0) {\n      blockedLineNumers = [];\n    }\n    var newEditorDecorations = [];\n    var isBlocked = function isBlocked(startLineNumber, endLineNumber) {\n      for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {\n        var blockedLineNumber = blockedLineNumers_1[_i];\n        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n          // first line is visible\n          return true;\n        }\n      }\n      return false;\n    };\n    var initRange = function initRange(index, isCollapsed) {\n      var startLineNumber = newRegions.getStartLineNumber(index);\n      if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\n        isCollapsed = false;\n      }\n      newRegions.setCollapsed(index, isCollapsed);\n      var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);\n      var decorationRange = {\n        startLineNumber: startLineNumber,\n        startColumn: maxColumn,\n        endLineNumber: startLineNumber,\n        endColumn: maxColumn\n      };\n      newEditorDecorations.push({\n        range: decorationRange,\n        options: _this._decorationProvider.getDecorationOption(isCollapsed)\n      });\n    };\n    var i = 0;\n    var nextCollapsed = function nextCollapsed() {\n      while (i < _this._regions.length) {\n        var isCollapsed = _this._regions.isCollapsed(i);\n        i++;\n        if (isCollapsed) {\n          return i - 1;\n        }\n      }\n      return -1;\n    };\n    var k = 0;\n    var collapsedIndex = nextCollapsed();\n    while (collapsedIndex !== -1 && k < newRegions.length) {\n      // get the latest range\n      var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n      if (decRange) {\n        var collapsedStartLineNumber = decRange.startLineNumber;\n        if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) {\n          // test that the decoration is still at the end otherwise it got deleted\n          while (k < newRegions.length) {\n            var startLineNumber = newRegions.getStartLineNumber(k);\n            if (collapsedStartLineNumber >= startLineNumber) {\n              initRange(k, collapsedStartLineNumber === startLineNumber);\n              k++;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      collapsedIndex = nextCollapsed();\n    }\n    while (k < newRegions.length) {\n      initRange(k, false);\n      k++;\n    }\n    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n    this._regions = newRegions;\n    this._isInitialized = true;\n    this._updateEventEmitter.fire({\n      model: this\n    });\n  };\n  /**\r\n   * Collapse state memento, for persistence only\r\n   */\n  FoldingModel.prototype.getMemento = function () {\n    var collapsedRanges = [];\n    for (var i = 0; i < this._regions.length; i++) {\n      if (this._regions.isCollapsed(i)) {\n        var range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n        if (range) {\n          var startLineNumber = range.startLineNumber;\n          var endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n          collapsedRanges.push({\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber\n          });\n        }\n      }\n    }\n    if (collapsedRanges.length > 0) {\n      return collapsedRanges;\n    }\n    return undefined;\n  };\n  /**\r\n   * Apply persisted state, for persistence only\r\n   */\n  FoldingModel.prototype.applyMemento = function (state) {\n    if (!Array.isArray(state)) {\n      return;\n    }\n    var toToogle = [];\n    for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\n      var range = state_1[_i];\n      var region = this.getRegionAtLine(range.startLineNumber);\n      if (region && !region.isCollapsed) {\n        toToogle.push(region);\n      }\n    }\n    this.toggleCollapseState(toToogle);\n  };\n  FoldingModel.prototype.dispose = function () {\n    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n  };\n  FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {\n    var result = [];\n    if (this._regions) {\n      var index = this._regions.findRange(lineNumber);\n      var level = 1;\n      while (index >= 0) {\n        var current = this._regions.toRegion(index);\n        if (!filter || filter(current, level)) {\n          result.push(current);\n        }\n        level++;\n        index = current.parentIndex;\n      }\n    }\n    return result;\n  };\n  FoldingModel.prototype.getRegionAtLine = function (lineNumber) {\n    if (this._regions) {\n      var index = this._regions.findRange(lineNumber);\n      if (index >= 0) {\n        return this._regions.toRegion(index);\n      }\n    }\n    return null;\n  };\n  FoldingModel.prototype.getRegionsInside = function (region, filter) {\n    var result = [];\n    var index = region ? region.regionIndex + 1 : 0;\n    var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n    if (filter && filter.length === 2) {\n      var levelStack = [];\n      for (var i = index, len = this._regions.length; i < len; i++) {\n        var current = this._regions.toRegion(i);\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n            levelStack.pop();\n          }\n          levelStack.push(current);\n          if (filter(current, levelStack.length)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (var i = index, len = this._regions.length; i < len; i++) {\n        var current = this._regions.toRegion(i);\n        if (this._regions.getStartLineNumber(i) < endLineNumber) {\n          if (!filter || filter(current)) {\n            result.push(current);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    return result;\n  };\n  return FoldingModel;\n}();\nexport { FoldingModel };\n/**\r\n * Collapse or expand the regions at the given locations\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n  var toToggle = [];\n  var _loop_1 = function _loop_1(lineNumber) {\n    var region = foldingModel.getRegionAtLine(lineNumber);\n    if (region) {\n      var doCollapse_1 = !region.isCollapsed;\n      toToggle.push(region);\n      if (levels > 1) {\n        var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n          return r.isCollapsed !== doCollapse_1 && level < levels;\n        });\n        toToggle.push.apply(toToggle, regionsInside);\n      }\n    }\n  };\n  for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {\n    var lineNumber = lineNumbers_1[_i];\n    _loop_1(lineNumber);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand the regions at the given locations including all children.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {\n  if (levels === void 0) {\n    levels = Number.MAX_VALUE;\n  }\n  var toToggle = [];\n  if (lineNumbers && lineNumbers.length > 0) {\n    for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {\n      var lineNumber = lineNumbers_2[_i];\n      var region = foldingModel.getRegionAtLine(lineNumber);\n      if (region) {\n        if (region.isCollapsed !== doCollapse) {\n          toToggle.push(region);\n        }\n        if (levels > 1) {\n          var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n            return r.isCollapsed !== doCollapse && level < levels;\n          });\n          toToggle.push.apply(toToggle, regionsInside);\n        }\n      }\n    }\n  } else {\n    var regionsInside = foldingModel.getRegionsInside(null, function (r, level) {\n      return r.isCollapsed !== doCollapse && level < levels;\n    });\n    toToggle.push.apply(toToggle, regionsInside);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand the regions at the given locations including all parents.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  var toToggle = [];\n  for (var _i = 0, lineNumbers_3 = lineNumbers; _i < lineNumbers_3.length; _i++) {\n    var lineNumber = lineNumbers_3[_i];\n    var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) {\n      return region.isCollapsed !== doCollapse && level <= levels;\n    });\n    toToggle.push.apply(toToggle, regions);\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n  var toToggle = [];\n  for (var _i = 0, lineNumbers_4 = lineNumbers; _i < lineNumbers_4.length; _i++) {\n    var lineNumber = lineNumbers_4[_i];\n    var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region) {\n      return region.isCollapsed !== doCollapse;\n    });\n    if (regions.length > 0) {\n      toToggle.push(regions[0]);\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\r\n * @param foldLevel level. Level == 1 is the top level\r\n * @param doCollapse Wheter to collase or expand\r\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  var filter = function filter(region, level) {\n    return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) {\n      return region.containsLine(line);\n    });\n  };\n  var toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds all regions for which the lines start with a given regex\r\n * @param foldingModel the folding model\r\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  var editorModel = foldingModel.textModel;\n  var regions = foldingModel.regions;\n  var toToggle = [];\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      var startLineNumber = regions.getStartLineNumber(i);\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\r\n * Folds all regions of the given type\r\n * @param foldingModel the folding model\r\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  var regions = foldingModel.regions;\n  var toToggle = [];\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}","map":{"version":3,"names":["Emitter","FoldingRegions","FoldingModel","textModel","decorationProvider","_updateEventEmitter","onDidChange","event","_textModel","_decorationProvider","_regions","Uint32Array","_editorDecorationIds","_isInitialized","Object","defineProperty","prototype","get","enumerable","configurable","toggleCollapseState","regions","_this","length","processed","changeDecorations","accessor","_i","regions_1","region","index","regionIndex","editorDecorationId","newCollapseState","isCollapsed","setCollapsed","changeDecorationOptions","getDecorationOption","fire","model","collapseStateChanged","update","newRegions","blockedLineNumers","newEditorDecorations","isBlocked","startLineNumber","endLineNumber","blockedLineNumers_1","blockedLineNumber","initRange","getStartLineNumber","getEndLineNumber","maxColumn","getLineMaxColumn","decorationRange","startColumn","endColumn","push","range","options","i","nextCollapsed","k","collapsedIndex","decRange","getDecorationRange","collapsedStartLineNumber","deltaDecorations","getMemento","collapsedRanges","undefined","applyMemento","state","Array","isArray","toToogle","state_1","getRegionAtLine","dispose","getAllRegionsAtLine","lineNumber","filter","result","findRange","level","current","toRegion","parentIndex","getRegionsInside","Number","MAX_VALUE","levelStack","len","containedBy","pop","foldingModel","levels","lineNumbers","toToggle","_loop_1","doCollapse_1","regionsInside","r","apply","lineNumbers_1","setCollapseStateLevelsDown","doCollapse","lineNumbers_2","setCollapseStateLevelsUp","lineNumbers_3","setCollapseStateUp","lineNumbers_4","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","some","line","containsLine","setCollapseStateForMatchingLines","regExp","editorModel","test","getLineContent","setCollapseStateForType","type","getType"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { FoldingRegions } from './foldingRanges.js';\r\nvar FoldingModel = /** @class */ (function () {\r\n    function FoldingModel(textModel, decorationProvider) {\r\n        this._updateEventEmitter = new Emitter();\r\n        this.onDidChange = this._updateEventEmitter.event;\r\n        this._textModel = textModel;\r\n        this._decorationProvider = decorationProvider;\r\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\r\n        this._editorDecorationIds = [];\r\n        this._isInitialized = false;\r\n    }\r\n    Object.defineProperty(FoldingModel.prototype, \"regions\", {\r\n        get: function () { return this._regions; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FoldingModel.prototype, \"textModel\", {\r\n        get: function () { return this._textModel; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FoldingModel.prototype, \"isInitialized\", {\r\n        get: function () { return this._isInitialized; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FoldingModel.prototype.toggleCollapseState = function (regions) {\r\n        var _this = this;\r\n        if (!regions.length) {\r\n            return;\r\n        }\r\n        var processed = {};\r\n        this._decorationProvider.changeDecorations(function (accessor) {\r\n            for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\r\n                var region = regions_1[_i];\r\n                var index = region.regionIndex;\r\n                var editorDecorationId = _this._editorDecorationIds[index];\r\n                if (editorDecorationId && !processed[editorDecorationId]) {\r\n                    processed[editorDecorationId] = true;\r\n                    var newCollapseState = !_this._regions.isCollapsed(index);\r\n                    _this._regions.setCollapsed(index, newCollapseState);\r\n                    accessor.changeDecorationOptions(editorDecorationId, _this._decorationProvider.getDecorationOption(newCollapseState));\r\n                }\r\n            }\r\n        });\r\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: regions });\r\n    };\r\n    FoldingModel.prototype.update = function (newRegions, blockedLineNumers) {\r\n        var _this = this;\r\n        if (blockedLineNumers === void 0) { blockedLineNumers = []; }\r\n        var newEditorDecorations = [];\r\n        var isBlocked = function (startLineNumber, endLineNumber) {\r\n            for (var _i = 0, blockedLineNumers_1 = blockedLineNumers; _i < blockedLineNumers_1.length; _i++) {\r\n                var blockedLineNumber = blockedLineNumers_1[_i];\r\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        var initRange = function (index, isCollapsed) {\r\n            var startLineNumber = newRegions.getStartLineNumber(index);\r\n            if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\r\n                isCollapsed = false;\r\n            }\r\n            newRegions.setCollapsed(index, isCollapsed);\r\n            var maxColumn = _this._textModel.getLineMaxColumn(startLineNumber);\r\n            var decorationRange = {\r\n                startLineNumber: startLineNumber,\r\n                startColumn: maxColumn,\r\n                endLineNumber: startLineNumber,\r\n                endColumn: maxColumn\r\n            };\r\n            newEditorDecorations.push({ range: decorationRange, options: _this._decorationProvider.getDecorationOption(isCollapsed) });\r\n        };\r\n        var i = 0;\r\n        var nextCollapsed = function () {\r\n            while (i < _this._regions.length) {\r\n                var isCollapsed = _this._regions.isCollapsed(i);\r\n                i++;\r\n                if (isCollapsed) {\r\n                    return i - 1;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        var k = 0;\r\n        var collapsedIndex = nextCollapsed();\r\n        while (collapsedIndex !== -1 && k < newRegions.length) {\r\n            // get the latest range\r\n            var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\r\n            if (decRange) {\r\n                var collapsedStartLineNumber = decRange.startLineNumber;\r\n                if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) { // test that the decoration is still at the end otherwise it got deleted\r\n                    while (k < newRegions.length) {\r\n                        var startLineNumber = newRegions.getStartLineNumber(k);\r\n                        if (collapsedStartLineNumber >= startLineNumber) {\r\n                            initRange(k, collapsedStartLineNumber === startLineNumber);\r\n                            k++;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            collapsedIndex = nextCollapsed();\r\n        }\r\n        while (k < newRegions.length) {\r\n            initRange(k, false);\r\n            k++;\r\n        }\r\n        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\r\n        this._regions = newRegions;\r\n        this._isInitialized = true;\r\n        this._updateEventEmitter.fire({ model: this });\r\n    };\r\n    /**\r\n     * Collapse state memento, for persistence only\r\n     */\r\n    FoldingModel.prototype.getMemento = function () {\r\n        var collapsedRanges = [];\r\n        for (var i = 0; i < this._regions.length; i++) {\r\n            if (this._regions.isCollapsed(i)) {\r\n                var range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\r\n                if (range) {\r\n                    var startLineNumber = range.startLineNumber;\r\n                    var endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\r\n                    collapsedRanges.push({ startLineNumber: startLineNumber, endLineNumber: endLineNumber });\r\n                }\r\n            }\r\n        }\r\n        if (collapsedRanges.length > 0) {\r\n            return collapsedRanges;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Apply persisted state, for persistence only\r\n     */\r\n    FoldingModel.prototype.applyMemento = function (state) {\r\n        if (!Array.isArray(state)) {\r\n            return;\r\n        }\r\n        var toToogle = [];\r\n        for (var _i = 0, state_1 = state; _i < state_1.length; _i++) {\r\n            var range = state_1[_i];\r\n            var region = this.getRegionAtLine(range.startLineNumber);\r\n            if (region && !region.isCollapsed) {\r\n                toToogle.push(region);\r\n            }\r\n        }\r\n        this.toggleCollapseState(toToogle);\r\n    };\r\n    FoldingModel.prototype.dispose = function () {\r\n        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\r\n    };\r\n    FoldingModel.prototype.getAllRegionsAtLine = function (lineNumber, filter) {\r\n        var result = [];\r\n        if (this._regions) {\r\n            var index = this._regions.findRange(lineNumber);\r\n            var level = 1;\r\n            while (index >= 0) {\r\n                var current = this._regions.toRegion(index);\r\n                if (!filter || filter(current, level)) {\r\n                    result.push(current);\r\n                }\r\n                level++;\r\n                index = current.parentIndex;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    FoldingModel.prototype.getRegionAtLine = function (lineNumber) {\r\n        if (this._regions) {\r\n            var index = this._regions.findRange(lineNumber);\r\n            if (index >= 0) {\r\n                return this._regions.toRegion(index);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    FoldingModel.prototype.getRegionsInside = function (region, filter) {\r\n        var result = [];\r\n        var index = region ? region.regionIndex + 1 : 0;\r\n        var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\r\n        if (filter && filter.length === 2) {\r\n            var levelStack = [];\r\n            for (var i = index, len = this._regions.length; i < len; i++) {\r\n                var current = this._regions.toRegion(i);\r\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\r\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\r\n                        levelStack.pop();\r\n                    }\r\n                    levelStack.push(current);\r\n                    if (filter(current, levelStack.length)) {\r\n                        result.push(current);\r\n                    }\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var i = index, len = this._regions.length; i < len; i++) {\r\n                var current = this._regions.toRegion(i);\r\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\r\n                    if (!filter || filter(current)) {\r\n                        result.push(current);\r\n                    }\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return FoldingModel;\r\n}());\r\nexport { FoldingModel };\r\n/**\r\n * Collapse or expand the regions at the given locations\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\r\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\r\n    var toToggle = [];\r\n    var _loop_1 = function (lineNumber) {\r\n        var region = foldingModel.getRegionAtLine(lineNumber);\r\n        if (region) {\r\n            var doCollapse_1 = !region.isCollapsed;\r\n            toToggle.push(region);\r\n            if (levels > 1) {\r\n                var regionsInside = foldingModel.getRegionsInside(region, function (r, level) { return r.isCollapsed !== doCollapse_1 && level < levels; });\r\n                toToggle.push.apply(toToggle, regionsInside);\r\n            }\r\n        }\r\n    };\r\n    for (var _i = 0, lineNumbers_1 = lineNumbers; _i < lineNumbers_1.length; _i++) {\r\n        var lineNumber = lineNumbers_1[_i];\r\n        _loop_1(lineNumber);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations including all children.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\r\n */\r\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels, lineNumbers) {\r\n    if (levels === void 0) { levels = Number.MAX_VALUE; }\r\n    var toToggle = [];\r\n    if (lineNumbers && lineNumbers.length > 0) {\r\n        for (var _i = 0, lineNumbers_2 = lineNumbers; _i < lineNumbers_2.length; _i++) {\r\n            var lineNumber = lineNumbers_2[_i];\r\n            var region = foldingModel.getRegionAtLine(lineNumber);\r\n            if (region) {\r\n                if (region.isCollapsed !== doCollapse) {\r\n                    toToggle.push(region);\r\n                }\r\n                if (levels > 1) {\r\n                    var regionsInside = foldingModel.getRegionsInside(region, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });\r\n                    toToggle.push.apply(toToggle, regionsInside);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        var regionsInside = foldingModel.getRegionsInside(null, function (r, level) { return r.isCollapsed !== doCollapse && level < levels; });\r\n        toToggle.push.apply(toToggle, regionsInside);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand the regions at the given locations including all parents.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\r\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\r\n    var toToggle = [];\r\n    for (var _i = 0, lineNumbers_3 = lineNumbers; _i < lineNumbers_3.length; _i++) {\r\n        var lineNumber = lineNumbers_3[_i];\r\n        var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) { return region.isCollapsed !== doCollapse && level <= levels; });\r\n        toToggle.push.apply(toToggle, regions);\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\r\n * @param doCollapse Wheter to collase or expand\r\n * @param lineNumbers the location of the regions to collapse or expand.\r\n */\r\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\r\n    var toToggle = [];\r\n    for (var _i = 0, lineNumbers_4 = lineNumbers; _i < lineNumbers_4.length; _i++) {\r\n        var lineNumber = lineNumbers_4[_i];\r\n        var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region) { return region.isCollapsed !== doCollapse; });\r\n        if (regions.length > 0) {\r\n            toToggle.push(regions[0]);\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\r\n * @param foldLevel level. Level == 1 is the top level\r\n * @param doCollapse Wheter to collase or expand\r\n*/\r\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\r\n    var filter = function (region, level) { return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) { return region.containsLine(line); }); };\r\n    var toToggle = foldingModel.getRegionsInside(null, filter);\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds all regions for which the lines start with a given regex\r\n * @param foldingModel the folding model\r\n */\r\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\r\n    var editorModel = foldingModel.textModel;\r\n    var regions = foldingModel.regions;\r\n    var toToggle = [];\r\n    for (var i = regions.length - 1; i >= 0; i--) {\r\n        if (doCollapse !== regions.isCollapsed(i)) {\r\n            var startLineNumber = regions.getStartLineNumber(i);\r\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\r\n                toToggle.push(regions.toRegion(i));\r\n            }\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n/**\r\n * Folds all regions of the given type\r\n * @param foldingModel the folding model\r\n */\r\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\r\n    var regions = foldingModel.regions;\r\n    var toToggle = [];\r\n    for (var i = regions.length - 1; i >= 0; i--) {\r\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\r\n            toToggle.push(regions.toRegion(i));\r\n        }\r\n    }\r\n    foldingModel.toggleCollapseState(toToggle);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}