{"ast":null,"code":"/**\n * Until SelectionRange lands in LSP, we'll return Range from server and convert it to\n * SelectionRange on client side\n */\nimport { Range, SelectionRange } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { parse } from '../parser/htmlParser.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nexport function getSelectionRanges(document, positions) {\n  function getSelectionRange(position) {\n    var applicableRanges = getApplicableRanges(document, position);\n    var prev = undefined;\n    var current = undefined;\n    for (var index = applicableRanges.length - 1; index >= 0; index--) {\n      var range = applicableRanges[index];\n      if (!prev || range[0] !== prev[0] || range[1] !== prev[1]) {\n        current = SelectionRange.create(Range.create(document.positionAt(applicableRanges[index][0]), document.positionAt(applicableRanges[index][1])), current);\n      }\n      prev = range;\n    }\n    if (!current) {\n      current = SelectionRange.create(Range.create(position, position));\n    }\n    return current;\n  }\n  return positions.map(getSelectionRange);\n}\nfunction getApplicableRanges(document, position) {\n  var htmlDoc = parse(document.getText());\n  var currOffset = document.offsetAt(position);\n  var currNode = htmlDoc.findNodeAt(currOffset);\n  var result = getAllParentTagRanges(currNode);\n  // Self-closing or void elements\n  if (currNode.startTagEnd && !currNode.endTagStart) {\n    // THe rare case of unmatching tag pairs like <div></div1>\n    if (currNode.startTagEnd !== currNode.end) {\n      return [[currNode.start, currNode.end]];\n    }\n    var closeRange = Range.create(document.positionAt(currNode.startTagEnd - 2), document.positionAt(currNode.startTagEnd));\n    var closeText = document.getText(closeRange);\n    // Self-closing element\n    if (closeText === '/>') {\n      result.unshift([currNode.start + 1, currNode.startTagEnd - 2]);\n    }\n    // Void element\n    else {\n      result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n    }\n    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n    result = attributeLevelRanges.concat(result);\n    return result;\n  }\n  if (!currNode.startTagEnd || !currNode.endTagStart) {\n    return result;\n  }\n  /**\n   * For html like\n   * `<div class=\"foo\">bar</div>`\n   */\n  result.unshift([currNode.start, currNode.end]);\n  /**\n   * Cursor inside `<div class=\"foo\">`\n   */\n  if (currNode.start < currOffset && currOffset < currNode.startTagEnd) {\n    result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n    result = attributeLevelRanges.concat(result);\n    return result;\n  }\n  /**\n   * Cursor inside `bar`\n   */else if (currNode.startTagEnd <= currOffset && currOffset <= currNode.endTagStart) {\n    result.unshift([currNode.startTagEnd, currNode.endTagStart]);\n    return result;\n  }\n  /**\n   * Cursor inside `</div>`\n   */else {\n    // `div` inside `</div>`\n    if (currOffset >= currNode.endTagStart + 2) {\n      result.unshift([currNode.endTagStart + 2, currNode.end - 1]);\n    }\n    return result;\n  }\n}\nfunction getAllParentTagRanges(initialNode) {\n  var currNode = initialNode;\n  var getNodeRanges = function getNodeRanges(n) {\n    if (n.startTagEnd && n.endTagStart && n.startTagEnd < n.endTagStart) {\n      return [[n.startTagEnd, n.endTagStart], [n.start, n.end]];\n    }\n    return [[n.start, n.end]];\n  };\n  var result = [];\n  while (currNode.parent) {\n    currNode = currNode.parent;\n    getNodeRanges(currNode).forEach(function (r) {\n      return result.push(r);\n    });\n  }\n  return result;\n}\nfunction getAttributeLevelRanges(document, currNode, currOffset) {\n  var currNodeRange = Range.create(document.positionAt(currNode.start), document.positionAt(currNode.end));\n  var currNodeText = document.getText(currNodeRange);\n  var relativeOffset = currOffset - currNode.start;\n  /**\n   * Tag level semantic selection\n   */\n  var scanner = createScanner(currNodeText);\n  var token = scanner.scan();\n  /**\n   * For text like\n   * <div class=\"foo\">bar</div>\n   */\n  var positionOffset = currNode.start;\n  var result = [];\n  var isInsideAttribute = false;\n  var attrStart = -1;\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.AttributeName:\n        {\n          if (relativeOffset < scanner.getTokenOffset()) {\n            isInsideAttribute = false;\n            break;\n          }\n          if (relativeOffset <= scanner.getTokenEnd()) {\n            // `class`\n            result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n          }\n          isInsideAttribute = true;\n          attrStart = scanner.getTokenOffset();\n          break;\n        }\n      case TokenType.AttributeValue:\n        {\n          if (!isInsideAttribute) {\n            break;\n          }\n          var valueText = scanner.getTokenText();\n          if (relativeOffset < scanner.getTokenOffset()) {\n            // `class=\"foo\"`\n            result.push([attrStart, scanner.getTokenEnd()]);\n            break;\n          }\n          if (relativeOffset >= scanner.getTokenOffset() && relativeOffset <= scanner.getTokenEnd()) {\n            // `\"foo\"`\n            result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n            // `foo`\n            if (valueText[0] === \"\\\"\" && valueText[valueText.length - 1] === \"\\\"\" || valueText[0] === \"'\" && valueText[valueText.length - 1] === \"'\") {\n              if (relativeOffset >= scanner.getTokenOffset() + 1 && relativeOffset <= scanner.getTokenEnd() - 1) {\n                result.unshift([scanner.getTokenOffset() + 1, scanner.getTokenEnd() - 1]);\n              }\n            }\n            // `class=\"foo\"`\n            result.push([attrStart, scanner.getTokenEnd()]);\n          }\n          break;\n        }\n    }\n    token = scanner.scan();\n  }\n  return result.map(function (pair) {\n    return [pair[0] + positionOffset, pair[1] + positionOffset];\n  });\n}","map":{"version":3,"names":["Range","SelectionRange","createScanner","parse","TokenType","getSelectionRanges","document","positions","getSelectionRange","position","applicableRanges","getApplicableRanges","prev","undefined","current","index","length","range","create","positionAt","map","htmlDoc","getText","currOffset","offsetAt","currNode","findNodeAt","result","getAllParentTagRanges","startTagEnd","endTagStart","end","start","closeRange","closeText","unshift","attributeLevelRanges","getAttributeLevelRanges","concat","initialNode","getNodeRanges","n","parent","forEach","r","push","currNodeRange","currNodeText","relativeOffset","scanner","token","scan","positionOffset","isInsideAttribute","attrStart","EOS","AttributeName","getTokenOffset","getTokenEnd","AttributeValue","valueText","getTokenText","pair"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlSelectionRange.js"],"sourcesContent":["/**\n * Until SelectionRange lands in LSP, we'll return Range from server and convert it to\n * SelectionRange on client side\n */\nimport { Range, SelectionRange } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { parse } from '../parser/htmlParser.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nexport function getSelectionRanges(document, positions) {\n    function getSelectionRange(position) {\n        var applicableRanges = getApplicableRanges(document, position);\n        var prev = undefined;\n        var current = undefined;\n        for (var index = applicableRanges.length - 1; index >= 0; index--) {\n            var range = applicableRanges[index];\n            if (!prev || range[0] !== prev[0] || range[1] !== prev[1]) {\n                current = SelectionRange.create(Range.create(document.positionAt(applicableRanges[index][0]), document.positionAt(applicableRanges[index][1])), current);\n            }\n            prev = range;\n        }\n        if (!current) {\n            current = SelectionRange.create(Range.create(position, position));\n        }\n        return current;\n    }\n    return positions.map(getSelectionRange);\n}\nfunction getApplicableRanges(document, position) {\n    var htmlDoc = parse(document.getText());\n    var currOffset = document.offsetAt(position);\n    var currNode = htmlDoc.findNodeAt(currOffset);\n    var result = getAllParentTagRanges(currNode);\n    // Self-closing or void elements\n    if (currNode.startTagEnd && !currNode.endTagStart) {\n        // THe rare case of unmatching tag pairs like <div></div1>\n        if (currNode.startTagEnd !== currNode.end) {\n            return [[currNode.start, currNode.end]];\n        }\n        var closeRange = Range.create(document.positionAt(currNode.startTagEnd - 2), document.positionAt(currNode.startTagEnd));\n        var closeText = document.getText(closeRange);\n        // Self-closing element\n        if (closeText === '/>') {\n            result.unshift([currNode.start + 1, currNode.startTagEnd - 2]);\n        }\n        // Void element\n        else {\n            result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n        }\n        var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n        result = attributeLevelRanges.concat(result);\n        return result;\n    }\n    if (!currNode.startTagEnd || !currNode.endTagStart) {\n        return result;\n    }\n    /**\n     * For html like\n     * `<div class=\"foo\">bar</div>`\n     */\n    result.unshift([currNode.start, currNode.end]);\n    /**\n     * Cursor inside `<div class=\"foo\">`\n     */\n    if (currNode.start < currOffset && currOffset < currNode.startTagEnd) {\n        result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);\n        var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);\n        result = attributeLevelRanges.concat(result);\n        return result;\n    }\n    /**\n     * Cursor inside `bar`\n     */\n    else if (currNode.startTagEnd <= currOffset && currOffset <= currNode.endTagStart) {\n        result.unshift([currNode.startTagEnd, currNode.endTagStart]);\n        return result;\n    }\n    /**\n     * Cursor inside `</div>`\n     */\n    else {\n        // `div` inside `</div>`\n        if (currOffset >= currNode.endTagStart + 2) {\n            result.unshift([currNode.endTagStart + 2, currNode.end - 1]);\n        }\n        return result;\n    }\n}\nfunction getAllParentTagRanges(initialNode) {\n    var currNode = initialNode;\n    var getNodeRanges = function (n) {\n        if (n.startTagEnd && n.endTagStart && n.startTagEnd < n.endTagStart) {\n            return [\n                [n.startTagEnd, n.endTagStart],\n                [n.start, n.end]\n            ];\n        }\n        return [\n            [n.start, n.end]\n        ];\n    };\n    var result = [];\n    while (currNode.parent) {\n        currNode = currNode.parent;\n        getNodeRanges(currNode).forEach(function (r) { return result.push(r); });\n    }\n    return result;\n}\nfunction getAttributeLevelRanges(document, currNode, currOffset) {\n    var currNodeRange = Range.create(document.positionAt(currNode.start), document.positionAt(currNode.end));\n    var currNodeText = document.getText(currNodeRange);\n    var relativeOffset = currOffset - currNode.start;\n    /**\n     * Tag level semantic selection\n     */\n    var scanner = createScanner(currNodeText);\n    var token = scanner.scan();\n    /**\n     * For text like\n     * <div class=\"foo\">bar</div>\n     */\n    var positionOffset = currNode.start;\n    var result = [];\n    var isInsideAttribute = false;\n    var attrStart = -1;\n    while (token !== TokenType.EOS) {\n        switch (token) {\n            case TokenType.AttributeName: {\n                if (relativeOffset < scanner.getTokenOffset()) {\n                    isInsideAttribute = false;\n                    break;\n                }\n                if (relativeOffset <= scanner.getTokenEnd()) {\n                    // `class`\n                    result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n                }\n                isInsideAttribute = true;\n                attrStart = scanner.getTokenOffset();\n                break;\n            }\n            case TokenType.AttributeValue: {\n                if (!isInsideAttribute) {\n                    break;\n                }\n                var valueText = scanner.getTokenText();\n                if (relativeOffset < scanner.getTokenOffset()) {\n                    // `class=\"foo\"`\n                    result.push([attrStart, scanner.getTokenEnd()]);\n                    break;\n                }\n                if (relativeOffset >= scanner.getTokenOffset() && relativeOffset <= scanner.getTokenEnd()) {\n                    // `\"foo\"`\n                    result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);\n                    // `foo`\n                    if ((valueText[0] === \"\\\"\" && valueText[valueText.length - 1] === \"\\\"\") || (valueText[0] === \"'\" && valueText[valueText.length - 1] === \"'\")) {\n                        if (relativeOffset >= scanner.getTokenOffset() + 1 && relativeOffset <= scanner.getTokenEnd() - 1) {\n                            result.unshift([scanner.getTokenOffset() + 1, scanner.getTokenEnd() - 1]);\n                        }\n                    }\n                    // `class=\"foo\"`\n                    result.push([attrStart, scanner.getTokenEnd()]);\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    return result.map(function (pair) {\n        return [pair[0] + positionOffset, pair[1] + positionOffset];\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}