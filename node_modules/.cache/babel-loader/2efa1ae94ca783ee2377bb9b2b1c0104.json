{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\nexport function or() {\n  var filter = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    filter[_i] = arguments[_i];\n  }\n  return function (word, wordToMatchAgainst) {\n    for (var i = 0, len = filter.length; i < len; i++) {\n      var match = filter[i](word, wordToMatchAgainst);\n      if (match) {\n        return match;\n      }\n    }\n    return null;\n  };\n}\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n  var matches;\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n  if (!matches) {\n    return null;\n  }\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n  if (index === -1) {\n    return null;\n  }\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      var result = null;\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n      return null;\n    }\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n}\n// CamelCase\nfunction isLower(code) {\n  return 97 /* a */ <= code && code <= 122 /* z */;\n}\n\nexport function isUpper(code) {\n  return 65 /* A */ <= code && code <= 90 /* Z */;\n}\n\nfunction isNumber(code) {\n  return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\n}\n\nfunction isWhitespace(code) {\n  return code === 32 /* Space */ || code === 9 /* Tab */ || code === 10 /* LineFeed */ || code === 13 /* CarriageReturn */;\n}\n\nvar wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'.split('').forEach(function (s) {\n  return wordSeparators.add(s.charCodeAt(0));\n});\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n  return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n  for (var i = start; i < camelCaseWord.length; i++) {\n    var c = camelCaseWord.charCodeAt(i);\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    var result = null;\n    var nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n  var upper = 0,\n    lower = 0,\n    alpha = 0,\n    numeric = 0,\n    code = 0;\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n  var upperPercent = upper / word.length;\n  var lowerPercent = lower / word.length;\n  var alphaPercent = alpha / word.length;\n  var numericPercent = numeric / word.length;\n  return {\n    upperPercent: upperPercent,\n    lowerPercent: lowerPercent,\n    alphaPercent: alphaPercent,\n    numericPercent: numericPercent\n  };\n}\nfunction isUpperCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n    lowerPercent = analysis.lowerPercent;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n    lowerPercent = analysis.lowerPercent,\n    alphaPercent = analysis.alphaPercent,\n    numericPercent = analysis.numericPercent;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n  var upper = 0,\n    lower = 0,\n    code = 0,\n    whitespace = 0;\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n  camelCaseWord = camelCaseWord.trim();\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n  var analysis = analyzeCamelCaseWord(camelCaseWord);\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n  var result = null;\n  var i = 0;\n  word = word.toLowerCase();\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n  return result;\n}\n// Fuzzy\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\n  if (enableSeparateSubstringMatching === void 0) {\n    enableSeparateSubstringMatching = false;\n  }\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  }\n  // Form RegExp for wildcard matches\n  var regexp = fuzzyRegExpCache.get(word);\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  }\n  // RegExp Filter\n  var match = regexp.exec(wordToMatchAgainst);\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  }\n  // Default Filter\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n  var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n  if (result) {\n    return result;\n  }\n  var matches = 0;\n  var score = 0;\n  var idx = _wordPos;\n  for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n    var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n    if (wordPos >= 0) {\n      score += 1;\n      matches += Math.pow(2, wordPos);\n      idx = wordPos + 1;\n    } else if (matches !== 0) {\n      // once we have started matching things\n      // we need to match the remaining pattern\n      // characters\n      break;\n    }\n  }\n  return [score, matches, _wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n  var matches = score[1].toString(2);\n  var wordStart = score[2];\n  var res = [];\n  for (var pos = wordStart; pos < _maxLen; pos++) {\n    if (matches[matches.length - (pos + 1)] === '1') {\n      var last = res[res.length - 1];\n      if (last && last.end === pos) {\n        last.end = pos + 1;\n      } else {\n        res.push({\n          start: pos,\n          end: pos + 1\n        });\n      }\n    }\n  }\n  return res;\n}\nvar _maxLen = 128;\nfunction initTable() {\n  var table = [];\n  var row = [0];\n  for (var i = 1; i <= _maxLen; i++) {\n    row.push(-i);\n  }\n  for (var i = 0; i <= _maxLen; i++) {\n    var thisRow = row.slice(0);\n    thisRow[0] = -i;\n    table.push(thisRow);\n  }\n  return table;\n}\nvar _table = initTable();\nvar _scores = initTable();\nvar _arrows = initTable();\nvar _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, pad) {\n    if (pad === void 0) {\n      pad = ' ';\n    }\n    while (s.length < n) {\n      s = pad + s;\n    }\n    return s;\n  }\n  var ret = \" |   |\" + word.split('').map(function (c) {\n    return pad(c, 3);\n  }).join('|') + \"\\n\";\n  for (var i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += pattern[i - 1] + \"|\";\n    }\n    ret += table[i].slice(0, wordLen + 1).map(function (n) {\n      return pad(n.toString(), 3);\n    }).join('|') + '\\n';\n  }\n  return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_scores, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  var code = value.charCodeAt(index);\n  switch (code) {\n    case 95 /* Underline */:\n    case 45 /* Dash */:\n    case 46 /* Period */:\n    case 32 /* Space */:\n    case 47 /* Slash */:\n    case 92 /* Backslash */:\n    case 39 /* SingleQuote */:\n    case 34 /* DoubleQuote */:\n    case 58 /* Colon */:\n    case 36 /* DollarSign */:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  var code = value.charCodeAt(index);\n  switch (code) {\n    case 32 /* Space */:\n    case 9 /* Tab */:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\n\nexport var FuzzyScore;\n(function (FuzzyScore) {\n  /**\r\n   * No matches and value `-100`\r\n   */\n  FuzzyScore.Default = Object.freeze([-100, 0, 0]);\n  function isDefault(score) {\n    return !score || score[0] === -100 && score[1] === 0 && score[2] === 0;\n  }\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  var wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {\n    return undefined;\n  }\n  var row = 1;\n  var column = 1;\n  var patternPos = patternStart;\n  var wordPos = wordStart;\n  // There will be a match, fill in tables\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {\n      var score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);\n      _scores[row][column] = score;\n      var diag = _table[row - 1][column - 1] + (score > 1 ? 1 : score);\n      var top_1 = _table[row - 1][column] + -1;\n      var left = _table[row][column - 1] + -1;\n      if (left >= top_1) {\n        // left or diag\n        if (left > diag) {\n          _table[row][column] = left;\n          _arrows[row][column] = 4 /* Left */;\n        } else if (left === diag) {\n          _table[row][column] = left;\n          _arrows[row][column] = 4 /* Left */ | 2 /* Diag */;\n        } else {\n          _table[row][column] = diag;\n          _arrows[row][column] = 2 /* Diag */;\n        }\n      } else {\n        // top or diag\n        if (top_1 > diag) {\n          _table[row][column] = top_1;\n          _arrows[row][column] = 1 /* Top */;\n        } else if (top_1 === diag) {\n          _table[row][column] = top_1;\n          _arrows[row][column] = 1 /* Top */ | 2 /* Diag */;\n        } else {\n          _table[row][column] = diag;\n          _arrows[row][column] = 2 /* Diag */;\n        }\n      }\n    }\n  }\n\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n  _matchesCount = 0;\n  _topScore = -100;\n  _wordStart = wordStart;\n  _firstMatchCanBeWeak = firstMatchCanBeWeak;\n  _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);\n  if (_matchesCount === 0) {\n    return undefined;\n  }\n  return [_topScore, _topMatch2, wordStart];\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return -1;\n  }\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    if (pattern[patternPos] === word[wordPos]) {\n      return 7;\n    } else {\n      return 5;\n    }\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    if (pattern[patternPos] === word[wordPos]) {\n      return 7;\n    } else {\n      return 5;\n    }\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    return 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    return 5;\n  } else {\n    return 1;\n  }\n}\nvar _matchesCount = 0;\nvar _topMatch2 = 0;\nvar _topScore = 0;\nvar _wordStart = 0;\nvar _firstMatchCanBeWeak = false;\nfunction _findAllMatches2(row, column, total, matches, lastMatched) {\n  if (_matchesCount >= 10 || total < -25) {\n    // stop when having already 10 results, or\n    // when a potential alignment as already 5 gaps\n    return;\n  }\n  var simpleMatchCount = 0;\n  while (row > 0 && column > 0) {\n    var score = _scores[row][column];\n    var arrow = _arrows[row][column];\n    if (arrow === 4 /* Left */) {\n      // left -> no match, skip a word character\n      column -= 1;\n      if (lastMatched) {\n        total -= 5; // new gap penalty\n      } else if (matches !== 0) {\n        total -= 1; // gap penalty after first match\n      }\n\n      lastMatched = false;\n      simpleMatchCount = 0;\n    } else if (arrow & 2 /* Diag */) {\n      if (arrow & 4 /* Left */) {\n        // left\n        _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total,\n        // gap penalty after first match\n        matches, lastMatched);\n      }\n      // diag\n      total += score;\n      row -= 1;\n      column -= 1;\n      lastMatched = true;\n      // match -> set a 1 at the word pos\n      matches += Math.pow(2, column + _wordStart);\n      // count simple matches and boost a row of\n      // simple matches when they yield in a\n      // strong match.\n      if (score === 1) {\n        simpleMatchCount += 1;\n        if (row === 0 && !_firstMatchCanBeWeak) {\n          // when the first match is a weak\n          // match we discard it\n          return undefined;\n        }\n      } else {\n        // boost\n        total += 1 + simpleMatchCount * (score - 1);\n        simpleMatchCount = 0;\n      }\n    } else {\n      return undefined;\n    }\n  }\n  total -= column >= 3 ? 9 : column * 3; // late start penalty\n  // dynamically keep track of the current top score\n  // and insert the current best score at head, the rest at tail\n  _matchesCount += 1;\n  if (total > _topScore) {\n    _topScore = total;\n    _topMatch2 = matches;\n  }\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n  var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    var tries = Math.min(7, pattern.length - 1);\n    for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      var newPattern = nextTypoPermutation(pattern, movingPatternPos);\n      if (newPattern) {\n        var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n  return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n  var swap1 = pattern[patternPos];\n  var swap2 = pattern[patternPos + 1];\n  if (swap1 === swap2) {\n    return undefined;\n  }\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n}\n//#endregion","map":{"version":3,"names":["LRUCache","strings","or","filter","_i","arguments","length","word","wordToMatchAgainst","i","len","match","matchesPrefix","_matchesPrefix","bind","undefined","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","get","RegExp","convertSimple2RegExpPattern","set","exec","anyScore","pattern","lowPattern","_patternPos","lowWord","_wordPos","fuzzyScore","score","idx","patternPos","_maxLen","wordPos","charAt","Math","pow","createMatches","toString","wordStart","res","pos","last","push","initTable","table","row","thisRow","slice","_table","_scores","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","map","printTables","patternStart","substr","console","log","isSeparatorAtPos","value","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","FuzzyScore","Default","Object","freeze","isDefault","firstMatchCanBeWeak","column","_doScore","diag","top_1","left","_matchesCount","_topScore","_wordStart","_firstMatchCanBeWeak","_findAllMatches2","_topMatch2","total","lastMatched","simpleMatchCount","arrow","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","min","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LRUCache } from './map.js';\r\nimport * as strings from './strings.js';\r\n// Combined filters\r\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\r\nexport function or() {\r\n    var filter = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        filter[_i] = arguments[_i];\r\n    }\r\n    return function (word, wordToMatchAgainst) {\r\n        for (var i = 0, len = filter.length; i < len; i++) {\r\n            var match = filter[i](word, wordToMatchAgainst);\r\n            if (match) {\r\n                return match;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n}\r\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\r\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\r\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\r\n        return null;\r\n    }\r\n    var matches;\r\n    if (ignoreCase) {\r\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\r\n    }\r\n    else {\r\n        matches = wordToMatchAgainst.indexOf(word) === 0;\r\n    }\r\n    if (!matches) {\r\n        return null;\r\n    }\r\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\r\n}\r\n// Contiguous Substring\r\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\r\n    var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\r\n    if (index === -1) {\r\n        return null;\r\n    }\r\n    return [{ start: index, end: index + word.length }];\r\n}\r\n// Substring\r\nexport function matchesSubString(word, wordToMatchAgainst) {\r\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\r\n}\r\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === wordToMatchAgainst.length) {\r\n        return null;\r\n    }\r\n    else {\r\n        if (word[i] === wordToMatchAgainst[j]) {\r\n            var result = null;\r\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\r\n                return join({ start: j, end: j + 1 }, result);\r\n            }\r\n            return null;\r\n        }\r\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\r\n    }\r\n}\r\n// CamelCase\r\nfunction isLower(code) {\r\n    return 97 /* a */ <= code && code <= 122 /* z */;\r\n}\r\nexport function isUpper(code) {\r\n    return 65 /* A */ <= code && code <= 90 /* Z */;\r\n}\r\nfunction isNumber(code) {\r\n    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\r\n}\r\nfunction isWhitespace(code) {\r\n    return (code === 32 /* Space */\r\n        || code === 9 /* Tab */\r\n        || code === 10 /* LineFeed */\r\n        || code === 13 /* CarriageReturn */);\r\n}\r\nvar wordSeparators = new Set();\r\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\r\n    .split('')\r\n    .forEach(function (s) { return wordSeparators.add(s.charCodeAt(0)); });\r\nfunction isAlphanumeric(code) {\r\n    return isLower(code) || isUpper(code) || isNumber(code);\r\n}\r\nfunction join(head, tail) {\r\n    if (tail.length === 0) {\r\n        tail = [head];\r\n    }\r\n    else if (head.end === tail[0].start) {\r\n        tail[0].start = head.start;\r\n    }\r\n    else {\r\n        tail.unshift(head);\r\n    }\r\n    return tail;\r\n}\r\nfunction nextAnchor(camelCaseWord, start) {\r\n    for (var i = start; i < camelCaseWord.length; i++) {\r\n        var c = camelCaseWord.charCodeAt(i);\r\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\r\n            return i;\r\n        }\r\n    }\r\n    return camelCaseWord.length;\r\n}\r\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === camelCaseWord.length) {\r\n        return null;\r\n    }\r\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\r\n        return null;\r\n    }\r\n    else {\r\n        var result = null;\r\n        var nextUpperIndex = j + 1;\r\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\r\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\r\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\r\n            nextUpperIndex++;\r\n        }\r\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n    }\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camelCaseWords.\r\nfunction analyzeCamelCaseWord(word) {\r\n    var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\r\n    for (var i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isAlphanumeric(code)) {\r\n            alpha++;\r\n        }\r\n        if (isNumber(code)) {\r\n            numeric++;\r\n        }\r\n    }\r\n    var upperPercent = upper / word.length;\r\n    var lowerPercent = lower / word.length;\r\n    var alphaPercent = alpha / word.length;\r\n    var numericPercent = numeric / word.length;\r\n    return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };\r\n}\r\nfunction isUpperCaseWord(analysis) {\r\n    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;\r\n    return lowerPercent === 0 && upperPercent > 0.6;\r\n}\r\nfunction isCamelCaseWord(analysis) {\r\n    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;\r\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camel case patterns.\r\nfunction isCamelCasePattern(word) {\r\n    var upper = 0, lower = 0, code = 0, whitespace = 0;\r\n    for (var i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isWhitespace(code)) {\r\n            whitespace++;\r\n        }\r\n    }\r\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\r\n        return word.length <= 30;\r\n    }\r\n    else {\r\n        return upper <= 5;\r\n    }\r\n}\r\nexport function matchesCamelCase(word, camelCaseWord) {\r\n    if (!camelCaseWord) {\r\n        return null;\r\n    }\r\n    camelCaseWord = camelCaseWord.trim();\r\n    if (camelCaseWord.length === 0) {\r\n        return null;\r\n    }\r\n    if (!isCamelCasePattern(word)) {\r\n        return null;\r\n    }\r\n    if (camelCaseWord.length > 60) {\r\n        return null;\r\n    }\r\n    var analysis = analyzeCamelCaseWord(camelCaseWord);\r\n    if (!isCamelCaseWord(analysis)) {\r\n        if (!isUpperCaseWord(analysis)) {\r\n            return null;\r\n        }\r\n        camelCaseWord = camelCaseWord.toLowerCase();\r\n    }\r\n    var result = null;\r\n    var i = 0;\r\n    word = word.toLowerCase();\r\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\r\n        i = nextAnchor(camelCaseWord, i + 1);\r\n    }\r\n    return result;\r\n}\r\n// Fuzzy\r\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\r\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\r\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\r\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\r\n    if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }\r\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\r\n        return null; // return early for invalid input\r\n    }\r\n    // Form RegExp for wildcard matches\r\n    var regexp = fuzzyRegExpCache.get(word);\r\n    if (!regexp) {\r\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\r\n        fuzzyRegExpCache.set(word, regexp);\r\n    }\r\n    // RegExp Filter\r\n    var match = regexp.exec(wordToMatchAgainst);\r\n    if (match) {\r\n        return [{ start: match.index, end: match.index + match[0].length }];\r\n    }\r\n    // Default Filter\r\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\r\n}\r\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\r\n    var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\r\n    if (result) {\r\n        return result;\r\n    }\r\n    var matches = 0;\r\n    var score = 0;\r\n    var idx = _wordPos;\r\n    for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\r\n        var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\r\n        if (wordPos >= 0) {\r\n            score += 1;\r\n            matches += Math.pow(2, wordPos);\r\n            idx = wordPos + 1;\r\n        }\r\n        else if (matches !== 0) {\r\n            // once we have started matching things\r\n            // we need to match the remaining pattern\r\n            // characters\r\n            break;\r\n        }\r\n    }\r\n    return [score, matches, _wordPos];\r\n}\r\n//#region --- fuzzyScore ---\r\nexport function createMatches(score) {\r\n    if (typeof score === 'undefined') {\r\n        return [];\r\n    }\r\n    var matches = score[1].toString(2);\r\n    var wordStart = score[2];\r\n    var res = [];\r\n    for (var pos = wordStart; pos < _maxLen; pos++) {\r\n        if (matches[matches.length - (pos + 1)] === '1') {\r\n            var last = res[res.length - 1];\r\n            if (last && last.end === pos) {\r\n                last.end = pos + 1;\r\n            }\r\n            else {\r\n                res.push({ start: pos, end: pos + 1 });\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\nvar _maxLen = 128;\r\nfunction initTable() {\r\n    var table = [];\r\n    var row = [0];\r\n    for (var i = 1; i <= _maxLen; i++) {\r\n        row.push(-i);\r\n    }\r\n    for (var i = 0; i <= _maxLen; i++) {\r\n        var thisRow = row.slice(0);\r\n        thisRow[0] = -i;\r\n        table.push(thisRow);\r\n    }\r\n    return table;\r\n}\r\nvar _table = initTable();\r\nvar _scores = initTable();\r\nvar _arrows = initTable();\r\nvar _debug = false;\r\nfunction printTable(table, pattern, patternLen, word, wordLen) {\r\n    function pad(s, n, pad) {\r\n        if (pad === void 0) { pad = ' '; }\r\n        while (s.length < n) {\r\n            s = pad + s;\r\n        }\r\n        return s;\r\n    }\r\n    var ret = \" |   |\" + word.split('').map(function (c) { return pad(c, 3); }).join('|') + \"\\n\";\r\n    for (var i = 0; i <= patternLen; i++) {\r\n        if (i === 0) {\r\n            ret += ' |';\r\n        }\r\n        else {\r\n            ret += pattern[i - 1] + \"|\";\r\n        }\r\n        ret += table[i].slice(0, wordLen + 1).map(function (n) { return pad(n.toString(), 3); }).join('|') + '\\n';\r\n    }\r\n    return ret;\r\n}\r\nfunction printTables(pattern, patternStart, word, wordStart) {\r\n    pattern = pattern.substr(patternStart);\r\n    word = word.substr(wordStart);\r\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_scores, pattern, pattern.length, word, word.length));\r\n}\r\nfunction isSeparatorAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    var code = value.charCodeAt(index);\r\n    switch (code) {\r\n        case 95 /* Underline */:\r\n        case 45 /* Dash */:\r\n        case 46 /* Period */:\r\n        case 32 /* Space */:\r\n        case 47 /* Slash */:\r\n        case 92 /* Backslash */:\r\n        case 39 /* SingleQuote */:\r\n        case 34 /* DoubleQuote */:\r\n        case 58 /* Colon */:\r\n        case 36 /* DollarSign */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isWhitespaceAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    var code = value.charCodeAt(index);\r\n    switch (code) {\r\n        case 32 /* Space */:\r\n        case 9 /* Tab */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isUpperCaseAtPos(pos, word, wordLow) {\r\n    return word[pos] !== wordLow[pos];\r\n}\r\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\r\n    while (patternPos < patternLen && wordPos < wordLen) {\r\n        if (patternLow[patternPos] === wordLow[wordPos]) {\r\n            patternPos += 1;\r\n        }\r\n        wordPos += 1;\r\n    }\r\n    return patternPos === patternLen; // pattern must be exhausted\r\n}\r\nexport var FuzzyScore;\r\n(function (FuzzyScore) {\r\n    /**\r\n     * No matches and value `-100`\r\n     */\r\n    FuzzyScore.Default = Object.freeze([-100, 0, 0]);\r\n    function isDefault(score) {\r\n        return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\r\n    }\r\n    FuzzyScore.isDefault = isDefault;\r\n})(FuzzyScore || (FuzzyScore = {}));\r\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\r\n    var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\r\n    var wordLen = word.length > _maxLen ? _maxLen : word.length;\r\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\r\n        return undefined;\r\n    }\r\n    // Run a simple check if the characters of pattern occur\r\n    // (in order) at all in word. If that isn't the case we\r\n    // stop because no match will be possible\r\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen)) {\r\n        return undefined;\r\n    }\r\n    var row = 1;\r\n    var column = 1;\r\n    var patternPos = patternStart;\r\n    var wordPos = wordStart;\r\n    // There will be a match, fill in tables\r\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\r\n        for (column = 1, wordPos = wordStart; wordPos < wordLen; column++, wordPos++) {\r\n            var score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos);\r\n            _scores[row][column] = score;\r\n            var diag = _table[row - 1][column - 1] + (score > 1 ? 1 : score);\r\n            var top_1 = _table[row - 1][column] + -1;\r\n            var left = _table[row][column - 1] + -1;\r\n            if (left >= top_1) {\r\n                // left or diag\r\n                if (left > diag) {\r\n                    _table[row][column] = left;\r\n                    _arrows[row][column] = 4 /* Left */;\r\n                }\r\n                else if (left === diag) {\r\n                    _table[row][column] = left;\r\n                    _arrows[row][column] = 4 /* Left */ | 2 /* Diag */;\r\n                }\r\n                else {\r\n                    _table[row][column] = diag;\r\n                    _arrows[row][column] = 2 /* Diag */;\r\n                }\r\n            }\r\n            else {\r\n                // top or diag\r\n                if (top_1 > diag) {\r\n                    _table[row][column] = top_1;\r\n                    _arrows[row][column] = 1 /* Top */;\r\n                }\r\n                else if (top_1 === diag) {\r\n                    _table[row][column] = top_1;\r\n                    _arrows[row][column] = 1 /* Top */ | 2 /* Diag */;\r\n                }\r\n                else {\r\n                    _table[row][column] = diag;\r\n                    _arrows[row][column] = 2 /* Diag */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (_debug) {\r\n        printTables(pattern, patternStart, word, wordStart);\r\n    }\r\n    _matchesCount = 0;\r\n    _topScore = -100;\r\n    _wordStart = wordStart;\r\n    _firstMatchCanBeWeak = firstMatchCanBeWeak;\r\n    _findAllMatches2(row - 1, column - 1, patternLen === wordLen ? 1 : 0, 0, false);\r\n    if (_matchesCount === 0) {\r\n        return undefined;\r\n    }\r\n    return [_topScore, _topMatch2, wordStart];\r\n}\r\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos) {\r\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\r\n        return -1;\r\n    }\r\n    if (wordPos === (patternPos - patternStart)) {\r\n        // common prefix: `foobar <-> foobaz`\r\n        //                            ^^^^^\r\n        if (pattern[patternPos] === word[wordPos]) {\r\n            return 7;\r\n        }\r\n        else {\r\n            return 5;\r\n        }\r\n    }\r\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\r\n        // hitting upper-case: `foo <-> forOthers`\r\n        //                              ^^ ^\r\n        if (pattern[patternPos] === word[wordPos]) {\r\n            return 7;\r\n        }\r\n        else {\r\n            return 5;\r\n        }\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\r\n        // hitting a separator: `. <-> foo.bar`\r\n        //                                ^\r\n        return 5;\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\r\n        // post separator: `foo <-> bar_foo`\r\n        //                              ^^^\r\n        return 5;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\nvar _matchesCount = 0;\r\nvar _topMatch2 = 0;\r\nvar _topScore = 0;\r\nvar _wordStart = 0;\r\nvar _firstMatchCanBeWeak = false;\r\nfunction _findAllMatches2(row, column, total, matches, lastMatched) {\r\n    if (_matchesCount >= 10 || total < -25) {\r\n        // stop when having already 10 results, or\r\n        // when a potential alignment as already 5 gaps\r\n        return;\r\n    }\r\n    var simpleMatchCount = 0;\r\n    while (row > 0 && column > 0) {\r\n        var score = _scores[row][column];\r\n        var arrow = _arrows[row][column];\r\n        if (arrow === 4 /* Left */) {\r\n            // left -> no match, skip a word character\r\n            column -= 1;\r\n            if (lastMatched) {\r\n                total -= 5; // new gap penalty\r\n            }\r\n            else if (matches !== 0) {\r\n                total -= 1; // gap penalty after first match\r\n            }\r\n            lastMatched = false;\r\n            simpleMatchCount = 0;\r\n        }\r\n        else if (arrow & 2 /* Diag */) {\r\n            if (arrow & 4 /* Left */) {\r\n                // left\r\n                _findAllMatches2(row, column - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\r\n                matches, lastMatched);\r\n            }\r\n            // diag\r\n            total += score;\r\n            row -= 1;\r\n            column -= 1;\r\n            lastMatched = true;\r\n            // match -> set a 1 at the word pos\r\n            matches += Math.pow(2, (column + _wordStart));\r\n            // count simple matches and boost a row of\r\n            // simple matches when they yield in a\r\n            // strong match.\r\n            if (score === 1) {\r\n                simpleMatchCount += 1;\r\n                if (row === 0 && !_firstMatchCanBeWeak) {\r\n                    // when the first match is a weak\r\n                    // match we discard it\r\n                    return undefined;\r\n                }\r\n            }\r\n            else {\r\n                // boost\r\n                total += 1 + (simpleMatchCount * (score - 1));\r\n                simpleMatchCount = 0;\r\n            }\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    total -= column >= 3 ? 9 : column * 3; // late start penalty\r\n    // dynamically keep track of the current top score\r\n    // and insert the current best score at head, the rest at tail\r\n    _matchesCount += 1;\r\n    if (total > _topScore) {\r\n        _topScore = total;\r\n        _topMatch2 = matches;\r\n    }\r\n}\r\n//#endregion\r\n//#region --- graceful ---\r\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\r\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\r\n}\r\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\r\n    var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n    if (top && !aggressive) {\r\n        // when using the original pattern yield a result we`\r\n        // return it unless we are aggressive and try to find\r\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\r\n        return top;\r\n    }\r\n    if (pattern.length >= 3) {\r\n        // When the pattern is long enough then try a few (max 7)\r\n        // permutations of the pattern to find a better match. The\r\n        // permutations only swap neighbouring characters, e.g\r\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\r\n        var tries = Math.min(7, pattern.length - 1);\r\n        for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\r\n            var newPattern = nextTypoPermutation(pattern, movingPatternPos);\r\n            if (newPattern) {\r\n                var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n                if (candidate) {\r\n                    candidate[0] -= 3; // permutation penalty\r\n                    if (!top || candidate[0] > top[0]) {\r\n                        top = candidate;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return top;\r\n}\r\nfunction nextTypoPermutation(pattern, patternPos) {\r\n    if (patternPos + 1 >= pattern.length) {\r\n        return undefined;\r\n    }\r\n    var swap1 = pattern[patternPos];\r\n    var swap2 = pattern[patternPos + 1];\r\n    if (swap1 === swap2) {\r\n        return undefined;\r\n    }\r\n    return pattern.slice(0, patternPos)\r\n        + swap2\r\n        + swap1\r\n        + pattern.slice(patternPos + 2);\r\n}\r\n//#endregion\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}