{"ast":null,"code":"import { getType, locate } from './mitsuketa';\nvar err = {\n  getCaller: function getCaller() {\n    var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    // A somewhat hacky solution that will yield different results in different JS engines. \n    // Since we only call this function when an error will actually be thrown we typically don't \n    // rally mind the performance impact this might have if called too often.\n    // Lucky for us we use nodeJS and thus only V8.\n    var stackTrace = new Error().stack;\n    var callerName = stackTrace.replace(/^Error\\s+/, '');\n    callerName = callerName.split(\"\\n\")[skip];\n    callerName = callerName.replace(/^\\s+at Object./, '').replace(/^\\s+at /, '').replace(/ \\(.+\\)$/, '');\n    return callerName;\n  },\n  throwError: function throwError() {\n    var fxName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown function';\n    var paramName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown parameter';\n    var expectation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'to be defined';\n    throw ['@', fxName, '(): Expected parameter \\'', paramName, '\\' ', expectation].join('');\n  },\n  isUndefined: function isUndefined() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    if ([null, undefined].indexOf(param) > -1) err.throwError(err.getCaller(2), paramName);\n  },\n  isFalsy: function isFalsy() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    if (!param) err.throwError(err.getCaller(2), paramName);\n  },\n  isNoneOf: function isNoneOf() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var contains = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (contains.indexOf(param) === -1) err.throwError(err.getCaller(2), paramName, 'to be any of' + JSON.stringify(contains));\n  },\n  isAnyOf: function isAnyOf() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var contains = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (contains.indexOf(param) > -1) err.throwError(err.getCaller(2), paramName, 'not to be any of' + JSON.stringify(contains));\n  },\n  isNotType: function isNotType() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    if (getType(param) !== type.toLowerCase()) err.throwError(err.getCaller(2), paramName, 'to be type ' + type.toLowerCase());\n  },\n  isAnyTypeOf: function isAnyTypeOf() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var types = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    types.forEach(function (type) {\n      if (getType(param) === type) err.throwError(err.getCaller(2), paramName, 'not to be type of ' + type.toLowerCase());\n    });\n  },\n  missingKey: function missingKey() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var keyName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    err.isUndefined(paramName, param);\n    if (Object.keys(param).indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n  },\n  missingAnyKeys: function missingAnyKeys() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var keyNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [''];\n    err.isUndefined(paramName, param);\n    var keyList = Object.keys(param);\n    keyNames.forEach(function (keyName) {\n      if (keyList.indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n    });\n  },\n  containsUndefined: function containsUndefined() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    [undefined, null].forEach(function (value) {\n      var location = locate(param, value);\n      if (location) err.throwError(err.getCaller(2), paramName, 'not to contain \\'' + JSON.stringify(value) + '\\' at ' + location);\n    });\n  },\n  isInvalidPath: function isInvalidPath() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    err.isUndefined(paramName, param);\n    err.isNotType(paramName, param, 'string');\n    err.isAnyOf(paramName, param, ['', '/']);\n    '.$[]#'.split().forEach(function (invalidChar) {\n      if (param.indexOf(invalidChar) > -1) err.throwError(err.getCaller(2), paramName, 'not to contain invalid character \\'' + invalidChar + '\\'');\n    });\n    if (param.match(/\\/{2,}/g)) err.throwError(err.getCaller(2), paramName, 'not to contain consecutive forward slash characters');\n  },\n  isInvalidWriteData: function isInvalidWriteData() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    err.isUndefined(paramName, param);\n    err.containsUndefined(paramName, param);\n  }\n};\nexport default err;","map":{"version":3,"names":["getType","locate","err","getCaller","skip","stackTrace","Error","stack","callerName","replace","split","throwError","fxName","paramName","expectation","join","isUndefined","param","undefined","indexOf","isFalsy","isNoneOf","contains","JSON","stringify","isAnyOf","isNotType","type","toLowerCase","isAnyTypeOf","types","forEach","missingKey","keyName","Object","keys","missingAnyKeys","keyNames","keyList","containsUndefined","value","location","isInvalidPath","invalidChar","match","isInvalidWriteData"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/react-json-editor-ajrm/es/err.js"],"sourcesContent":["import { getType, locate } from './mitsuketa';\nconst err = {\n  getCaller: (skip = 1) => {\n    // A somewhat hacky solution that will yield different results in different JS engines. \n    // Since we only call this function when an error will actually be thrown we typically don't \n    // rally mind the performance impact this might have if called too often.\n    // Lucky for us we use nodeJS and thus only V8.\n    const stackTrace = new Error().stack;\n    var callerName = stackTrace.replace(/^Error\\s+/, '');\n    callerName = callerName.split(\"\\n\")[skip];\n    callerName = callerName.replace(/^\\s+at Object./, '').replace(/^\\s+at /, '').replace(/ \\(.+\\)$/, '');\n    return callerName;\n  },\n  throwError: (fxName = 'unknown function', paramName = 'unknown parameter', expectation = 'to be defined') => {\n    throw ['@', fxName, '(): Expected parameter \\'', paramName, '\\' ', expectation].join('');\n  },\n  isUndefined: (paramName = '<unknown parameter>', param) => {\n    if ([null, undefined].indexOf(param) > -1) err.throwError(err.getCaller(2), paramName);\n  },\n  isFalsy: (paramName = '<unknown parameter>', param) => {\n    if (!param) err.throwError(err.getCaller(2), paramName);\n  },\n  isNoneOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) === -1) err.throwError(err.getCaller(2), paramName, 'to be any of' + JSON.stringify(contains));\n  },\n  isAnyOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) > -1) err.throwError(err.getCaller(2), paramName, 'not to be any of' + JSON.stringify(contains));\n  },\n  isNotType: (paramName = '<unknown parameter>', param, type = '') => {\n    if (getType(param) !== type.toLowerCase()) err.throwError(err.getCaller(2), paramName, 'to be type ' + type.toLowerCase());\n  },\n  isAnyTypeOf: (paramName = '<unknown parameter>', param, types = []) => {\n    types.forEach(type => {\n      if (getType(param) === type) err.throwError(err.getCaller(2), paramName, 'not to be type of ' + type.toLowerCase());\n    });\n  },\n  missingKey: (paramName = '<unknown parameter>', param, keyName = '') => {\n    err.isUndefined(paramName, param);\n    if (Object.keys(param).indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n  },\n  missingAnyKeys: (paramName = '<unknown parameter>', param, keyNames = ['']) => {\n    err.isUndefined(paramName, param);\n    const keyList = Object.keys(param);\n    keyNames.forEach(keyName => {\n      if (keyList.indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n    });\n  },\n  containsUndefined: (paramName = '<unknown parameter>', param) => {\n    [undefined, null].forEach(value => {\n      const location = locate(param, value);\n      if (location) err.throwError(err.getCaller(2), paramName, 'not to contain \\'' + JSON.stringify(value) + '\\' at ' + location);\n    });\n  },\n  isInvalidPath: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.isNotType(paramName, param, 'string');\n    err.isAnyOf(paramName, param, ['', '/']);\n    '.$[]#'.split().forEach(invalidChar => {\n      if (param.indexOf(invalidChar) > -1) err.throwError(err.getCaller(2), paramName, 'not to contain invalid character \\'' + invalidChar + '\\'');\n    });\n    if (param.match(/\\/{2,}/g)) err.throwError(err.getCaller(2), paramName, 'not to contain consecutive forward slash characters');\n  },\n  isInvalidWriteData: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.containsUndefined(paramName, param);\n  }\n};\nexport default err;"],"mappings":"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"},"metadata":{},"sourceType":"module"}