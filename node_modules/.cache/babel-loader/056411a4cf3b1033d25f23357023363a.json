{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\akash\\\\Desktop\\\\agat project\\\\CLientapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"C:\\\\Users\\\\akash\\\\Desktop\\\\agat project\\\\CLientapp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nvar _this = this,\n  _jsxFileName = \"C:\\\\Users\\\\akash\\\\Desktop\\\\agat project\\\\CLientapp\\\\src\\\\containers\\\\Mapper\\\\blockValidation.js\";\nimport React from 'react';\nimport Blockly from 'blockly/core';\nimport { errorModal, getStudyID, validJSON, strLowerCase, CallServerPost, showProgress, hideProgress, isObject, isArray, isNotNull, errorModalCallback, isObjectCheck } from '../Utility/sharedUtility';\nimport { Block } from '../Program/Blockly';\nvar unique = [];\nvar msg = [];\nexport var checkXML = function checkXML(usedBlocks) {\n  var returnOnlyMsgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  //Unique variable to check if multiple same type block exist means it check  for one block\n  msg = [];\n  var errors = [];\n  usedBlocks.map(function (block) {\n    var blocktype = block.type;\n    //condn to check root of the block is step category\n    if (block.getRootBlock().highPriority) {\n      if (validator[blocktype]) {\n        var _msg = validator[blocktype](block);\n        if (_msg) {\n          typeof _msg === \"string\" ? errors.push(_msg) : errors.push.apply(errors, _toConsumableArray(_msg));\n        }\n      }\n    }\n  });\n  if (!returnOnlyMsgs) {\n    if (errors.length > 0) {\n      var errorMsg = [];\n      errors.map(function (er, i) {\n        //the following if remove duplicates\n        if (er && errors.indexOf(er) === i) {\n          errorMsg.push( /*#__PURE__*/React.createElement(\"div\", {\n            key: errorMsg.length + 1,\n            __self: _this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 39,\n              columnNumber: 35\n            }\n          }, errorMsg.length + 1, \". \", er));\n        }\n      });\n      errorModal(errorMsg);\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return errors;\n  }\n};\nvar validator = {\n  map_type: function map_type(block) {\n    //About Map Block\n    //This Block have two arguments\n    //1.Statement argument name @Map\n    // Map statement Accepts only one Dataset.--> this check will happen inbuilt \n    //2.Statement argument name @Conditions\n    //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\n    //Condition may be single or multiple\n    //Following fn will check Map statement block have one or multiple input.\n    //mandatory check.\n\n    //Map Statement\n    var mapBlk_firstChild = block.getInputTargetBlock(\"map_value\");\n    var mapBlk_secondChild = mapBlk_firstChild ? mapBlk_firstChild.getNextBlock() : false;\n\n    //Condn statement\n    var condnBlock_firstChild = block.getInputTargetBlock(\"conditions\");\n    if (!mapBlk_firstChild || !condnBlock_firstChild) {\n      return \"Map block arguments should not be empty. Find any built in validations available in blockly.\";\n    }\n    if (mapBlk_secondChild) {\n      return \"Only one argument is allowed for Map.\";\n    }\n  },\n  date_type: function date_type(block) {\n    //About Date Block\n    //This Block have one statement argument\n    //1.StatementBlock \n    //Accepts only one variable (Source,Target,Work)--> this check will happen inbuilt \n    //Following fn will check statement block have one or multiple input\n    var dropDownValue = block.getFieldValue(\"op_name\");\n    var dateBlk_firstChild = block.getInputTargetBlock(\"input_block\");\n    var dateBlk_secondChild = dateBlk_firstChild ? dateBlk_firstChild.getNextBlock() : false;\n    return !dateBlk_firstChild ? dropDownValue + \" block arguments should not be empty. Find any built in validations available in blockly.\" : dateBlk_secondChild && !dropDownValue.toLowerCase().includes(\"datetime\") ? \"Only one argument is allowed for \" + dropDownValue + \".\" : \"\";\n  },\n  hardcode_type: function hardcode_type(block) {\n    //About Hardcode Block\n    //This Block have one statement argument name @Hardcode\n    //HardCode accepts only String / Integer literal. --> this check will happen inbuilt \n    //Following fn will check statement block have one or multiple input\n\n    var hardcode_firstChild = block.getInputTargetBlock(\"hardcode_statement\");\n    var hardcode_secondChild = hardcode_firstChild ? hardcode_firstChild.getNextBlock() : false;\n    return !hardcode_firstChild ? \"Hardcode block arguments should not be empty. Find any built in validations available in blockly.\" : hardcode_secondChild ? \"Only one argument is allowed for Hardcode.\" : \"\";\n  },\n  find_replace_type: function find_replace_type(block) {\n    //About FindAndReplaceType Block\n    //This Block have three arguments\n    //1.Statement argument name @FindAndReplace\n    //Accepts only Variable(Source,Target,Work) for first argument  --> this check will happen inbuilt\n    //2.Textbox argument name @Find\n    //3.TextBox argument name @Replace\n    //Following fn will check FindAndReplace statement argument have one or multiple input\n    //All fileds mandatory check\n\n    //FindAndReplace\n    var findReplace_firstChild = block.getInputTargetBlock(\"fr_statement\");\n    var findReplace_secondChild = findReplace_firstChild ? findReplace_firstChild.getNextBlock() : false;\n\n    //Find Textbox\n    var findText = block.getFieldValue(\"input_string_extra\");\n\n    //Replace Textbox\n    var replaceText = block.getFieldValue(\"input_replace_string_extra\");\n    var err = [];\n    if (!(findReplace_firstChild && findText && replaceText)) {\n      err.push(\"FindAndReplace block arguments should not be empty. Find any built in validations available in blockly.\");\n    }\n    if (findReplace_secondChild) {\n      err.push(\"Only one argument is allowed for FindAndReplace.\");\n    }\n    return err;\n  },\n  sort_operations: function sort_operations(block) {\n    //About Sort Block\n    //This Block have one statement argument\n    //Accepts only one Variable(Source,Target,Work) --> this check will happen inbuilt\n    //Following fn will check Sort statement argument have one or multiple input\n    //All fileds mandatory check\n\n    var sort_firstChild = block.getInputTargetBlock(\"op_values\");\n    var sort_secondChild = sort_firstChild ? sort_firstChild.getNextBlock() : false;\n    return !sort_firstChild ? \"Sort block arguments should not be empty. Find any built in validations available in blockly.\" : sort_secondChild ? \"Only one argument is allowed for Sort.\" : \"\";\n  },\n  sort_variable_operation: function sort_variable_operation(block) {\n    //About Sort Variable Operation Block\n    //This Block have two arguments\n    //1.Statement argument name @Sort\n    //Accepts only Dataset --> this check will happen inbuilt\n    //2.Statement argument name @By Variables\n    //Accepts only Variables  --> this check will happen inbuilt\n    //Accepts Variables that only from the used dataset in Sort statement \n    //Following fn will check @By Variables accepts Variables that only from the used dataset in Sort statement\n    //Following fn will check @Sort statement argument accepts only one dataset\n    //All fileds mandatory check\n\n    var isVarBlkNotFromSameDataset = false;\n    var isNotVarBlock = false;\n    var err = [];\n\n    //get sort Statement Block\n    var sort_statementBlk_firstChild = block.getInputTargetBlock(\"sort_variable\");\n    var sort_statementBlk_secondChild = sort_statementBlk_firstChild ? sort_statementBlk_firstChild.getNextBlock() : false;\n\n    //get sort by variable statement block \n    var by_var = block.getInputTargetBlock(\"by_variables\");\n    if (!sort_statementBlk_firstChild || !by_var) {\n      err.push(\"Sort block arguments should not be empty. Find any built in validations available in blockly.\");\n    }\n    if (sort_statementBlk_firstChild) {\n      if (sort_statementBlk_firstChild && sort_statementBlk_secondChild) {\n        err.push(\"Sort accepts only one Dataset.\");\n      }\n\n      //by variable validation\n      if ('data' in sort_statementBlk_firstChild && sort_statementBlk_firstChild.data !== null) {\n        var sort_statementBlkData = JSON.parse(sort_statementBlk_firstChild.data);\n        var sortDatasetName = sort_statementBlkData.blockType === \"Source\" ? sort_statementBlkData.TABLE_NAME : sort_statementBlkData.blockType === \"Target\" ? sort_statementBlkData.domain : sort_statementBlkData.name;\n        var get_var = function get_var(b) {\n          if (b && typeof b === \"object\") {\n            if (isVariableType(b.type)) {\n              if ('data' in b && b.data !== null) {\n                var data = JSON.parse(b.data);\n                // Variable based on source dataset\n                if ('TABLE_NAME' in data) {\n                  if (!isVarBlkNotFromSameDataset && sortDatasetName !== data.TABLE_NAME) {\n                    err.push(\"By Variables should be from \" + sortDatasetName + \".\");\n                    isVarBlkNotFromSameDataset = true;\n                  }\n                } //Variable based on Target dataset\n                else if ('cdiscDataStdDomainMetadataID' in data) {\n                  if (!isVarBlkNotFromSameDataset && sortDatasetName !== data.domain) {\n                    err.push(\"By Variables should be from \" + sortDatasetName + \".\");\n                    isVarBlkNotFromSameDataset = true;\n                  }\n                } else if ('name' in data) {\n                  if (!isVarBlkNotFromSameDataset && sortDatasetName !== data.name) {\n                    err.push(\"By Variables should be from \" + sortDatasetName + \".\");\n                    isVarBlkNotFromSameDataset = true;\n                  }\n                }\n                if (isVarBlkNotFromSameDataset && isNotVarBlock) {\n                  return;\n                }\n                var nxtConnectedBlock = b.getNextBlock();\n                get_var(nxtConnectedBlock);\n              } else if (!isVariableType(block.type)) {\n                isNotVarBlock = true;\n              }\n            } else {\n              isNotVarBlock = true;\n            }\n          }\n        };\n        if (by_var) {\n          get_var(by_var);\n        }\n\n        //Sort Statement validation End\n        if (isNotVarBlock) {\n          err.push(\"By Variable Should accept only Variables.\");\n        }\n        return err;\n      }\n    }\n    return err;\n  },\n  simple_ops_mutiple_args_type: function simple_ops_mutiple_args_type(block) {\n    //About simple_ops_mutiple_args_type\n    //This block have two argument(1,2)\n    //1.Dropdown argument (DirectMove,NumToChar,CharToNum,UpperCase,LowerCase).\n    //2.Statment argument ,\n    //Statement argument accepts Variable --> this check will happen inbuilt,\n    //Following fn will check statement argument accepts only one input.\n    //All fileds mandatory check\n\n    var dropDownValue = block.getFieldValue(\"op_name\");\n    var statementBlk_firstChild = block.getInputTargetBlock(\"input_block\");\n    var statementBlk_secondChild = statementBlk_firstChild ? statementBlk_firstChild.getNextBlock() : false;\n    if (!statementBlk_firstChild) {\n      return dropDownValue + \" block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else if (statementBlk_secondChild) {\n      return \"Only one argument is allowed for \" + dropDownValue + \".\";\n    }\n  },\n  complex_ops_multi: function complex_ops_multi(block) {\n    //About complex_ops_multi\n    //This block have three arguments\n    //1.Dropdown argument (Group Min,Max,Avg,Sum).\n    //2.Statment argument name @ By Variables,\n    //By Variables accepts Variable --> this check will happen inbuilt,\n    //2.Statment argument name @ ID Variables,\n    //ID Variables accepts Variable --> this check will happen inbuilt,\n    //Following fn will check both By and ID Variables from same dataset.\n    //Following fn will check ID Variables accepts only one input.\n    //All fileds mandatory check\n\n    var isVarBlkNotFromSameDataset = false;\n    var isNotVarBlock = false;\n    var dataset = [];\n    var err = [];\n    var dropDownValue = block.getFieldValue(\"op_name\");\n\n    //This below get_var function called at end of this function\n    var get_var = function get_var(b) {\n      if (b && typeof b === \"object\") {\n        if (isVariableType(b.type)) {\n          if ('data' in b && b.data !== null) {\n            var data = JSON.parse(b.data);\n\n            // Variable based on source dataset\n            if ('TABLE_NAME' in data) {\n              if (dataset.length === 0) {\n                dataset.push(data.TABLE_NAME);\n              } else if (dataset.indexOf(data.TABLE_NAME) === -1) {\n                isVarBlkNotFromSameDataset = true;\n              }\n            }\n            //Variable based on Target dataset\n            else if ('cdiscDataStdDomainMetadataID' in data) {\n              if (dataset.length === 0) {\n                dataset.push(data.domain);\n              } else if (dataset.indexOf(data.domain) === -1) {\n                isVarBlkNotFromSameDataset = true;\n              }\n            }\n            if (isVarBlkNotFromSameDataset && isNotVarBlock) {\n              return;\n            }\n            var nxtConnectedBlock = b.getNextBlock();\n            get_var(nxtConnectedBlock);\n          } else if (!isVariableType(block.type)) {\n            isNotVarBlock = true;\n          }\n        } else {\n          isNotVarBlock = true;\n        }\n      }\n    };\n\n    //get used variable block from by_variables statement in complex_ops_multi\n    var by_var = block.getInputTargetBlock(\"by_variables\");\n\n    ////get used variable block from ID statement in complex_ops_multi\n    var id_var = block.getInputTargetBlock(\"id_variable\");\n    if (!(id_var && typeof id_var === \"object\") || !(by_var && typeof by_var === \"object\")) {\n      err.push(dropDownValue + \" block argument should not be empty. Find any built in validations available in blockly.\");\n    }\n\n    //get used variable block from by_variables statement in complex_ops_multi\n    get_var(by_var);\n\n    //get used variable block from ID statement in complex_ops_multi\n    if (id_var && typeof id_var === \"object\") {\n      if (isVariableType(id_var.type)) {\n        if (id_var && typeof id_var === \"object\" && id_var.getNextBlock()) {\n          err.push(\"ID Variables accepts only one Variables.\");\n        }\n        get_var(id_var);\n      } else {\n        err.push(\"ID Variables accepts only Variables.\");\n      }\n    }\n    if (isVarBlkNotFromSameDataset) {\n      err.push(\"BY/ID Variables should be from \" + dataset[0] + \".\");\n    }\n    if (isNotVarBlock) {\n      err.push(\"BY/ID Variables accepts only Variables.\");\n    }\n    return err;\n  },\n  merge_type: function merge_type(block) {\n    //About Merge Block\n    //This block have two arguments (1,2)\n    //1.Statment argument name @Merge,\n    //Merge accepts only dataset(Source,Target,Work) --> this check will happen inbuilt,\n    //2.Statment argument name @By Variables,\n    //By Variables accepts only drop type variables(Source,Target,Work) --> this check will happen inbuilt,\n    //Following fn will check Merge argument should allow two dataset\n    //Following fn will check By Variables arguments are should be common variable of Merge two dataset\n    //All fileds mandatory check\n\n    var err = [];\n    //First argument StatementBlk\n    var datasetBlk_firstChild = block.getInputTargetBlock(\"datasets_to_merge\");\n    var datasetBlk_secondChild = datasetBlk_firstChild ? datasetBlk_firstChild.getNextBlock() : false;\n\n    //Second argument Statement Block\n    var byVarBlk_firstChild = block.getInputTargetBlock(\"by_variables\");\n\n    //Last Field \n    var text = block.getFieldValue(\"if_condition_extra\");\n    if (!(datasetBlk_firstChild && byVarBlk_firstChild && text)) {\n      err.push(\"Merge block arguments should not be empty. Find any built in validations available in blockly.\");\n    }\n\n    //First StatementBlock (@Merge Block) accept only two datasets\n    if (datasetBlk_firstChild) {\n      if (datasetBlk_secondChild && !datasetBlk_secondChild.getNextBlock()) {\n        //get Two DataSet UniqueIDs\n        var datasetBlockIDs = [];\n        (function () {\n          //get Two DataSet UniqueIDs \n          //for to match with Varibles used in second statement block\n          var firstDatasetBlk = datasetBlk_firstChild;\n          var data1 = validJSON(firstDatasetBlk.data);\n          var secondDatasetBlk = datasetBlk_secondChild;\n          var data2 = validJSON(secondDatasetBlk.data);\n          datasetBlockIDs = [data1.primaryID, data2.primaryID];\n        })();\n\n        //Fn to check used Variable Blocks are from used datasets Blocks\n        var isVarType = true;\n        var commonVariable = true;\n        var varBlockFn = function varBlockFn(varBlk) {\n          if (varBlk && typeof varBlk === \"object\") {\n            if (isVariableType(varBlk.type)) {\n              var data = validJSON(varBlk.data);\n              if (!data.bothParentDataset || datasetBlockIDs.toString() !== data.bothParentDataset) {\n                commonVariable = false;\n                err.push(\"By variables should be from the datasets used in Merge Argument.\");\n              }\n            } else {\n              isVarType = false;\n              err.push(\"By Variables Should accept only Variables.\");\n            }\n            var nxtBlock = varBlk.getNextBlock();\n            if ((isVarType || commonVariable) && nxtBlock) {\n              varBlockFn(nxtBlock);\n            }\n          }\n        };\n        varBlockFn(byVarBlk_firstChild);\n      } else {\n        err.push(\"Merge should accept two Datasets.\");\n      }\n    }\n    return err;\n  },\n  input_format_type: function input_format_type(block) {\n    //About Input Format block\n    //This block have one arguments(1)\n    //1.Textbox arguments\n    //Following fn to check Input Format allow only \"C\" or \"N\"\n    //All fileds mandatory check\n    var textboxValue = block.getFieldValue(\"input_format\");\n    if (!textboxValue || textboxValue === \"\") {\n      return \"Input Format should not be empty.\";\n    }\n    //else if (textboxValue &&\n    //           (textboxValue.toLowerCase() !== \"c\" ||\n    //    textboxValue.toLowerCase() !== \"n\"))\n    //{\n    //    return \"Input Format should allow either C or N.\" \n    //}\n  },\n\n  output_format_type: function output_format_type(block) {\n    //About Output Format block\n    //This block have one arguments(1)\n    //1.Textbox arguments\n    //Following fn to check Input Format allow only \"C\" or \"N\"\n    //All fileds mandatory check\n    var textboxValue = block.getFieldValue(\"output_format\");\n    if (!textboxValue || textboxValue === \"\") {\n      return \"Output Format should not be empty.\";\n    }\n    //else if (textboxValue &&\n    //    (textboxValue.toLowerCase() !== \"c\" ||\n    //    textboxValue.toLowerCase() !== \"n\")) {\n    //    return \"Output Format should allow either C or N.\"\n    //}\n  },\n\n  id_variable_type: function id_variable_type(block) {\n    //About ID Variable block\n    //This block have one arguments (1)\n    //1.Statment argument name @ID Variable,\n    //Accepts only variable(Source,Target,Work) --> this check will happen inbuilt,\n    //Following fn will check @ID Variable argument variable are single or multiple\n    //All fileds mandatory check\n\n    var statement_firstChild = block.getInputTargetBlock(\"id_variable\");\n    var statement_secondChild = statement_firstChild ? statement_firstChild.getNextBlock() : false;\n    return !statement_firstChild ? \"ID Variable block should not be empty. Find any built in validations available in blockly.\" : statement_secondChild ? \"ID Variable block accepts only one variable.\" : \"\";\n  },\n  arithmatic_operations: function arithmatic_operations(block) {\n    //About Arithmatic Operations block\n    //This block have two arguments (1,2)\n    //1.Dropdown argument [Add,Sub,Mul,Div],\n    //2.Statement argument\n    //Accepts only variable(Source,Target,Work) and int_constant_type_multi --> this check will happen inbuilt,\n    //Following fn will check Statement argument value should be int_constant_type_multi and varibale\n    //All fileds mandatory check\n\n    var dropDownValue = block.getFieldValue(\"arithmatic_operations\");\n\n    //Statement Argument\n    var firstChild = block.getInputTargetBlock(\"op_values\");\n    var err = [];\n    if (!firstChild) {\n      return dropDownValue + \" should not be empty. Find any built in validations available in blockly.\";\n    } else {\n      var checkOnlyVarTypeOrIntLiteral = function checkOnlyVarTypeOrIntLiteral(blk) {\n        if (blk && typeof blk === \"object\") {\n          if (isVariableType(blk.type) || blk.type === \"int_constant_type_multi\") {\n            var nxtBlk = blk.getNextBlock();\n            checkOnlyVarTypeOrIntLiteral(nxtBlk);\n          } else {\n            err.push(dropDownValue + \" should accept only Variable or Int Literal.\");\n            return false;\n          }\n        }\n      };\n      checkOnlyVarTypeOrIntLiteral(firstChild);\n      return err;\n    }\n  },\n  rename_type: function rename_type(block) {\n    //About Rename block\n    //This block have one arguments (1)\n    //1.Textbox argument,\n    //All fileds mandatory check\n    var textboxValue = block.getFieldValue(\"rename_var\");\n    return textboxValue === \"\" ? \"Rename block should not be empty. Find any built in validations available in blockly.\" : parseInt(textboxValue) ? \"Rename block should accept only string.\" : \"\";\n  },\n  compress_type: function compress_type(block) {\n    //About Compress Block\n    //This block have Three arguments (1,2,3)\n    //1.StatementBlock name @Compress\n    //Accepts only variable (Source,Target,Work)--> this check will happen inbuilt \n    //2.Textbox arguments name @To Remove\n    //3.Textbox arguments name @Modifier\n    //Following fn will check Compress statement block have one or multiple input\n\n    var err = [];\n    //Compress statement block\n    var firstChild = block.getInputTargetBlock(\"compressvariable\");\n    var secondChild = firstChild ? firstChild.getNextBlock() : false;\n\n    //@To Remove textbox\n    var remove = block.getFieldValue(\"remove\");\n    //Modifier Textbox\n    var modifier = block.getFieldValue(\"modifier\");\n    if (!firstChild) {\n      err.push(\"Compress block arguments should not be empty. Find any built in validations available in blockly.\");\n    }\n    if (secondChild) {\n      err.push(\"Compress block should accept only one Variables.\");\n    }\n    return err;\n  },\n  filter_type: function filter_type(block) {\n    //About Filter Variable block\n    //This block have one arguments (1,2)\n    //1.Statment argument name @Filter,\n    //Accepts only Dataset(Source,Target,Work) --> this check will happen inbuilt,\n    //2.Statment argument name @Condition,\n    //Accepts only condition --> this check will happen inbuilt,\n    //Following fn will check @ID Variable argument variable are single or multiple\n    //All fileds mandatory check\n\n    var err = [];\n    //first argument\n    var filter_firstChild = block.getInputTargetBlock(\"filter_value\");\n    var filter_secondChild = filter_firstChild ? filter_firstChild.getNextBlock() : false;\n\n    //second argument\n    var condnArg_firstChild = block.getInputTargetBlock(\"filter_condition\");\n    if (!condnArg_firstChild || !filter_firstChild) {\n      err.push(\"Filter block argumnets should not be empty. Find any built in validations available in blockly.\");\n    }\n    if (filter_firstChild) {\n      if (filter_secondChild) {\n        err.push(\"Filter block argumnets accepts only one Dataset.\");\n      }\n    }\n    return err;\n  },\n  set_type: function set_type(block) {\n    //About Set block\n    //This block have one arguments (1)\n    //1.Statement argument name @Set,\n    //All fileds mandatory check\n\n    var statement = block.getInputTargetBlock(\"set_statement\");\n    return !statement ? \"Set block should not be empty. Find any built in validations available in blockly.\" : \"\";\n  },\n  eq_type: function eq_type(block) {\n    //About eq_type block\n    //This block have two arguments (1,2,3)\n    //Dropdown values \n    //1.Statement argument  ,\n    //2.Statement argument  ,\n    //All fileds mandatory check\n    //First statement\n    var dropdownvalue = block.getFieldValue(\"operator_name\");\n    var statement_left = block.getInputTargetBlock(\"left_values\");\n    var statement_right = block.getInputTargetBlock(\"right_values\");\n    return !statement_left || !statement_right ? dropdownvalue + \" arguments should not be empty. Find any built in validations available in blockly.\" : \"\";\n  },\n  andor_type: function andor_type(block) {\n    //About andor_type block\n    //This block have two arguments (1,2,3)\n    //Dropdown values \n    //1.Statement argument  ,\n    //2.Statement argument  ,\n    //All fileds mandatory check\n\n    var dropdownvalue = block.getFieldValue(\"operator\");\n    var statement_left = block.getInputTargetBlock(\"left_value\");\n    var statement_right = block.getInputTargetBlock(\"right_value\");\n    return !statement_left || !statement_right ? dropdownvalue + \" arguments should not be empty. Find any built in validations available in blockly.\" : \"\";\n  },\n  condition_type: function condition_type(block) {\n    //About Condition_Then block\n    //This block have two arguments (1,2)\n    //1.Statement argument  ,\n    //2.Statement argument  ,\n    //All fileds mandatory check\n\n    //First statement\n    var statement_firstChild = block.getInputTargetBlock(\"Condition\");\n    var statement_secondChild = block.getInputTargetBlock(\"Then\");\n    return !statement_firstChild || !statement_secondChild ? \"Condition block arguments should not be empty. Find any built in validations available in blockly.\" : \"\";\n  },\n  where_type: function where_type(block) {\n    //About Where block\n    //This block have two argument (1)\n    //1.Statement argument  ,\n    //All fileds mandatory check\n\n    //First statement\n    var statement = block.getInputTargetBlock(\"where_value\");\n    return !statement ? \"Where block arguments should not be empty. Find any built in validations available in blockly.\" : \"\";\n  },\n  concatenate_type: function concatenate_type(block) {\n    //About concatenate block\n    //This block have one argument (1)\n    //1.Statement argument  ,\n    //All fileds mandatory check\n\n    //First statement\n    var statement = block.getInputTargetBlock(\"concatenate_statement\");\n    if (!statement) {\n      return \"Concatenate block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else {\n      var err = {\n        intLitPresent: false,\n        isVarBlkPresent: false,\n        minBlk: 2,\n        msg: []\n      };\n      var checkOnlyVarType = function checkOnlyVarType(blk, index) {\n        if (blk && typeof blk === \"object\") {\n          if (!err.intLitPresent && blk.type === \"int_constant_type_multi\") {\n            err.intLitPresent = !err.intLitPresent;\n            err.msg.push(\"Concatenate block should accept only string literal and variable block.\");\n          }\n          if (!err.isVarBlkPresent && isVariableType(blk.type)) {\n            err.isVarBlkPresent = !err.isVarBlkPresent;\n          }\n          var nxtBlk = blk.getNextBlock();\n          //loop control\n\n          if (nxtBlk && (!err.intLitPresent || !err.isVarBlkPresent)) {\n            return checkOnlyVarType(nxtBlk, index + 1);\n          } else {\n            if (index === 1) {\n              err.msg.push(\"Concatenate should have minimum 2 blocks \");\n            }\n            return !err.isVarBlkPresent ? [].concat(_toConsumableArray(err.msg), [\"Concatenate block should accept atleast one variable.\"]) : err.msg;\n          }\n        }\n      };\n      return checkOnlyVarType(statement, 1);\n    }\n  },\n  sort_seq_type: function sort_seq_type(block) {\n    //About sort_seq block\n    //This block have one argument (1)\n    //1.Statement argument  ,\n    //All fileds mandatory check\n\n    var err = [];\n    //First statement\n    var statement = block.getInputTargetBlock(\"by_variables\");\n    if (!statement) {\n      return \"Seq By Variables block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else {\n      //Check DataType it shoul be variable \n      var dataType_check_err = false;\n      //Variable should be from same dataset\n      var var_from_same_dataset_check_err = false;\n      var data = JSON.parse(statement.data);\n      var fromDatasetName = \"TABLE_NAME\" in data ? data.TABLE_NAME : data.domain;\n      var is_variable_from_samedataset = function is_variable_from_samedataset(blk) {\n        if (blk && typeof blk === \"object\") {\n          if (isVariableType(blk.type)) {\n            if ('data' in blk && blk.data !== null && !var_from_same_dataset_check_err) {\n              var _data = JSON.parse(blk.data);\n              // Variable based on source dataset\n              if ('TABLE_NAME' in _data) {\n                if (!var_from_same_dataset_check_err && fromDatasetName !== _data.TABLE_NAME) {\n                  err.push(\"Seq By Variables block should be from \" + fromDatasetName + \".\");\n                  var_from_same_dataset_check_err = true;\n                }\n              }\n              //Variable based on Target dataset\n              else if ('cdiscDataStdDomainMetadataID' in _data) {\n                if (!var_from_same_dataset_check_err && fromDatasetName !== _data.domain) {\n                  err.push(\"Seq By Variables block should be from \" + fromDatasetName + \".\");\n                  var_from_same_dataset_check_err = true;\n                }\n              }\n            }\n          } else {\n            dataType_check_err = true;\n            err.push(\"Seq By Variables block should accept only variables.\");\n          }\n          if (!dataType_check_err || !var_from_same_dataset_check_err) {\n            var nxtBlk = blk.getNextBlock();\n            if (nxtBlk) {\n              is_variable_from_samedataset(nxtBlk);\n            }\n          } else {\n            return;\n          }\n        }\n      };\n      is_variable_from_samedataset(statement);\n      return err;\n    }\n  },\n  constant_type_multi: function constant_type_multi(block) {\n    //About Literal block\n    //Blocks can be empty for null/empty check\n    return \"\";\n  },\n  keep_drop_type2: function keep_drop_type2(block) {\n    //About Keep Drop block\n    //This block have two arguments (1,2)\n    //1.Dropdown argument (Keep,Drop)\n    //2.Statement argument\n    //Accepts only variable(Source,Target,Work)  --> this check will happen inbuilt,\n    //All fileds mandatory check\n    var err = [];\n    var dropDownValue = block.getFieldValue(\"keep_drop\");\n\n    //Statement Argument\n    var statement = block.getInputTargetBlock(\"variables\");\n    if (!statement) {\n      return dropDownValue + \" should not be empty. Find any built in validations available in blockly.\";\n    } else {\n      //Check DataType it shoul be variable or int_constant_type_multi\n      var dataType_check_err = false;\n      //Variable should be from same dataset\n      var var_from_same_dataset_check_err = false;\n      var data = JSON.parse(statement.data);\n\n      //get first used datasetname\n      var fromDatasetName = getDatasetByVar(data);\n      var is_variable_from_samedataset = function is_variable_from_samedataset(blk) {\n        if (blk && typeof blk === \"object\") {\n          if (isVariableType(blk.type) || blk.type === \"int_constant_type_multi\") {\n            if ('data' in blk && blk.data !== null && !var_from_same_dataset_check_err) {\n              var _data2 = JSON.parse(blk.data);\n              var prevBlock = block && block.getPreviousBlock();\n              if (prevBlock && prevBlock != \"\" && typeof prevBlock == 'object' && prevBlock.type != \"merge_type\" && prevBlock.type != \"set_type\") {\n                // Variable based on source dataset\n                switch (_data2.blockType) {\n                  case \"SourceVar\":\n                    if (!var_from_same_dataset_check_err && fromDatasetName !== _data2.TABLE_NAME) {\n                      err.push(dropDownValue + \" block should be from \" + fromDatasetName + \".\");\n                      var_from_same_dataset_check_err = true;\n                    }\n                    break;\n                  case \"TargetVar\":\n                    if (!var_from_same_dataset_check_err && fromDatasetName !== _data2.domain) {\n                      err.push(dropDownValue + \" block should be from \" + fromDatasetName + \".\");\n                      var_from_same_dataset_check_err = true;\n                    }\n                    break;\n                  case \"WorkVar\":\n                    if (!var_from_same_dataset_check_err && fromDatasetName !== _data2.dataset) {\n                      err.push(dropDownValue + \" block should be from \" + fromDatasetName + \".\");\n                      var_from_same_dataset_check_err = true;\n                    }\n                    break;\n                }\n              }\n            }\n          } else {\n            dataType_check_err = true;\n            err.push(dropDownValue + \" block should accept only variables and Int literals.\");\n          }\n          if (!dataType_check_err || !var_from_same_dataset_check_err) {\n            var nxtBlk = blk.getNextBlock();\n            if (nxtBlk) {\n              is_variable_from_samedataset(nxtBlk);\n            }\n          } else {\n            return;\n          }\n        }\n      };\n      is_variable_from_samedataset(statement);\n      return err;\n    }\n  },\n  transpose_operation: function transpose_operation(block) {\n    //About complex_ops_multi\n    //This block have three arguments\n    //1.Dropdown argument (Group Min,Max,Avg,Sum).\n    //2.Statment argument name @ By Variables,\n    //By Variables accepts Variable --> this check will happen inbuilt,\n    //2.Statment argument name @ ID Variables,\n    //ID Variables accepts Variable --> this check will happen inbuilt,\n    //Following fn will check both By and ID Variables from same dataset.\n    //Following fn will check ID Variables accepts only one input.\n    //All fileds mandatory check\n\n    var var_from_same_dataset_check_err = false;\n    var isNotVarBlock = false;\n    var err = [];\n    function transpose_validation(blk) {\n      this.TranseBlock = blk;\n      this.usedDataset = {};\n      this.usedDatasetName = \"\";\n      this.allUsedBlock = [];\n    }\n    transpose_validation.prototype.begins = function () {\n      var TranseBlock = this.TranseBlock;\n\n      //Check Multi dataset are used\n      this.allDataset = TranseBlock.getInputTargetBlock(\"transpose_dataset\");\n      if (this.isAllValuePresent()) {\n        return this.datasetvalidation();\n      } else {\n        return err;\n      }\n    };\n\n    //Check mandatory\n    transpose_validation.prototype.isAllValuePresent = function () {\n      //temp variable\n      var out = true;\n      [{\n        type: \"transpose_dataset\",\n        name: \"Transpose\"\n      }, {\n        type: \"by_variables\",\n        name: \"By Variable(s)\"\n      }, {\n        type: \"var_variables\",\n        name: \"VAR Variable(s)\"\n      }].map(function (stmt) {\n        if (!block.getInputTargetBlock(stmt.type)) {\n          out = false;\n          err.push(stmt.name + \" should not be empty.\");\n        }\n      });\n      return out;\n    };\n\n    //Check Only SIngle dataset\n    transpose_validation.prototype.datasetvalidation = function () {\n      var allDataset = this.allDataset,\n        TranseBlock = this.TranseBlock;\n      if (allDataset && \"getNextBlock\" in allDataset && !allDataset.getNextBlock()) {\n        var dataset = allDataset.getDescendants()[0];\n        var data = JSON.parse(dataset.data);\n        this.usedDataset = data;\n        this.usedDatasetName = getDataset(data);\n        this.allUsedBlock = TranseBlock.getDescendants();\n        return this.isAllVarFromUsedDataset();\n      } else {\n        err = [\"Transpose block should accept only one Dataset.\"];\n        return err;\n      }\n    };\n\n    //Check all var from same used dataset\n    transpose_validation.prototype.isAllVarFromUsedDataset = function () {\n      var allUsedBlock = this.allUsedBlock,\n        usedDatasetName = this.usedDatasetName;\n      function isVarFromUsedDataset(blk, statementname) {\n        var notCheckMandatory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (blk && typeof blk === \"object\") {\n          if (isVariableType(blk.type)) {\n            if ('data' in blk && blk.data !== null) {\n              var data = JSON.parse(blk.data);\n\n              // Variable based on source dataset\n              switch (data.blockType) {\n                case \"SourceVar\":\n                  if (usedDatasetName !== data.TABLE_NAME) {\n                    err.push(statementname + \" block should be from \" + usedDatasetName + \".\");\n                    var_from_same_dataset_check_err = true;\n                  }\n                  break;\n                case \"TargetVar\":\n                  if (usedDatasetName !== data.domain) {\n                    err.push(statementname + \" block should be from \" + usedDatasetName + \".\");\n                    var_from_same_dataset_check_err = true;\n                  }\n                  break;\n                case \"WorkVar\":\n                  if (usedDatasetName !== data.dataset) {\n                    err.push(statementname + \" block should be from \" + usedDatasetName + \".\");\n                    var_from_same_dataset_check_err = true;\n                  }\n                  break;\n              }\n            }\n          } else {\n            isNotVarBlock = true;\n            err.push(statementname + \" block should accept only variables.\");\n          }\n          var nxtBlk = blk.getNextBlock();\n          if (nxtBlk) {\n            isVarFromUsedDataset(nxtBlk, statementname);\n          } else {\n            return;\n          }\n        } else {\n          !notCheckMandatory && err.push(statementname + \" block argument should not be empty.Find any built in validations available in blockly\");\n        }\n      }\n\n      //get used variable block from by_variables statement in complex_ops_multi\n      isVarFromUsedDataset(block.getInputTargetBlock(\"by_variables\"), \"By Variable(s)\");\n      isVarFromUsedDataset(block.getInputTargetBlock(\"var_variables\"), \"VAR Variable(s)\");\n\n      //For only variable only allowed validation\n      isVarFromUsedDataset(block.getInputTargetBlock(\"copy_variables\"), \"Copy Variable(s)\", true);\n      isVarFromUsedDataset(block.getInputTargetBlock(\"id_variable\"), \"ID Variable(s)\", true);\n      return err;\n    };\n    var transposevalidation = new transpose_validation(block);\n    return transposevalidation.begins();\n  },\n  bulkmap_type: function bulkmap_type(block) {\n    //About BulkMap Block\n    //This Block have three arguments\n    //1.Statement argument name @BulkMap\n    // BulkMap statement Accepts only one Source Datatable variable/Target Datatable varaible.--> this check will happen inbuilt\n    //2.Statement argument name @Config variable\n    // Config variable will accept only bulkmap variables from operations section\n    //3.Statement argument name @Condition\n    //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\n    //Condition may be single or multiple\n    //Following fn will check BulkMap statement block have one or multiple input.\n    //mandatory check.\n\n    //BulkMap Statement\n    var bulkmapBlk_firstChild = block.getInputTargetBlock(\"map_value\");\n    var bulkmapBlk_secondChild = bulkmapBlk_firstChild ? bulkmapBlk_firstChild.getNextBlock() : false;\n\n    //Config variable statement\n    var configBlock_firstChild = block.getInputTargetBlock(\"config_variable\");\n    var configBlock_secondChild = configBlock_firstChild ? configBlock_firstChild.getNextBlock() : false;\n    if (!bulkmapBlk_firstChild || !configBlock_firstChild) {\n      return \"Bulk Map block arguments should not be empty. Find any built in validations available in blockly.\";\n    }\n    if (bulkmapBlk_secondChild) {\n      return \"Only one argument is allowed for BulkMap.\";\n    }\n    if (configBlock_secondChild) {\n      return \"Only one argument is allowed for Config variable.\";\n    }\n  },\n  unitconvert_type: function unitconvert_type(block) {\n    //About UnitConversion Block\n    //This Block have six arguments\n    //1.Statement argument name @UnitConversion\n    // UnitConversion statement Accepts only one Source Datatable variable/Target Datatable varaible.--> this check will happen inbuilt\n    //2.Statement argument name @TestName\n    // TestName variable will accept only input\n    //3.Statement argument name @TestCode\n    // TestCode variable will accept only input\n    //4.Statement argument name @Specimen\n    // Specimen variable will accept only input\n    //5.Statement argument name @Category\n    // Category variable will accept only input\n    //6.Statement argument name @Condition\n    //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\n    //Condition may be single or multiple\n    //Following fn will check UnitConversion statement block have one or multiple input.\n    //mandatory check.\n\n    //UnitConversion Statement\n    var unitconvBlk_firstChild = block.getInputTargetBlock(\"map_value\");\n    var unitconvBlk_secondChild = unitconvBlk_firstChild ? unitconvBlk_firstChild.getNextBlock() : false;\n\n    //TestName Statement\n    var testnameBlk_firstChild = block.getInputTargetBlock(\"test_name\");\n    var testnameBlk_secondChild = testnameBlk_firstChild ? testnameBlk_firstChild.getNextBlock() : false;\n\n    //TestCode Statement\n    var testcodeBlk_firstChild = block.getInputTargetBlock(\"test_code\");\n    var testcodeBlk_secondChild = testcodeBlk_firstChild ? testcodeBlk_firstChild.getNextBlock() : false;\n\n    //TestCategory Statement\n    var testcategoryBlk_firstChild = block.getInputTargetBlock(\"test_cat\");\n    var testcategoryBlk_secondChild = testcategoryBlk_firstChild ? testcategoryBlk_firstChild.getNextBlock() : false;\n\n    //TestSpecimen Statement\n    var testspecBlk_firstChild = block.getInputTargetBlock(\"test_spec\");\n    var testspecBlk_secondChild = testspecBlk_firstChild ? testspecBlk_firstChild.getNextBlock() : false;\n\n    //Mandatory check\n    if (!unitconvBlk_firstChild && (!testnameBlk_firstChild || !testcodeBlk_firstChild || !testcategoryBlk_firstChild || !testspecBlk_firstChild)) {\n      return \"Unit Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else if (unitconvBlk_firstChild && !testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild) {\n      return \"Unit Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else {\n      if (!unitconvBlk_firstChild && (testnameBlk_firstChild || testcodeBlk_firstChild || testcategoryBlk_firstChild || testspecBlk_firstChild)) return \"Unit Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    }\n\n    //Second value check\n    if (unitconvBlk_secondChild) {\n      return \"Only one argument is allowed for Unit Conversion.\";\n    } else if (testnameBlk_secondChild) {\n      return \"Only one argument is allowed for Test Name.\";\n    } else if (testcodeBlk_secondChild) {\n      return \"Only one argument is allowed for Test Code.\";\n    } else if (testcategoryBlk_secondChild) {\n      return \"Only one argument is allowed for Test Category.\";\n    } else {\n      if (testspecBlk_secondChild) {\n        return \"Only one argument is allowed for Specimen.\";\n      }\n    }\n  },\n  substring_type: function substring_type(block) {\n    //About Substring Block\n    //This Block have three arguments\n    //1.Statement argument name @Substring\n    //Accepts only Variable(Source,Target,Work) for first argument  --> this check will happen inbuilt\n    //2.Textbox argument name @start is mandatory\n    //3.TextBox argument name @end is optional\n    //Following fn will check Substring statement argument have one or multiple input\n    //All fileds mandatory check\n\n    //Substring\n    var substring_firstChild = block.getInputTargetBlock(\"fr_statement\");\n    var substring_secondChild = substring_firstChild ? substring_firstChild.getNextBlock() : false;\n\n    //Start Textbox\n    var startText = block.getFieldValue(\"start_extra\");\n\n    //End Textbox\n    var endText = block.getFieldValue(\"end_extra\");\n    var err = [];\n\n    //Mandatory Check\n    if (!(substring_firstChild && startText)) {\n      err.push(\"SubString block arguments should not be empty. Find any built in validations available in blockly.\");\n    }\n\n    //Second value check\n    if (substring_secondChild) {\n      err.push(\"Only one argument is allowed for SubString.\");\n    }\n    return err;\n  },\n  unit_operations: function unit_operations(block) {\n    //About unit_operations block\n    //This block have one arguments\n    //Dropdown values (TestCode, Specimen , Category)\n    //All fileds mandatory check\n    //First statement\n\n    //Unit Operations\n    var dropdownvalue = block.getFieldValue(\"unit_operations\");\n\n    //SourceTestName statement\n    var sourcetestnameBlk_firstChild = block.getInputTargetBlock(\"input_block\");\n    var sourcetestnameBlk_secondChild = sourcetestnameBlk_firstChild ? sourcetestnameBlk_firstChild.getNextBlock() : false;\n\n    //Multi input check\n    if (sourcetestnameBlk_secondChild) {\n      return \"Only one argument is allowed for \" + dropdownvalue + \".\";\n    }\n\n    //Mandatory Check\n    return !sourcetestnameBlk_firstChild ? dropdownvalue + \" arguments should not be empty. Find any built in validations available in blockly.\" : \"\";\n  },\n  unitresult_type: function unitresult_type(block) {\n    //About UnitResultConversion Block\n    //This Block have seven arguments\n    //1.Statement argument name @UnitResultConversion\n    // UnitResultConversion statement Accepts only one Source Datatable variable/Target Datatable varaible.--> this check will happen inbuilt\n    //2.Statement argument name @UnitVariable\n    // TestName variable will accept only input\n    //3.Statement argument name @TestName\n    // TestName variable will accept only input\n    //4.Statement argument name @TestCode\n    // TestCode variable will accept only input\n    //5.Statement argument name @Specimen\n    // Specimen variable will accept only input\n    //6.Statement argument name @Category\n    // Category variable will accept only input\n    //7.Statement argument name @Condition\n    //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\n    //Condition may be single or multiple\n    //Following fn will check UnitConversion statement block have one or multiple input.\n    //mandatory check.\n\n    //UnitConversion Statement\n    var unitresultBlk_firstChild = block.getInputTargetBlock(\"map_value\");\n    var unitresultBlk_secondChild = unitresultBlk_firstChild ? unitresultBlk_firstChild.getNextBlock() : false;\n\n    //UnitVariable Statement\n    var unitvar_firstChild = block.getInputTargetBlock(\"unit_variable\");\n    var unitvar_secondChild = unitvar_firstChild ? unitvar_firstChild.getNextBlock() : false;\n\n    //TestName Statement\n    var testnameBlk_firstChild = block.getInputTargetBlock(\"test_name\");\n    var testnameBlk_secondChild = testnameBlk_firstChild ? testnameBlk_firstChild.getNextBlock() : false;\n\n    //TestCode Statement\n    var testcodeBlk_firstChild = block.getInputTargetBlock(\"test_code\");\n    var testcodeBlk_secondChild = testcodeBlk_firstChild ? testcodeBlk_firstChild.getNextBlock() : false;\n\n    //TestCategory Statement\n    var testcategoryBlk_firstChild = block.getInputTargetBlock(\"test_cat\");\n    var testcategoryBlk_secondChild = testcategoryBlk_firstChild ? testcategoryBlk_firstChild.getNextBlock() : false;\n\n    //TestSpecimen Statement\n    var testspecBlk_firstChild = block.getInputTargetBlock(\"test_spec\");\n    var testspecBlk_secondChild = testspecBlk_firstChild ? testspecBlk_firstChild.getNextBlock() : false;\n\n    //Mandatory Check\n    if (!unitresultBlk_firstChild && !unitvar_firstChild && (!testnameBlk_firstChild || !testcodeBlk_firstChild || !testcategoryBlk_firstChild || !testspecBlk_firstChild)) {\n      return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else if (unitresultBlk_firstChild && !unitvar_firstChild && !testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild) {\n      return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else if (!unitresultBlk_firstChild || unitvar_firstChild && !testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild) {\n      return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else if ((unitresultBlk_firstChild || !unitvar_firstChild) && !testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild) {\n      return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    } else {\n      if (!unitresultBlk_firstChild || !unitvar_firstChild && (testnameBlk_firstChild || testcodeBlk_firstChild || testcategoryBlk_firstChild || testspecBlk_firstChild)) return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\n    }\n\n    //Multi input check\n    if (unitresultBlk_secondChild) {\n      return \"Only one argument is allowed for Unit Result Conversion.\";\n    } else if (unitvar_secondChild) {\n      return \"Only one argument is allowed for Unit Variable.\";\n    } else if (testnameBlk_secondChild) {\n      return \"Only one argument is allowed for Test Name.\";\n    } else if (testcodeBlk_secondChild) {\n      return \"Only one argument is allowed for Test Code.\";\n    } else if (testcategoryBlk_secondChild) {\n      return \"Only one argument is allowed for Test Category.\";\n    } else {\n      if (testspecBlk_secondChild) {\n        return \"Only one argument is allowed for Specimen.\";\n      }\n    }\n  }\n};\nvar getDataset = function getDataset(data) {\n  if (\"blockType\" in data) {\n    switch (data.blockType) {\n      case \"Source\":\n        //console.log(\"s\")\n        return data.TABLE_NAME;\n      case \"Target\":\n        return data.domain;\n      case \"Work\":\n        return data.name;\n      default:\n        return \"\";\n    }\n  }\n};\nvar getDatasetByVar = function getDatasetByVar(data) {\n  if (\"blockType\" in data) {\n    switch (data.blockType) {\n      case \"SourceVar\":\n        //console.log(\"s\")\n        return data.TABLE_NAME;\n      case \"TargetVar\":\n        return data.domain;\n      case \"WorkVar\":\n        return data.dataset;\n      default:\n        return \"\";\n    }\n  }\n};\nvar isVariableType = function isVariableType(type) {\n  var varaibleBlocks = [\"variable_type_drop_multi\", \"variable_type_target_multi\", \"variable_type_source_multi\", \"variable_type_work_multi\", \"variable_type_drop_multi\", \"variable_type_work_multi_2\", \"variable_type_target_multi_2\", \"variable_type_source_multi_2\"];\n  return varaibleBlocks.indexOf(type) === -1 ? false : true;\n};\nvar isDataset = function isDataset(type) {\n  var targetBlockTypes = [\"dataset_type_multi_source\", \"dataset_type_multi_target\", \"dataset_type_multi_work\"];\n  return targetBlockTypes.indexOf(type) === -1 ? false : true;\n};\nexport var StepBlockValidation = function StepBlockValidation(stepToCheck, blocks) {\n  switch (stepToCheck) {\n    case \"allstep\":\n      {\n        var final = blocks.find(function (x) {\n          return x.type === \"final_step_type\";\n        });\n        var final_statementBlock = final ? final.getInputTargetBlock(\"step_statement\") : false;\n        var step_datatable = blocks.filter(function (x) {\n          return x.type === \"step_type\";\n        });\n        var step_datatable_statementBlock = step_datatable.length > 0 ? step_datatable.some(function (st) {\n          return !st.getInputTargetBlock(\"step_statement\");\n        }) : false;\n        var step_variable = blocks.filter(function (x) {\n          return x.type === \"step_type_variable\";\n        });\n        var step_variable_statementBlock = step_variable.length > 0 ? step_variable.some(function (st) {\n          return !st.getInputTargetBlock(\"step_statement\");\n        }) : false;\n        return (step_variable.length === 0 || !step_variable_statementBlock) && (step_datatable.length === 0 || !step_datatable_statementBlock) && final_statementBlock && typeof final_statementBlock === \"object\";\n      }\n    case \"step_type_and_step_type_variable\":\n      {\n        var _step_datatable = blocks.filter(function (x) {\n          return x.type === \"step_type\";\n        });\n        var empty_step_datatable_statementBlock = _step_datatable.some(function (sd) {\n          return !isObjectCheck(sd.getInputTargetBlock(\"step_statement\"));\n        });\n        var _step_variable = blocks.filter(function (x) {\n          return x.type === \"step_type_variable\";\n        });\n        var empty_step_variable_statementBlock = _step_variable.some(function (sd) {\n          return !isObjectCheck(sd.getInputTargetBlock(\"step_statement\"));\n        });\n        return !empty_step_datatable_statementBlock && !empty_step_variable_statementBlock;\n      }\n    case \"partialstep\":\n      {\n        var _final = blocks.find(function (x) {\n          return x.type === \"final_step_type\";\n        });\n        var _final_statementBlock = _final ? _final.getInputTargetBlock(\"step_statement\") : true;\n        var _step_datatable2 = blocks.filter(function (x) {\n          return x.type === \"step_type\";\n        });\n        var _step_datatable_statementBlock = _step_datatable2.length > 0 ? _step_datatable2.some(function (st) {\n          return !st.getInputTargetBlock(\"step_statement\");\n        }) : false;\n        var _step_variable2 = blocks.filter(function (x) {\n          return x.type === \"step_type_variable\";\n        });\n        var _step_variable_statementBlock = _step_variable2.length > 0 ? _step_variable2.some(function (st) {\n          return !st.getInputTargetBlock(\"step_statement\");\n        }) : false;\n        return (_step_variable2.length === 0 || !_step_variable_statementBlock) && (_step_datatable2.length === 0 || !_step_datatable_statementBlock) && (_final_statementBlock || isObjectCheck(_final_statementBlock === \"object\"));\n      }\n  }\n};\n\n//Get all the variable of used variable's dataset in Finalstep / in Keep drop\n//@Note --- For Program Execution page by variable concept\n//passing this values in Extra2 \n//If Keep or drop not used, All variables in that domain should be sent in \"Extra1\"\n//If keep is used, only the variables used inside keep should be sent in \"Extra1\"\n//If drop is used, take all variables in that domain and remove variables used in drop and send remaining in \"Extra1\"\n\nexport function Get_Var_From_Step() {\n  var SourceDataset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var Standards = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var MappingDatas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var work_datasets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  this.SourceDataset = SourceDataset;\n  this.Standards = Standards;\n  this.MappingDatas = MappingDatas;\n  this.work_datasets = work_datasets;\n  //Finalstep/Variable step\n  //Initially null\n  this.StepType = \"\";\n  this.SourceOfRule = {};\n}\nGet_Var_From_Step.prototype.init = function () {\n  try {\n    var StepType = this.StepType,\n      StepBlock = this.StepBlock,\n      SourceOfRule = this.SourceOfRule,\n      WorkDataTable = this.WorkDataTable;\n    switch (StepType.toLowerCase()) {\n      case \"variablestep\":\n        {\n          //get first used statement block\n          var First_Statement_Blks = StepBlock.getInputTargetBlock(\"step_statement\");\n          //do\n          //{\n          //    children.push(Statement_Blks);\n          //} while (Statement_Blks = Statement_Blks.getNextBlock());\n          if (First_Statement_Blks) {\n            //get all used block inside the variable step  \n            var children = First_Statement_Blks && typeof First_Statement_Blks === \"object\" ? First_Statement_Blks.getDescendants() : [];\n            //get only dataset blk from datatable step\n\n            var is_keep_drop_used = children ? children.filter(function (x) {\n              return x.type === \"keep_drop_type2\";\n            }) : [];\n            if (is_keep_drop_used.length > 0) {\n              return validJSON(this.Var_From_KeepDrop(is_keep_drop_used[0]));\n            } else {\n              if (First_Statement_Blks.type === \"hardcode_type\") {\n                var Variable = this.SourceDataset && \"Variable\" in this.SourceDataset ? this.SourceDataset.Variable : [];\n                var source_var = [];\n                Variable = Variable.filter(function (v) {\n                  return v.TABLE_NAME === SourceOfRule.sourceDataset;\n                });\n                source_var = (Variable || []).map(function (va) {\n                  return {\n                    memname: WorkDataTable,\n                    name: va.COLUMN_NAME\n                  };\n                });\n                return source_var;\n              } else {\n                return validJSON(this.Var_From_Step(children));\n              }\n            }\n          } else {\n            return [];\n          }\n        }\n        break;\n      case \"datatablestep\":\n        {\n          var _First_Statement_Blks = StepBlock.getInputTargetBlock(\"step_statement\");\n          //do {\n          //    children.push(Statement_Blks);\n          //} while (Statement_Blks = Statement_Blks.getNextBlock());\n          if (_First_Statement_Blks) {\n            //get all used block inside the datatable step  \n            var _children = _First_Statement_Blks && typeof _First_Statement_Blks === \"object\" ? _First_Statement_Blks.getDescendants() : [];\n            //get only dataset blk from datatable step\n\n            var _is_keep_drop_used = _children ? _children.filter(function (x) {\n              return x.type === \"keep_drop_type2\";\n            }) : [];\n            if (_First_Statement_Blks.type === \"merge_type\" || _First_Statement_Blks.type === \"set_type\") {\n              var filteredvar = this.Get_Var_For_Merger_Set(_children);\n              if (_is_keep_drop_used.length > 0) {\n                return this.Merge_Set_Keep_Drop(_is_keep_drop_used[0], filteredvar);\n              }\n              return filteredvar;\n            } else {\n              if (_is_keep_drop_used.length > 0) {\n                return validJSON(this.Var_From_KeepDrop(_is_keep_drop_used[0]));\n              } else {\n                return this.Var_From_DatatTableStep(_children);\n              }\n            }\n          } else {\n            return [];\n          }\n        }\n        break;\n      case \"finalstep\":\n        {\n          var final_step = Blockly.getMainWorkspace().getBlocksByType(\"final_step_type\");\n          var Descendants = final_step[0].getDescendants();\n          var _is_keep_drop_used2 = Descendants ? Descendants.filter(function (x) {\n            return x.type === \"keep_drop_type2\";\n          }) : [];\n          if (_is_keep_drop_used2.length > 0) {\n            return this.Var_From_KeepDrop(_is_keep_drop_used2[0]);\n          } else {\n            return this.Var_From_Step(Descendants);\n          }\n        }\n        break;\n      case \"WkFinalStep\":\n        {\n          var _Descendants = StepBlock.getDescendants();\n          var _is_keep_drop_used3 = _Descendants ? _Descendants.filter(function (x) {\n            return x.type === \"keep_drop_type2\";\n          }) : [];\n          if (_is_keep_drop_used3.length > 0) {\n            return this.Var_From_KeepDrop(_is_keep_drop_used3[0]);\n          } else {\n            return this.Var_From_Step(_Descendants);\n          }\n        }\n        break;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n};\n\n//for keep drop\nGet_Var_From_Step.prototype.Merge_Set_Keep_Drop = function (keep_drop, obje) {\n  //Get the value from the drop down (whether the value is keep or drop)\n  var dropdown_val = keep_drop.getFieldValue(\"keep_drop\");\n  //Get all the used variable in the statement input of keepdrop block\n  var statement_blk = keep_drop.getInputTargetBlock(\"variables\");\n  var ForToGetWorkDataset = this.ForToGetWorkDataset,\n    WorkDataTable = this.WorkDataTable;\n  switch (dropdown_val) {\n    case \"Keep\":\n      {\n        var usedvar_in_keep = [];\n        var get_Used_Var_In_Keep = function get_Used_Var_In_Keep(statement_blk) {\n          if (statement_blk) {\n            var data = validJSON(statement_blk.data);\n            var nxt = statement_blk.getNextBlock();\n            if (nxt) {\n              get_Used_Var_In_Keep(nxt);\n            }\n            switch (data.blockType) {\n              case \"SourceVar\":\n                if (!usedvar_in_keep.some(function (va) {\n                  return va.name === data.COLUMN_NAME;\n                })) {\n                  usedvar_in_keep.push({\n                    memname: WorkDataTable,\n                    name: data.COLUMN_NAME\n                  });\n                }\n                break;\n              case \"TargetVar\":\n                if (!usedvar_in_keep.some(function (va) {\n                  return va.name === data.variableName;\n                })) {\n                  usedvar_in_keep.push({\n                    memname: WorkDataTable,\n                    name: data.variableName\n                  });\n                }\n                break;\n              case \"WorkVar\":\n                if (!usedvar_in_keep.some(function (va) {\n                  return va.name === data.variable;\n                })) {\n                  usedvar_in_keep.push({\n                    memname: WorkDataTable,\n                    name: data.variable\n                  });\n                }\n                break;\n            }\n          }\n        };\n        get_Used_Var_In_Keep(statement_blk);\n        return usedvar_in_keep;\n      }\n    case \"Drop\":\n      {\n        var usedvar_in_drop = [];\n        var get_Used_Var_In_Drop = function get_Used_Var_In_Drop(statement_blk) {\n          if (statement_blk) {\n            var data = validJSON(statement_blk.data);\n            var nxt = statement_blk.getNextBlock();\n            if (nxt) {\n              get_Used_Var_In_Drop(nxt);\n            }\n            switch (data.blockType) {\n              case \"SourceVar\":\n                {\n                  var getIndex = obje.findIndex(function (vari) {\n                    return vari.blockType === \"SourceVar\" && vari.name === data.COLUMN_NAME;\n                  });\n                  obje = obje.filter(function (va, ind) {\n                    return ind != getIndex;\n                  });\n                }\n                break;\n              case \"TargetVar\":\n                {\n                  var _getIndex = obje.findIndex(function (vari) {\n                    return vari.blockType === \"TargetVar\" && vari.name === data.variableName;\n                  });\n                  obje = obje.filter(function (va, ind) {\n                    return ind != _getIndex;\n                  });\n                }\n                break;\n              case \"WorkVar\":\n                {\n                  var _getIndex2 = obje.findIndex(function (vari) {\n                    return vari.blockType === \"WorkVar\" && vari.name === data.variable;\n                  });\n                  obje = obje.filter(function (va, ind) {\n                    return ind != _getIndex2;\n                  });\n                }\n                break;\n            }\n          }\n        };\n        get_Used_Var_In_Drop(statement_blk);\n        return obje;\n      }\n  }\n};\n//for keep drop\nGet_Var_From_Step.prototype.Var_From_KeepDrop = function (keep_drop) {\n  //Get the value from the drop down (whether the value is keep or drop)\n  var dropdown_val = keep_drop.getFieldValue(\"keep_drop\");\n  //Get all the used variable in the statement input of keepdrop block\n  var statement_blk = keep_drop.getInputTargetBlock(\"variables\");\n  var ForToGetWorkDataset = this.ForToGetWorkDataset,\n    WorkDataTable = this.WorkDataTable;\n  switch (dropdown_val) {\n    case \"Keep\":\n      {\n        var usedvar_in_keep = [];\n        var get_Used_Var_In_Keep = function get_Used_Var_In_Keep(statement_blk) {\n          if (statement_blk) {\n            var data = validJSON(statement_blk.data);\n            var nxt = statement_blk.getNextBlock();\n            if (nxt) {\n              get_Used_Var_In_Keep(nxt);\n            }\n            switch (data.blockType) {\n              case \"SourceVar\":\n                if (!usedvar_in_keep.some(function (va) {\n                  return va.variableName === data.COLUMN_NAME || va.name === data.COLUMN_NAME;\n                })) {\n                  ForToGetWorkDataset ? usedvar_in_keep.push({\n                    memname: WorkDataTable,\n                    name: data.COLUMN_NAME\n                  }) : usedvar_in_keep.push({\n                    type: \"Source\",\n                    dataset: data.TABLE_NAME,\n                    variableName: data.COLUMN_NAME\n                  });\n                }\n                break;\n              case \"TargetVar\":\n                if (!usedvar_in_keep.some(function (va) {\n                  return va.variableName === data.variableName || va.name === data.variableName;\n                })) {\n                  ForToGetWorkDataset ? usedvar_in_keep.push({\n                    memname: WorkDataTable,\n                    name: data.variableName\n                  }) : usedvar_in_keep.push({\n                    type: \"Source\",\n                    dataset: data.domain,\n                    variableName: data.variableName\n                  });\n                }\n                break;\n              case \"WorkVar\":\n                if (!usedvar_in_keep.some(function (va) {\n                  return va.variableName === data.variable || va.name === data.variable;\n                })) {\n                  ForToGetWorkDataset ? usedvar_in_keep.push({\n                    memname: WorkDataTable,\n                    name: data.variable\n                  }) : usedvar_in_keep.push({\n                    type: \"Source\",\n                    dataset: data.dataset,\n                    variableName: data.variable\n                  });\n                }\n                break;\n            }\n          }\n        };\n        get_Used_Var_In_Keep(statement_blk);\n        return JSON.stringify(usedvar_in_keep);\n      }\n    case \"Drop\":\n      {\n        var usedvar_in_drop = [];\n        var get_Used_Var_In_Drop = function get_Used_Var_In_Drop(statement_blk) {\n          if (statement_blk) {\n            var data = validJSON(statement_blk.data);\n            var nxt = statement_blk.getNextBlock();\n            if (nxt) {\n              get_Used_Var_In_Drop(nxt);\n            }\n            switch (data.blockType) {\n              case \"SourceVar\":\n                usedvar_in_drop.push(data.COLUMN_NAME);\n                break;\n              case \"TargetVar\":\n                usedvar_in_drop.push(data.variableName);\n                break;\n              case \"WorkVar\":\n                usedvar_in_drop.push(data.variable);\n                break;\n            }\n          }\n        };\n        get_Used_Var_In_Drop(statement_blk);\n        var all_var = this.findWhichdDataset(statement_blk, true, usedvar_in_drop);\n        return JSON.stringify(all_var);\n      }\n  }\n};\n//for step and Variable step\nGet_Var_From_Step.prototype.Var_From_Step = function (descendants) {\n  var statement_blk = descendants.filter(function (child) {\n    return isVariableType(child.type);\n  });\n  var all_var = this.findWhichdDataset(statement_blk[0]);\n  return JSON.stringify(all_var);\n};\n//Transpose block\nGet_Var_From_Step.prototype.WorkVar_From_Transposeblock = function (transposeblock) {\n  try {\n    var WorkDataTable = this.WorkDataTable;\n\n    //get Used first Variable in by varible statement\n    var by_var_statement_blk = transposeblock.getInputTargetBlock(\"by_variables\");\n    if (by_var_statement_blk) {\n      //get Used all Variable's in by varible statement\n      var getAllUsedVar = by_var_statement_blk && typeof by_var_statement_blk === \"object\" ? by_var_statement_blk.getDescendants() : [];\n\n      //default column add here\n      var defaultcol = [\"_NAME_\", \"_LABEL_\", \"COL1\"];\n      var out = _toConsumableArray(defaultcol.map(function (dcol) {\n        return {\n          name: dcol,\n          memname: WorkDataTable\n        };\n      }));\n      (getAllUsedVar || []).map(function (var_blk) {\n        var data = validJSON(var_blk.data);\n        var type = data ? data.blockType : \"\";\n        switch (type) {\n          case \"SourceVar\":\n            {\n              !out.some(function (v) {\n                return v.name.toLowerCase() === data.COLUMN_NAME.toLowerCase();\n              }) && out.push({\n                name: data.COLUMN_NAME,\n                memname: WorkDataTable\n              });\n            }\n            break;\n          case \"TargetVar\":\n            {\n              !out.some(function (v) {\n                return v.name.toLowerCase() === data.variableName.toLowerCase();\n              }) && out.push({\n                name: data.variableName,\n                memname: WorkDataTable\n              });\n            }\n            break;\n          case \"WorkVar\":\n            {\n              !out.some(function (v) {\n                return v.name.toLowerCase() === data.variable.toLowerCase();\n              }) && out.push({\n                name: data.variable,\n                memname: WorkDataTable\n              });\n            }\n            break;\n          default:\n            break;\n        }\n      });\n      return out;\n    }\n    return [];\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n};\n\n//Filter used var from Rename Block \nexport function GetRenameVariables(children, src, tar, work_ds) {\n  try {\n    var index;\n    var _ret = function () {\n      //out variable\n      var rename_var = {};\n\n      //Check Duplication (do not rename multiple columns with the same name).\n      var find_Duplication = {\n        identify: [],\n        duplicate: []\n      };\n      var identify = find_Duplication.identify,\n        duplicate = find_Duplication.duplicate;\n      var _loop = function _loop() {\n        //Block used in selcted block\n        var block = children[index];\n        var dataset_info = validJSON(block.data);\n        var dataset_type = dataset_info.blockType;\n        var type = block.type;\n\n        //Should check for only Variable step ,DataTable step\n        if (isDataset(type)) {\n          //get block value connection \n          //Get the used dataTableOptions in dataset\n          var dataTableOptions = block && block.getOnlyValueConnection_ && block.getOnlyValueConnection_();\n          dataTableOptions = dataTableOptions && dataTableOptions.targetBlock && dataTableOptions.targetBlock();\n          var dataTableOpt_child = dataTableOptions && dataTableOptions.getChildren && dataTableOptions.getChildren();\n          //Get the used rename blk in dataset\n          var renameBlk = isArray(dataTableOpt_child) && dataTableOpt_child[0];\n          //get first used block in rename block (type - rename_vars)\n          var used_blk_in_rename = isObject(renameBlk) && renameBlk.getDescendants ? renameBlk.getDescendants() : [];\n          used_blk_in_rename.map(function (b) {\n            //uvbr -> used var block in rename\n            var uvbr_dataInfo = validJSON(b.data);\n            var var_type = uvbr_dataInfo.blockType;\n\n            //get text from rename block.(rename - rename_type)\n            var rename_text_blk = b.getOnlyValueConnection_();\n            rename_text_blk = isObject(rename_text_blk) ? rename_text_blk.targetBlock() : false;\n            var renameText = isObject(rename_text_blk) ? rename_text_blk.getFieldValue(\"rename_var\") : \"\";\n            //End \n            if (renameText != \"\" && typeof renameText === \"string\" && !parseInt(renameText)) {\n              switch (dataset_type) {\n                case \"Source\":\n                  {\n                    var srcVar = src.Variable;\n                    var s_ds = strLowerCase(uvbr_dataInfo.TABLE_NAME);\n                    var s_var = strLowerCase(uvbr_dataInfo.COLUMN_NAME);\n                    //Get only the used used source var from rename block,if Source DATASET means\n                    if (var_type === \"SourceVar\" && uvbr_dataInfo.TABLE_NAME === dataset_info.TABLE_NAME && srcVar.some(function (sv) {\n                      return strLowerCase(sv.TABLE_NAME) == s_ds && strLowerCase(sv.COLUMN_NAME) === s_var;\n                    })) {\n                      var blockType = dataset_info.blockType,\n                        TABLE_NAME = dataset_info.TABLE_NAME;\n                      //uvbr -> used var block in rename\n                      var COLUMN_NAME = uvbr_dataInfo.COLUMN_NAME;\n\n                      //Check Duplication (do not rename multiple columns with the same name).\n                      //check the combination of type(src/tar/work) and rename text\n                      //Same re-name allowed for same variable ex(demo.domain rename is x ,can have another demo.domain rename is x )\n                      var dp_chk_renametxt = var_type + '.' + TABLE_NAME + '.' + renameText.toLowerCase();\n                      var dp_chk_varname = var_type + '.' + TABLE_NAME + '.' + COLUMN_NAME;\n                      if (!identify.some(function (dpo) {\n                        return dpo.v_name.toLowerCase() !== dp_chk_varname.toLowerCase() && dpo.r_name.toLowerCase() === dp_chk_renametxt.toLowerCase();\n                      })) {\n                        identify.push({\n                          r_name: dp_chk_renametxt,\n                          v_name: dp_chk_varname\n                        });\n                        rename_var[TABLE_NAME + \"@_\" + var_type] = rename_var[TABLE_NAME + \"@_\" + var_type] || {};\n                        rename_var[TABLE_NAME + \"@_\" + var_type][COLUMN_NAME] = _objectSpread(_objectSpread({}, uvbr_dataInfo), {}, {\n                          renameTo: renameText.toUpperCase()\n                        });\n                      } else {\n                        duplicate.indexOf(TABLE_NAME + \" - \" + renameText) === -1 && duplicate.push(TABLE_NAME + \" - \" + renameText);\n                      }\n                    }\n                  }\n                  break;\n                case \"Target\":\n                  {\n                    //Get only the used used target var from rename block,if Target DATASET means\n                    var t_ds = strLowerCase(uvbr_dataInfo.domain);\n                    var t_var = strLowerCase(uvbr_dataInfo.variableName);\n                    if (var_type === \"TargetVar\" && uvbr_dataInfo.domain === dataset_info.domain && tar.some(function (tv) {\n                      return strLowerCase(tv.targetDataSet) == t_ds && strLowerCase(tv.targetVariableName) === t_var;\n                    })) {\n                      var _blockType = dataset_info.blockType,\n                        domain = dataset_info.domain;\n                      //uvbr -> used var block in rename\n                      var variableName = uvbr_dataInfo.variableName;\n                      //Check Duplication (do not rename multiple columns with the same name).\n                      //Check Duplication (do not rename multiple columns with the same name).\n                      //check the combination of type(src/tar/work) and rename text\n                      var _dp_chk_renametxt = var_type + '.' + domain + '.' + renameText.toLowerCase();\n                      //Same re-name allowed for same variable ex(demo.domain rename is x ,can have another demo.domain rename is x )\n                      var _dp_chk_varname = var_type + '.' + domain + '.' + variableName;\n                      if (!identify.some(function (dpo) {\n                        return dpo.v_name.toLowerCase() !== _dp_chk_varname.toLowerCase() && dpo.r_name.toLowerCase() === _dp_chk_renametxt.toLowerCase();\n                      })) {\n                        identify.push({\n                          r_name: _dp_chk_renametxt,\n                          v_name: _dp_chk_varname\n                        });\n                        rename_var[domain + \"@_\" + var_type] = rename_var[domain + \"@_\" + var_type] || {};\n                        rename_var[domain + \"@_\" + var_type][variableName] = _objectSpread(_objectSpread({}, uvbr_dataInfo), {}, {\n                          renameTo: renameText.toUpperCase()\n                        });\n                      } else {\n                        duplicate.indexOf(domain + \" - \" + renameText) === -1 && duplicate.push(domain + \" - \" + renameText);\n                      }\n                    }\n                  }\n                  break;\n                case \"Work\":\n                  {\n                    var w_ds = strLowerCase(uvbr_dataInfo.dataset);\n                    //Get only the used used Work var from rename block,if Work DATASET means\n                    if (var_type === \"WorkVar\" && w_ds === strLowerCase(dataset_info.name) && work_ds.some(function (v) {\n                      return strLowerCase(v.memname) == w_ds && strLowerCase(v.name) == strLowerCase(uvbr_dataInfo.variable);\n                    })) {\n                      var _blockType2 = dataset_info.blockType,\n                        name = dataset_info.name;\n                      //uvbr -> used var block in rename\n                      var variable = uvbr_dataInfo.variable;\n                      //Check Duplication (do not rename multiple columns with the same name).\n                      //Check Duplication (do not rename multiple columns with the same name).\n                      //check the combination of type(src/tar/work) and rename text\n\n                      var _dp_chk_renametxt2 = var_type + '.' + name + '.' + renameText.toLowerCase();\n                      //Same re-name allowed for same variable ex(demo.domain rename is x ,can have another demo.domain rename is x )\n                      var _dp_chk_varname2 = var_type + '.' + name + '.' + variable;\n                      if (!identify.some(function (dpo) {\n                        return dpo.v_name.toLowerCase() !== _dp_chk_varname2.toLowerCase() && dpo.r_name.toLowerCase() === _dp_chk_renametxt2.toLowerCase();\n                      })) {\n                        identify.push({\n                          r_name: _dp_chk_renametxt2,\n                          v_name: _dp_chk_varname2\n                        });\n                        rename_var[name + \"@_\" + var_type] = rename_var[name + \"@_\" + var_type] || {};\n                        rename_var[name + \"@_\" + var_type][variable] = _objectSpread(_objectSpread({}, uvbr_dataInfo), {}, {\n                          renameTo: renameText.toUpperCase()\n                        });\n                      } else {\n                        duplicate.indexOf(variable + \" - \" + renameText) === -1 && duplicate.push(variable + \" - \" + renameText);\n                      }\n                    }\n                  }\n                  break;\n              }\n            }\n          });\n        }\n      };\n      for (index = 0; index < children.length; index++) {\n        _loop();\n      }\n      return {\n        v: {\n          variableRenameList: rename_var,\n          duplicate: duplicate\n        }\n      };\n    }();\n    if (typeof _ret === \"object\") return _ret.v;\n  } catch (e) {\n    console.log(e);\n    return {};\n  }\n}\n\n//for  datatable step\n// parameter @children is the used block inside datatable step\nGet_Var_From_Step.prototype.Var_From_DatatTableStep = function (children) {\n  var _this2 = this;\n  try {\n    var WorkDataTable = this.WorkDataTable,\n      Standards = this.Standards,\n      work_datasets = this.work_datasets,\n      variableRenameList = this.variableRenameList;\n    var out = [];\n    if (children && typeof children === \"object\" && children.length > 0) {\n      //for transpose block\n      var isTransPoseBlkUsed = (children || []).find(function (child) {\n        return child.type == \"transpose_operation\";\n      });\n      if (isTransPoseBlkUsed && typeof isTransPoseBlkUsed === \"object\") {\n        out = this.WorkVar_From_Transposeblock(isTransPoseBlkUsed, variableRenameList);\n      } else {\n        //get only dataset blk from datatable step\n        var used_dataset_blk = children.filter(function (child) {\n          return isDataset(child.type);\n        });\n        //Controlling duplication for dataset\n        var cntrlDuplication = [];\n        (used_dataset_blk || []).map(function (ds_blk) {\n          var data = validJSON(ds_blk.data);\n          var type = data ? data.blockType : \"\";\n          //Controlling duplication for dataset\n          var duplicationcontrol = cntrlDuplication.some(function (cd) {\n            return cd.dataset === data.TABLE_NAME && cd.type === \"Source\";\n          });\n          if (!duplicationcontrol) {\n            switch (type) {\n              case \"Source\":\n                {\n                  //Controlling duplication for dataset\n                  cntrlDuplication.push({\n                    dataset: data.TABLE_NAME,\n                    type: type\n                  });\n                  var Dataset = _this2.SourceDataset && \"Domain\" in _this2.SourceDataset ? _this2.SourceDataset.Domain : [];\n                  var Variable = _this2.SourceDataset && \"Variable\" in _this2.SourceDataset ? _this2.SourceDataset.Variable : [];\n                  var var_by_used_dataset = Variable.filter(function (va) {\n                    //Rename the variable ,if a rename block exists \n                    var rename_obj = variableRenameList[data.TABLE_NAME + \"@_\" + \"SourceVar\"];\n                    var renameTo = rename_obj && rename_obj[va.COLUMN_NAME] && rename_obj[va.COLUMN_NAME].renameTo;\n                    var col_Name = isNotNull(renameTo) ? renameTo : va.COLUMN_NAME;\n                    if (va.TABLE_NAME === data.TABLE_NAME && !out.some(function (wkva) {\n                      return wkva.name === col_Name;\n                    })) {\n                      out.push({\n                        name: col_Name,\n                        memname: WorkDataTable\n                      });\n                    }\n                  });\n                }\n                break;\n              case \"Target\":\n                {\n                  //Controlling duplication for dataset\n                  cntrlDuplication.push({\n                    dataset: data.domain,\n                    type: type\n                  });\n                  var _Dataset = Standards && \"Domain\" in Standards ? _this2.SourceDataset.Domain : [];\n                  var _Variable = Standards && \"Variable\" in Standards ? Standards.Variable : [];\n                  _Variable.filter(function (va) {\n                    var mappingConstruct = _this2.MappingDatas.MappingList.find(function (mapper) {\n                      return mapper.cdiscDataStdVariableMetadataID === va.cdiscDataStdVariableMetadataID || typeof va.domain == 'string' && va.domain.toLowerCase().includes('_int');\n                    });\n                    if (typeof mappingConstruct === 'object' && mappingConstruct) {\n                      //Rename the variable ,if a rename block exists \n                      var rename_obj = variableRenameList[data.domain + \"@_\" + \"TargetVar\"];\n                      var renameTo = rename_obj && rename_obj[va.variableName] && rename_obj[va.variableName].renameTo;\n                      var col_Name = isNotNull(renameTo) ? renameTo : va.variableName;\n                      if (va.cdiscDataStdDomainMetadataID === data.cdiscDataStdDomainMetadataID && !out.some(function (wkva) {\n                        return wkva.name === col_Name;\n                      })) {\n                        out.push({\n                          name: col_Name,\n                          memname: WorkDataTable\n                        });\n                      }\n                    }\n                  });\n                }\n                break;\n              case \"Work\":\n                {\n                  //Controlling duplication for dataset\n                  // data.name -> is work dataset\n                  cntrlDuplication.push({\n                    dataset: data.name,\n                    type: type\n                  });\n                  var work_var = [];\n                  //In work_datasets object -> name key is work variable , memname key is dataset\n                  work_datasets.filter(function (va) {\n                    //Rename the variable ,if a rename block exists \n                    var rename_obj = variableRenameList[data.name + \"@_\" + \"WorkVar\"];\n                    var renameTo = rename_obj && rename_obj[va.name] && rename_obj[va.name].renameTo;\n                    var col_Name = isNotNull(renameTo) ? renameTo : va.name;\n                    if (va.memname === data.name && !out.some(function (wkva) {\n                      return wkva.name === col_Name;\n                    })) {\n                      out.push({\n                        name: col_Name,\n                        memname: WorkDataTable\n                      });\n                    }\n                  });\n                }\n                break;\n              default:\n                break;\n            }\n          }\n        });\n      }\n      return out;\n    }\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n  return [];\n};\n//for  datatable step\n// parameter @children is the used block inside datatable step\nGet_Var_From_Step.prototype.Get_Var_For_Merger_Set = function (children) {\n  var _this3 = this;\n  try {\n    var WorkDataTable = this.WorkDataTable,\n      Standards = this.Standards,\n      work_datasets = this.work_datasets,\n      variableRenameList = this.variableRenameList;\n    var out = [];\n    if (children && typeof children === \"object\" && children.length > 0) {\n      //for transpose block\n      var isTransPoseBlkUsed = (children || []).find(function (child) {\n        return child.type == \"transpose_operation\";\n      });\n      if (isTransPoseBlkUsed && typeof isTransPoseBlkUsed === \"object\") {\n        out = this.WorkVar_From_Transposeblock(isTransPoseBlkUsed, variableRenameList);\n      } else {\n        //get only dataset blk from datatable step\n        var used_dataset_blk = children.filter(function (child) {\n          return isDataset(child.type);\n        });\n        //Controlling duplication for dataset\n        var cntrlDuplication = [];\n        (used_dataset_blk || []).map(function (ds_blk) {\n          var data = validJSON(ds_blk.data);\n          var type = data ? data.blockType : \"\";\n          //Controlling duplication for dataset\n          var duplicationcontrol = cntrlDuplication.some(function (cd) {\n            return cd.dataset === data.TABLE_NAME && cd.type === \"Source\";\n          });\n          if (!duplicationcontrol) {\n            switch (type) {\n              case \"Source\":\n                {\n                  //Controlling duplication for dataset\n                  cntrlDuplication.push({\n                    dataset: data.TABLE_NAME,\n                    type: type\n                  });\n                  var Dataset = _this3.SourceDataset && \"Domain\" in _this3.SourceDataset ? _this3.SourceDataset.Domain : [];\n                  var Variable = _this3.SourceDataset && \"Variable\" in _this3.SourceDataset ? _this3.SourceDataset.Variable : [];\n                  var var_by_used_dataset = Variable.filter(function (va) {\n                    //Rename the variable ,if a rename block exists \n                    var rename_obj = variableRenameList[data.TABLE_NAME + \"@_\" + \"SourceVar\"];\n                    var renameTo = rename_obj && rename_obj[va.COLUMN_NAME] && rename_obj[va.COLUMN_NAME].renameTo;\n                    var col_Name = isNotNull(renameTo) ? renameTo : va.COLUMN_NAME;\n                    if (va.TABLE_NAME === data.TABLE_NAME && !out.some(function (wkva) {\n                      return wkva.name === col_Name;\n                    })) {\n                      out.push({\n                        name: col_Name,\n                        memname: WorkDataTable,\n                        blockType: \"SourceVar\"\n                      });\n                    }\n                  });\n                }\n                break;\n              case \"Target\":\n                {\n                  //Controlling duplication for dataset\n                  cntrlDuplication.push({\n                    dataset: data.domain,\n                    type: type\n                  });\n                  var _Dataset2 = Standards && \"Domain\" in Standards ? _this3.SourceDataset.Domain : [];\n                  var _Variable2 = Standards && \"Variable\" in Standards ? Standards.Variable : [];\n                  _Variable2.filter(function (va) {\n                    var mappingConstruct = _this3.MappingDatas.MappingList.find(function (mapper) {\n                      return mapper.cdiscDataStdVariableMetadataID === va.cdiscDataStdVariableMetadataID || typeof va.domain == 'string' && va.domain.toLowerCase().includes('_int');\n                    });\n                    if (typeof mappingConstruct === 'object' && mappingConstruct) {\n                      //Rename the variable ,if a rename block exists \n                      var rename_obj = variableRenameList[data.domain + \"@_\" + \"TargetVar\"];\n                      var renameTo = rename_obj && rename_obj[va.variableName] && rename_obj[va.variableName].renameTo;\n                      var col_Name = isNotNull(renameTo) ? renameTo : va.variableName;\n                      if (va.cdiscDataStdDomainMetadataID === data.cdiscDataStdDomainMetadataID && !out.some(function (wkva) {\n                        return wkva.name === col_Name;\n                      })) {\n                        out.push({\n                          name: col_Name,\n                          memname: WorkDataTable,\n                          blockType: \"TargetVar\"\n                        });\n                      }\n                    }\n                  });\n                }\n                break;\n              case \"Work\":\n                {\n                  //Controlling duplication for dataset\n                  // data.name -> is work dataset\n                  cntrlDuplication.push({\n                    dataset: data.name,\n                    type: type\n                  });\n                  var work_var = [];\n                  //In work_datasets object -> name key is work variable , memname key is dataset\n                  work_datasets.filter(function (va) {\n                    //Rename the variable ,if a rename block exists \n                    var rename_obj = variableRenameList[data.name + \"@_\" + \"WorkVar\"];\n                    var renameTo = rename_obj && rename_obj[va.name] && rename_obj[va.name].renameTo;\n                    var col_Name = isNotNull(renameTo) ? renameTo : va.name;\n                    if (va.memname === data.name && !out.some(function (wkva) {\n                      return wkva.name === col_Name;\n                    })) {\n                      out.push({\n                        name: col_Name,\n                        memname: WorkDataTable,\n                        blockType: \"WorkVar\"\n                      });\n                    }\n                  });\n                }\n                break;\n              default:\n                break;\n            }\n          }\n        });\n      }\n      return out;\n    }\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n  return [];\n};\n//Return Variables Based on dataset\n//blk parameter is a first statement input of the block\n//drop and usedvarindrop\nGet_Var_From_Step.prototype.findWhichdDataset = function (blk) {\n  var _this4 = this;\n  var drop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var usedvarindrop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var ForToGetWorkDataset = this.ForToGetWorkDataset,\n    WorkDataTable = this.WorkDataTable;\n  if (blk) {\n    var data = validJSON(blk.data);\n    var type = data ? data.blockType : \"\";\n    try {\n      switch (type) {\n        case \"SourceVar\":\n          {\n            var Variable = this.SourceDataset && \"Variable\" in this.SourceDataset ? this.SourceDataset.Variable : [];\n            var source_var = [];\n            Variable = Variable.filter(function (v) {\n              return v.TABLE_NAME === data.TABLE_NAME;\n            });\n            (Variable || []).map(function (va) {\n              if ((!drop || usedvarindrop.indexOf(va.COLUMN_NAME) === -1) && !source_var.some(function (v) {\n                return v.variableName === va.COLUMN_NAME;\n              })) {\n                ForToGetWorkDataset ? source_var.push({\n                  memname: WorkDataTable,\n                  name: va.COLUMN_NAME\n                }) : source_var.push({\n                  type: \"Source\",\n                  dataset: va.TABLE_NAME,\n                  variableName: va.COLUMN_NAME\n                });\n              }\n            });\n            return source_var;\n          }\n        case \"TargetVar\":\n          {\n            var target_var = [];\n            var variable = this.Standards ? this.Standards.Variable : [];\n            var varible = variable.filter(function (v) {\n              return v.cdiscDataStdDomainMetadataID === data.cdiscDataStdDomainMetadataID;\n            });\n            varible.map(function (va) {\n              var mappingConstruct = _this4.MappingDatas.MappingList.find(function (mapper) {\n                return mapper.cdiscDataStdVariableMetadataID === va.cdiscDataStdVariableMetadataID || typeof va.domain == 'string' && va.domain.toLowerCase().includes('_int');\n              });\n              if (typeof mappingConstruct === 'object' && mappingConstruct) {\n                if ((!drop || usedvarindrop.indexOf(va.variableName) === -1) && !target_var.some(function (v) {\n                  return v.variableName === va.variableName;\n                })) {\n                  ForToGetWorkDataset ? target_var.push({\n                    memname: WorkDataTable,\n                    name: va.variableName\n                  }) : target_var.push({\n                    type: \"Target\",\n                    dataset: data.domain,\n                    variableName: va.variableName\n                  });\n                }\n              }\n            });\n            return target_var;\n          }\n        case \"WorkVar\":\n          {\n            var work_var = [];\n            this.work_datasets.filter(function (va) {\n              if (va.memname === data.dataset && (!drop || usedvarindrop.indexOf(va.name) === -1) && !work_var.some(function (v) {\n                return v.variableName === va.name;\n              })) {\n                ForToGetWorkDataset ? work_var.push({\n                  memname: WorkDataTable,\n                  name: va.name\n                }) : work_var.push({\n                  type: \"Work\",\n                  variableName: va.name,\n                  dataset: va.memname\n                });\n              }\n            });\n            return work_var;\n          }\n      }\n    } catch (e) {\n      //console.log(e);\n      return [];\n    }\n  } else {\n    return [];\n  }\n};\n\n//Get variable from used dataset in DataTable step\n\nexport function ImpactValidation(Standards, SourceDataset, xml) {\n  var record = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  try {\n    this.xml = xml;\n    this.record = record;\n    //convert string to xml \n    //all used block data information\n    this.data_info = this.xml.getElementsByTagName(\"data\");\n\n    //deciding var\n    //if false ,imapct exist else not\n    this.none_impacted = true;\n    this.impacted = false;\n\n    //used block in rule validation\n    var Domain = SourceDataset.Domain,\n      Variable = SourceDataset.Variable;\n    this.src_domain = Domain;\n    this.src_variable = Variable;\n    this.std_domain = Standards.Domain;\n    this.std_variable = Standards.Variable;\n\n    //impacted list \n    this.ImpactedList = {};\n    //for create/update/generate program/individual run should validate the work.but ,get workdataset no need to validate the work here\n    this.NotValidateWork = false;\n    this.work_exist = true;\n    this.NotAvailWorkList = {};\n    this.variableRenameList = {};\n\n    //Duplicate column due to renaming variable\n    this.duplicateColumn = [];\n  } catch (e) {\n    //console.log(e);\n  }\n}\n\n//Actual source of the record\n//IsMappedSourceAvaliable\n//this only used by importmappinlibrary.js\nImpactValidation.prototype.IsMappedSourceAvaliable = function () {\n  try {\n    //record -> sel record\n    var src_variable = this.src_variable,\n      record = this.record;\n    if (src_variable.some(function (sv) {\n      return sv.TABLE_NAME === record.sourceDataset && sv.COLUMN_NAME === record.sourceVariableName;\n    })) {\n      record.impact = 0;\n      record.changeReason = \"Create\";\n    } else {\n      record.impact = 1;\n      record.changeReason = \"Create\";\n    }\n  } catch (e) {\n    //console.log(e);\n  }\n};\n\n////Here Validate the used blocks in rule\n//Only ImportMapping Library uses this function\nImpactValidation.prototype.ValidationOfAllBlocksUsed = function () {\n  var _this5 = this;\n  try {\n    var i;\n    (function () {\n      var xml = _this5.xml,\n        data_info = _this5.data_info,\n        std_domain = _this5.std_domain,\n        src_domain = _this5.src_domain,\n        MappingList = _this5.MappingList,\n        std_variable = _this5.std_variable,\n        src_variable = _this5.src_variable,\n        WorkDatatset = _this5.WorkDatatset,\n        none_impacted = _this5.none_impacted,\n        NotValidateWork = _this5.NotValidateWork,\n        VariableRenameList = _this5.VariableRenameList;\n      var _loop2 = function _loop2() {\n        var data = data_info[i];\n        var d = validJSON(data_info[i].textContent);\n        switch (d.blockType) {\n          case \"Source\":\n            {\n              var nothing_impacted = src_domain.some(function (va) {\n                return va.TABLE_NAME === d.TABLE_NAME;\n              });\n              !nothing_impacted && (_this5.ImpactedList[d.TABLE_NAME] = \"Source Dataset - \" + d.TABLE_NAME);\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && nothing_impacted;\n            }\n            break;\n          case \"SourceVar\":\n            {\n              //Combine renamed variables also before check for impact\n              var renameVarsByDataset = VariableRenameList && VariableRenameList[d.TABLE_NAME + \"@_SourceVar\"];\n              renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\n              var combineBothVariables = [].concat(_toConsumableArray(src_variable), _toConsumableArray((Object.keys(renameVarsByDataset) || []).map(function (rv) {\n                return renameVarsByDataset[rv];\n              })));\n              var _nothing_impacted = combineBothVariables.some(function (va) {\n                var renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\n                return va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && va.COLUMN_NAME.toUpperCase() === d.COLUMN_NAME.toUpperCase() || va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && renameTo.toUpperCase() === d.COLUMN_NAME.toUpperCase();\n              });\n              !_nothing_impacted && (_this5.ImpactedList[d.TABLE_NAME + \".\" + d.COLUMN_NAME] = \"Source Variable - \" + d.TABLE_NAME + \".\" + d.COLUMN_NAME);\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && _nothing_impacted;\n            }\n            break;\n          case \"Target\":\n            {\n              var _nothing_impacted2 = std_domain.some(function (va) {\n                return d.domain === va.domain;\n              });\n\n              //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\n              if (d && d.domain && !d.domain.includes(\"_int\")) {\n                _nothing_impacted2 = _nothing_impacted2 && MappingList.some(function (va) {\n                  return d.domain === va.targetDataSet;\n                });\n              }\n              !_nothing_impacted2 && (_this5.ImpactedList[d.domain] = \"Target Dataset - \" + d.domain);\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && _nothing_impacted2;\n            }\n            break;\n          case \"TargetVar\":\n            {\n              var blockOfData = data.parentElement;\n              var fieldTag = data_info[i].parentElement.getElementsByTagName('field');\n              var fieldName = fieldTag && typeof fieldTag == 'object' ? fieldTag[0].textContent : \"\";\n              var domainName = isNotNull(fieldName) ? fieldName.split('.')[0] : \"\";\n\n              //get used block std domain name for usedblk variable by cdiscDataStdDomainMetadataID\n              var usedBlkDomain = std_domain.find(function (dm1) {\n                return dm1.domain.toLowerCase() === domainName.toLowerCase();\n              });\n              var usedBlkDomainName = usedBlkDomain && typeof usedBlkDomain === \"object\" ? usedBlkDomain.domain : \"\";\n              d.cdiscDataStdDomainMetadataID = usedBlkDomain && typeof usedBlkDomain === \"object\" ? usedBlkDomain.cdiscDataStdDomainMetadataID : 0;\n              var _nothing_impacted3 = std_variable.some(function (va) {\n                //get std domain name for variable by cdiscDataStdDomainMetadataID\n                var domain = std_domain.find(function (dm) {\n                  return dm.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID;\n                });\n                var domainname = domain && typeof domain === \"object\" ? domain.domain : \"\";\n\n                //let getDomain = Standards.Domain.find(d => d.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID);\n                if (usedBlkDomainName.toUpperCase() === domainname.toUpperCase() && va.variableName.toUpperCase() === d.variableName.toUpperCase()) {\n                  d.cdiscDataStdVariableMetadataID = va.cdiscDataStdVariableMetadataID;\n                  data_info[i].parentElement.childNodes[1].textContent = JSON.stringify(d);\n                  return true;\n                }\n                ;\n              });\n              //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\n              //HERE available Mapping List validation\n              if (usedBlkDomain && usedBlkDomain.domain && !usedBlkDomain.domain.includes(\"_int\")) {\n                _nothing_impacted3 = _nothing_impacted3 && MappingList.some(function (va) {\n                  return usedBlkDomainName.toUpperCase() === va.targetDataSet.toUpperCase() && va.cdiscDataStdVariableMetadataID === d.cdiscDataStdVariableMetadataID;\n                });\n              }\n              !_nothing_impacted3 && (_this5.ImpactedList[usedBlkDomainName + \".\" + d.variableName] = \"Target Variable - \" + usedBlkDomainName + \".\" + d.variableName);\n\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && _nothing_impacted3;\n            }\n            break;\n        }\n        if (!none_impacted) {}\n      };\n      for (i = 0; i < data_info.length; i++) {\n        _loop2();\n      }\n\n      //here we inverse \n      //for other end developing \n      _this5.impacted = !none_impacted;\n    })();\n  } catch (e) {\n    console.log(e);\n  }\n};\n\n//Here Validate the used blocks in rule\n//Only blocklyWorkspcae.js uses this function\nImpactValidation.prototype.ImpactValidationOfUsedBlocks = function () {\n  var _this6 = this;\n  try {\n    var i;\n    (function () {\n      var stepblk = _this6.stepblk,\n        data_info = _this6.data_info,\n        std_domain = _this6.std_domain,\n        src_domain = _this6.src_domain,\n        MappingList = _this6.MappingList,\n        std_variable = _this6.std_variable,\n        src_variable = _this6.src_variable,\n        WorkDatatset = _this6.WorkDatatset,\n        none_impacted = _this6.none_impacted,\n        NotValidateWork = _this6.NotValidateWork,\n        variableRenameList = _this6.variableRenameList;\n      var _loop3 = function _loop3() {\n        var blk = stepblk[i];\n        var data_info = blk.data;\n        var d = validJSON(data_info);\n        switch (d.blockType) {\n          case \"Source\":\n            {\n              var nothing_impacted = src_domain.some(function (va) {\n                return va.TABLE_NAME === d.TABLE_NAME;\n              });\n              !nothing_impacted && (_this6.ImpactedList[d.TABLE_NAME] = \"Source Dataset - \" + d.TABLE_NAME);\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && nothing_impacted;\n            }\n            break;\n          case \"SourceVar\":\n            {\n              //Combine renamed variables also before check for impact\n              var renameVarsByDataset = variableRenameList && variableRenameList[d.TABLE_NAME + \"@_SourceVar\"];\n              renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\n              var combineBothVariables = [].concat(_toConsumableArray(src_variable), _toConsumableArray((Object.keys(renameVarsByDataset) || []).map(function (rv) {\n                return renameVarsByDataset[rv];\n              })));\n              var _nothing_impacted4 = combineBothVariables.some(function (va) {\n                var renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\n                return va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && va.COLUMN_NAME.toUpperCase() === d.COLUMN_NAME.toUpperCase() || va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && renameTo.toUpperCase() === d.COLUMN_NAME.toUpperCase();\n              });\n              !_nothing_impacted4 && (_this6.ImpactedList[d.TABLE_NAME + \".\" + d.COLUMN_NAME] = \"Source Variable - \" + d.TABLE_NAME + \".\" + d.COLUMN_NAME);\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && _nothing_impacted4;\n            }\n            break;\n          case \"Target\":\n            {\n              var _nothing_impacted5 = std_domain.some(function (va) {\n                return d.domain === va.domain;\n              });\n\n              //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\n              if (d && d.domain && !d.domain.includes(\"_int\")) {\n                _nothing_impacted5 = _nothing_impacted5 && MappingList.some(function (va) {\n                  return d.domain === va.targetDataSet;\n                });\n              }\n              !_nothing_impacted5 && (_this6.ImpactedList[d.domain] = \"Target Dataset - \" + d.domain);\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && _nothing_impacted5;\n            }\n            break;\n          case \"TargetVar\":\n            {\n              //get used block std domain name for usedblk variable by cdiscDataStdDomainMetadataID\n              var usedBlkDomain = std_domain.find(function (dm1) {\n                return dm1.cdiscDataStdDomainMetadataID === d.cdiscDataStdDomainMetadataID;\n              });\n              var usedBlkDomainName = usedBlkDomain && typeof usedBlkDomain === \"object\" ? usedBlkDomain.domain : d.domain;\n              //Combine renamed variables also before check for impact\n              var _renameVarsByDataset = variableRenameList && variableRenameList[usedBlkDomainName + \"@_TargetVar\"];\n              _renameVarsByDataset = isObjectCheck(_renameVarsByDataset) ? _renameVarsByDataset : {};\n              var bothVariables = [].concat(_toConsumableArray(std_variable), _toConsumableArray((Object.keys(_renameVarsByDataset) || []).map(function (rv) {\n                return _renameVarsByDataset[rv];\n              })));\n              var _nothing_impacted6 = bothVariables.some(function (va) {\n                var renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\n\n                //get std domain name for variable by cdiscDataStdDomainMetadataID\n                var domain = std_domain.find(function (dm) {\n                  return dm.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID;\n                });\n                var domainname = domain && typeof domain === \"object\" ? domain.domain : \"\";\n\n                //let getDomain = Standards.Domain.find(d => d.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID);\n                return usedBlkDomainName.toUpperCase() === domainname.toUpperCase() && (va.variableName.toUpperCase() === d.variableName.toUpperCase() || d.variableName.toUpperCase() === renameTo.toUpperCase());\n              });\n\n              //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\n              //HERE available Mapping List validation\n              if (usedBlkDomain && usedBlkDomain.domain && !usedBlkDomain.domain.includes(\"_int\")) {\n                _nothing_impacted6 = _nothing_impacted6 && MappingList.some(function (va) {\n                  return usedBlkDomainName.toUpperCase() === va.targetDataSet.toUpperCase() && va.cdiscDataStdVariableMetadataID === d.cdiscDataStdVariableMetadataID;\n                });\n              }\n              !_nothing_impacted6 && (_this6.ImpactedList[usedBlkDomainName + \".\" + d.variableName] = \"Target Variable - \" + usedBlkDomainName + \".\" + d.variableName);\n\n              //Maintaing statge of overal check\n              none_impacted = none_impacted && _nothing_impacted6;\n            }\n            break;\n        }\n        if (!none_impacted) {}\n      };\n      for (i = 0; i < stepblk.length; i++) {\n        _loop3();\n      }\n\n      //here we inverse \n      //for other end developing \n      _this6.impacted = !none_impacted;\n    })();\n  } catch (e) {\n    console.log(e);\n  }\n};\n\n//NCICodeList_Validation For Workspace\n//Only blocklyWorkspcae.js uses this function\nImpactValidation.prototype.ImapctNCICodeListValidationWorkspace = function () {\n  var _this7 = this;\n  var data_info = this.data_info,\n    NCICODELISTDATA = this.NCICODELISTDATA;\n  var nci_list = NCICODELISTDATA && typeof NCICODELISTDATA === \"object\" ? NCICODELISTDATA : [];\n  var usedblk_info = data_info;\n  var _loop4 = function _loop4(i) {\n    var block_info = usedblk_info[i] && usedblk_info[i].textContent ? validJSON(usedblk_info[i].textContent) : {};\n    if (block_info.blockType === \"NciCodeListData\") {\n      if (!nci_list.some(function (x) {\n        return x.code === block_info.code;\n      })) {\n        var cdiscSubmissionValue = block_info.cdiscSubmissionValue;\n        _this7.impacted = true;\n        _this7.ImpactedList[\"Nci\" + \".\" + cdiscSubmissionValue] = \"NCI Codelist - \" + cdiscSubmissionValue;\n      }\n    }\n  };\n  for (var i = 0; i < usedblk_info.length; i++) {\n    _loop4(i);\n  }\n};\n\n//NCICodeList_Validation while copying records\nImpactValidation.prototype.ImpactNCICodeListValidation = function () {\n  var Standards = this.Standards,\n    selected_records = this.selected_records,\n    resolve = this.resolve,\n    reject = this.reject;\n  var loop_index = 0;\n  try {\n    var loop = function loop(rule) {\n      //convert string to xml     \n      var xml = rule.constructJson && typeof rule.constructJson === \"string\" && new DOMParser().parseFromString(rule.constructJson, \"application/xml\");\n\n      //get info from rule\n      var usedblk_info = xml && xml.getElementsByTagName(\"data\");\n      if (rule.constructJson && usedblk_info && typeof usedblk_info === \"object\" && usedblk_info.length > 0) {\n        //Domain aval for the study\n        var isDomainAval = (Domain || []).find(function (dm) {\n          return dm.domain === rule.targetDataSet;\n        });\n        if (isDomainAval) {\n          var cdiscDataStdDomainMetadataID = (isDomainAval || {}).cdiscDataStdDomainMetadataID;\n          var isVariableAval = (Variable || []).find(function (va) {\n            return va.variableName === rule.targetVariableName && va.cdiscDataStdDomainMetadataID === isDomainAval.cdiscDataStdDomainMetadataID;\n          });\n          if (isVariableAval) {\n            //match the name and update the id \n            var cdiscDataStdVariableMetadataID = (isVariableAval || {}).cdiscDataStdVariableMetadataID;\n            var inp_data = {\n              cDISCDataStdID: JSON.parse(sessionStorage.getItem(\"studyDetails\")).standardID,\n              cdiscDataStdDomainMetadataID: cdiscDataStdDomainMetadataID,\n              cdiscDataStdVariableMetadataID: cdiscDataStdVariableMetadataID\n            };\n            inp_data[\"StudyID\"] = getStudyID();\n            showProgress();\n            controller_call(inp_data, usedblk_info);\n            return;\n          }\n        }\n        ++loop_index;\n        selected_records[loop_index] ? loop(selected_records[loop_index]) : resolve();\n      } else {\n        ++loop_index;\n        selected_records[loop_index] ? loop(selected_records[loop_index]) : resolve();\n      }\n      function controller_call(inp_data, usedblk) {\n        CallServerPost(\"NCICodeList/GetNCIByDatasetVariable\", inp_data).then(function (res) {\n          hideProgress();\n          var avail_codelist = res.value;\n          if (res.status === 1 && avail_codelist && typeof avail_codelist === \"object\" && avail_codelist.length > 0) {\n            var _avail_codelist = res.value;\n            var _loop5 = function _loop5(i) {\n              var block_info = usedblk[i] && usedblk[i].textContent ? validJSON(usedblk[i].textContent) : {};\n              if (block_info.blockType === \"NciCodeListData\") {\n                if (!_avail_codelist.some(function (x) {\n                  return x.code === block_info.code;\n                })) {\n                  selected_records[loop_index].impact = 1;\n                  return \"break\";\n                }\n              }\n            };\n            for (var i = 0; i < usedblk.length; i++) {\n              var _ret2 = _loop5(i);\n              if (_ret2 === \"break\") break;\n            }\n          } else {\n            Array.from(usedblk).some(function (blk) {\n              //get used block info\n              //block info in data block\n              var data = blk && blk.textContent ? validJSON(blk.textContent) : {};\n              if (data.blockType === \"NciCodeListData\") {\n                selected_records[loop_index].impact = 1;\n                return true;\n              }\n            });\n          }\n          ++loop_index;\n          selected_records[loop_index] ? loop(selected_records[loop_index]) : resolve();\n        });\n      }\n    };\n    //Std Target Domain Variable\n    var _ref = Standards || [],\n      Domain = _ref.Domain,\n      Variable = _ref.Variable;\n\n    //fn init\n    loop(selected_records[loop_index]);\n  } catch (e) {\n    reject();\n    hideProgress();\n    console.log(e);\n  }\n};\n//WorkDataset Variable Exists\nexport function WorkDatasetVariableExists(stepBlock, workDataset, VariableRenameList) {\n  //overall check \n  var exist = true;\n  //get all used block inside the variable step  \n  var frst_children = stepBlock && typeof stepBlock === \"object\" ? stepBlock.getInputTargetBlock(\"step_statement\") : [];\n  var children = isObject(frst_children) ? frst_children.getDescendants() : [];\n  var workBlocks = children.filter(function (sblock) {\n    return sblock.type === \"variable_type_work_multi\" || sblock.type === \"dataset_type_multi_work\" || sblock.type === \"variable_type_work_multi_2\";\n  });\n  //get only dataset blk from datatable step\n\n  var not_avail_wks = {};\n  var _loop6 = function _loop6() {\n    var blk = workBlocks[i];\n    var data_info = validJSON(blk.data);\n    switch (data_info.blockType) {\n      case \"Work\":\n        {\n          var isExist = workDataset.some(function (va) {\n            return data_info.name.toUpperCase() === va.memname.toUpperCase();\n          });\n          !isExist && (not_avail_wks[data_info.name] = \"Work Dataset - \" + data_info.name);\n          //maintaining status\n          exist = exist && isExist;\n        }\n        break;\n      case \"WorkVar\":\n        {\n          //Combine renamed variables also before check for impact\n          var renameVarsByDataset = VariableRenameList && VariableRenameList[data_info.dataset + \"@_WorkVar\"];\n          renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\n          var bothVariables = [].concat(_toConsumableArray(workDataset), _toConsumableArray((Object.keys(renameVarsByDataset) || []).map(function (rv) {\n            return renameVarsByDataset[rv];\n          })));\n          var _isExist = exist && bothVariables.some(function (va) {\n            var renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\n            var vds = isObjectCheck(va) ? 'dataset' in va ? va.dataset : 'memname' in va ? va.memname : '' : '';\n            var vname = isObjectCheck(va) ? 'name' in va ? va.name : 'variable' in va ? va.variable : '' : '';\n            if (data_info.dataset.toUpperCase() === vds.toUpperCase() && (data_info.variable.toUpperCase() === vname.toUpperCase() || data_info.variable.toUpperCase() === renameTo.toUpperCase())) {\n              return true;\n            }\n          });\n          !_isExist && (not_avail_wks[data_info.dataset + \".\" + data_info.variable] = \"Work Variable - \" + data_info.dataset + \".\" + data_info.variable);\n          //maintaining status\n          exist = exist && _isExist;\n        }\n        break;\n    }\n  };\n  for (var i = 0; i < workBlocks.length; i++) {\n    _loop6();\n  }\n  return {\n    Work_Exist: exist,\n    Not_Avail_WkList: not_avail_wks\n  };\n}\nexport function FormErrorHtmlIfObj(header, errObj) {\n  var _this8 = this;\n  try {\n    var err = [/*#__PURE__*/React.createElement(\"div\", {\n      className: \"errorpop_map marginTopBottomFive\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2827,\n        columnNumber: 20\n      }\n    }, header, \" :\"), /*#__PURE__*/React.createElement(\"ol\", {\n      className: \"errOrderLi\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2828,\n        columnNumber: 9\n      }\n    }, (Object.keys(errObj) || []).map(function (keyName, index) {\n      return /*#__PURE__*/React.createElement(\"li\", {\n        key: index,\n        __self: _this8,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2829,\n          columnNumber: 20\n        }\n      }, errObj[keyName]);\n    }))];\n    return err;\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n}\nexport function FormErrorIfArray(header, errObj) {\n  var _this9 = this;\n  try {\n    var errOb = [];\n    errObj.map(function (er, i) {\n      if (errObj.indexOf(er) === i) {\n        errOb.push(er);\n      }\n    });\n    var err = [/*#__PURE__*/React.createElement(\"div\", {\n      className: \"errorpop_map marginTopBottomFive\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2852,\n        columnNumber: 20\n      }\n    }, header, \" :\"), /*#__PURE__*/React.createElement(\"ol\", {\n      className: \"errOrderLi\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 2853,\n        columnNumber: 9\n      }\n    }, (errOb || []).map(function (er, i) {\n      return /*#__PURE__*/React.createElement(\"li\", {\n        key: er,\n        __self: _this9,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2854,\n          columnNumber: 20\n        }\n      }, er);\n    }))];\n    return err;\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n}","map":{"version":3,"names":["React","Blockly","errorModal","getStudyID","validJSON","strLowerCase","CallServerPost","showProgress","hideProgress","isObject","isArray","isNotNull","errorModalCallback","isObjectCheck","Block","unique","msg","checkXML","usedBlocks","returnOnlyMsgs","errors","map","block","blocktype","type","getRootBlock","highPriority","validator","push","length","errorMsg","er","i","indexOf","map_type","mapBlk_firstChild","getInputTargetBlock","mapBlk_secondChild","getNextBlock","condnBlock_firstChild","date_type","dropDownValue","getFieldValue","dateBlk_firstChild","dateBlk_secondChild","toLowerCase","includes","hardcode_type","hardcode_firstChild","hardcode_secondChild","find_replace_type","findReplace_firstChild","findReplace_secondChild","findText","replaceText","err","sort_operations","sort_firstChild","sort_secondChild","sort_variable_operation","isVarBlkNotFromSameDataset","isNotVarBlock","sort_statementBlk_firstChild","sort_statementBlk_secondChild","by_var","data","sort_statementBlkData","JSON","parse","sortDatasetName","blockType","TABLE_NAME","domain","name","get_var","b","isVariableType","nxtConnectedBlock","simple_ops_mutiple_args_type","statementBlk_firstChild","statementBlk_secondChild","complex_ops_multi","dataset","id_var","merge_type","datasetBlk_firstChild","datasetBlk_secondChild","byVarBlk_firstChild","text","datasetBlockIDs","firstDatasetBlk","data1","secondDatasetBlk","data2","primaryID","isVarType","commonVariable","varBlockFn","varBlk","bothParentDataset","toString","nxtBlock","input_format_type","textboxValue","output_format_type","id_variable_type","statement_firstChild","statement_secondChild","arithmatic_operations","firstChild","checkOnlyVarTypeOrIntLiteral","blk","nxtBlk","rename_type","parseInt","compress_type","secondChild","remove","modifier","filter_type","filter_firstChild","filter_secondChild","condnArg_firstChild","set_type","statement","eq_type","dropdownvalue","statement_left","statement_right","andor_type","condition_type","where_type","concatenate_type","intLitPresent","isVarBlkPresent","minBlk","checkOnlyVarType","index","sort_seq_type","dataType_check_err","var_from_same_dataset_check_err","fromDatasetName","is_variable_from_samedataset","constant_type_multi","keep_drop_type2","getDatasetByVar","prevBlock","getPreviousBlock","transpose_operation","transpose_validation","TranseBlock","usedDataset","usedDatasetName","allUsedBlock","prototype","begins","allDataset","isAllValuePresent","datasetvalidation","out","stmt","getDescendants","getDataset","isAllVarFromUsedDataset","isVarFromUsedDataset","statementname","notCheckMandatory","transposevalidation","bulkmap_type","bulkmapBlk_firstChild","bulkmapBlk_secondChild","configBlock_firstChild","configBlock_secondChild","unitconvert_type","unitconvBlk_firstChild","unitconvBlk_secondChild","testnameBlk_firstChild","testnameBlk_secondChild","testcodeBlk_firstChild","testcodeBlk_secondChild","testcategoryBlk_firstChild","testcategoryBlk_secondChild","testspecBlk_firstChild","testspecBlk_secondChild","substring_type","substring_firstChild","substring_secondChild","startText","endText","unit_operations","sourcetestnameBlk_firstChild","sourcetestnameBlk_secondChild","unitresult_type","unitresultBlk_firstChild","unitresultBlk_secondChild","unitvar_firstChild","unitvar_secondChild","varaibleBlocks","isDataset","targetBlockTypes","StepBlockValidation","stepToCheck","blocks","final","find","x","final_statementBlock","step_datatable","filter","step_datatable_statementBlock","some","st","step_variable","step_variable_statementBlock","empty_step_datatable_statementBlock","sd","empty_step_variable_statementBlock","Get_Var_From_Step","SourceDataset","Standards","MappingDatas","work_datasets","StepType","SourceOfRule","init","StepBlock","WorkDataTable","First_Statement_Blks","children","is_keep_drop_used","Var_From_KeepDrop","Variable","source_var","v","sourceDataset","va","memname","COLUMN_NAME","Var_From_Step","filteredvar","Get_Var_For_Merger_Set","Merge_Set_Keep_Drop","Var_From_DatatTableStep","final_step","getMainWorkspace","getBlocksByType","Descendants","e","console","log","keep_drop","obje","dropdown_val","statement_blk","ForToGetWorkDataset","usedvar_in_keep","get_Used_Var_In_Keep","nxt","variableName","variable","usedvar_in_drop","get_Used_Var_In_Drop","getIndex","findIndex","vari","ind","stringify","all_var","findWhichdDataset","descendants","child","WorkVar_From_Transposeblock","transposeblock","by_var_statement_blk","getAllUsedVar","defaultcol","dcol","var_blk","GetRenameVariables","src","tar","work_ds","rename_var","find_Duplication","identify","duplicate","dataset_info","dataset_type","dataTableOptions","getOnlyValueConnection_","targetBlock","dataTableOpt_child","getChildren","renameBlk","used_blk_in_rename","uvbr_dataInfo","var_type","rename_text_blk","renameText","srcVar","s_ds","s_var","sv","dp_chk_renametxt","dp_chk_varname","dpo","v_name","r_name","renameTo","toUpperCase","t_ds","t_var","tv","targetDataSet","targetVariableName","w_ds","variableRenameList","isTransPoseBlkUsed","used_dataset_blk","cntrlDuplication","ds_blk","duplicationcontrol","cd","Dataset","Domain","var_by_used_dataset","rename_obj","col_Name","wkva","mappingConstruct","MappingList","mapper","cdiscDataStdVariableMetadataID","cdiscDataStdDomainMetadataID","work_var","drop","usedvarindrop","target_var","varible","ImpactValidation","xml","record","data_info","getElementsByTagName","none_impacted","impacted","src_domain","src_variable","std_domain","std_variable","ImpactedList","NotValidateWork","work_exist","NotAvailWorkList","duplicateColumn","IsMappedSourceAvaliable","sourceVariableName","impact","changeReason","ValidationOfAllBlocksUsed","WorkDatatset","VariableRenameList","d","textContent","nothing_impacted","renameVarsByDataset","combineBothVariables","Object","keys","rv","blockOfData","parentElement","fieldTag","fieldName","domainName","split","usedBlkDomain","dm1","usedBlkDomainName","dm","domainname","childNodes","ImpactValidationOfUsedBlocks","stepblk","bothVariables","ImapctNCICodeListValidationWorkspace","NCICODELISTDATA","nci_list","usedblk_info","block_info","code","cdiscSubmissionValue","ImpactNCICodeListValidation","selected_records","resolve","reject","loop_index","loop","rule","constructJson","DOMParser","parseFromString","isDomainAval","isVariableAval","inp_data","cDISCDataStdID","sessionStorage","getItem","standardID","controller_call","usedblk","then","res","avail_codelist","value","status","Array","from","WorkDatasetVariableExists","stepBlock","workDataset","exist","frst_children","workBlocks","sblock","not_avail_wks","isExist","vds","vname","Work_Exist","Not_Avail_WkList","FormErrorHtmlIfObj","header","errObj","keyName","FormErrorIfArray","errOb"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/src/containers/Mapper/blockValidation.js"],"sourcesContent":["import React from 'react';\r\nimport Blockly from 'blockly/core';\r\nimport { errorModal, getStudyID, validJSON, strLowerCase, CallServerPost, showProgress, hideProgress, isObject, isArray, isNotNull, errorModalCallback, isObjectCheck } from '../Utility/sharedUtility';\r\nimport { Block } from '../Program/Blockly';\r\n\r\nlet unique = [];\r\nlet msg = [];\r\n\r\nexport let checkXML = (usedBlocks, returnOnlyMsgs = false) => {\r\n\r\n    //Unique variable to check if multiple same type block exist means it check  for one block\r\n    msg = [];\r\n    let errors = [];\r\n    usedBlocks.map(block => {\r\n\r\n        let blocktype = block.type;\r\n        //condn to check root of the block is step category\r\n        if (block.getRootBlock().highPriority) {\r\n            if (validator[blocktype]) {\r\n                let msg = validator[blocktype](block);\r\n                if (msg) {\r\n                    typeof msg === \"string\" ?\r\n                        errors.push(msg) :\r\n                        errors.push(...msg);\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    if (!returnOnlyMsgs) {\r\n        if (errors.length > 0) {\r\n            let errorMsg = [];\r\n            errors.map((er, i) => {\r\n                //the following if remove duplicates\r\n                if (er &&\r\n                    errors.indexOf(er) === i) {\r\n                    errorMsg.push(<div key={errorMsg.length + 1}>{errorMsg.length + 1}. {er}</div>)\r\n                }\r\n            })\r\n            errorModal(errorMsg);\r\n            return false;\r\n        }\r\n        else {\r\n            return true\r\n        }\r\n    }\r\n    else {\r\n        return errors;\r\n    }\r\n}\r\n\r\nlet validator =\r\n{\r\n    map_type: (block) => {\r\n        //About Map Block\r\n        //This Block have two arguments\r\n        //1.Statement argument name @Map\r\n        // Map statement Accepts only one Dataset.--> this check will happen inbuilt \r\n        //2.Statement argument name @Conditions\r\n        //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\r\n        //Condition may be single or multiple\r\n        //Following fn will check Map statement block have one or multiple input.\r\n        //mandatory check.\r\n\r\n        //Map Statement\r\n        let mapBlk_firstChild = block.getInputTargetBlock(\"map_value\");\r\n        let mapBlk_secondChild = mapBlk_firstChild ? mapBlk_firstChild.getNextBlock() : false;\r\n\r\n        //Condn statement\r\n        let condnBlock_firstChild = block.getInputTargetBlock(\"conditions\")\r\n\r\n        if (!mapBlk_firstChild || !condnBlock_firstChild) {\r\n            return \"Map block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n\r\n        if (mapBlk_secondChild) {\r\n            return \"Only one argument is allowed for Map.\";\r\n        }\r\n\r\n\r\n    },\r\n    date_type: (block) => {\r\n        //About Date Block\r\n        //This Block have one statement argument\r\n        //1.StatementBlock \r\n        //Accepts only one variable (Source,Target,Work)--> this check will happen inbuilt \r\n        //Following fn will check statement block have one or multiple input\r\n        let dropDownValue = block.getFieldValue(\"op_name\");\r\n\r\n        let dateBlk_firstChild = block.getInputTargetBlock(\"input_block\");\r\n        let dateBlk_secondChild = dateBlk_firstChild ? dateBlk_firstChild.getNextBlock() : false;\r\n\r\n        return !dateBlk_firstChild ?\r\n            dropDownValue + \" block arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            dateBlk_secondChild && !dropDownValue.toLowerCase().includes(\"datetime\") ?\r\n                \"Only one argument is allowed for \" + dropDownValue + \".\" :\r\n                \"\";\r\n    },\r\n    hardcode_type: (block) => {\r\n        //About Hardcode Block\r\n        //This Block have one statement argument name @Hardcode\r\n        //HardCode accepts only String / Integer literal. --> this check will happen inbuilt \r\n        //Following fn will check statement block have one or multiple input\r\n\r\n        let hardcode_firstChild = block.getInputTargetBlock(\"hardcode_statement\");\r\n        let hardcode_secondChild = hardcode_firstChild ? hardcode_firstChild.getNextBlock() : false;\r\n\r\n        return !hardcode_firstChild ?\r\n            \"Hardcode block arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            hardcode_secondChild ?\r\n                \"Only one argument is allowed for Hardcode.\" :\r\n                \"\";\r\n    },\r\n    find_replace_type: (block) => {\r\n        //About FindAndReplaceType Block\r\n        //This Block have three arguments\r\n        //1.Statement argument name @FindAndReplace\r\n        //Accepts only Variable(Source,Target,Work) for first argument  --> this check will happen inbuilt\r\n        //2.Textbox argument name @Find\r\n        //3.TextBox argument name @Replace\r\n        //Following fn will check FindAndReplace statement argument have one or multiple input\r\n        //All fileds mandatory check\r\n\r\n        //FindAndReplace\r\n        let findReplace_firstChild = block.getInputTargetBlock(\"fr_statement\");\r\n        let findReplace_secondChild = findReplace_firstChild ? findReplace_firstChild.getNextBlock() : false;\r\n\r\n        //Find Textbox\r\n        let findText = block.getFieldValue(\"input_string_extra\");\r\n\r\n        //Replace Textbox\r\n        let replaceText = block.getFieldValue(\"input_replace_string_extra\");\r\n\r\n        let err = [];\r\n\r\n        if (!(findReplace_firstChild && findText && replaceText)) {\r\n            err.push(\"FindAndReplace block arguments should not be empty. Find any built in validations available in blockly.\");\r\n        }\r\n\r\n        if (findReplace_secondChild) {\r\n            err.push(\"Only one argument is allowed for FindAndReplace.\");\r\n        }\r\n        return err;\r\n    },\r\n\r\n    sort_operations: (block) => {\r\n        //About Sort Block\r\n        //This Block have one statement argument\r\n        //Accepts only one Variable(Source,Target,Work) --> this check will happen inbuilt\r\n        //Following fn will check Sort statement argument have one or multiple input\r\n        //All fileds mandatory check\r\n\r\n        let sort_firstChild = block.getInputTargetBlock(\"op_values\");\r\n        let sort_secondChild = sort_firstChild ? sort_firstChild.getNextBlock() : false;\r\n\r\n        return !sort_firstChild ?\r\n            \"Sort block arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            sort_secondChild ?\r\n                \"Only one argument is allowed for Sort.\" :\r\n                \"\";\r\n    },\r\n\r\n    sort_variable_operation: (block) => {\r\n        //About Sort Variable Operation Block\r\n        //This Block have two arguments\r\n        //1.Statement argument name @Sort\r\n        //Accepts only Dataset --> this check will happen inbuilt\r\n        //2.Statement argument name @By Variables\r\n        //Accepts only Variables  --> this check will happen inbuilt\r\n        //Accepts Variables that only from the used dataset in Sort statement \r\n        //Following fn will check @By Variables accepts Variables that only from the used dataset in Sort statement\r\n        //Following fn will check @Sort statement argument accepts only one dataset\r\n        //All fileds mandatory check\r\n\r\n        let isVarBlkNotFromSameDataset = false;\r\n        let isNotVarBlock = false;\r\n        let err = [];\r\n\r\n        //get sort Statement Block\r\n        let sort_statementBlk_firstChild = block.getInputTargetBlock(\"sort_variable\");\r\n        let sort_statementBlk_secondChild = sort_statementBlk_firstChild ? sort_statementBlk_firstChild.getNextBlock() : false;\r\n\r\n        //get sort by variable statement block \r\n        let by_var = block.getInputTargetBlock(\"by_variables\");\r\n\r\n        if (!(sort_statementBlk_firstChild) ||\r\n            !(by_var)) {\r\n            err.push(\"Sort block arguments should not be empty. Find any built in validations available in blockly.\");\r\n        }\r\n        if (sort_statementBlk_firstChild) {\r\n            if (sort_statementBlk_firstChild && sort_statementBlk_secondChild) {\r\n                err.push(\"Sort accepts only one Dataset.\");\r\n            }\r\n\r\n            //by variable validation\r\n            if ('data' in sort_statementBlk_firstChild && sort_statementBlk_firstChild.data !== null) {\r\n                let sort_statementBlkData = JSON.parse(sort_statementBlk_firstChild.data);\r\n                let sortDatasetName = sort_statementBlkData.blockType === \"Source\" ? sort_statementBlkData.TABLE_NAME : sort_statementBlkData.blockType === \"Target\" ? sort_statementBlkData.domain : sort_statementBlkData.name;\r\n\r\n                var get_var = (b) => {\r\n                    if (b && typeof b === \"object\") {\r\n\r\n                        if (isVariableType(b.type)) {\r\n                            if ('data' in b && b.data !== null) {\r\n                                let data = JSON.parse(b.data);\r\n                                // Variable based on source dataset\r\n                                if ('TABLE_NAME' in data) {\r\n                                    if (!isVarBlkNotFromSameDataset &&\r\n                                        sortDatasetName !== data.TABLE_NAME) {\r\n                                        err.push(\"By Variables should be from \" + sortDatasetName + \".\");\r\n                                        isVarBlkNotFromSameDataset = true;\r\n                                    }\r\n\r\n                                }   //Variable based on Target dataset\r\n                                else if ('cdiscDataStdDomainMetadataID' in data) {\r\n                                    if (!isVarBlkNotFromSameDataset &&\r\n                                        sortDatasetName !== data.domain) {\r\n                                        err.push(\"By Variables should be from \" + sortDatasetName + \".\");\r\n                                        isVarBlkNotFromSameDataset = true;\r\n                                    }\r\n\r\n                                }\r\n                                else if ('name' in data) {\r\n                                    if (!isVarBlkNotFromSameDataset &&\r\n                                        sortDatasetName !== data.name) {\r\n                                        err.push(\"By Variables should be from \" + sortDatasetName + \".\");\r\n                                        isVarBlkNotFromSameDataset = true;\r\n                                    }\r\n\r\n                                }\r\n\r\n                                if (isVarBlkNotFromSameDataset && isNotVarBlock) {\r\n                                    return;\r\n                                }\r\n\r\n                                let nxtConnectedBlock = b.getNextBlock();\r\n                                get_var(nxtConnectedBlock);\r\n                            }\r\n                            else if (!isVariableType(block.type)) {\r\n                                isNotVarBlock = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            isNotVarBlock = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (by_var) {\r\n                    get_var(by_var);\r\n                }\r\n\r\n                //Sort Statement validation End\r\n                if (isNotVarBlock) {\r\n                    err.push(\"By Variable Should accept only Variables.\");\r\n                }\r\n                return err;\r\n            }\r\n        }\r\n        return err;\r\n    },\r\n    simple_ops_mutiple_args_type: (block) => {\r\n        //About simple_ops_mutiple_args_type\r\n        //This block have two argument(1,2)\r\n        //1.Dropdown argument (DirectMove,NumToChar,CharToNum,UpperCase,LowerCase).\r\n        //2.Statment argument ,\r\n        //Statement argument accepts Variable --> this check will happen inbuilt,\r\n        //Following fn will check statement argument accepts only one input.\r\n        //All fileds mandatory check\r\n\r\n        let dropDownValue = block.getFieldValue(\"op_name\");\r\n        let statementBlk_firstChild = block.getInputTargetBlock(\"input_block\");\r\n        let statementBlk_secondChild = statementBlk_firstChild ? statementBlk_firstChild.getNextBlock() : false;\r\n\r\n        if (!statementBlk_firstChild) {\r\n            return dropDownValue + \" block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else if (statementBlk_secondChild) {\r\n            return \"Only one argument is allowed for \" + dropDownValue + \".\";\r\n        }\r\n    },\r\n    complex_ops_multi: (block) => {\r\n        //About complex_ops_multi\r\n        //This block have three arguments\r\n        //1.Dropdown argument (Group Min,Max,Avg,Sum).\r\n        //2.Statment argument name @ By Variables,\r\n        //By Variables accepts Variable --> this check will happen inbuilt,\r\n        //2.Statment argument name @ ID Variables,\r\n        //ID Variables accepts Variable --> this check will happen inbuilt,\r\n        //Following fn will check both By and ID Variables from same dataset.\r\n        //Following fn will check ID Variables accepts only one input.\r\n        //All fileds mandatory check\r\n\r\n        let isVarBlkNotFromSameDataset = false;\r\n        let isNotVarBlock = false;\r\n        let dataset = [];\r\n        let err = [];\r\n        let dropDownValue = block.getFieldValue(\"op_name\");\r\n\r\n        //This below get_var function called at end of this function\r\n        var get_var = (b) => {\r\n            if (b && typeof b === \"object\") {\r\n\r\n                if (isVariableType(b.type)) {\r\n                    if ('data' in b && b.data !== null) {\r\n                        let data = JSON.parse(b.data);\r\n\r\n                        // Variable based on source dataset\r\n                        if ('TABLE_NAME' in data) {\r\n                            if (dataset.length === 0) {\r\n                                dataset.push(data.TABLE_NAME);\r\n\r\n                            }\r\n                            else if (dataset.indexOf(data.TABLE_NAME) === -1) {\r\n                                isVarBlkNotFromSameDataset = true;\r\n                            }\r\n\r\n                        }\r\n                        //Variable based on Target dataset\r\n                        else if ('cdiscDataStdDomainMetadataID' in data) {\r\n                            if (dataset.length === 0) {\r\n                                dataset.push(data.domain);\r\n                            }\r\n                            else if (dataset.indexOf(data.domain) === -1) {\r\n                                isVarBlkNotFromSameDataset = true;\r\n                            }\r\n\r\n                        }\r\n\r\n                        if (isVarBlkNotFromSameDataset && isNotVarBlock) {\r\n                            return;\r\n                        }\r\n                        let nxtConnectedBlock = b.getNextBlock();\r\n                        get_var(nxtConnectedBlock);\r\n\r\n                    }\r\n                    else if (!isVariableType(block.type)) {\r\n                        isNotVarBlock = true;\r\n                    }\r\n                }\r\n                else {\r\n                    isNotVarBlock = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //get used variable block from by_variables statement in complex_ops_multi\r\n        let by_var = block.getInputTargetBlock(\"by_variables\");\r\n\r\n        ////get used variable block from ID statement in complex_ops_multi\r\n        let id_var = block.getInputTargetBlock(\"id_variable\");\r\n\r\n        if (!(id_var && typeof id_var === \"object\") ||\r\n            !(by_var && typeof by_var === \"object\")) {\r\n            err.push(dropDownValue + \" block argument should not be empty. Find any built in validations available in blockly.\");\r\n\r\n        }\r\n\r\n        //get used variable block from by_variables statement in complex_ops_multi\r\n        get_var(by_var);\r\n\r\n        //get used variable block from ID statement in complex_ops_multi\r\n        if (id_var && typeof id_var === \"object\") {\r\n            if (isVariableType(id_var.type)) {\r\n\r\n                if (id_var && typeof id_var === \"object\" && id_var.getNextBlock()) {\r\n                    err.push(\"ID Variables accepts only one Variables.\");\r\n                }\r\n\r\n                get_var(id_var);\r\n\r\n            }\r\n            else {\r\n                err.push(\"ID Variables accepts only Variables.\");\r\n            }\r\n        }\r\n\r\n        if (isVarBlkNotFromSameDataset) {\r\n            err.push(\"BY/ID Variables should be from \" + dataset[0] + \".\");\r\n\r\n        } if (isNotVarBlock) {\r\n            err.push(\"BY/ID Variables accepts only Variables.\");\r\n        }\r\n        return err;\r\n    },\r\n    merge_type: (block) => {\r\n        //About Merge Block\r\n        //This block have two arguments (1,2)\r\n        //1.Statment argument name @Merge,\r\n        //Merge accepts only dataset(Source,Target,Work) --> this check will happen inbuilt,\r\n        //2.Statment argument name @By Variables,\r\n        //By Variables accepts only drop type variables(Source,Target,Work) --> this check will happen inbuilt,\r\n        //Following fn will check Merge argument should allow two dataset\r\n        //Following fn will check By Variables arguments are should be common variable of Merge two dataset\r\n        //All fileds mandatory check\r\n\r\n        let err = [];\r\n        //First argument StatementBlk\r\n        let datasetBlk_firstChild = block.getInputTargetBlock(\"datasets_to_merge\");\r\n        let datasetBlk_secondChild = datasetBlk_firstChild ? datasetBlk_firstChild.getNextBlock() : false;\r\n\r\n        //Second argument Statement Block\r\n        let byVarBlk_firstChild = block.getInputTargetBlock(\"by_variables\");\r\n\r\n        //Last Field \r\n        let text = block.getFieldValue(\"if_condition_extra\");\r\n\r\n        if (!(datasetBlk_firstChild &&\r\n            byVarBlk_firstChild &&\r\n            text)) {\r\n            err.push(\"Merge block arguments should not be empty. Find any built in validations available in blockly.\");\r\n        }\r\n\r\n\r\n        //First StatementBlock (@Merge Block) accept only two datasets\r\n        if (datasetBlk_firstChild) {\r\n            if (datasetBlk_secondChild && !datasetBlk_secondChild.getNextBlock()) {\r\n                //get Two DataSet UniqueIDs\r\n                let datasetBlockIDs = [];\r\n                (function () {\r\n                    //get Two DataSet UniqueIDs \r\n                    //for to match with Varibles used in second statement block\r\n                    let firstDatasetBlk = datasetBlk_firstChild;\r\n                    let data1 = validJSON(firstDatasetBlk.data);\r\n\r\n                    let secondDatasetBlk = datasetBlk_secondChild;\r\n                    let data2 = validJSON(secondDatasetBlk.data);\r\n\r\n                    datasetBlockIDs = [data1.primaryID, data2.primaryID];\r\n\r\n                })();\r\n\r\n                //Fn to check used Variable Blocks are from used datasets Blocks\r\n                let isVarType = true;\r\n                let commonVariable = true;\r\n\r\n                let varBlockFn = (varBlk) => {\r\n                    if (varBlk && typeof varBlk === \"object\") {\r\n                        if (isVariableType(varBlk.type)) {\r\n                            let data = validJSON(varBlk.data);\r\n                            if (!data.bothParentDataset ||\r\n                                datasetBlockIDs.toString() !== data.bothParentDataset) {\r\n                                commonVariable = false;\r\n                                err.push(\"By variables should be from the datasets used in Merge Argument.\");\r\n                            }\r\n                        }\r\n                        else {\r\n                            isVarType = false;\r\n                            err.push(\"By Variables Should accept only Variables.\");\r\n                        }\r\n\r\n                        let nxtBlock = varBlk.getNextBlock();\r\n                        if ((isVarType || commonVariable) && nxtBlock) {\r\n                            varBlockFn(nxtBlock);\r\n                        }\r\n                    }\r\n                }\r\n                varBlockFn(byVarBlk_firstChild);\r\n            }\r\n            else {\r\n                err.push(\"Merge should accept two Datasets.\");\r\n            }\r\n        }\r\n        return err;\r\n    },\r\n    input_format_type: (block) => {\r\n        //About Input Format block\r\n        //This block have one arguments(1)\r\n        //1.Textbox arguments\r\n        //Following fn to check Input Format allow only \"C\" or \"N\"\r\n        //All fileds mandatory check\r\n        let textboxValue = block.getFieldValue(\"input_format\");\r\n        if (!textboxValue || textboxValue === \"\") {\r\n            return \"Input Format should not be empty.\"\r\n        }\r\n        //else if (textboxValue &&\r\n        //           (textboxValue.toLowerCase() !== \"c\" ||\r\n        //    textboxValue.toLowerCase() !== \"n\"))\r\n        //{\r\n        //    return \"Input Format should allow either C or N.\" \r\n        //}\r\n    },\r\n    output_format_type: (block) => {\r\n        //About Output Format block\r\n        //This block have one arguments(1)\r\n        //1.Textbox arguments\r\n        //Following fn to check Input Format allow only \"C\" or \"N\"\r\n        //All fileds mandatory check\r\n        let textboxValue = block.getFieldValue(\"output_format\");\r\n        if (!textboxValue || textboxValue === \"\") {\r\n            return \"Output Format should not be empty.\"\r\n        }\r\n        //else if (textboxValue &&\r\n        //    (textboxValue.toLowerCase() !== \"c\" ||\r\n        //    textboxValue.toLowerCase() !== \"n\")) {\r\n        //    return \"Output Format should allow either C or N.\"\r\n        //}\r\n    },\r\n    id_variable_type: (block) => {\r\n        //About ID Variable block\r\n        //This block have one arguments (1)\r\n        //1.Statment argument name @ID Variable,\r\n        //Accepts only variable(Source,Target,Work) --> this check will happen inbuilt,\r\n        //Following fn will check @ID Variable argument variable are single or multiple\r\n        //All fileds mandatory check\r\n\r\n        let statement_firstChild = block.getInputTargetBlock(\"id_variable\");\r\n        let statement_secondChild = statement_firstChild ? statement_firstChild.getNextBlock() : false;\r\n\r\n        return !statement_firstChild ?\r\n            \"ID Variable block should not be empty. Find any built in validations available in blockly.\" :\r\n            statement_secondChild ? \"ID Variable block accepts only one variable.\" : \"\";\r\n    },\r\n    arithmatic_operations: (block) => {\r\n        //About Arithmatic Operations block\r\n        //This block have two arguments (1,2)\r\n        //1.Dropdown argument [Add,Sub,Mul,Div],\r\n        //2.Statement argument\r\n        //Accepts only variable(Source,Target,Work) and int_constant_type_multi --> this check will happen inbuilt,\r\n        //Following fn will check Statement argument value should be int_constant_type_multi and varibale\r\n        //All fileds mandatory check\r\n\r\n        let dropDownValue = block.getFieldValue(\"arithmatic_operations\");\r\n\r\n        //Statement Argument\r\n        let firstChild = block.getInputTargetBlock(\"op_values\");\r\n        let err = [];\r\n\r\n        if (!firstChild) {\r\n            return dropDownValue + \" should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else {\r\n            let checkOnlyVarTypeOrIntLiteral = (blk) => {\r\n                if (blk && typeof blk === \"object\") {\r\n                    if (isVariableType(blk.type) || blk.type === \"int_constant_type_multi\") {\r\n                        let nxtBlk = blk.getNextBlock();\r\n                        checkOnlyVarTypeOrIntLiteral(nxtBlk);\r\n                    }\r\n                    else {\r\n                        err.push(dropDownValue + \" should accept only Variable or Int Literal.\");\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n            }\r\n            checkOnlyVarTypeOrIntLiteral(firstChild);\r\n            return err;\r\n\r\n        }\r\n    },\r\n    rename_type: (block) => {\r\n        //About Rename block\r\n        //This block have one arguments (1)\r\n        //1.Textbox argument,\r\n        //All fileds mandatory check\r\n        let textboxValue = block.getFieldValue(\"rename_var\");\r\n        return textboxValue === \"\" ?\r\n            \"Rename block should not be empty. Find any built in validations available in blockly.\" :\r\n            parseInt(textboxValue) ?\r\n                \"Rename block should accept only string.\" : \"\";\r\n    },\r\n    compress_type: (block) => {\r\n        //About Compress Block\r\n        //This block have Three arguments (1,2,3)\r\n        //1.StatementBlock name @Compress\r\n        //Accepts only variable (Source,Target,Work)--> this check will happen inbuilt \r\n        //2.Textbox arguments name @To Remove\r\n        //3.Textbox arguments name @Modifier\r\n        //Following fn will check Compress statement block have one or multiple input\r\n\r\n        let err = [];\r\n        //Compress statement block\r\n        let firstChild = block.getInputTargetBlock(\"compressvariable\");\r\n        let secondChild = firstChild ? firstChild.getNextBlock() : false;\r\n\r\n        //@To Remove textbox\r\n        let remove = block.getFieldValue(\"remove\");\r\n        //Modifier Textbox\r\n        let modifier = block.getFieldValue(\"modifier\");\r\n\r\n        if (!firstChild) {\r\n            err.push(\"Compress block arguments should not be empty. Find any built in validations available in blockly.\");\r\n        }\r\n        if (secondChild) {\r\n            err.push(\"Compress block should accept only one Variables.\");\r\n        }\r\n\r\n        return err;\r\n    },\r\n    filter_type: (block) => {\r\n        //About Filter Variable block\r\n        //This block have one arguments (1,2)\r\n        //1.Statment argument name @Filter,\r\n        //Accepts only Dataset(Source,Target,Work) --> this check will happen inbuilt,\r\n        //2.Statment argument name @Condition,\r\n        //Accepts only condition --> this check will happen inbuilt,\r\n        //Following fn will check @ID Variable argument variable are single or multiple\r\n        //All fileds mandatory check\r\n\r\n        let err = [];\r\n        //first argument\r\n        let filter_firstChild = block.getInputTargetBlock(\"filter_value\");\r\n        let filter_secondChild = filter_firstChild ? filter_firstChild.getNextBlock() : false;\r\n\r\n        //second argument\r\n        let condnArg_firstChild = block.getInputTargetBlock(\"filter_condition\");\r\n        if (!condnArg_firstChild || !filter_firstChild) {\r\n            err.push(\"Filter block argumnets should not be empty. Find any built in validations available in blockly.\");\r\n        }\r\n        if (filter_firstChild) {\r\n            if (filter_secondChild) {\r\n                err.push(\"Filter block argumnets accepts only one Dataset.\");\r\n            }\r\n        }\r\n        return err;\r\n    },\r\n    set_type: (block) => {\r\n        //About Set block\r\n        //This block have one arguments (1)\r\n        //1.Statement argument name @Set,\r\n        //All fileds mandatory check\r\n\r\n        let statement = block.getInputTargetBlock(\"set_statement\");\r\n        return !statement ?\r\n            \"Set block should not be empty. Find any built in validations available in blockly.\" :\r\n            \"\";\r\n    },\r\n    eq_type: (block) => {\r\n        //About eq_type block\r\n        //This block have two arguments (1,2,3)\r\n        //Dropdown values \r\n        //1.Statement argument  ,\r\n        //2.Statement argument  ,\r\n        //All fileds mandatory check\r\n        //First statement\r\n        let dropdownvalue = block.getFieldValue(\"operator_name\");\r\n\r\n        let statement_left = block.getInputTargetBlock(\"left_values\");\r\n\r\n        let statement_right = block.getInputTargetBlock(\"right_values\");\r\n\r\n\r\n        return (!statement_left || !statement_right) ?\r\n            dropdownvalue + \" arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            \"\";\r\n    },\r\n    andor_type: (block) => {\r\n        //About andor_type block\r\n        //This block have two arguments (1,2,3)\r\n        //Dropdown values \r\n        //1.Statement argument  ,\r\n        //2.Statement argument  ,\r\n        //All fileds mandatory check\r\n\r\n        let dropdownvalue = block.getFieldValue(\"operator\");\r\n\r\n        let statement_left = block.getInputTargetBlock(\"left_value\");\r\n        let statement_right = block.getInputTargetBlock(\"right_value\");\r\n\r\n        return (!statement_left || !statement_right) ?\r\n            dropdownvalue + \" arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            \"\";\r\n    },\r\n    condition_type: (block) => {\r\n        //About Condition_Then block\r\n        //This block have two arguments (1,2)\r\n        //1.Statement argument  ,\r\n        //2.Statement argument  ,\r\n        //All fileds mandatory check\r\n\r\n        //First statement\r\n        let statement_firstChild = block.getInputTargetBlock(\"Condition\");\r\n\r\n        let statement_secondChild = block.getInputTargetBlock(\"Then\");\r\n\r\n        return (!statement_firstChild || !statement_secondChild) ?\r\n            \"Condition block arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            \"\";\r\n    },\r\n    where_type: (block) => {\r\n        //About Where block\r\n        //This block have two argument (1)\r\n        //1.Statement argument  ,\r\n        //All fileds mandatory check\r\n\r\n        //First statement\r\n        let statement = block.getInputTargetBlock(\"where_value\");\r\n\r\n        return (!statement) ?\r\n            \"Where block arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            \"\";\r\n    },\r\n    concatenate_type: (block) => {\r\n        //About concatenate block\r\n        //This block have one argument (1)\r\n        //1.Statement argument  ,\r\n        //All fileds mandatory check\r\n\r\n        //First statement\r\n        let statement = block.getInputTargetBlock(\"concatenate_statement\");\r\n\r\n        if (!statement) {\r\n            return \"Concatenate block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else {\r\n            let err =\r\n            {\r\n                intLitPresent: false,\r\n                isVarBlkPresent: false,\r\n                minBlk: 2,\r\n                msg: []\r\n            };\r\n\r\n            let checkOnlyVarType = (blk, index) => {\r\n                if (blk && typeof blk === \"object\") {\r\n                    if (!err.intLitPresent && blk.type === \"int_constant_type_multi\") {\r\n                        err.intLitPresent = !err.intLitPresent;\r\n                        err.msg.push(\"Concatenate block should accept only string literal and variable block.\");\r\n                    }\r\n                    if (!err.isVarBlkPresent && isVariableType(blk.type)) {\r\n                        err.isVarBlkPresent = !err.isVarBlkPresent;\r\n                    }\r\n\r\n                    let nxtBlk = blk.getNextBlock();\r\n                    //loop control\r\n\r\n                    if (nxtBlk && (!err.intLitPresent || !err.isVarBlkPresent)) {\r\n                        return checkOnlyVarType(nxtBlk, index + 1);\r\n                    }\r\n                    else {\r\n                        if (index === 1) {\r\n                            err.msg.push(\"Concatenate should have minimum 2 blocks \");\r\n                        }\r\n                        return !err.isVarBlkPresent ?\r\n                            [...err.msg, \"Concatenate block should accept atleast one variable.\"] : err.msg;\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n            return checkOnlyVarType(statement, 1);\r\n        }\r\n    },\r\n    sort_seq_type: (block) => {\r\n        //About sort_seq block\r\n        //This block have one argument (1)\r\n        //1.Statement argument  ,\r\n        //All fileds mandatory check\r\n\r\n        let err = [];\r\n        //First statement\r\n        let statement = block.getInputTargetBlock(\"by_variables\");\r\n\r\n        if (!statement) {\r\n            return \"Seq By Variables block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else {\r\n            //Check DataType it shoul be variable \r\n            let dataType_check_err = false;\r\n            //Variable should be from same dataset\r\n            let var_from_same_dataset_check_err = false;\r\n            let data = JSON.parse(statement.data);\r\n\r\n            let fromDatasetName = \"TABLE_NAME\" in data ? data.TABLE_NAME : data.domain;\r\n\r\n            let is_variable_from_samedataset = (blk) => {\r\n                if (blk && typeof blk === \"object\") {\r\n                    if (isVariableType(blk.type)) {\r\n                        if ('data' in blk && blk.data !== null && !var_from_same_dataset_check_err) {\r\n                            let data = JSON.parse(blk.data);\r\n                            // Variable based on source dataset\r\n                            if ('TABLE_NAME' in data) {\r\n                                if (!var_from_same_dataset_check_err &&\r\n                                    fromDatasetName !== data.TABLE_NAME) {\r\n                                    err.push(\"Seq By Variables block should be from \" + fromDatasetName + \".\");\r\n                                    var_from_same_dataset_check_err = true;\r\n                                }\r\n                            }\r\n                            //Variable based on Target dataset\r\n                            else if ('cdiscDataStdDomainMetadataID' in data) {\r\n                                if (!var_from_same_dataset_check_err &&\r\n                                    fromDatasetName !== data.domain) {\r\n                                    err.push(\"Seq By Variables block should be from \" + fromDatasetName + \".\");\r\n                                    var_from_same_dataset_check_err = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        dataType_check_err = true;\r\n                        err.push(\"Seq By Variables block should accept only variables.\");\r\n                    }\r\n\r\n                    if (!dataType_check_err || !var_from_same_dataset_check_err) {\r\n                        let nxtBlk = blk.getNextBlock();\r\n                        if (nxtBlk) {\r\n                            is_variable_from_samedataset(nxtBlk);\r\n                        }\r\n                    }\r\n                    else {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            is_variable_from_samedataset(statement);\r\n            return err;\r\n        }\r\n    },\r\n    constant_type_multi: (block) => {\r\n        //About Literal block\r\n        //Blocks can be empty for null/empty check\r\n        return \"\";\r\n    },\r\n    keep_drop_type2: (block) => {\r\n        //About Keep Drop block\r\n        //This block have two arguments (1,2)\r\n        //1.Dropdown argument (Keep,Drop)\r\n        //2.Statement argument\r\n        //Accepts only variable(Source,Target,Work)  --> this check will happen inbuilt,\r\n        //All fileds mandatory check\r\n        let err = [];\r\n        let dropDownValue = block.getFieldValue(\"keep_drop\");\r\n\r\n        //Statement Argument\r\n        let statement = block.getInputTargetBlock(\"variables\");\r\n\r\n        if (!statement) {\r\n            return dropDownValue + \" should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else {\r\n            //Check DataType it shoul be variable or int_constant_type_multi\r\n            let dataType_check_err = false;\r\n            //Variable should be from same dataset\r\n            let var_from_same_dataset_check_err = false;\r\n\r\n            let data = JSON.parse(statement.data);\r\n\r\n            //get first used datasetname\r\n            let fromDatasetName = getDatasetByVar(data);\r\n\r\n            let is_variable_from_samedataset = (blk) => {\r\n                if (blk && typeof blk === \"object\") {\r\n                    if (isVariableType(blk.type) || blk.type === \"int_constant_type_multi\") {\r\n                        if ('data' in blk && blk.data !== null && !var_from_same_dataset_check_err) {\r\n                            let data = JSON.parse(blk.data);\r\n\r\n                            let prevBlock = block && block.getPreviousBlock();\r\n                            if (prevBlock && prevBlock != \"\" && typeof prevBlock == 'object' && (prevBlock.type != \"merge_type\" && prevBlock.type != \"set_type\")) {\r\n                                // Variable based on source dataset\r\n                                switch (data.blockType) {\r\n                                    case \"SourceVar\":\r\n                                        if (!var_from_same_dataset_check_err &&\r\n                                            fromDatasetName !== data.TABLE_NAME) {\r\n                                            err.push(dropDownValue + \" block should be from \" + fromDatasetName + \".\");\r\n                                            var_from_same_dataset_check_err = true;\r\n                                        }\r\n                                        break;\r\n                                    case \"TargetVar\":\r\n                                        if (!var_from_same_dataset_check_err &&\r\n                                            fromDatasetName !== data.domain) {\r\n                                            err.push(dropDownValue + \" block should be from \" + fromDatasetName + \".\");\r\n                                            var_from_same_dataset_check_err = true;\r\n                                        }\r\n                                        break;\r\n                                    case \"WorkVar\":\r\n                                        if (!var_from_same_dataset_check_err &&\r\n                                            fromDatasetName !== data.dataset) {\r\n                                            err.push(dropDownValue + \" block should be from \" + fromDatasetName + \".\");\r\n                                            var_from_same_dataset_check_err = true;\r\n                                        }\r\n                                        break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        dataType_check_err = true;\r\n                        err.push(dropDownValue + \" block should accept only variables and Int literals.\");\r\n                    }\r\n\r\n                    if (!dataType_check_err || !var_from_same_dataset_check_err) {\r\n                        let nxtBlk = blk.getNextBlock();\r\n                        if (nxtBlk) {\r\n                            is_variable_from_samedataset(nxtBlk);\r\n                        }\r\n                    }\r\n                    else {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            is_variable_from_samedataset(statement);\r\n            return err;\r\n\r\n        }\r\n    },\r\n    transpose_operation: (block) => {\r\n        //About complex_ops_multi\r\n        //This block have three arguments\r\n        //1.Dropdown argument (Group Min,Max,Avg,Sum).\r\n        //2.Statment argument name @ By Variables,\r\n        //By Variables accepts Variable --> this check will happen inbuilt,\r\n        //2.Statment argument name @ ID Variables,\r\n        //ID Variables accepts Variable --> this check will happen inbuilt,\r\n        //Following fn will check both By and ID Variables from same dataset.\r\n        //Following fn will check ID Variables accepts only one input.\r\n        //All fileds mandatory check\r\n\r\n        let var_from_same_dataset_check_err = false;\r\n        let isNotVarBlock = false;\r\n        let err = [];\r\n\r\n        function transpose_validation(blk) {\r\n            this.TranseBlock = blk;\r\n            this.usedDataset = {};\r\n            this.usedDatasetName = \"\";\r\n            this.allUsedBlock = [];\r\n\r\n        }\r\n\r\n\r\n        transpose_validation.prototype.begins = function () {\r\n\r\n            let { TranseBlock } = this;\r\n\r\n            //Check Multi dataset are used\r\n            this.allDataset = TranseBlock.getInputTargetBlock(\"transpose_dataset\");\r\n\r\n            if (this.isAllValuePresent()) {\r\n                return this.datasetvalidation();\r\n            }\r\n            else {\r\n                return err;\r\n            }\r\n\r\n        }\r\n\r\n        //Check mandatory\r\n        transpose_validation.prototype.isAllValuePresent = function () {\r\n            //temp variable\r\n            let out = true;\r\n            [{ type: \"transpose_dataset\", name: \"Transpose\" },\r\n            { type: \"by_variables\", name: \"By Variable(s)\" },\r\n            { type: \"var_variables\", name: \"VAR Variable(s)\" }].map((stmt) => {\r\n\r\n                if (!block.getInputTargetBlock(stmt.type)) {\r\n                    out = false;\r\n                    err.push(stmt.name + \" should not be empty.\")\r\n                }\r\n            });\r\n\r\n            return out;\r\n        }\r\n\r\n        //Check Only SIngle dataset\r\n        transpose_validation.prototype.datasetvalidation = function () {\r\n            let { allDataset, TranseBlock } = this;\r\n\r\n            if (allDataset && \"getNextBlock\" in allDataset && !allDataset.getNextBlock()) {\r\n\r\n                let dataset = allDataset.getDescendants()[0];\r\n                let data = JSON.parse(dataset.data);\r\n\r\n                this.usedDataset = data;\r\n                this.usedDatasetName = getDataset(data);\r\n                this.allUsedBlock = TranseBlock.getDescendants();\r\n                return this.isAllVarFromUsedDataset();\r\n\r\n            }\r\n            else {\r\n                err = [\"Transpose block should accept only one Dataset.\"];\r\n                return err;\r\n            }\r\n        }\r\n\r\n        //Check all var from same used dataset\r\n        transpose_validation.prototype.isAllVarFromUsedDataset = function () {\r\n            let { allUsedBlock, usedDatasetName } = this;\r\n\r\n            function isVarFromUsedDataset(blk, statementname, notCheckMandatory = false) {\r\n                if (blk && typeof blk === \"object\") {\r\n                    if (isVariableType(blk.type)) {\r\n                        if ('data' in blk && blk.data !== null) {\r\n                            let data = JSON.parse(blk.data);\r\n\r\n                            // Variable based on source dataset\r\n                            switch (data.blockType) {\r\n                                case \"SourceVar\":\r\n                                    if (usedDatasetName !== data.TABLE_NAME) {\r\n                                        err.push(statementname + \" block should be from \" + usedDatasetName + \".\");\r\n                                        var_from_same_dataset_check_err = true;\r\n                                    }\r\n                                    break;\r\n                                case \"TargetVar\":\r\n                                    if (usedDatasetName !== data.domain) {\r\n                                        err.push(statementname + \" block should be from \" + usedDatasetName + \".\");\r\n                                        var_from_same_dataset_check_err = true;\r\n                                    }\r\n                                    break;\r\n                                case \"WorkVar\":\r\n                                    if (usedDatasetName !== data.dataset) {\r\n                                        err.push(statementname + \" block should be from \" + usedDatasetName + \".\");\r\n                                        var_from_same_dataset_check_err = true;\r\n                                    }\r\n                                    break;\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    else {\r\n                        isNotVarBlock = true;\r\n\r\n                        err.push(statementname + \" block should accept only variables.\");\r\n                    }\r\n\r\n                    let nxtBlk = blk.getNextBlock();\r\n                    if (nxtBlk) {\r\n                        isVarFromUsedDataset(nxtBlk, statementname);\r\n                    }\r\n                    else {\r\n                        return;\r\n                    }\r\n\r\n                }\r\n                else {\r\n                    !notCheckMandatory && err.push(statementname + \" block argument should not be empty.Find any built in validations available in blockly\");\r\n\r\n                }\r\n\r\n            }\r\n\r\n            //get used variable block from by_variables statement in complex_ops_multi\r\n            isVarFromUsedDataset(block.getInputTargetBlock(\"by_variables\"), \"By Variable(s)\");\r\n            isVarFromUsedDataset(block.getInputTargetBlock(\"var_variables\"), \"VAR Variable(s)\");\r\n\r\n            //For only variable only allowed validation\r\n            isVarFromUsedDataset(block.getInputTargetBlock(\"copy_variables\"), \"Copy Variable(s)\", true);\r\n            isVarFromUsedDataset(block.getInputTargetBlock(\"id_variable\"), \"ID Variable(s)\", true);\r\n\r\n            return err;\r\n\r\n        }\r\n\r\n\r\n        var transposevalidation = new transpose_validation(block);\r\n        return transposevalidation.begins();\r\n    },\r\n\r\n    bulkmap_type: (block) => {\r\n        //About BulkMap Block\r\n        //This Block have three arguments\r\n        //1.Statement argument name @BulkMap\r\n        // BulkMap statement Accepts only one Source Datatable variable/Target Datatable varaible.--> this check will happen inbuilt\r\n        //2.Statement argument name @Config variable\r\n        // Config variable will accept only bulkmap variables from operations section\r\n        //3.Statement argument name @Condition\r\n        //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\r\n        //Condition may be single or multiple\r\n        //Following fn will check BulkMap statement block have one or multiple input.\r\n        //mandatory check.\r\n\r\n        //BulkMap Statement\r\n        let bulkmapBlk_firstChild = block.getInputTargetBlock(\"map_value\");\r\n        let bulkmapBlk_secondChild = bulkmapBlk_firstChild ? bulkmapBlk_firstChild.getNextBlock() : false;\r\n\r\n        //Config variable statement\r\n        let configBlock_firstChild = block.getInputTargetBlock(\"config_variable\");\r\n        let configBlock_secondChild = configBlock_firstChild ? configBlock_firstChild.getNextBlock() : false;\r\n\r\n        if (!bulkmapBlk_firstChild || !configBlock_firstChild) {\r\n            return \"Bulk Map block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        if (bulkmapBlk_secondChild) {\r\n            return \"Only one argument is allowed for BulkMap.\";\r\n        }\r\n\r\n        if (configBlock_secondChild) {\r\n            return \"Only one argument is allowed for Config variable.\";\r\n        }\r\n    },\r\n\r\n    unitconvert_type: (block) => {\r\n        //About UnitConversion Block\r\n        //This Block have six arguments\r\n        //1.Statement argument name @UnitConversion\r\n        // UnitConversion statement Accepts only one Source Datatable variable/Target Datatable varaible.--> this check will happen inbuilt\r\n        //2.Statement argument name @TestName\r\n        // TestName variable will accept only input\r\n        //3.Statement argument name @TestCode\r\n        // TestCode variable will accept only input\r\n        //4.Statement argument name @Specimen\r\n        // Specimen variable will accept only input\r\n        //5.Statement argument name @Category\r\n        // Category variable will accept only input\r\n        //6.Statement argument name @Condition\r\n        //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\r\n        //Condition may be single or multiple\r\n        //Following fn will check UnitConversion statement block have one or multiple input.\r\n        //mandatory check.\r\n\r\n        //UnitConversion Statement\r\n        let unitconvBlk_firstChild = block.getInputTargetBlock(\"map_value\");\r\n        let unitconvBlk_secondChild = unitconvBlk_firstChild ? unitconvBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestName Statement\r\n        let testnameBlk_firstChild = block.getInputTargetBlock(\"test_name\");\r\n        let testnameBlk_secondChild = testnameBlk_firstChild ? testnameBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestCode Statement\r\n        let testcodeBlk_firstChild = block.getInputTargetBlock(\"test_code\");\r\n        let testcodeBlk_secondChild = testcodeBlk_firstChild ? testcodeBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestCategory Statement\r\n        let testcategoryBlk_firstChild = block.getInputTargetBlock(\"test_cat\");\r\n        let testcategoryBlk_secondChild = testcategoryBlk_firstChild ? testcategoryBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestSpecimen Statement\r\n        let testspecBlk_firstChild = block.getInputTargetBlock(\"test_spec\");\r\n        let testspecBlk_secondChild = testspecBlk_firstChild ? testspecBlk_firstChild.getNextBlock() : false;\r\n\r\n        //Mandatory check\r\n        if ((!unitconvBlk_firstChild && (!testnameBlk_firstChild || !testcodeBlk_firstChild || !testcategoryBlk_firstChild || !testspecBlk_firstChild))) {\r\n            return \"Unit Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else if ((unitconvBlk_firstChild && (!testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild))) {\r\n            return \"Unit Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else {\r\n            if ((!unitconvBlk_firstChild && (testnameBlk_firstChild || testcodeBlk_firstChild || testcategoryBlk_firstChild || testspecBlk_firstChild)))\r\n                return \"Unit Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n\r\n        //Second value check\r\n        if (unitconvBlk_secondChild) {\r\n            return \"Only one argument is allowed for Unit Conversion.\";\r\n        }\r\n        else if (testnameBlk_secondChild) {\r\n            return \"Only one argument is allowed for Test Name.\";\r\n        }\r\n        else if (testcodeBlk_secondChild) {\r\n            return \"Only one argument is allowed for Test Code.\";\r\n        }\r\n        else if (testcategoryBlk_secondChild) {\r\n            return \"Only one argument is allowed for Test Category.\";\r\n        }\r\n        else {\r\n            if (testspecBlk_secondChild) {\r\n                return \"Only one argument is allowed for Specimen.\";\r\n            }\r\n        }\r\n    },\r\n\r\n    substring_type: (block) => {\r\n        //About Substring Block\r\n        //This Block have three arguments\r\n        //1.Statement argument name @Substring\r\n        //Accepts only Variable(Source,Target,Work) for first argument  --> this check will happen inbuilt\r\n        //2.Textbox argument name @start is mandatory\r\n        //3.TextBox argument name @end is optional\r\n        //Following fn will check Substring statement argument have one or multiple input\r\n        //All fileds mandatory check\r\n\r\n        //Substring\r\n        let substring_firstChild = block.getInputTargetBlock(\"fr_statement\");\r\n        let substring_secondChild = substring_firstChild ? substring_firstChild.getNextBlock() : false;\r\n\r\n        //Start Textbox\r\n        let startText = block.getFieldValue(\"start_extra\");\r\n\r\n        //End Textbox\r\n        let endText = block.getFieldValue(\"end_extra\");\r\n\r\n        let err = [];\r\n\r\n        //Mandatory Check\r\n        if (!(substring_firstChild && startText)) {\r\n            err.push(\"SubString block arguments should not be empty. Find any built in validations available in blockly.\");\r\n        }\r\n\r\n        //Second value check\r\n        if (substring_secondChild) {\r\n            err.push(\"Only one argument is allowed for SubString.\");\r\n        }\r\n        return err;\r\n    },\r\n\r\n    unit_operations: (block) => {\r\n        //About unit_operations block\r\n        //This block have one arguments\r\n        //Dropdown values (TestCode, Specimen , Category)\r\n        //All fileds mandatory check\r\n        //First statement\r\n\r\n        //Unit Operations\r\n        let dropdownvalue = block.getFieldValue(\"unit_operations\");\r\n\r\n        //SourceTestName statement\r\n        let sourcetestnameBlk_firstChild = block.getInputTargetBlock(\"input_block\");\r\n        let sourcetestnameBlk_secondChild = sourcetestnameBlk_firstChild ? sourcetestnameBlk_firstChild.getNextBlock() : false;\r\n\r\n        //Multi input check\r\n        if (sourcetestnameBlk_secondChild) {\r\n            return \"Only one argument is allowed for \" + dropdownvalue + \".\";\r\n        }\r\n\r\n        //Mandatory Check\r\n        return (!sourcetestnameBlk_firstChild) ?\r\n            dropdownvalue + \" arguments should not be empty. Find any built in validations available in blockly.\" :\r\n            \"\";\r\n    },\r\n\r\n    unitresult_type: (block) => {\r\n        //About UnitResultConversion Block\r\n        //This Block have seven arguments\r\n        //1.Statement argument name @UnitResultConversion\r\n        // UnitResultConversion statement Accepts only one Source Datatable variable/Target Datatable varaible.--> this check will happen inbuilt\r\n        //2.Statement argument name @UnitVariable\r\n        // TestName variable will accept only input\r\n        //3.Statement argument name @TestName\r\n        // TestName variable will accept only input\r\n        //4.Statement argument name @TestCode\r\n        // TestCode variable will accept only input\r\n        //5.Statement argument name @Specimen\r\n        // Specimen variable will accept only input\r\n        //6.Statement argument name @Category\r\n        // Category variable will accept only input\r\n        //7.Statement argument name @Condition\r\n        //Conditions statement should be condition(condition_type) --> this check will happen inbuilt ,\r\n        //Condition may be single or multiple\r\n        //Following fn will check UnitConversion statement block have one or multiple input.\r\n        //mandatory check.\r\n\r\n        //UnitConversion Statement\r\n        let unitresultBlk_firstChild = block.getInputTargetBlock(\"map_value\");\r\n        let unitresultBlk_secondChild = unitresultBlk_firstChild ? unitresultBlk_firstChild.getNextBlock() : false;\r\n\r\n        //UnitVariable Statement\r\n        let unitvar_firstChild = block.getInputTargetBlock(\"unit_variable\");\r\n        let unitvar_secondChild = unitvar_firstChild ? unitvar_firstChild.getNextBlock() : false;\r\n\r\n        //TestName Statement\r\n        let testnameBlk_firstChild = block.getInputTargetBlock(\"test_name\");\r\n        let testnameBlk_secondChild = testnameBlk_firstChild ? testnameBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestCode Statement\r\n        let testcodeBlk_firstChild = block.getInputTargetBlock(\"test_code\");\r\n        let testcodeBlk_secondChild = testcodeBlk_firstChild ? testcodeBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestCategory Statement\r\n        let testcategoryBlk_firstChild = block.getInputTargetBlock(\"test_cat\");\r\n        let testcategoryBlk_secondChild = testcategoryBlk_firstChild ? testcategoryBlk_firstChild.getNextBlock() : false;\r\n\r\n        //TestSpecimen Statement\r\n        let testspecBlk_firstChild = block.getInputTargetBlock(\"test_spec\");\r\n        let testspecBlk_secondChild = testspecBlk_firstChild ? testspecBlk_firstChild.getNextBlock() : false;\r\n\r\n        //Mandatory Check\r\n        if ((!unitresultBlk_firstChild && !unitvar_firstChild && (!testnameBlk_firstChild || !testcodeBlk_firstChild || !testcategoryBlk_firstChild || !testspecBlk_firstChild))) {\r\n            return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else if ((unitresultBlk_firstChild && !unitvar_firstChild && (!testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild))) {\r\n            return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else if ((!unitresultBlk_firstChild || unitvar_firstChild && (!testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild))) {\r\n            return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else if (((unitresultBlk_firstChild || !unitvar_firstChild) && (!testnameBlk_firstChild && !testcodeBlk_firstChild && !testcategoryBlk_firstChild && !testspecBlk_firstChild))) {\r\n            return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n        else {\r\n            if ((!unitresultBlk_firstChild || !unitvar_firstChild && (testnameBlk_firstChild || testcodeBlk_firstChild || testcategoryBlk_firstChild || testspecBlk_firstChild)))\r\n                return \"Unit Result Conversion block arguments should not be empty. Find any built in validations available in blockly.\";\r\n        }\r\n\r\n        //Multi input check\r\n        if (unitresultBlk_secondChild) {\r\n            return \"Only one argument is allowed for Unit Result Conversion.\";\r\n        }\r\n        else if (unitvar_secondChild) {\r\n            return \"Only one argument is allowed for Unit Variable.\";\r\n        }\r\n        else if (testnameBlk_secondChild) {\r\n            return \"Only one argument is allowed for Test Name.\";\r\n        }\r\n        else if (testcodeBlk_secondChild) {\r\n            return \"Only one argument is allowed for Test Code.\";\r\n        }\r\n        else if (testcategoryBlk_secondChild) {\r\n            return \"Only one argument is allowed for Test Category.\";\r\n        }\r\n        else {\r\n            if (testspecBlk_secondChild) {\r\n                return \"Only one argument is allowed for Specimen.\";\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nlet getDataset = (data) => {\r\n    if (\"blockType\" in data) {\r\n        switch (data.blockType) {\r\n            case \"Source\":\r\n                //console.log(\"s\")\r\n                return data.TABLE_NAME\r\n\r\n            case \"Target\":\r\n                return data.domain\r\n\r\n            case \"Work\":\r\n                return data.name\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n\r\n}\r\nlet getDatasetByVar = (data) => {\r\n    if (\"blockType\" in data) {\r\n        switch (data.blockType) {\r\n            case \"SourceVar\":\r\n                //console.log(\"s\")\r\n                return data.TABLE_NAME\r\n\r\n            case \"TargetVar\":\r\n                return data.domain\r\n\r\n            case \"WorkVar\":\r\n                return data.dataset\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n}\r\n\r\nlet isVariableType = (type) => {\r\n    let varaibleBlocks = [\"variable_type_drop_multi\",\r\n        \"variable_type_target_multi\", \"variable_type_source_multi\",\r\n        \"variable_type_work_multi\",\r\n        \"variable_type_drop_multi\",\r\n        \"variable_type_work_multi_2\",\r\n        \"variable_type_target_multi_2\",\r\n        \"variable_type_source_multi_2\"];\r\n    return varaibleBlocks.indexOf(type) === -1 ? false : true;\r\n\r\n}\r\n\r\n\r\nlet isDataset = (type) => {\r\n    let targetBlockTypes = [\"dataset_type_multi_source\",\r\n        \"dataset_type_multi_target\",\r\n        \"dataset_type_multi_work\"];\r\n    return targetBlockTypes.indexOf(type) === -1 ? false : true;\r\n\r\n}\r\n\r\nexport let StepBlockValidation = (stepToCheck, blocks) => {\r\n\r\n    switch (stepToCheck) {\r\n        case \"allstep\":\r\n            {\r\n                let final = blocks.find(x => x.type === \"final_step_type\");\r\n                let final_statementBlock = final ? final.getInputTargetBlock(\"step_statement\") : false;\r\n\r\n                let step_datatable = blocks.filter(x => x.type === \"step_type\");\r\n                let step_datatable_statementBlock = step_datatable.length > 0 ? step_datatable.some(st => {\r\n\r\n                    return !st.getInputTargetBlock(\"step_statement\");\r\n                }) :\r\n                    false;\r\n\r\n                let step_variable = blocks.filter(x => x.type === \"step_type_variable\");\r\n                let step_variable_statementBlock = step_variable.length > 0 ? step_variable.some(st => {\r\n\r\n                    return !st.getInputTargetBlock(\"step_statement\");\r\n                }) :\r\n                    false;\r\n\r\n\r\n                return ((step_variable.length === 0 || !step_variable_statementBlock) &&\r\n                    (step_datatable.length === 0 || !step_datatable_statementBlock) &&\r\n                    (final_statementBlock && typeof final_statementBlock === \"object\"));\r\n            }\r\n        case \"step_type_and_step_type_variable\":\r\n            {\r\n\r\n                let step_datatable = blocks.filter(x => x.type === \"step_type\");\r\n                let empty_step_datatable_statementBlock = step_datatable.some(sd => {\r\n                    return !isObjectCheck(sd.getInputTargetBlock(\"step_statement\"));\r\n                });\r\n\r\n                let step_variable = blocks.filter(x => x.type === \"step_type_variable\");\r\n                let empty_step_variable_statementBlock = step_variable.some(sd => {\r\n                    return !isObjectCheck(sd.getInputTargetBlock(\"step_statement\"));\r\n                });\r\n\r\n                return !empty_step_datatable_statementBlock && !empty_step_variable_statementBlock;\r\n            }\r\n        case \"partialstep\":\r\n            {\r\n                let final = blocks.find(x => x.type === \"final_step_type\");\r\n                let final_statementBlock = final ? final.getInputTargetBlock(\"step_statement\") : true;\r\n\r\n                let step_datatable = blocks.filter(x => x.type === \"step_type\");\r\n                let step_datatable_statementBlock = step_datatable.length > 0 ? step_datatable.some(st => {\r\n\r\n                    return !st.getInputTargetBlock(\"step_statement\");\r\n                }) : false;\r\n\r\n                let step_variable = blocks.filter(x => x.type === \"step_type_variable\");\r\n                let step_variable_statementBlock = step_variable.length > 0 ? step_variable.some(st => {\r\n\r\n                    return !st.getInputTargetBlock(\"step_statement\");\r\n                }) : false;\r\n\r\n                return ((step_variable.length === 0 || !step_variable_statementBlock) &&\r\n                    (step_datatable.length === 0 || !step_datatable_statementBlock) &&\r\n                    (final_statementBlock || isObjectCheck(final_statementBlock === \"object\")));\r\n            }\r\n    }\r\n}\r\n\r\n//Get all the variable of used variable's dataset in Finalstep / in Keep drop\r\n//@Note --- For Program Execution page by variable concept\r\n//passing this values in Extra2 \r\n//If Keep or drop not used, All variables in that domain should be sent in \"Extra1\"\r\n//If keep is used, only the variables used inside keep should be sent in \"Extra1\"\r\n//If drop is used, take all variables in that domain and remove variables used in drop and send remaining in \"Extra1\"\r\n\r\nexport function Get_Var_From_Step(SourceDataset = [], Standards = [], MappingDatas = [], work_datasets = []) {\r\n\r\n\r\n    this.SourceDataset = SourceDataset;\r\n    this.Standards = Standards;\r\n    this.MappingDatas = MappingDatas;\r\n    this.work_datasets = work_datasets;\r\n    //Finalstep/Variable step\r\n    //Initially null\r\n    this.StepType = \"\";\r\n    this.SourceOfRule = {};\r\n\r\n\r\n}\r\n\r\nGet_Var_From_Step.prototype.init = function () {\r\n    try {\r\n        let { StepType, StepBlock, SourceOfRule, WorkDataTable } = this;\r\n        switch (StepType.toLowerCase()) {\r\n            case \"variablestep\":\r\n                {\r\n\r\n                    //get first used statement block\r\n                    let First_Statement_Blks = StepBlock.getInputTargetBlock(\"step_statement\");\r\n                    //do\r\n                    //{\r\n                    //    children.push(Statement_Blks);\r\n                    //} while (Statement_Blks = Statement_Blks.getNextBlock());\r\n                    if (First_Statement_Blks) {\r\n                        //get all used block inside the variable step  \r\n                        let children = First_Statement_Blks && typeof First_Statement_Blks === \"object\" ? First_Statement_Blks.getDescendants() : [];\r\n                        //get only dataset blk from datatable step\r\n\r\n                        let is_keep_drop_used = children ? children.filter(x => x.type === \"keep_drop_type2\") : [];\r\n\r\n                        if (is_keep_drop_used.length > 0) {\r\n                            return validJSON(this.Var_From_KeepDrop(is_keep_drop_used[0]));\r\n                        }\r\n                        else {\r\n                            if (First_Statement_Blks.type === \"hardcode_type\") {\r\n\r\n                                let Variable = (this.SourceDataset && \"Variable\" in this.SourceDataset) ?\r\n                                    this.SourceDataset.Variable : [];\r\n\r\n                                let source_var = [];\r\n                                Variable = Variable.filter(v => v.TABLE_NAME === SourceOfRule.sourceDataset);\r\n                                source_var = (Variable || []).map(va => {\r\n                                    return {\r\n                                        memname: WorkDataTable,\r\n                                        name: va.COLUMN_NAME\r\n                                    }\r\n                                });\r\n\r\n                                return source_var;\r\n                            }\r\n                            else {\r\n                                return validJSON(this.Var_From_Step(children));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        return []\r\n                    }\r\n                }\r\n                break;\r\n            case \"datatablestep\":\r\n                {\r\n\r\n                    let First_Statement_Blks = StepBlock.getInputTargetBlock(\"step_statement\");\r\n                    //do {\r\n                    //    children.push(Statement_Blks);\r\n                    //} while (Statement_Blks = Statement_Blks.getNextBlock());\r\n                    if (First_Statement_Blks) {\r\n                        //get all used block inside the datatable step  \r\n                        let children = First_Statement_Blks && typeof First_Statement_Blks === \"object\" ? First_Statement_Blks.getDescendants() : [];\r\n                        //get only dataset blk from datatable step\r\n\r\n                        let is_keep_drop_used = children ? children.filter(x => x.type === \"keep_drop_type2\") : [];\r\n                        if (First_Statement_Blks.type === \"merge_type\" || First_Statement_Blks.type === \"set_type\") {\r\n                            let filteredvar = this.Get_Var_For_Merger_Set(children);\r\n                            if (is_keep_drop_used.length > 0) {\r\n                                return this.Merge_Set_Keep_Drop(is_keep_drop_used[0], filteredvar);\r\n                            }\r\n                            return filteredvar;\r\n                        }\r\n                        else {\r\n                            if (is_keep_drop_used.length > 0) {\r\n                                return (validJSON(this.Var_From_KeepDrop(is_keep_drop_used[0])));\r\n                            } else {\r\n                                return this.Var_From_DatatTableStep(children);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        return [];\r\n                    }\r\n                }\r\n                break;\r\n            case \"finalstep\":\r\n                {\r\n                    let final_step = Blockly.getMainWorkspace().getBlocksByType(\"final_step_type\");\r\n                    let Descendants = final_step[0].getDescendants();\r\n                    let is_keep_drop_used = Descendants ? Descendants.filter(x => x.type === \"keep_drop_type2\") : [];\r\n\r\n                    if (is_keep_drop_used.length > 0) {\r\n                        return this.Var_From_KeepDrop(is_keep_drop_used[0]);\r\n                    }\r\n                    else {\r\n                        return this.Var_From_Step(Descendants);\r\n                    }\r\n                }\r\n                break;\r\n            case \"WkFinalStep\":\r\n                {\r\n\r\n                    let Descendants = StepBlock.getDescendants();\r\n                    let is_keep_drop_used = Descendants ? Descendants.filter(x => x.type === \"keep_drop_type2\") : [];\r\n\r\n                    if (is_keep_drop_used.length > 0) {\r\n                        return this.Var_From_KeepDrop(is_keep_drop_used[0]);\r\n                    }\r\n                    else {\r\n                        return this.Var_From_Step(Descendants);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n    }\r\n\r\n}\r\n\r\n//for keep drop\r\nGet_Var_From_Step.prototype.Merge_Set_Keep_Drop = function (keep_drop, obje) {\r\n    //Get the value from the drop down (whether the value is keep or drop)\r\n    let dropdown_val = keep_drop.getFieldValue(\"keep_drop\");\r\n    //Get all the used variable in the statement input of keepdrop block\r\n    let statement_blk = keep_drop.getInputTargetBlock(\"variables\");\r\n    let { ForToGetWorkDataset, WorkDataTable } = this;\r\n\r\n    switch (dropdown_val) {\r\n        case \"Keep\":\r\n            {\r\n                let usedvar_in_keep = [];\r\n                let get_Used_Var_In_Keep = (statement_blk) => {\r\n                    if (statement_blk) {\r\n\r\n                        let data = validJSON(statement_blk.data);\r\n                        let nxt = statement_blk.getNextBlock();\r\n                        if (nxt) {\r\n                            get_Used_Var_In_Keep(nxt);\r\n                        }\r\n                        switch (data.blockType) {\r\n                            case \"SourceVar\":\r\n                                if (!usedvar_in_keep.some(va => va.name === data.COLUMN_NAME)) {\r\n                                    usedvar_in_keep.push({\r\n                                        memname: WorkDataTable,\r\n                                        name: data.COLUMN_NAME\r\n                                    });\r\n                                }\r\n                                break;\r\n                            case \"TargetVar\":\r\n                                if (!usedvar_in_keep.some(va => va.name === data.variableName)) {\r\n                                    usedvar_in_keep.push({\r\n                                        memname: WorkDataTable,\r\n                                        name: data.variableName\r\n                                    });\r\n                                }\r\n                                break;\r\n                            case \"WorkVar\":\r\n                                if (!usedvar_in_keep.some(va => va.name === data.variable)) {\r\n                                    usedvar_in_keep.push({\r\n                                        memname: WorkDataTable,\r\n                                        name: data.variable\r\n                                    });\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n                get_Used_Var_In_Keep(statement_blk);\r\n\r\n                return usedvar_in_keep;\r\n            }\r\n        case \"Drop\":\r\n            {\r\n                let usedvar_in_drop = [];\r\n                let get_Used_Var_In_Drop = (statement_blk) => {\r\n                    if (statement_blk) {\r\n                        let data = validJSON(statement_blk.data);\r\n                        let nxt = statement_blk.getNextBlock();\r\n                        if (nxt) {\r\n                            get_Used_Var_In_Drop(nxt);\r\n                        }\r\n                        switch (data.blockType) {\r\n                            case \"SourceVar\":\r\n                                {\r\n                                    let getIndex = obje.findIndex(vari => vari.blockType === \"SourceVar\" && vari.name === data.COLUMN_NAME);\r\n                                    obje = obje.filter((va, ind) => ind != getIndex);\r\n                                }\r\n                                break;\r\n                            case \"TargetVar\":\r\n                                {\r\n                                    let getIndex = obje.findIndex(vari => vari.blockType === \"TargetVar\" && vari.name === data.variableName);\r\n                                    obje = obje.filter((va, ind) => ind != getIndex);\r\n                                }\r\n                                break;\r\n                            case \"WorkVar\":\r\n                                {\r\n                                    let getIndex = obje.findIndex(vari => vari.blockType === \"WorkVar\" && vari.name === data.variable);\r\n                                    obje = obje.filter((va, ind) => ind != getIndex);\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                }\r\n                get_Used_Var_In_Drop(statement_blk);\r\n                return obje;\r\n            }\r\n    }\r\n};\r\n//for keep drop\r\nGet_Var_From_Step.prototype.Var_From_KeepDrop = function (keep_drop) {\r\n    //Get the value from the drop down (whether the value is keep or drop)\r\n    let dropdown_val = keep_drop.getFieldValue(\"keep_drop\");\r\n    //Get all the used variable in the statement input of keepdrop block\r\n    let statement_blk = keep_drop.getInputTargetBlock(\"variables\");\r\n    let { ForToGetWorkDataset, WorkDataTable } = this;\r\n\r\n    switch (dropdown_val) {\r\n        case \"Keep\":\r\n            {\r\n                let usedvar_in_keep = [];\r\n                let get_Used_Var_In_Keep = (statement_blk) => {\r\n                    if (statement_blk) {\r\n                        let data = validJSON(statement_blk.data);\r\n                        let nxt = statement_blk.getNextBlock();\r\n                        if (nxt) {\r\n                            get_Used_Var_In_Keep(nxt);\r\n                        }\r\n                        switch (data.blockType) {\r\n                            case \"SourceVar\":\r\n                                if (!usedvar_in_keep.some(va => va.variableName === data.COLUMN_NAME || va.name === data.COLUMN_NAME)) {\r\n                                    ForToGetWorkDataset ?\r\n                                        usedvar_in_keep.push({\r\n                                            memname: WorkDataTable,\r\n                                            name: data.COLUMN_NAME\r\n                                        }) :\r\n                                        usedvar_in_keep.push({\r\n                                            type: \"Source\",\r\n                                            dataset: data.TABLE_NAME,\r\n                                            variableName: data.COLUMN_NAME\r\n                                        });\r\n                                }\r\n                                break;\r\n                            case \"TargetVar\":\r\n                                if (!usedvar_in_keep.some(va => va.variableName === data.variableName || va.name === data.variableName)) {\r\n                                    ForToGetWorkDataset ?\r\n                                        usedvar_in_keep.push({\r\n                                            memname: WorkDataTable,\r\n                                            name: data.variableName\r\n                                        }) :\r\n                                        usedvar_in_keep.push({\r\n                                            type: \"Source\",\r\n                                            dataset: data.domain,\r\n                                            variableName: data.variableName\r\n                                        });\r\n                                }\r\n                                break;\r\n                            case \"WorkVar\":\r\n                                if (!usedvar_in_keep.some(va => va.variableName === data.variable || va.name === data.variable)) {\r\n                                    ForToGetWorkDataset ?\r\n                                        usedvar_in_keep.push({\r\n                                            memname: WorkDataTable,\r\n                                            name: data.variable\r\n                                        }) :\r\n                                        usedvar_in_keep.push({\r\n                                            type: \"Source\",\r\n                                            dataset: data.dataset,\r\n                                            variableName: data.variable\r\n                                        });\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n                get_Used_Var_In_Keep(statement_blk);\r\n\r\n                return JSON.stringify(usedvar_in_keep);\r\n            }\r\n        case \"Drop\":\r\n            {\r\n                let usedvar_in_drop = [];\r\n                let get_Used_Var_In_Drop = (statement_blk) => {\r\n                    if (statement_blk) {\r\n                        let data = validJSON(statement_blk.data);\r\n                        let nxt = statement_blk.getNextBlock();\r\n                        if (nxt) {\r\n                            get_Used_Var_In_Drop(nxt);\r\n                        }\r\n                        switch (data.blockType) {\r\n                            case \"SourceVar\":\r\n                                usedvar_in_drop.push(data.COLUMN_NAME);\r\n                                break;\r\n                            case \"TargetVar\":\r\n                                usedvar_in_drop.push(data.variableName);\r\n                                break;\r\n                            case \"WorkVar\":\r\n                                usedvar_in_drop.push(data.variable);\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n                get_Used_Var_In_Drop(statement_blk);\r\n                let all_var = this.findWhichdDataset(statement_blk, true, usedvar_in_drop);\r\n                return JSON.stringify(all_var);\r\n            }\r\n    }\r\n};\r\n//for step and Variable step\r\nGet_Var_From_Step.prototype.Var_From_Step = function (descendants) {\r\n    let statement_blk = descendants.filter(child => isVariableType(child.type));\r\n    let all_var = this.findWhichdDataset(statement_blk[0]);\r\n    return JSON.stringify(all_var);\r\n};\r\n//Transpose block\r\nGet_Var_From_Step.prototype.WorkVar_From_Transposeblock = function (transposeblock) {\r\n    try {\r\n        let { WorkDataTable } = this;\r\n\r\n        //get Used first Variable in by varible statement\r\n        let by_var_statement_blk = transposeblock.getInputTargetBlock(\"by_variables\");\r\n        if (by_var_statement_blk) {\r\n\r\n            //get Used all Variable's in by varible statement\r\n            let getAllUsedVar = (by_var_statement_blk && typeof by_var_statement_blk === \"object\") ? by_var_statement_blk.getDescendants() : [];\r\n\r\n            //default column add here\r\n            let defaultcol = [\"_NAME_\", \"_LABEL_\", \"COL1\"]\r\n            let out = [...defaultcol.map(dcol => { return { name: dcol, memname: WorkDataTable } })];\r\n\r\n            (getAllUsedVar || []).map(var_blk => {\r\n                let data = validJSON(var_blk.data);\r\n                let type = data ? data.blockType : \"\";\r\n                switch (type) {\r\n                    case \"SourceVar\":\r\n                        {\r\n                            !out.some(v => v.name.toLowerCase() === data.COLUMN_NAME.toLowerCase()) &&\r\n                                out.push({ name: data.COLUMN_NAME, memname: WorkDataTable });\r\n                        }\r\n                        break;\r\n                    case \"TargetVar\":\r\n                        {\r\n                            !out.some(v => v.name.toLowerCase() === data.variableName.toLowerCase()) &&\r\n                                out.push({ name: data.variableName, memname: WorkDataTable });\r\n                        }\r\n                        break;\r\n                    case \"WorkVar\":\r\n                        {\r\n                            !out.some(v => v.name.toLowerCase() === data.variable.toLowerCase()) &&\r\n                                out.push({ name: data.variable, memname: WorkDataTable });\r\n                        }\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n            });\r\n\r\n\r\n            return out;\r\n        }\r\n        return [];\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        return [];\r\n    }\r\n};\r\n\r\n//Filter used var from Rename Block \r\nexport function GetRenameVariables(children, src, tar, work_ds) {\r\n    try {\r\n        //out variable\r\n        let rename_var = {}\r\n\r\n        //Check Duplication (do not rename multiple columns with the same name).\r\n        let find_Duplication = { identify: [], duplicate: [] };\r\n        let { identify, duplicate } = find_Duplication;\r\n\r\n        for (var index = 0; index < children.length; index++) {\r\n            //Block used in selcted block\r\n            let block = children[index];\r\n            let dataset_info = validJSON(block.data);\r\n            let dataset_type = dataset_info.blockType;\r\n            let type = block.type;\r\n\r\n            //Should check for only Variable step ,DataTable step\r\n            if (isDataset(type)) {\r\n                //get block value connection \r\n                //Get the used dataTableOptions in dataset\r\n                let dataTableOptions = block && (block.getOnlyValueConnection_ && block.getOnlyValueConnection_());\r\n                dataTableOptions = dataTableOptions && (dataTableOptions.targetBlock && dataTableOptions.targetBlock());\r\n                let dataTableOpt_child = dataTableOptions && (dataTableOptions.getChildren && dataTableOptions.getChildren());\r\n                //Get the used rename blk in dataset\r\n                let renameBlk = isArray(dataTableOpt_child) && dataTableOpt_child[0];\r\n                //get first used block in rename block (type - rename_vars)\r\n                let used_blk_in_rename = (isObject(renameBlk) && renameBlk.getDescendants) ? renameBlk.getDescendants() : [];\r\n\r\n                used_blk_in_rename.map(b => {\r\n                    //uvbr -> used var block in rename\r\n                    let uvbr_dataInfo = validJSON(b.data);\r\n                    let var_type = uvbr_dataInfo.blockType;\r\n\r\n                    //get text from rename block.(rename - rename_type)\r\n                    let rename_text_blk = b.getOnlyValueConnection_();\r\n                    rename_text_blk = isObject(rename_text_blk) ? rename_text_blk.targetBlock() : false;\r\n                    let renameText = isObject(rename_text_blk) ? rename_text_blk.getFieldValue(\"rename_var\") : \"\";\r\n                    //End \r\n                    if (renameText != \"\" && typeof renameText === \"string\" && !parseInt(renameText)) {\r\n                        switch (dataset_type) {\r\n                            case \"Source\":\r\n                                {\r\n                                    let srcVar = src.Variable;\r\n                                    let s_ds = strLowerCase(uvbr_dataInfo.TABLE_NAME);\r\n                                    let s_var = strLowerCase(uvbr_dataInfo.COLUMN_NAME);\r\n                                    //Get only the used used source var from rename block,if Source DATASET means\r\n                                    if (var_type === \"SourceVar\" && uvbr_dataInfo.TABLE_NAME === dataset_info.TABLE_NAME &&\r\n                                        srcVar.some(sv => strLowerCase(sv.TABLE_NAME) == s_ds && strLowerCase(sv.COLUMN_NAME) === s_var)) {\r\n\r\n                                        let { blockType, TABLE_NAME } = dataset_info;\r\n                                        //uvbr -> used var block in rename\r\n                                        let { COLUMN_NAME } = uvbr_dataInfo;\r\n\r\n                                        //Check Duplication (do not rename multiple columns with the same name).\r\n                                        //check the combination of type(src/tar/work) and rename text\r\n                                        //Same re-name allowed for same variable ex(demo.domain rename is x ,can have another demo.domain rename is x )\r\n                                        let dp_chk_renametxt = var_type + '.' + TABLE_NAME + '.' + renameText.toLowerCase();\r\n                                        let dp_chk_varname = var_type + '.' + TABLE_NAME + '.' + COLUMN_NAME;\r\n\r\n                                        if (!identify.some(dpo => dpo.v_name.toLowerCase() !== dp_chk_varname.toLowerCase() && dpo.r_name.toLowerCase() === dp_chk_renametxt.toLowerCase())) {\r\n                                            identify.push({ r_name: dp_chk_renametxt, v_name: dp_chk_varname });\r\n\r\n                                            rename_var[TABLE_NAME + \"@_\" + var_type] = rename_var[TABLE_NAME + \"@_\" + var_type] || {};\r\n                                            rename_var[TABLE_NAME + \"@_\" + var_type][COLUMN_NAME] = { ...uvbr_dataInfo, renameTo: renameText.toUpperCase() };\r\n                                        }\r\n                                        else {\r\n                                            duplicate.indexOf(TABLE_NAME + \" - \" + renameText) === -1 && duplicate.push(TABLE_NAME + \" - \" + renameText);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case \"Target\":\r\n                                {\r\n                                    //Get only the used used target var from rename block,if Target DATASET means\r\n                                    let t_ds = strLowerCase(uvbr_dataInfo.domain);\r\n                                    let t_var = strLowerCase(uvbr_dataInfo.variableName);\r\n                                    if (var_type === \"TargetVar\" && uvbr_dataInfo.domain === dataset_info.domain &&\r\n                                        tar.some(tv => strLowerCase(tv.targetDataSet) == t_ds && strLowerCase(tv.targetVariableName) === t_var)) {\r\n                                        let { blockType, domain } = dataset_info;\r\n                                        //uvbr -> used var block in rename\r\n                                        let { variableName } = uvbr_dataInfo;\r\n                                        //Check Duplication (do not rename multiple columns with the same name).\r\n                                        //Check Duplication (do not rename multiple columns with the same name).\r\n                                        //check the combination of type(src/tar/work) and rename text\r\n                                        let dp_chk_renametxt = var_type + '.' + domain + '.' + renameText.toLowerCase();\r\n                                        //Same re-name allowed for same variable ex(demo.domain rename is x ,can have another demo.domain rename is x )\r\n                                        let dp_chk_varname = var_type + '.' + domain + '.' + variableName;\r\n\r\n                                        if (!identify.some(dpo => dpo.v_name.toLowerCase() !== dp_chk_varname.toLowerCase() && dpo.r_name.toLowerCase() === dp_chk_renametxt.toLowerCase())) {\r\n                                            identify.push({ r_name: dp_chk_renametxt, v_name: dp_chk_varname });\r\n                                            rename_var[domain + \"@_\" + var_type] = rename_var[domain + \"@_\" + var_type] || {};\r\n                                            rename_var[domain + \"@_\" + var_type][variableName] = { ...uvbr_dataInfo, renameTo: renameText.toUpperCase() };\r\n                                        }\r\n                                        else {\r\n                                            duplicate.indexOf(domain + \" - \" + renameText) === -1 && duplicate.push(domain + \" - \" + renameText);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case \"Work\":\r\n                                {\r\n                                    let w_ds = strLowerCase(uvbr_dataInfo.dataset);\r\n                                    //Get only the used used Work var from rename block,if Work DATASET means\r\n                                    if (var_type === \"WorkVar\" && w_ds === strLowerCase(dataset_info.name) &&\r\n                                        work_ds.some(v => strLowerCase(v.memname) == w_ds && strLowerCase(v.name) == strLowerCase(uvbr_dataInfo.variable))) {\r\n                                        let { blockType, name } = dataset_info;\r\n                                        //uvbr -> used var block in rename\r\n                                        let { variable } = uvbr_dataInfo;\r\n                                        //Check Duplication (do not rename multiple columns with the same name).\r\n                                        //Check Duplication (do not rename multiple columns with the same name).\r\n                                        //check the combination of type(src/tar/work) and rename text\r\n\r\n                                        let dp_chk_renametxt = var_type + '.' + name + '.' + renameText.toLowerCase();\r\n                                        //Same re-name allowed for same variable ex(demo.domain rename is x ,can have another demo.domain rename is x )\r\n                                        let dp_chk_varname = var_type + '.' + name + '.' + variable;\r\n\r\n                                        if (!identify.some(dpo => dpo.v_name.toLowerCase() !== dp_chk_varname.toLowerCase() && dpo.r_name.toLowerCase() === dp_chk_renametxt.toLowerCase())) {\r\n                                            identify.push({ r_name: dp_chk_renametxt, v_name: dp_chk_varname });\r\n\r\n                                            rename_var[name + \"@_\" + var_type] = rename_var[name + \"@_\" + var_type] || {};\r\n                                            rename_var[name + \"@_\" + var_type][variable] = { ...uvbr_dataInfo, renameTo: renameText.toUpperCase() };\r\n                                        }\r\n                                        else {\r\n                                            duplicate.indexOf(variable + \" - \" + renameText) === -1 && duplicate.push(variable + \" - \" + renameText);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n        }\r\n\r\n        return {\r\n            variableRenameList: rename_var, duplicate: duplicate\r\n        };\r\n    } catch (e) {\r\n        console.log(e);\r\n        return {};\r\n    }\r\n}\r\n\r\n//for  datatable step\r\n// parameter @children is the used block inside datatable step\r\nGet_Var_From_Step.prototype.Var_From_DatatTableStep = function (children) {\r\n    try {\r\n        let { WorkDataTable, Standards, work_datasets, variableRenameList } = this;\r\n        let out = [];\r\n\r\n        if (children && typeof children === \"object\" && children.length > 0) {\r\n            //for transpose block\r\n            let isTransPoseBlkUsed = (children || []).find(child => child.type == \"transpose_operation\");\r\n            if (isTransPoseBlkUsed && typeof isTransPoseBlkUsed === \"object\") {\r\n                out = this.WorkVar_From_Transposeblock(isTransPoseBlkUsed, variableRenameList);\r\n            }\r\n            else {\r\n                //get only dataset blk from datatable step\r\n                let used_dataset_blk = children.filter(child => isDataset(child.type));\r\n                //Controlling duplication for dataset\r\n                let cntrlDuplication = [];\r\n\r\n                (used_dataset_blk || []).map(ds_blk => {\r\n                    let data = validJSON(ds_blk.data);\r\n                    let type = data ? data.blockType : \"\";\r\n                    //Controlling duplication for dataset\r\n                    let duplicationcontrol = cntrlDuplication.some(cd => cd.dataset === data.TABLE_NAME && cd.type === \"Source\");\r\n                    if (!duplicationcontrol) {\r\n                        switch (type) {\r\n                            case \"Source\":\r\n                                {\r\n                                    //Controlling duplication for dataset\r\n                                    cntrlDuplication.push({ dataset: data.TABLE_NAME, type: type });\r\n\r\n                                    let Dataset = (this.SourceDataset && \"Domain\" in this.SourceDataset) ?\r\n                                        this.SourceDataset.Domain : [];\r\n                                    let Variable = (this.SourceDataset && \"Variable\" in this.SourceDataset) ?\r\n                                        this.SourceDataset.Variable : [];\r\n\r\n                                    let var_by_used_dataset = Variable.filter(va => {\r\n                                        //Rename the variable ,if a rename block exists \r\n                                        let rename_obj = variableRenameList[data.TABLE_NAME + \"@_\" + \"SourceVar\"];\r\n\r\n                                        let renameTo = rename_obj && rename_obj[va.COLUMN_NAME] && rename_obj[va.COLUMN_NAME].renameTo;\r\n\r\n                                        let col_Name = isNotNull(renameTo) ? renameTo : va.COLUMN_NAME;\r\n\r\n\r\n                                        if (va.TABLE_NAME === data.TABLE_NAME && !out.some(wkva => wkva.name === col_Name)) {\r\n                                            out.push({ name: col_Name, memname: WorkDataTable });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                break;\r\n                            case \"Target\":\r\n                                {\r\n                                    //Controlling duplication for dataset\r\n                                    cntrlDuplication.push({ dataset: data.domain, type: type });\r\n\r\n                                    let Dataset = (Standards && \"Domain\" in Standards) ?\r\n                                        this.SourceDataset.Domain : [];\r\n                                    let Variable = (Standards && \"Variable\" in Standards) ?\r\n                                        Standards.Variable : [];\r\n\r\n                                    Variable.filter(va => {\r\n                                        let mappingConstruct = this.MappingDatas.MappingList.find(\r\n                                            mapper =>\r\n                                                mapper.cdiscDataStdVariableMetadataID ===\r\n                                                va.cdiscDataStdVariableMetadataID || (typeof va.domain == 'string' && va.domain.toLowerCase().includes('_int'))\r\n                                        );\r\n                                        if (typeof mappingConstruct === 'object' &&\r\n                                            mappingConstruct) {\r\n                                            //Rename the variable ,if a rename block exists \r\n                                            let rename_obj = variableRenameList[data.domain + \"@_\" + \"TargetVar\"];\r\n\r\n                                            let renameTo = rename_obj && rename_obj[va.variableName] && rename_obj[va.variableName].renameTo;\r\n                                            let col_Name = isNotNull(renameTo) ? renameTo : va.variableName;\r\n\r\n                                            if (va.cdiscDataStdDomainMetadataID === data.cdiscDataStdDomainMetadataID && !out.some(wkva => wkva.name === col_Name)) {\r\n                                                out.push({ name: col_Name, memname: WorkDataTable });\r\n                                            }\r\n                                        }\r\n                                    });\r\n                                }\r\n                                break;\r\n                            case \"Work\":\r\n                                {\r\n                                    //Controlling duplication for dataset\r\n                                    // data.name -> is work dataset\r\n                                    cntrlDuplication.push({ dataset: data.name, type: type });\r\n\r\n                                    let work_var = [];\r\n                                    //In work_datasets object -> name key is work variable , memname key is dataset\r\n                                    work_datasets.filter(va => {\r\n                                        //Rename the variable ,if a rename block exists \r\n                                        let rename_obj = variableRenameList[data.name + \"@_\" + \"WorkVar\"];\r\n                                        let renameTo = rename_obj && rename_obj[va.name] && rename_obj[va.name].renameTo;\r\n                                        let col_Name = isNotNull(renameTo) ? renameTo : va.name;\r\n\r\n                                        if (va.memname === data.name && !out.some(wkva => wkva.name === col_Name)) {\r\n                                            out.push({ name: col_Name, memname: WorkDataTable });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                break;\r\n                            default:\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                });\r\n            }\r\n            return out;\r\n        }\r\n    } catch (e) {\r\n        console.log(e);\r\n        return [];\r\n    }\r\n    return [];\r\n};\r\n//for  datatable step\r\n// parameter @children is the used block inside datatable step\r\nGet_Var_From_Step.prototype.Get_Var_For_Merger_Set = function (children) {\r\n    try {\r\n        let { WorkDataTable, Standards, work_datasets, variableRenameList } = this;\r\n        let out = [];\r\n\r\n        if (children && typeof children === \"object\" && children.length > 0) {\r\n\r\n\r\n            //for transpose block\r\n            let isTransPoseBlkUsed = (children || []).find(child => child.type == \"transpose_operation\");\r\n            if (isTransPoseBlkUsed && typeof isTransPoseBlkUsed === \"object\") {\r\n                out = this.WorkVar_From_Transposeblock(isTransPoseBlkUsed, variableRenameList);\r\n            }\r\n            else {\r\n\r\n                //get only dataset blk from datatable step\r\n                let used_dataset_blk = children.filter(child => isDataset(child.type));\r\n                //Controlling duplication for dataset\r\n                let cntrlDuplication = [];\r\n\r\n                (used_dataset_blk || []).map(ds_blk => {\r\n                    let data = validJSON(ds_blk.data);\r\n                    let type = data ? data.blockType : \"\";\r\n                    //Controlling duplication for dataset\r\n                    let duplicationcontrol = cntrlDuplication.some(cd => cd.dataset === data.TABLE_NAME && cd.type === \"Source\");\r\n                    if (!duplicationcontrol) {\r\n                        switch (type) {\r\n                            case \"Source\":\r\n                                {\r\n                                    //Controlling duplication for dataset\r\n                                    cntrlDuplication.push({ dataset: data.TABLE_NAME, type: type });\r\n\r\n                                    let Dataset = (this.SourceDataset && \"Domain\" in this.SourceDataset) ?\r\n                                        this.SourceDataset.Domain : [];\r\n                                    let Variable = (this.SourceDataset && \"Variable\" in this.SourceDataset) ?\r\n                                        this.SourceDataset.Variable : [];\r\n\r\n                                    let var_by_used_dataset = Variable.filter(va => {\r\n                                        //Rename the variable ,if a rename block exists \r\n                                        let rename_obj = variableRenameList[data.TABLE_NAME + \"@_\" + \"SourceVar\"];\r\n\r\n                                        let renameTo = rename_obj && rename_obj[va.COLUMN_NAME] && rename_obj[va.COLUMN_NAME].renameTo;\r\n\r\n                                        let col_Name = isNotNull(renameTo) ? renameTo : va.COLUMN_NAME;\r\n\r\n\r\n                                        if (va.TABLE_NAME === data.TABLE_NAME && !out.some(wkva => wkva.name === col_Name)) {\r\n                                            out.push({ name: col_Name, memname: WorkDataTable, blockType: \"SourceVar\" });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                break;\r\n                            case \"Target\":\r\n                                {\r\n                                    //Controlling duplication for dataset\r\n                                    cntrlDuplication.push({ dataset: data.domain, type: type });\r\n\r\n                                    let Dataset = (Standards && \"Domain\" in Standards) ?\r\n                                        this.SourceDataset.Domain : [];\r\n                                    let Variable = (Standards && \"Variable\" in Standards) ?\r\n                                        Standards.Variable : [];\r\n\r\n                                    Variable.filter(va => {\r\n                                        let mappingConstruct = this.MappingDatas.MappingList.find(\r\n                                            mapper =>\r\n                                                mapper.cdiscDataStdVariableMetadataID ===\r\n                                                va.cdiscDataStdVariableMetadataID || (typeof va.domain == 'string' && va.domain.toLowerCase().includes('_int'))\r\n                                        );\r\n                                        if (typeof mappingConstruct === 'object' &&\r\n                                            mappingConstruct) {\r\n                                            //Rename the variable ,if a rename block exists \r\n                                            let rename_obj = variableRenameList[data.domain + \"@_\" + \"TargetVar\"];\r\n\r\n                                            let renameTo = rename_obj && rename_obj[va.variableName] && rename_obj[va.variableName].renameTo;\r\n                                            let col_Name = isNotNull(renameTo) ? renameTo : va.variableName;\r\n\r\n                                            if (va.cdiscDataStdDomainMetadataID === data.cdiscDataStdDomainMetadataID && !out.some(wkva => wkva.name === col_Name)) {\r\n                                                out.push({ name: col_Name, memname: WorkDataTable, blockType: \"TargetVar\" });\r\n                                            }\r\n                                        }\r\n                                    });\r\n                                }\r\n                                break;\r\n                            case \"Work\":\r\n                                {\r\n                                    //Controlling duplication for dataset\r\n                                    // data.name -> is work dataset\r\n                                    cntrlDuplication.push({ dataset: data.name, type: type });\r\n\r\n                                    let work_var = [];\r\n                                    //In work_datasets object -> name key is work variable , memname key is dataset\r\n                                    work_datasets.filter(va => {\r\n                                        //Rename the variable ,if a rename block exists \r\n                                        let rename_obj = variableRenameList[data.name + \"@_\" + \"WorkVar\"];\r\n                                        let renameTo = rename_obj && rename_obj[va.name] && rename_obj[va.name].renameTo;\r\n                                        let col_Name = isNotNull(renameTo) ? renameTo : va.name;\r\n\r\n                                        if (va.memname === data.name && !out.some(wkva => wkva.name === col_Name)) {\r\n                                            out.push({ name: col_Name, memname: WorkDataTable, blockType: \"WorkVar\" });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                break;\r\n                            default:\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                });\r\n            }\r\n            return out;\r\n        }\r\n    } catch (e) {\r\n        console.log(e);\r\n        return [];\r\n    }\r\n    return [];\r\n};\r\n//Return Variables Based on dataset\r\n//blk parameter is a first statement input of the block\r\n//drop and usedvarindrop\r\nGet_Var_From_Step.prototype.findWhichdDataset = function (blk, drop = false, usedvarindrop = []) {\r\n    let { ForToGetWorkDataset, WorkDataTable } = this;\r\n\r\n    if (blk) {\r\n        let data = validJSON(blk.data);\r\n        let type = data ? data.blockType : \"\";\r\n        try {\r\n            switch (type) {\r\n                case \"SourceVar\":\r\n                    {\r\n                        let Variable = (this.SourceDataset && \"Variable\" in this.SourceDataset) ?\r\n                            this.SourceDataset.Variable : [];\r\n\r\n                        let source_var = [];\r\n                        Variable = Variable.filter(v => v.TABLE_NAME === data.TABLE_NAME);\r\n                        (Variable || []).map(va => {\r\n                            if ((!drop || usedvarindrop.indexOf(va.COLUMN_NAME) === -1) &&\r\n                                !source_var.some(v => v.variableName === va.COLUMN_NAME)) {\r\n                                ForToGetWorkDataset ?\r\n                                    source_var.push({\r\n                                        memname: WorkDataTable,\r\n                                        name: va.COLUMN_NAME\r\n                                    }) :\r\n                                    source_var.push({\r\n                                        type: \"Source\",\r\n                                        dataset: va.TABLE_NAME,\r\n                                        variableName: va.COLUMN_NAME\r\n                                    })\r\n                            }\r\n                        });\r\n\r\n                        return source_var;\r\n                    }\r\n                case \"TargetVar\":\r\n                    {\r\n\r\n                        let target_var = [];\r\n                        let variable = this.Standards ?\r\n                            this.Standards.Variable : [];\r\n\r\n                        let varible = variable.filter(\r\n                            v =>\r\n                                v.cdiscDataStdDomainMetadataID ===\r\n                                data.cdiscDataStdDomainMetadataID\r\n                        );\r\n\r\n\r\n                        varible.map(va => {\r\n                            let mappingConstruct = this.MappingDatas.MappingList.find(\r\n                                mapper =>\r\n                                    mapper.cdiscDataStdVariableMetadataID ===\r\n                                    va.cdiscDataStdVariableMetadataID || (typeof va.domain == 'string' && va.domain.toLowerCase().includes('_int'))\r\n                            );\r\n                            if (typeof mappingConstruct === 'object' &&\r\n                                mappingConstruct) {\r\n                                if ((!drop || usedvarindrop.indexOf(va.variableName) === -1) &&\r\n                                    !target_var.some(v => v.variableName === va.variableName)) {\r\n                                    ForToGetWorkDataset ?\r\n                                        target_var.push({\r\n                                            memname: WorkDataTable,\r\n                                            name: va.variableName\r\n                                        }) :\r\n                                        target_var.push({\r\n                                            type: \"Target\",\r\n                                            dataset: data.domain,\r\n                                            variableName: va.variableName\r\n                                        });\r\n                                }\r\n                            }\r\n                        });\r\n                        return target_var;\r\n                    }\r\n                case \"WorkVar\":\r\n                    {\r\n                        let work_var = [];\r\n\r\n                        this.work_datasets.filter(va => {\r\n                            if (va.memname === data.dataset &&\r\n                                (!drop || usedvarindrop.indexOf(va.name) === -1) &&\r\n                                !work_var.some(v => v.variableName === va.name)\r\n                            ) {\r\n                                ForToGetWorkDataset ?\r\n                                    work_var.push({\r\n                                        memname: WorkDataTable,\r\n                                        name: va.name\r\n                                    })\r\n                                    :\r\n                                    work_var.push({\r\n                                        type: \"Work\",\r\n                                        variableName: va.name,\r\n                                        dataset: va.memname\r\n                                    });\r\n                            }\r\n                        });\r\n                        return work_var;\r\n                    }\r\n            }\r\n        }\r\n        catch (e) {\r\n            //console.log(e);\r\n            return [];\r\n        }\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n\r\n//Get variable from used dataset in DataTable step\r\n\r\nexport function ImpactValidation(Standards, SourceDataset, xml, record = false) {\r\n    try {\r\n        this.xml = xml;\r\n        this.record = record;\r\n        //convert string to xml \r\n        //all used block data information\r\n        this.data_info = this.xml.getElementsByTagName(\"data\");\r\n\r\n        //deciding var\r\n        //if false ,imapct exist else not\r\n        this.none_impacted = true;\r\n        this.impacted = false;\r\n\r\n        //used block in rule validation\r\n        let { Domain, Variable } = SourceDataset;\r\n        this.src_domain = Domain;\r\n        this.src_variable = Variable;\r\n        this.std_domain = Standards.Domain;\r\n        this.std_variable = Standards.Variable;\r\n\r\n        //impacted list \r\n        this.ImpactedList = {};\r\n        //for create/update/generate program/individual run should validate the work.but ,get workdataset no need to validate the work here\r\n        this.NotValidateWork = false;\r\n        this.work_exist = true;\r\n        this.NotAvailWorkList = {};\r\n        this.variableRenameList = {};\r\n\r\n        //Duplicate column due to renaming variable\r\n        this.duplicateColumn = [];\r\n    }\r\n    catch (e) {\r\n        //console.log(e);\r\n    }\r\n}\r\n\r\n//Actual source of the record\r\n//IsMappedSourceAvaliable\r\n//this only used by importmappinlibrary.js\r\nImpactValidation.prototype.IsMappedSourceAvaliable = function () {\r\n    try {\r\n        //record -> sel record\r\n        let { src_variable, record } = this;\r\n\r\n        if (src_variable.some(sv =>\r\n            sv.TABLE_NAME === record.sourceDataset &&\r\n            sv.COLUMN_NAME === record.sourceVariableName)) {\r\n            record.impact = 0;\r\n            record.changeReason = \"Create\";\r\n        }\r\n        else {\r\n            record.impact = 1;\r\n            record.changeReason = \"Create\";\r\n        }\r\n    }\r\n    catch (e) {\r\n        //console.log(e);\r\n    }\r\n}\r\n\r\n////Here Validate the used blocks in rule\r\n//Only ImportMapping Library uses this function\r\nImpactValidation.prototype.ValidationOfAllBlocksUsed = function ()\r\n{\r\n    try {\r\n        let {\r\n            xml,\r\n            data_info,\r\n            std_domain,\r\n            src_domain,\r\n            MappingList,\r\n            std_variable,\r\n            src_variable,\r\n            WorkDatatset,\r\n            none_impacted,\r\n            NotValidateWork,\r\n            VariableRenameList\r\n        } = this;\r\n\r\n        for (var i = 0; i < data_info.length; i++)\r\n        {\r\n            let data = data_info[i];\r\n            let d = validJSON(data_info[i].textContent);\r\n\r\n            switch (d.blockType) {\r\n                case \"Source\":\r\n                    {\r\n\r\n                        let nothing_impacted = src_domain.some(va => {\r\n                            return va.TABLE_NAME === d.TABLE_NAME;\r\n                        });\r\n\r\n                        !nothing_impacted && (this.ImpactedList[d.TABLE_NAME] = \"Source Dataset - \" + d.TABLE_NAME);\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n                case \"SourceVar\":\r\n                    {\r\n                        //Combine renamed variables also before check for impact\r\n                        let renameVarsByDataset = VariableRenameList && VariableRenameList[d.TABLE_NAME + \"@_SourceVar\"];\r\n                        renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\r\n\r\n                        let combineBothVariables = [...src_variable,\r\n                        ...(Object.keys(renameVarsByDataset) || []).map(rv => renameVarsByDataset[rv])];\r\n\r\n                        let nothing_impacted = combineBothVariables.some(va => {\r\n                            let renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\r\n                            return (va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && va.COLUMN_NAME.toUpperCase() === d.COLUMN_NAME.toUpperCase()) ||\r\n                                (va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && renameTo.toUpperCase() === d.COLUMN_NAME.toUpperCase());\r\n                        });\r\n\r\n                        !nothing_impacted && (this.ImpactedList[d.TABLE_NAME + \".\" + d.COLUMN_NAME] = \"Source Variable - \" + d.TABLE_NAME + \".\" + d.COLUMN_NAME);\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n                case \"Target\":\r\n                    {\r\n                        let nothing_impacted = std_domain.some(va => {\r\n                            return d.domain === va.domain\r\n                        });\r\n\r\n                        //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\r\n                        if (d && d.domain && !d.domain.includes(\"_int\")) {\r\n                            nothing_impacted = nothing_impacted && MappingList.some(va => {\r\n                                return d.domain === va.targetDataSet\r\n                            });\r\n                        }\r\n                        !nothing_impacted && (this.ImpactedList[d.domain] = \"Target Dataset - \" + d.domain);\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n                case \"TargetVar\":\r\n                    {\r\n                        let blockOfData = data.parentElement;\r\n                        let fieldTag = data_info[i].parentElement.getElementsByTagName('field');\r\n                        let fieldName = fieldTag && typeof fieldTag == 'object' ? fieldTag[0].textContent : \"\";\r\n                        let domainName = isNotNull(fieldName) ? fieldName.split('.')[0] : \"\";\r\n\r\n                        //get used block std domain name for usedblk variable by cdiscDataStdDomainMetadataID\r\n                        let usedBlkDomain = std_domain.find(dm1 => dm1.domain.toLowerCase() === domainName.toLowerCase());\r\n                        let usedBlkDomainName = usedBlkDomain && typeof usedBlkDomain === \"object\" ? usedBlkDomain.domain : \"\";\r\n                        d.cdiscDataStdDomainMetadataID = usedBlkDomain && typeof usedBlkDomain === \"object\" ? usedBlkDomain.cdiscDataStdDomainMetadataID : 0;\r\n                        \r\n                        \r\n\r\n                        let nothing_impacted = std_variable.some(va => {\r\n\r\n                            //get std domain name for variable by cdiscDataStdDomainMetadataID\r\n                            let domain = std_domain.find(dm => dm.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID);\r\n                            let domainname = domain && typeof domain === \"object\" ? domain.domain : \"\";\r\n\r\n                            //let getDomain = Standards.Domain.find(d => d.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID);\r\n                            if (usedBlkDomainName.toUpperCase() === domainname.toUpperCase() &&\r\n                                va.variableName.toUpperCase() === d.variableName.toUpperCase())\r\n                            {\r\n                                d.cdiscDataStdVariableMetadataID = va.cdiscDataStdVariableMetadataID\r\n                                data_info[i].parentElement.childNodes[1].textContent = JSON.stringify(d)\r\n                                return true;\r\n                            };\r\n                        });\r\n                        //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\r\n                        //HERE available Mapping List validation\r\n                        if (usedBlkDomain && usedBlkDomain.domain && !usedBlkDomain.domain.includes(\"_int\")) {\r\n                            nothing_impacted = nothing_impacted &&\r\n                                MappingList.some(va => {\r\n                                    return usedBlkDomainName.toUpperCase() === va.targetDataSet.toUpperCase() && va.cdiscDataStdVariableMetadataID === d.cdiscDataStdVariableMetadataID;\r\n                                });\r\n                        }\r\n                        !nothing_impacted && (this.ImpactedList[usedBlkDomainName + \".\" + d.variableName] = \"Target Variable - \" + usedBlkDomainName + \".\" + d.variableName);\r\n\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n\r\n            }\r\n\r\n            if (!none_impacted) {\r\n\r\n            }\r\n        }\r\n\r\n        //here we inverse \r\n        //for other end developing \r\n        this.impacted = !none_impacted;\r\n\r\n    }\r\n    catch (e) {\r\n        console.log(e)\r\n    }\r\n}\r\n\r\n//Here Validate the used blocks in rule\r\n//Only blocklyWorkspcae.js uses this function\r\nImpactValidation.prototype.ImpactValidationOfUsedBlocks = function () {\r\n    try {\r\n        let {\r\n            \r\n            stepblk,\r\n            data_info,\r\n            std_domain,\r\n            src_domain,\r\n            MappingList,\r\n            std_variable,\r\n            src_variable,\r\n            WorkDatatset,\r\n            none_impacted,\r\n            NotValidateWork,\r\n            variableRenameList\r\n        } = this;\r\n\r\n\r\n        for (var i = 0; i < stepblk.length; i++) {\r\n            let blk = stepblk[i];\r\n            let data_info = blk.data;\r\n            let d = validJSON(data_info);\r\n\r\n            switch (d.blockType) {\r\n                case \"Source\":\r\n                    {\r\n\r\n                        let nothing_impacted = src_domain.some(va => {\r\n                            return va.TABLE_NAME === d.TABLE_NAME;\r\n                        });\r\n\r\n                        !nothing_impacted && (this.ImpactedList[d.TABLE_NAME] = \"Source Dataset - \" + d.TABLE_NAME);\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n                case \"SourceVar\":\r\n                    {\r\n                        //Combine renamed variables also before check for impact\r\n                        let renameVarsByDataset = variableRenameList && variableRenameList[d.TABLE_NAME + \"@_SourceVar\"];\r\n                        renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\r\n\r\n                        let combineBothVariables = [...src_variable,\r\n                        ...(Object.keys(renameVarsByDataset) || []).map(rv => renameVarsByDataset[rv])];\r\n\r\n                        let nothing_impacted = combineBothVariables.some(va => {\r\n                            let renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\r\n                            return (va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && va.COLUMN_NAME.toUpperCase() === d.COLUMN_NAME.toUpperCase()) ||\r\n                                (va.TABLE_NAME.toUpperCase() === d.TABLE_NAME.toUpperCase() && renameTo.toUpperCase() === d.COLUMN_NAME.toUpperCase());\r\n                        });\r\n\r\n                        !nothing_impacted && (this.ImpactedList[d.TABLE_NAME + \".\" + d.COLUMN_NAME] = \"Source Variable - \" + d.TABLE_NAME + \".\" + d.COLUMN_NAME);\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n                case \"Target\":\r\n                    {\r\n                        let nothing_impacted = std_domain.some(va => {\r\n                            return d.domain === va.domain\r\n                        });\r\n\r\n                        //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\r\n                        if (d && d.domain && !d.domain.includes(\"_int\")) {\r\n                            nothing_impacted = nothing_impacted && MappingList.some(va => {\r\n                                return d.domain === va.targetDataSet\r\n                            });\r\n                        }\r\n                        !nothing_impacted && (this.ImpactedList[d.domain] = \"Target Dataset - \" + d.domain);\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n                case \"TargetVar\":\r\n                    {\r\n\r\n                        //get used block std domain name for usedblk variable by cdiscDataStdDomainMetadataID\r\n                        let usedBlkDomain = std_domain.find(dm1 => dm1.cdiscDataStdDomainMetadataID === d.cdiscDataStdDomainMetadataID);\r\n                        let usedBlkDomainName = usedBlkDomain && typeof usedBlkDomain === \"object\" ? usedBlkDomain.domain : d.domain;\r\n                        //Combine renamed variables also before check for impact\r\n                        let renameVarsByDataset = variableRenameList && variableRenameList[usedBlkDomainName + \"@_TargetVar\"];\r\n                        renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\r\n\r\n                        let bothVariables = [...std_variable,\r\n                        ...(Object.keys(renameVarsByDataset) || []).map(rv => renameVarsByDataset[rv])];\r\n\r\n\r\n                        let nothing_impacted = bothVariables.some(va => {\r\n                            let renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\r\n\r\n                            //get std domain name for variable by cdiscDataStdDomainMetadataID\r\n                            let domain = std_domain.find(dm => dm.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID);\r\n                            let domainname = domain && typeof domain === \"object\" ? domain.domain : \"\";\r\n\r\n                            //let getDomain = Standards.Domain.find(d => d.cdiscDataStdDomainMetadataID === va.cdiscDataStdDomainMetadataID);\r\n                            return usedBlkDomainName.toUpperCase() === domainname.toUpperCase() &&\r\n                                (va.variableName.toUpperCase() === d.variableName.toUpperCase() || d.variableName.toUpperCase() === renameTo.toUpperCase());\r\n                        });\r\n\r\n                        //not to override  above validation .if above validation itself found impact ,then no need to do following validation.that's why condn added below\r\n                        //HERE available Mapping List validation\r\n                        if (usedBlkDomain && usedBlkDomain.domain && !usedBlkDomain.domain.includes(\"_int\")) {\r\n                            nothing_impacted = nothing_impacted &&\r\n                                MappingList.some(va => {\r\n                                    return usedBlkDomainName.toUpperCase() === va.targetDataSet.toUpperCase() && va.cdiscDataStdVariableMetadataID === d.cdiscDataStdVariableMetadataID;\r\n                                });\r\n                        }\r\n                        !nothing_impacted && (this.ImpactedList[usedBlkDomainName + \".\" + d.variableName] = \"Target Variable - \" + usedBlkDomainName + \".\" + d.variableName);\r\n\r\n                        //Maintaing statge of overal check\r\n                        none_impacted = none_impacted && nothing_impacted;\r\n                    }\r\n                    break;\r\n\r\n            }\r\n\r\n            if (!none_impacted) {\r\n\r\n            }\r\n        }\r\n\r\n        //here we inverse \r\n        //for other end developing \r\n        this.impacted = !none_impacted;\r\n\r\n    }\r\n    catch (e) {\r\n        console.log(e)\r\n    }\r\n}\r\n\r\n//NCICodeList_Validation For Workspace\r\n//Only blocklyWorkspcae.js uses this function\r\nImpactValidation.prototype.ImapctNCICodeListValidationWorkspace = function () {\r\n    let { data_info, NCICODELISTDATA } = this;\r\n    let nci_list = NCICODELISTDATA && typeof NCICODELISTDATA === \"object\" ? NCICODELISTDATA : [];\r\n    let usedblk_info = data_info;\r\n    for (let i = 0; i < usedblk_info.length; i++) {\r\n        let block_info = usedblk_info[i] && usedblk_info[i].textContent ? validJSON(usedblk_info[i].textContent) : {};\r\n\r\n        if (block_info.blockType === \"NciCodeListData\") {\r\n            if (!nci_list.some(x => x.code === block_info.code)) {\r\n                let cdiscSubmissionValue = block_info.cdiscSubmissionValue;\r\n\r\n                this.impacted = true;\r\n                this.ImpactedList[\"Nci\" + \".\" + cdiscSubmissionValue] = \"NCI Codelist - \" + cdiscSubmissionValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//NCICodeList_Validation while copying records\r\nImpactValidation.prototype.ImpactNCICodeListValidation = function () {\r\n    let { Standards, selected_records, resolve, reject } = this;\r\n    let loop_index = 0;\r\n    try {\r\n        //Std Target Domain Variable\r\n        let { Domain, Variable } = Standards || [];\r\n\r\n        //fn init\r\n        loop(selected_records[loop_index]);\r\n\r\n        function loop(rule) {\r\n            //convert string to xml     \r\n            let xml = rule.constructJson &&\r\n                typeof rule.constructJson === \"string\" &&\r\n                new DOMParser().parseFromString(rule.constructJson, \"application/xml\");\r\n\r\n            //get info from rule\r\n            let usedblk_info = xml &&\r\n                xml.getElementsByTagName(\"data\");\r\n\r\n            if (rule.constructJson && usedblk_info && typeof usedblk_info === \"object\" && usedblk_info.length > 0) {\r\n                //Domain aval for the study\r\n                let isDomainAval = (Domain || []).find(dm => dm.domain === rule.targetDataSet);\r\n                if (isDomainAval) {\r\n                    let cdiscDataStdDomainMetadataID = (isDomainAval || {}).cdiscDataStdDomainMetadataID;\r\n                    let isVariableAval = (Variable || []).find(va => va.variableName === rule.targetVariableName &&\r\n                        va.cdiscDataStdDomainMetadataID === isDomainAval.cdiscDataStdDomainMetadataID);\r\n\r\n                    if (isVariableAval) {\r\n                        //match the name and update the id \r\n                        let cdiscDataStdVariableMetadataID = (isVariableAval || {}).cdiscDataStdVariableMetadataID;\r\n\r\n                        let inp_data = {\r\n                            cDISCDataStdID: JSON.parse(\r\n                                sessionStorage.getItem(\"studyDetails\")\r\n                            ).standardID,\r\n                            cdiscDataStdDomainMetadataID: cdiscDataStdDomainMetadataID,\r\n                            cdiscDataStdVariableMetadataID: cdiscDataStdVariableMetadataID\r\n                        }\r\n                        inp_data[\"StudyID\"] = getStudyID();\r\n                        showProgress();\r\n                        controller_call(inp_data, usedblk_info);\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                ++loop_index;\r\n                selected_records[loop_index] ? loop(selected_records[loop_index]) : resolve();\r\n            }\r\n            else {\r\n                ++loop_index;\r\n                selected_records[loop_index] ? loop(selected_records[loop_index]) : resolve();\r\n            }\r\n\r\n\r\n            function controller_call(inp_data, usedblk) {\r\n                CallServerPost(\"NCICodeList/GetNCIByDatasetVariable\", inp_data).then((res) =>\r\n                {\r\n                    hideProgress();\r\n                    let avail_codelist = res.value;\r\n\r\n                    if (res.status === 1 && avail_codelist && typeof avail_codelist === \"object\" && avail_codelist.length > 0) {\r\n\r\n                        let avail_codelist = res.value;\r\n\r\n                        for (let i = 0; i < usedblk.length; i++) {\r\n                            let block_info = usedblk[i] && usedblk[i].textContent ? validJSON(usedblk[i].textContent) : {};\r\n\r\n                            if (block_info.blockType === \"NciCodeListData\") {\r\n                                if (!avail_codelist.some(x => x.code === block_info.code)) {\r\n                                    selected_records[loop_index].impact = 1;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                    else {\r\n                        Array.from(usedblk).some(blk => {\r\n                            //get used block info\r\n                            //block info in data block\r\n                            let data = blk && blk.textContent ? validJSON(blk.textContent) : {};\r\n                            if (data.blockType === \"NciCodeListData\") {\r\n                                selected_records[loop_index].impact = 1;\r\n                                return true;\r\n                            }\r\n                        })\r\n                    }\r\n\r\n                    ++loop_index;\r\n                    selected_records[loop_index] ? loop(selected_records[loop_index]) : resolve();\r\n                });\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        reject();\r\n        hideProgress();\r\n        console.log(e);\r\n    }\r\n\r\n}\r\n//WorkDataset Variable Exists\r\nexport function WorkDatasetVariableExists(stepBlock, workDataset, VariableRenameList) {\r\n    //overall check \r\n    let exist = true;\r\n    //get all used block inside the variable step  \r\n    let frst_children = stepBlock && typeof stepBlock === \"object\" ? stepBlock.getInputTargetBlock(\"step_statement\") : [];\r\n    let children = isObject(frst_children) ? frst_children.getDescendants() : [];\r\n    let workBlocks = children.filter(sblock => sblock.type === \"variable_type_work_multi\" || sblock.type === \"dataset_type_multi_work\" || sblock.type === \"variable_type_work_multi_2\");\r\n    //get only dataset blk from datatable step\r\n\r\n    let not_avail_wks = {};\r\n\r\n    for (var i = 0; i < workBlocks.length; i++) {\r\n\r\n        let blk = workBlocks[i];\r\n        let data_info = validJSON(blk.data);\r\n\r\n        switch (data_info.blockType) {\r\n            case \"Work\":\r\n                {\r\n                    let isExist = workDataset.some(va => {\r\n                        return data_info.name.toUpperCase() === va.memname.toUpperCase()\r\n                    });\r\n\r\n                    !isExist && (not_avail_wks[data_info.name] = \"Work Dataset - \" + data_info.name);\r\n                    //maintaining status\r\n                    exist = exist && isExist;\r\n                }\r\n                break;\r\n            case \"WorkVar\":\r\n                {\r\n                    //Combine renamed variables also before check for impact\r\n                    let renameVarsByDataset = VariableRenameList && VariableRenameList[data_info.dataset + \"@_WorkVar\"];\r\n                    renameVarsByDataset = isObjectCheck(renameVarsByDataset) ? renameVarsByDataset : {};\r\n\r\n                    let bothVariables = [...workDataset,\r\n                    ...(Object.keys(renameVarsByDataset) || []).map(rv => renameVarsByDataset[rv])];\r\n\r\n                    let isExist = exist && bothVariables.some(va => {\r\n                        let renameTo = va.renameTo && typeof va.renameTo === \"string\" ? va.renameTo : \"\";\r\n                        let vds = isObjectCheck(va) ? 'dataset' in va ? va.dataset : 'memname' in va ? va.memname : '' : '';\r\n                        let vname = isObjectCheck(va) ? 'name' in va ? va.name : 'variable' in va ? va.variable : '' : '';\r\n\r\n                        if (data_info.dataset.toUpperCase() === vds.toUpperCase() &&\r\n                            (data_info.variable.toUpperCase() === vname.toUpperCase() || data_info.variable.toUpperCase() === renameTo.toUpperCase())) {\r\n                            return true;\r\n                        }\r\n                    });\r\n\r\n                    !isExist && (not_avail_wks[data_info.dataset + \".\" + data_info.variable] = \"Work Variable - \" + data_info.dataset + \".\" + data_info.variable);\r\n                    //maintaining status\r\n                    exist = exist && isExist;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    return { Work_Exist: exist, Not_Avail_WkList: not_avail_wks }\r\n}\r\n\r\n\r\nexport function FormErrorHtmlIfObj(header, errObj) {\r\n    try {\r\n        let err = [<div className=\"errorpop_map marginTopBottomFive\">{header} :</div>,\r\n        <ol className=\"errOrderLi\">{(Object.keys(errObj) || []).map((keyName, index) => {\r\n            return <li key={index}>\r\n                {errObj[keyName]}\r\n            </li>\r\n        })}\r\n        </ol>];\r\n        return err;\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport function FormErrorIfArray(header, errObj) {\r\n    try {\r\n\r\n        let errOb = [];\r\n        errObj.map((er, i) => {\r\n            if (errObj.indexOf(er) === i) {\r\n                errOb.push(er)\r\n            }\r\n        });\r\n\r\n        let err = [<div className=\"errorpop_map marginTopBottomFive\">{header} :</div>,\r\n        <ol className=\"errOrderLi\">{(errOb || []).map((er, i) => {\r\n            return <li key={er}>\r\n                {er}\r\n            </li>\r\n        })}\r\n\r\n        </ol>];\r\n        return err;\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        return [];\r\n    }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}