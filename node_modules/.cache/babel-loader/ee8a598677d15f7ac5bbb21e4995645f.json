{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nvar LineCommentCommand = /** @class */function () {\n  function LineCommentCommand(selection, tabSize, type, insertSpace) {\n    this._selection = selection;\n    this._tabSize = tabSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n  }\n  /**\r\n   * Do an initial pass over the lines and gather info about the line comment string.\r\n   * Returns null if any of the lines doesn't support a line comment string.\r\n   */\n  LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {\n    model.tokenizeIfCheap(startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n    var commentStr = config ? config.lineCommentToken : null;\n    if (!commentStr) {\n      // Mode does not support line comments\n      return null;\n    }\n    var lines = [];\n    for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n      lines[i] = {\n        ignore: false,\n        commentStr: commentStr,\n        commentStrOffset: 0,\n        commentStrLength: commentStr.length\n      };\n    }\n    return lines;\n  };\n  /**\r\n   * Analyze lines and decide which lines are relevant and what the toggle should do.\r\n   * Also, build up several offsets and lengths useful in the generation of editor operations.\r\n   */\n  LineCommentCommand._analyzeLines = function (type, insertSpace, model, lines, startLineNumber) {\n    var onlyWhitespaceLines = true;\n    var shouldRemoveComments;\n    if (type === 0 /* Toggle */) {\n      shouldRemoveComments = true;\n    } else if (type === 1 /* ForceAdd */) {\n      shouldRemoveComments = false;\n    } else {\n      shouldRemoveComments = true;\n    }\n    for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n      var lineData = lines[i];\n      var lineNumber = startLineNumber + i;\n      var lineContent = model.getLineContent(lineNumber);\n      var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n      if (lineContentStartOffset === -1) {\n        // Empty or whitespace only line\n        if (type === 0 /* Toggle */) {\n          lineData.ignore = true;\n        } else if (type === 1 /* ForceAdd */) {\n          lineData.ignore = true;\n        } else {\n          lineData.ignore = true;\n        }\n        lineData.commentStrOffset = lineContent.length;\n        continue;\n      }\n      onlyWhitespaceLines = false;\n      lineData.ignore = false;\n      lineData.commentStrOffset = lineContentStartOffset;\n      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n        if (type === 0 /* Toggle */) {\n          // Every line so far has been a line comment, but this one is not\n          shouldRemoveComments = false;\n        } else if (type === 1 /* ForceAdd */) {\n          // Will not happen\n        } else {\n          lineData.ignore = true;\n        }\n      }\n      if (shouldRemoveComments && insertSpace) {\n        // Remove a following space if present\n        var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\n          lineData.commentStrLength += 1;\n        }\n      }\n    }\n    if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\n      // For only whitespace lines, we insert comments\n      shouldRemoveComments = false;\n      // Also, no longer ignore them\n      for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n        lines[i].ignore = false;\n      }\n    }\n    return {\n      supported: true,\n      shouldRemoveComments: shouldRemoveComments,\n      lines: lines\n    };\n  };\n  /**\r\n   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\r\n   */\n  LineCommentCommand._gatherPreflightData = function (type, insertSpace, model, startLineNumber, endLineNumber) {\n    var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\n    if (lines === null) {\n      return {\n        supported: false\n      };\n    }\n    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber);\n  };\n  /**\r\n   * Given a successful analysis, execute either insert line comments, either remove line comments\r\n   */\n  LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {\n    var ops;\n    if (data.shouldRemoveComments) {\n      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n    } else {\n      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\n      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n    }\n    var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n    for (var i = 0, len = ops.length; i < len; i++) {\n      builder.addEditOperation(ops[i].range, ops[i].text);\n      if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\n        var lineContent = model.getLineContent(cursorPosition.lineNumber);\n        if (lineContent.length + 1 === cursorPosition.column) {\n          this._deltaColumn = (ops[i].text || '').length;\n        }\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n  };\n  LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {\n    var startLineNumber = s.startLineNumber;\n    var endLineNumber = s.endLineNumber;\n    var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n    var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n    var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n    if (startTokenIndex !== -1 && endTokenIndex === -1) {\n      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      endLineNumber = startLineNumber;\n    }\n    if (startTokenIndex === -1 && endTokenIndex !== -1) {\n      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n      startLineNumber = endLineNumber;\n    }\n    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n      if (startTokenIndex !== -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n      }\n    }\n    // We have to adjust to possible inner white space.\n    // For Space after startToken, add Space to startToken - range math will work out.\n    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\n      startToken += ' ';\n    }\n    // For Space before endToken, add Space before endToken and shift index one left.\n    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\n      endToken = ' ' + endToken;\n      endTokenIndex -= 1;\n    }\n    if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n    }\n    return null;\n  };\n  /**\r\n   * Given an unsuccessful analysis, delegate to the block comment command\r\n   */\n  LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {\n    model.tokenizeIfCheap(s.startLineNumber);\n    var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n    var config = LanguageConfigurationRegistry.getComments(languageId);\n    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n      // Mode does not support block comments\n      return;\n    }\n    var startToken = config.blockCommentStartToken;\n    var endToken = config.blockCommentEndToken;\n    var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n    if (!ops) {\n      if (s.isEmpty()) {\n        var lineContent = model.getLineContent(s.startLineNumber);\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n        if (firstNonWhitespaceIndex === -1) {\n          // Line is empty or contains only whitespace\n          firstNonWhitespaceIndex = lineContent.length;\n        }\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n      } else {\n        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n      }\n      if (ops.length === 1) {\n        // Leave cursor after token and Space\n        this._deltaColumn = startToken.length + 1;\n      }\n    }\n    this._selectionId = builder.trackSelection(s);\n    for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\n      var op = ops_1[_i];\n      builder.addEditOperation(op.range, op.text);\n    }\n  };\n  LineCommentCommand.prototype.getEditOperations = function (model, builder) {\n    var s = this._selection;\n    this._moveEndPositionDown = false;\n    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n      this._moveEndPositionDown = true;\n      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n    }\n    var data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber);\n    if (data.supported) {\n      return this._executeLineComments(model, builder, data, s);\n    }\n    return this._executeBlockComment(model, builder, s);\n  };\n  LineCommentCommand.prototype.computeCursorState = function (model, helper) {\n    var result = helper.getTrackedSelection(this._selectionId);\n    if (this._moveEndPositionDown) {\n      result = result.setEndPosition(result.endLineNumber + 1, 1);\n    }\n    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n  };\n  /**\r\n   * Generate edit operations in the remove line comment case\r\n   */\n  LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {\n    var res = [];\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var lineData = lines[i];\n      if (lineData.ignore) {\n        continue;\n      }\n      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n    }\n    return res;\n  };\n  /**\r\n   * Generate edit operations in the add line comment case\r\n   */\n  LineCommentCommand.prototype._createAddLineCommentsOperations = function (lines, startLineNumber) {\n    var res = [];\n    var afterCommentStr = this._insertSpace ? ' ' : '';\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var lineData = lines[i];\n      if (lineData.ignore) {\n        continue;\n      }\n      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n    }\n    return res;\n  };\n  LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\n    if (isTab) {\n      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);\n    }\n    return currentVisibleColumn + columnSize;\n  };\n  /**\r\n   * Adjust insertion points to have them vertically aligned in the add line comment case\r\n   */\n  LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {\n    var minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    var j;\n    var lenJ;\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n      var lineContent = model.getLineContent(startLineNumber + i);\n      var currentVisibleColumn = 0;\n      for (var j_1 = 0, lenJ_1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j_1 < lenJ_1; j_1++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j_1) === 9 /* Tab */, 1);\n      }\n      if (currentVisibleColumn < minVisibleColumn) {\n        minVisibleColumn = currentVisibleColumn;\n      }\n    }\n    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\n    for (var i = 0, len = lines.length; i < len; i++) {\n      if (lines[i].ignore) {\n        continue;\n      }\n      var lineContent = model.getLineContent(startLineNumber + i);\n      var currentVisibleColumn = 0;\n      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\n      }\n      if (currentVisibleColumn > minVisibleColumn) {\n        lines[i].commentStrOffset = j - 1;\n      } else {\n        lines[i].commentStrOffset = j;\n      }\n    }\n  };\n  return LineCommentCommand;\n}();\nexport { LineCommentCommand };","map":{"version":3,"names":["strings","EditOperation","Position","Range","Selection","LanguageConfigurationRegistry","BlockCommentCommand","LineCommentCommand","selection","tabSize","type","insertSpace","_selection","_tabSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_gatherPreflightCommentStrings","model","startLineNumber","endLineNumber","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getComments","commentStr","lineCommentToken","lines","i","lineCount","ignore","commentStrOffset","commentStrLength","length","_analyzeLines","onlyWhitespaceLines","shouldRemoveComments","lineData","lineNumber","lineContent","getLineContent","lineContentStartOffset","firstNonWhitespaceIndex","_haystackHasNeedleAtOffset","commentStrEndOffset","charCodeAt","supported","_gatherPreflightData","prototype","_executeLineComments","builder","data","s","ops","_createRemoveLineCommentsOperations","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","len","addEditOperation","range","text","isEmpty","getStartPosition","equals","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","_createRemoveBlockCommentOperations","_executeBlockComment","blockCommentStartToken","blockCommentEndToken","_createAddBlockCommentOperations","getLineMaxColumn","_i","ops_1","op","getEditOperations","setEndPosition","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","push","delete","afterCommentStr","insert","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","j_1","lenJ_1","floor"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../../common/modes/languageConfigurationRegistry.js';\r\nimport { BlockCommentCommand } from './blockCommentCommand.js';\r\nvar LineCommentCommand = /** @class */ (function () {\r\n    function LineCommentCommand(selection, tabSize, type, insertSpace) {\r\n        this._selection = selection;\r\n        this._tabSize = tabSize;\r\n        this._type = type;\r\n        this._insertSpace = insertSpace;\r\n        this._selectionId = null;\r\n        this._deltaColumn = 0;\r\n        this._moveEndPositionDown = false;\r\n    }\r\n    /**\r\n     * Do an initial pass over the lines and gather info about the line comment string.\r\n     * Returns null if any of the lines doesn't support a line comment string.\r\n     */\r\n    LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {\r\n        model.tokenizeIfCheap(startLineNumber);\r\n        var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\r\n        var config = LanguageConfigurationRegistry.getComments(languageId);\r\n        var commentStr = (config ? config.lineCommentToken : null);\r\n        if (!commentStr) {\r\n            // Mode does not support line comments\r\n            return null;\r\n        }\r\n        var lines = [];\r\n        for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\r\n            lines[i] = {\r\n                ignore: false,\r\n                commentStr: commentStr,\r\n                commentStrOffset: 0,\r\n                commentStrLength: commentStr.length\r\n            };\r\n        }\r\n        return lines;\r\n    };\r\n    /**\r\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\r\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\r\n     */\r\n    LineCommentCommand._analyzeLines = function (type, insertSpace, model, lines, startLineNumber) {\r\n        var onlyWhitespaceLines = true;\r\n        var shouldRemoveComments;\r\n        if (type === 0 /* Toggle */) {\r\n            shouldRemoveComments = true;\r\n        }\r\n        else if (type === 1 /* ForceAdd */) {\r\n            shouldRemoveComments = false;\r\n        }\r\n        else {\r\n            shouldRemoveComments = true;\r\n        }\r\n        for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\r\n            var lineData = lines[i];\r\n            var lineNumber = startLineNumber + i;\r\n            var lineContent = model.getLineContent(lineNumber);\r\n            var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (lineContentStartOffset === -1) {\r\n                // Empty or whitespace only line\r\n                if (type === 0 /* Toggle */) {\r\n                    lineData.ignore = true;\r\n                }\r\n                else if (type === 1 /* ForceAdd */) {\r\n                    lineData.ignore = true;\r\n                }\r\n                else {\r\n                    lineData.ignore = true;\r\n                }\r\n                lineData.commentStrOffset = lineContent.length;\r\n                continue;\r\n            }\r\n            onlyWhitespaceLines = false;\r\n            lineData.ignore = false;\r\n            lineData.commentStrOffset = lineContentStartOffset;\r\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\r\n                if (type === 0 /* Toggle */) {\r\n                    // Every line so far has been a line comment, but this one is not\r\n                    shouldRemoveComments = false;\r\n                }\r\n                else if (type === 1 /* ForceAdd */) {\r\n                    // Will not happen\r\n                }\r\n                else {\r\n                    lineData.ignore = true;\r\n                }\r\n            }\r\n            if (shouldRemoveComments && insertSpace) {\r\n                // Remove a following space if present\r\n                var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\r\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {\r\n                    lineData.commentStrLength += 1;\r\n                }\r\n            }\r\n        }\r\n        if (type === 0 /* Toggle */ && onlyWhitespaceLines) {\r\n            // For only whitespace lines, we insert comments\r\n            shouldRemoveComments = false;\r\n            // Also, no longer ignore them\r\n            for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\r\n                lines[i].ignore = false;\r\n            }\r\n        }\r\n        return {\r\n            supported: true,\r\n            shouldRemoveComments: shouldRemoveComments,\r\n            lines: lines\r\n        };\r\n    };\r\n    /**\r\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\r\n     */\r\n    LineCommentCommand._gatherPreflightData = function (type, insertSpace, model, startLineNumber, endLineNumber) {\r\n        var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);\r\n        if (lines === null) {\r\n            return {\r\n                supported: false\r\n            };\r\n        }\r\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber);\r\n    };\r\n    /**\r\n     * Given a successful analysis, execute either insert line comments, either remove line comments\r\n     */\r\n    LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {\r\n        var ops;\r\n        if (data.shouldRemoveComments) {\r\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\r\n        }\r\n        else {\r\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);\r\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\r\n        }\r\n        var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\r\n        for (var i = 0, len = ops.length; i < len; i++) {\r\n            builder.addEditOperation(ops[i].range, ops[i].text);\r\n            if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {\r\n                var lineContent = model.getLineContent(cursorPosition.lineNumber);\r\n                if (lineContent.length + 1 === cursorPosition.column) {\r\n                    this._deltaColumn = (ops[i].text || '').length;\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n    };\r\n    LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {\r\n        var startLineNumber = s.startLineNumber;\r\n        var endLineNumber = s.endLineNumber;\r\n        var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\r\n        var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\r\n        var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\r\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\r\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\r\n            endLineNumber = startLineNumber;\r\n        }\r\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\r\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\r\n            startLineNumber = endLineNumber;\r\n        }\r\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\r\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\r\n            if (startTokenIndex !== -1) {\r\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\r\n            }\r\n        }\r\n        // We have to adjust to possible inner white space.\r\n        // For Space after startToken, add Space to startToken - range math will work out.\r\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* Space */) {\r\n            startToken += ' ';\r\n        }\r\n        // For Space before endToken, add Space before endToken and shift index one left.\r\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* Space */) {\r\n            endToken = ' ' + endToken;\r\n            endTokenIndex -= 1;\r\n        }\r\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\r\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Given an unsuccessful analysis, delegate to the block comment command\r\n     */\r\n    LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {\r\n        model.tokenizeIfCheap(s.startLineNumber);\r\n        var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\r\n        var config = LanguageConfigurationRegistry.getComments(languageId);\r\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\r\n            // Mode does not support block comments\r\n            return;\r\n        }\r\n        var startToken = config.blockCommentStartToken;\r\n        var endToken = config.blockCommentEndToken;\r\n        var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\r\n        if (!ops) {\r\n            if (s.isEmpty()) {\r\n                var lineContent = model.getLineContent(s.startLineNumber);\r\n                var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n                if (firstNonWhitespaceIndex === -1) {\r\n                    // Line is empty or contains only whitespace\r\n                    firstNonWhitespaceIndex = lineContent.length;\r\n                }\r\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\r\n            }\r\n            else {\r\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\r\n            }\r\n            if (ops.length === 1) {\r\n                // Leave cursor after token and Space\r\n                this._deltaColumn = startToken.length + 1;\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(s);\r\n        for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {\r\n            var op = ops_1[_i];\r\n            builder.addEditOperation(op.range, op.text);\r\n        }\r\n    };\r\n    LineCommentCommand.prototype.getEditOperations = function (model, builder) {\r\n        var s = this._selection;\r\n        this._moveEndPositionDown = false;\r\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\r\n            this._moveEndPositionDown = true;\r\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\r\n        }\r\n        var data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber);\r\n        if (data.supported) {\r\n            return this._executeLineComments(model, builder, data, s);\r\n        }\r\n        return this._executeBlockComment(model, builder, s);\r\n    };\r\n    LineCommentCommand.prototype.computeCursorState = function (model, helper) {\r\n        var result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._moveEndPositionDown) {\r\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\r\n        }\r\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\r\n    };\r\n    /**\r\n     * Generate edit operations in the remove line comment case\r\n     */\r\n    LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {\r\n        var res = [];\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            var lineData = lines[i];\r\n            if (lineData.ignore) {\r\n                continue;\r\n            }\r\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Generate edit operations in the add line comment case\r\n     */\r\n    LineCommentCommand.prototype._createAddLineCommentsOperations = function (lines, startLineNumber) {\r\n        var res = [];\r\n        var afterCommentStr = this._insertSpace ? ' ' : '';\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            var lineData = lines[i];\r\n            if (lineData.ignore) {\r\n                continue;\r\n            }\r\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\r\n        }\r\n        return res;\r\n    };\r\n    LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {\r\n        if (isTab) {\r\n            return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\r\n        }\r\n        return currentVisibleColumn + columnSize;\r\n    };\r\n    /**\r\n     * Adjust insertion points to have them vertically aligned in the add line comment case\r\n     */\r\n    LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {\r\n        var minVisibleColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        var j;\r\n        var lenJ;\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].ignore) {\r\n                continue;\r\n            }\r\n            var lineContent = model.getLineContent(startLineNumber + i);\r\n            var currentVisibleColumn = 0;\r\n            for (var j_1 = 0, lenJ_1 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j_1 < lenJ_1; j_1++) {\r\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j_1) === 9 /* Tab */, 1);\r\n            }\r\n            if (currentVisibleColumn < minVisibleColumn) {\r\n                minVisibleColumn = currentVisibleColumn;\r\n            }\r\n        }\r\n        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;\r\n        for (var i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].ignore) {\r\n                continue;\r\n            }\r\n            var lineContent = model.getLineContent(startLineNumber + i);\r\n            var currentVisibleColumn = 0;\r\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\r\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);\r\n            }\r\n            if (currentVisibleColumn > minVisibleColumn) {\r\n                lines[i].commentStrOffset = j - 1;\r\n            }\r\n            else {\r\n                lines[i].commentStrOffset = j;\r\n            }\r\n        }\r\n    };\r\n    return LineCommentCommand;\r\n}());\r\nexport { LineCommentCommand };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}