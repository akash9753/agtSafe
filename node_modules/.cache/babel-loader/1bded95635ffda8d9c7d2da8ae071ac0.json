{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { URI } from './uri.js';\nimport { posix, normalize } from './path.js';\nimport { startsWithIgnoreCase, rtrim, startsWith } from './strings.js';\nimport { Schemas } from './network.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { isEqual, basename, relativePath } from './resources.js';\n/**\r\n * @deprecated use LabelService instead\r\n */\nexport function getPathLabel(resource, userHomeProvider, rootProvider) {\n  if (typeof resource === 'string') {\n    resource = URI.file(resource);\n  }\n  // return early if we can resolve a relative path label from the root\n  if (rootProvider) {\n    var baseResource = rootProvider.getWorkspaceFolder(resource);\n    if (baseResource) {\n      var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\n      var pathLabel = void 0;\n      if (isEqual(baseResource.uri, resource)) {\n        pathLabel = ''; // no label if paths are identical\n      } else {\n        pathLabel = relativePath(baseResource.uri, resource);\n      }\n      if (hasMultipleRoots) {\n        var rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);\n        pathLabel = pathLabel ? rootName + ' • ' + pathLabel : rootName; // always show root basename if there are multiple\n      }\n\n      return pathLabel;\n    }\n  }\n  // return if the resource is neither file:// nor untitled:// and no baseResource was provided\n  if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\n    return resource.with({\n      query: null,\n      fragment: null\n    }).toString(true);\n  }\n  // convert c:\\something => C:\\something\n  if (hasDriveLetter(resource.fsPath)) {\n    return normalize(normalizeDriveLetter(resource.fsPath));\n  }\n  // normalize and tildify (macOS, Linux only)\n  var res = normalize(resource.fsPath);\n  if (!isWindows && userHomeProvider) {\n    res = tildify(res, userHomeProvider.userHome);\n  }\n  return res;\n}\nexport function getBaseLabel(resource) {\n  if (!resource) {\n    return undefined;\n  }\n  if (typeof resource === 'string') {\n    resource = URI.file(resource);\n  }\n  var base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\n  // convert c: => C:\n  if (hasDriveLetter(base)) {\n    return normalizeDriveLetter(base);\n  }\n  return base;\n}\nfunction hasDriveLetter(path) {\n  return !!(isWindows && path && path[1] === ':');\n}\nexport function normalizeDriveLetter(path) {\n  if (hasDriveLetter(path)) {\n    return path.charAt(0).toUpperCase() + path.slice(1);\n  }\n  return path;\n}\nvar normalizedUserHomeCached = Object.create(null);\nexport function tildify(path, userHome) {\n  if (isWindows || !path || !userHome) {\n    return path; // unsupported\n  }\n  // Keep a normalized user home path as cache to prevent accumulated string creation\n  var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n  if (!normalizedUserHome) {\n    normalizedUserHome = \"\" + rtrim(userHome, posix.sep) + posix.sep;\n    normalizedUserHomeCached = {\n      original: userHome,\n      normalized: normalizedUserHome\n    };\n  }\n  // Linux: case sensitive, macOS: case insensitive\n  if (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\n    path = \"~/\" + path.substr(normalizedUserHome.length);\n  }\n  return path;\n}","map":{"version":3,"names":["URI","posix","normalize","startsWithIgnoreCase","rtrim","startsWith","Schemas","isLinux","isWindows","isEqual","basename","relativePath","getPathLabel","resource","userHomeProvider","rootProvider","file","baseResource","getWorkspaceFolder","hasMultipleRoots","getWorkspace","folders","length","pathLabel","uri","rootName","name","scheme","untitled","with","query","fragment","toString","hasDriveLetter","fsPath","normalizeDriveLetter","res","tildify","userHome","getBaseLabel","undefined","base","path","charAt","toUpperCase","slice","normalizedUserHomeCached","Object","create","normalizedUserHome","original","normalized","sep","substr"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/common/labels.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { URI } from './uri.js';\r\nimport { posix, normalize } from './path.js';\r\nimport { startsWithIgnoreCase, rtrim, startsWith } from './strings.js';\r\nimport { Schemas } from './network.js';\r\nimport { isLinux, isWindows } from './platform.js';\r\nimport { isEqual, basename, relativePath } from './resources.js';\r\n/**\r\n * @deprecated use LabelService instead\r\n */\r\nexport function getPathLabel(resource, userHomeProvider, rootProvider) {\r\n    if (typeof resource === 'string') {\r\n        resource = URI.file(resource);\r\n    }\r\n    // return early if we can resolve a relative path label from the root\r\n    if (rootProvider) {\r\n        var baseResource = rootProvider.getWorkspaceFolder(resource);\r\n        if (baseResource) {\r\n            var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;\r\n            var pathLabel = void 0;\r\n            if (isEqual(baseResource.uri, resource)) {\r\n                pathLabel = ''; // no label if paths are identical\r\n            }\r\n            else {\r\n                pathLabel = relativePath(baseResource.uri, resource);\r\n            }\r\n            if (hasMultipleRoots) {\r\n                var rootName = baseResource.name ? baseResource.name : basename(baseResource.uri);\r\n                pathLabel = pathLabel ? (rootName + ' • ' + pathLabel) : rootName; // always show root basename if there are multiple\r\n            }\r\n            return pathLabel;\r\n        }\r\n    }\r\n    // return if the resource is neither file:// nor untitled:// and no baseResource was provided\r\n    if (resource.scheme !== Schemas.file && resource.scheme !== Schemas.untitled) {\r\n        return resource.with({ query: null, fragment: null }).toString(true);\r\n    }\r\n    // convert c:\\something => C:\\something\r\n    if (hasDriveLetter(resource.fsPath)) {\r\n        return normalize(normalizeDriveLetter(resource.fsPath));\r\n    }\r\n    // normalize and tildify (macOS, Linux only)\r\n    var res = normalize(resource.fsPath);\r\n    if (!isWindows && userHomeProvider) {\r\n        res = tildify(res, userHomeProvider.userHome);\r\n    }\r\n    return res;\r\n}\r\nexport function getBaseLabel(resource) {\r\n    if (!resource) {\r\n        return undefined;\r\n    }\r\n    if (typeof resource === 'string') {\r\n        resource = URI.file(resource);\r\n    }\r\n    var base = basename(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;\r\n    // convert c: => C:\r\n    if (hasDriveLetter(base)) {\r\n        return normalizeDriveLetter(base);\r\n    }\r\n    return base;\r\n}\r\nfunction hasDriveLetter(path) {\r\n    return !!(isWindows && path && path[1] === ':');\r\n}\r\nexport function normalizeDriveLetter(path) {\r\n    if (hasDriveLetter(path)) {\r\n        return path.charAt(0).toUpperCase() + path.slice(1);\r\n    }\r\n    return path;\r\n}\r\nvar normalizedUserHomeCached = Object.create(null);\r\nexport function tildify(path, userHome) {\r\n    if (isWindows || !path || !userHome) {\r\n        return path; // unsupported\r\n    }\r\n    // Keep a normalized user home path as cache to prevent accumulated string creation\r\n    var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\r\n    if (!normalizedUserHome) {\r\n        normalizedUserHome = \"\" + rtrim(userHome, posix.sep) + posix.sep;\r\n        normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\r\n    }\r\n    // Linux: case sensitive, macOS: case insensitive\r\n    if (isLinux ? startsWith(path, normalizedUserHome) : startsWithIgnoreCase(path, normalizedUserHome)) {\r\n        path = \"~/\" + path.substr(normalizedUserHome.length);\r\n    }\r\n    return path;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}