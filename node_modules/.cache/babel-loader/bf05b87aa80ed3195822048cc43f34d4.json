{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nvar CACHE_STACK_DEPTH = 5;\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\nvar MonarchStackElementFactory = /** @class */function () {\n  function MonarchStackElementFactory(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  MonarchStackElementFactory.create = function (parent, state) {\n    return this._INSTANCE.create(parent, state);\n  };\n  MonarchStackElementFactory.prototype.create = function (parent, state) {\n    if (parent !== null && parent.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchStackElement(parent, state);\n    }\n    var stackElementId = MonarchStackElement.getStackElementId(parent);\n    if (stackElementId.length > 0) {\n      stackElementId += '|';\n    }\n    stackElementId += state;\n    var result = this._entries[stackElementId];\n    if (result) {\n      return result;\n    }\n    result = new MonarchStackElement(parent, state);\n    this._entries[stackElementId] = result;\n    return result;\n  };\n  MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n  return MonarchStackElementFactory;\n}();\nvar MonarchStackElement = /** @class */function () {\n  function MonarchStackElement(parent, state) {\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n  MonarchStackElement.getStackElementId = function (element) {\n    var result = '';\n    while (element !== null) {\n      if (result.length > 0) {\n        result += '|';\n      }\n      result += element.state;\n      element = element.parent;\n    }\n    return result;\n  };\n  MonarchStackElement._equals = function (a, b) {\n    while (a !== null && b !== null) {\n      if (a === b) {\n        return true;\n      }\n      if (a.state !== b.state) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    }\n    if (a === null && b === null) {\n      return true;\n    }\n    return false;\n  };\n  MonarchStackElement.prototype.equals = function (other) {\n    return MonarchStackElement._equals(this, other);\n  };\n  MonarchStackElement.prototype.push = function (state) {\n    return MonarchStackElementFactory.create(this, state);\n  };\n  MonarchStackElement.prototype.pop = function () {\n    return this.parent;\n  };\n  MonarchStackElement.prototype.popall = function () {\n    var result = this;\n    while (result.parent) {\n      result = result.parent;\n    }\n    return result;\n  };\n  MonarchStackElement.prototype.switchTo = function (state) {\n    return MonarchStackElementFactory.create(this.parent, state);\n  };\n  return MonarchStackElement;\n}();\nvar EmbeddedModeData = /** @class */function () {\n  function EmbeddedModeData(modeId, state) {\n    this.modeId = modeId;\n    this.state = state;\n  }\n  EmbeddedModeData.prototype.equals = function (other) {\n    return this.modeId === other.modeId && this.state.equals(other.state);\n  };\n  EmbeddedModeData.prototype.clone = function () {\n    var stateClone = this.state.clone();\n    // save an object\n    if (stateClone === this.state) {\n      return this;\n    }\n    return new EmbeddedModeData(this.modeId, this.state);\n  };\n  return EmbeddedModeData;\n}();\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\nvar MonarchLineStateFactory = /** @class */function () {\n  function MonarchLineStateFactory(maxCacheDepth) {\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  MonarchLineStateFactory.create = function (stack, embeddedModeData) {\n    return this._INSTANCE.create(stack, embeddedModeData);\n  };\n  MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {\n    if (embeddedModeData !== null) {\n      // no caching when embedding\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n    if (stack !== null && stack.depth >= this._maxCacheDepth) {\n      // no caching above a certain depth\n      return new MonarchLineState(stack, embeddedModeData);\n    }\n    var stackElementId = MonarchStackElement.getStackElementId(stack);\n    var result = this._entries[stackElementId];\n    if (result) {\n      return result;\n    }\n    result = new MonarchLineState(stack, null);\n    this._entries[stackElementId] = result;\n    return result;\n  };\n  MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n  return MonarchLineStateFactory;\n}();\nvar MonarchLineState = /** @class */function () {\n  function MonarchLineState(stack, embeddedModeData) {\n    this.stack = stack;\n    this.embeddedModeData = embeddedModeData;\n  }\n  MonarchLineState.prototype.clone = function () {\n    var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\n    // save an object\n    if (embeddedModeDataClone === this.embeddedModeData) {\n      return this;\n    }\n    return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n  };\n  MonarchLineState.prototype.equals = function (other) {\n    if (!(other instanceof MonarchLineState)) {\n      return false;\n    }\n    if (!this.stack.equals(other.stack)) {\n      return false;\n    }\n    if (this.embeddedModeData === null && other.embeddedModeData === null) {\n      return true;\n    }\n    if (this.embeddedModeData === null || other.embeddedModeData === null) {\n      return false;\n    }\n    return this.embeddedModeData.equals(other.embeddedModeData);\n  };\n  return MonarchLineState;\n}();\nvar MonarchClassicTokensCollector = /** @class */function () {\n  function MonarchClassicTokensCollector() {\n    this._tokens = [];\n    this._language = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n  MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {\n    this._language = modeId;\n  };\n  MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {\n    if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\n      return;\n    }\n    this._lastTokenType = type;\n    this._lastTokenLanguage = this._language;\n    this._tokens.push(new Token(startOffset, type, this._language));\n  };\n  MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\n    var nestedModeId = embeddedModeData.modeId;\n    var embeddedModeState = embeddedModeData.state;\n    var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n    var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);\n    this._tokens = this._tokens.concat(nestedResult.tokens);\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n    this._language = null;\n    return nestedResult.endState;\n  };\n  MonarchClassicTokensCollector.prototype.finalize = function (endState) {\n    return new TokenizationResult(this._tokens, endState);\n  };\n  return MonarchClassicTokensCollector;\n}();\nvar MonarchModernTokensCollector = /** @class */function () {\n  function MonarchModernTokensCollector(modeService, theme) {\n    this._modeService = modeService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0 /* Null */;\n    this._lastTokenMetadata = 0;\n  }\n  MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {\n    this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\n  };\n  MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {\n    var metadata = this._theme.match(this._currentLanguageId, type);\n    if (this._lastTokenMetadata === metadata) {\n      return;\n    }\n    this._lastTokenMetadata = metadata;\n    this._tokens.push(startOffset);\n    this._tokens.push(metadata);\n  };\n  MonarchModernTokensCollector._merge = function (a, b, c) {\n    var aLen = a !== null ? a.length : 0;\n    var bLen = b.length;\n    var cLen = c !== null ? c.length : 0;\n    if (aLen === 0 && bLen === 0 && cLen === 0) {\n      return new Uint32Array(0);\n    }\n    if (aLen === 0 && bLen === 0) {\n      return c;\n    }\n    if (bLen === 0 && cLen === 0) {\n      return a;\n    }\n    var result = new Uint32Array(aLen + bLen + cLen);\n    if (a !== null) {\n      result.set(a);\n    }\n    for (var i = 0; i < bLen; i++) {\n      result[aLen + i] = b[i];\n    }\n    if (c !== null) {\n      result.set(c, aLen + bLen);\n    }\n    return result;\n  };\n  MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\n    var nestedModeId = embeddedModeData.modeId;\n    var embeddedModeState = embeddedModeData.state;\n    var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n    if (!nestedModeTokenizationSupport) {\n      this.enterMode(offsetDelta, nestedModeId);\n      this.emit(offsetDelta, '');\n      return embeddedModeState;\n    }\n    var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);\n    this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n    this._tokens = [];\n    this._currentLanguageId = 0;\n    this._lastTokenMetadata = 0;\n    return nestedResult.endState;\n  };\n  MonarchModernTokensCollector.prototype.finalize = function (endState) {\n    return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n  };\n  return MonarchModernTokensCollector;\n}();\nvar MonarchTokenizer = /** @class */function () {\n  function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {\n    var _this = this;\n    this._modeService = modeService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._modeId = modeId;\n    this._lexer = lexer;\n    this._embeddedModes = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined);\n    // Set up listening for embedded modes\n    var emitting = false;\n    this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {\n      if (emitting) {\n        return;\n      }\n      var isOneOfMyEmbeddedModes = false;\n      for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\n        var language = e.changedLanguages[i];\n        if (_this._embeddedModes[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        modes.TokenizationRegistry.fire([_this._modeId]);\n        emitting = false;\n      }\n    });\n  }\n  MonarchTokenizer.prototype.dispose = function () {\n    this._tokenizationRegistryListener.dispose();\n  };\n  MonarchTokenizer.prototype.getLoadStatus = function () {\n    var promises = [];\n    for (var nestedModeId in this._embeddedModes) {\n      var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n      if (tokenizationSupport) {\n        // The nested mode is already loaded\n        if (tokenizationSupport instanceof MonarchTokenizer) {\n          var nestedModeStatus = tokenizationSupport.getLoadStatus();\n          if (nestedModeStatus.loaded === false) {\n            promises.push(nestedModeStatus.promise);\n          }\n        }\n        continue;\n      }\n      var tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n      if (tokenizationSupportPromise) {\n        // The nested mode is in the process of being loaded\n        promises.push(tokenizationSupportPromise);\n      }\n    }\n    if (promises.length === 0) {\n      return {\n        loaded: true\n      };\n    }\n    return {\n      loaded: false,\n      promise: Promise.all(promises).then(function (_) {\n        return undefined;\n      })\n    };\n  };\n  MonarchTokenizer.prototype.getInitialState = function () {\n    var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n    return MonarchLineStateFactory.create(rootState, null);\n  };\n  MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {\n    var tokensCollector = new MonarchClassicTokensCollector();\n    var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n    return tokensCollector.finalize(endLineState);\n  };\n  MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {\n    var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);\n    var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n    return tokensCollector.finalize(endLineState);\n  };\n  MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {\n    if (lineState.embeddedModeData) {\n      return this._nestedTokenize(line, lineState, offsetDelta, collector);\n    } else {\n      return this._myTokenize(line, lineState, offsetDelta, collector);\n    }\n  };\n  MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {\n    var rules = this._lexer.tokenizer[state.stack.state];\n    if (!rules) {\n      rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n      if (!rules) {\n        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n      }\n    }\n    var popOffset = -1;\n    var hasEmbeddedPopRule = false;\n    for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\n      var rule = rules_1[_i];\n      if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n        continue;\n      }\n      hasEmbeddedPopRule = true;\n      var regex = rule.regex;\n      var regexSource = rule.regex.source;\n      if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n        regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');\n      }\n      var result = line.search(regex);\n      if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n        continue;\n      }\n      if (popOffset === -1 || result < popOffset) {\n        popOffset = result;\n      }\n    }\n    if (!hasEmbeddedPopRule) {\n      throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n    }\n    return popOffset;\n  };\n  MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {\n    var popOffset = this._findLeavingNestedModeOffset(line, lineState);\n    if (popOffset === -1) {\n      // tokenization will not leave nested mode\n      var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);\n      return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\n    }\n    var nestedModeLine = line.substring(0, popOffset);\n    if (nestedModeLine.length > 0) {\n      // tokenize with the nested mode\n      tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);\n    }\n    var restOfTheLine = line.substring(popOffset);\n    return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);\n  };\n  MonarchTokenizer.prototype._safeRuleName = function (rule) {\n    if (rule) {\n      return rule.name;\n    }\n    return '(unknown)';\n  };\n  MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {\n    tokensCollector.enterMode(offsetDelta, this._modeId);\n    var lineLength = line.length;\n    var embeddedModeData = lineState.embeddedModeData;\n    var stack = lineState.stack;\n    var pos = 0;\n    var groupMatching = null;\n    // See https://github.com/Microsoft/monaco-editor/issues/1235:\n    // Evaluate rules at least once for an empty line\n    var forceEvaluation = true;\n    while (forceEvaluation || pos < lineLength) {\n      var pos0 = pos;\n      var stackLen0 = stack.depth;\n      var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n      var state = stack.state;\n      var matches = null;\n      var matched = null;\n      var action = null;\n      var rule = null;\n      var enteringEmbeddedMode = null;\n      // check if we need to process group matches first\n      if (groupMatching) {\n        matches = groupMatching.matches;\n        var groupEntry = groupMatching.groups.shift();\n        matched = groupEntry.matched;\n        action = groupEntry.action;\n        rule = groupMatching.rule;\n        // cleanup if necessary\n        if (groupMatching.groups.length === 0) {\n          groupMatching = null;\n        }\n      } else {\n        // otherwise we match on the token stream\n        if (!forceEvaluation && pos >= lineLength) {\n          // nothing to do\n          break;\n        }\n        forceEvaluation = false;\n        // get the rules for this state\n        var rules = this._lexer.tokenizer[state];\n        if (!rules) {\n          rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n          if (!rules) {\n            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n          }\n        }\n        // try each rule until we match\n        var restOfLine = line.substr(pos);\n        for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {\n          var rule_1 = rules_2[_i];\n          if (pos === 0 || !rule_1.matchOnlyAtLineStart) {\n            matches = restOfLine.match(rule_1.regex);\n            if (matches) {\n              matched = matches[0];\n              action = rule_1.action;\n              break;\n            }\n          }\n        }\n      }\n      // We matched 'rule' with 'matches' and 'action'\n      if (!matches) {\n        matches = [''];\n        matched = '';\n      }\n      if (!action) {\n        // bad: we didn't match anything, and there is no action to take\n        // we need to advance the stream or we get progress trouble\n        if (pos < lineLength) {\n          matches = [line.charAt(pos)];\n          matched = matches[0];\n        }\n        action = this._lexer.defaultToken;\n      }\n      if (matched === null) {\n        // should never happen, needed for strict null checking\n        break;\n      }\n      // advance stream\n      pos += matched.length;\n      // maybe call action function (used for 'cases')\n      while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n        action = action.test(matched, matches, state, pos === lineLength);\n      }\n      var result = null;\n      // set the result: either a string or an array of actions\n      if (typeof action === 'string' || Array.isArray(action)) {\n        result = action;\n      } else if (action.group) {\n        result = action.group;\n      } else if (action.token !== null && action.token !== undefined) {\n        // do $n replacements?\n        if (action.tokenSubst) {\n          result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n        } else {\n          result = action.token;\n        }\n        // enter embedded mode?\n        if (action.nextEmbedded) {\n          if (action.nextEmbedded === '@pop') {\n            if (!embeddedModeData) {\n              throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n            }\n            embeddedModeData = null;\n          } else if (embeddedModeData) {\n            throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n          } else {\n            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n          }\n        }\n        // state transformations\n        if (action.goBack) {\n          // back up the stream..\n          pos = Math.max(0, pos - action.goBack);\n        }\n        if (action.switchTo && typeof action.switchTo === 'string') {\n          var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n          if (nextState[0] === '@') {\n            nextState = nextState.substr(1); // peel off starting '@'\n          }\n\n          if (!monarchCommon.findRules(this._lexer, nextState)) {\n            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n          } else {\n            stack = stack.switchTo(nextState);\n          }\n        } else if (action.transform && typeof action.transform === 'function') {\n          throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n        } else if (action.next) {\n          if (action.next === '@push') {\n            if (stack.depth >= this._lexer.maxStack) {\n              throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n            } else {\n              stack = stack.push(state);\n            }\n          } else if (action.next === '@pop') {\n            if (stack.depth <= 1) {\n              throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.pop();\n            }\n          } else if (action.next === '@popall') {\n            stack = stack.popall();\n          } else {\n            var nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.push(nextState);\n            }\n          }\n        }\n        if (action.log && typeof action.log === 'string') {\n          monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n        }\n      }\n      // check result\n      if (result === null) {\n        throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n      }\n      // is the result a group match?\n      if (Array.isArray(result)) {\n        if (groupMatching && groupMatching.groups.length > 0) {\n          throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n        }\n        if (matches.length !== result.length + 1) {\n          throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n        }\n        var totalLen = 0;\n        for (var i = 1; i < matches.length; i++) {\n          totalLen += matches[i].length;\n        }\n        if (totalLen !== matched.length) {\n          throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n        }\n        groupMatching = {\n          rule: rule,\n          matches: matches,\n          groups: []\n        };\n        for (var i = 0; i < result.length; i++) {\n          groupMatching.groups[i] = {\n            action: result[i],\n            matched: matches[i + 1]\n          };\n        }\n        pos -= matched.length;\n        // call recursively to initiate first result match\n        continue;\n      } else {\n        // regular result\n        // check for '@rematch'\n        if (result === '@rematch') {\n          pos -= matched.length;\n          matched = ''; // better set the next state too..\n          matches = null;\n          result = '';\n        }\n        // check progress\n        if (matched.length === 0) {\n          if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n            continue;\n          } else {\n            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n          }\n        }\n        // return the result (and check for brace matching)\n        // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n        var tokenType = null;\n        if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n          var rest = result.substr('@brackets'.length);\n          var bracket = findBracket(this._lexer, matched);\n          if (!bracket) {\n            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n          }\n          tokenType = monarchCommon.sanitize(bracket.token + rest);\n        } else {\n          var token = result === '' ? '' : result + this._lexer.tokenPostfix;\n          tokenType = monarchCommon.sanitize(token);\n        }\n        tokensCollector.emit(pos0 + offsetDelta, tokenType);\n      }\n      if (enteringEmbeddedMode !== null) {\n        // substitute language alias to known modes to support syntax highlighting\n        var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n        if (enteringEmbeddedModeId) {\n          enteringEmbeddedMode = enteringEmbeddedModeId;\n        }\n        var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n        if (pos < lineLength) {\n          // there is content from the embedded mode on this line\n          var restOfLine = line.substr(pos);\n          return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);\n        } else {\n          return MonarchLineStateFactory.create(stack, embeddedModeData_1);\n        }\n      }\n    }\n    return MonarchLineStateFactory.create(stack, embeddedModeData);\n  };\n  MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {\n    var nestedModeId = this._locateMode(mimetypeOrModeId);\n    if (nestedModeId) {\n      var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n      if (tokenizationSupport) {\n        return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n      }\n    }\n    return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n  };\n  MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {\n    if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n      return null;\n    }\n    if (mimetypeOrModeId === this._modeId) {\n      // embedding myself...\n      return mimetypeOrModeId;\n    }\n    var modeId = this._modeService.getModeId(mimetypeOrModeId);\n    if (modeId) {\n      // Fire mode loading event\n      this._modeService.triggerMode(modeId);\n      this._embeddedModes[modeId] = true;\n    }\n    return modeId;\n  };\n  return MonarchTokenizer;\n}();\nexport { MonarchTokenizer };\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n  matched = monarchCommon.fixCase(lexer, matched);\n  var brackets = lexer.brackets;\n  for (var _i = 0, brackets_1 = brackets; _i < brackets_1.length; _i++) {\n    var bracket = brackets_1[_i];\n    if (bracket.open === matched) {\n      return {\n        token: bracket.token,\n        bracketType: 1 /* Open */\n      };\n    } else if (bracket.close === matched) {\n      return {\n        token: bracket.token,\n        bracketType: -1 /* Close */\n      };\n    }\n  }\n\n  return null;\n}\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\n  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\n}","map":{"version":3,"names":["Token","TokenizationResult","TokenizationResult2","modes","NULL_MODE_ID","NULL_STATE","monarchCommon","CACHE_STACK_DEPTH","MonarchStackElementFactory","maxCacheDepth","_maxCacheDepth","_entries","Object","create","parent","state","_INSTANCE","prototype","depth","MonarchStackElement","stackElementId","getStackElementId","length","result","element","_equals","a","b","equals","other","push","pop","popall","switchTo","EmbeddedModeData","modeId","clone","stateClone","MonarchLineStateFactory","stack","embeddedModeData","MonarchLineState","embeddedModeDataClone","MonarchClassicTokensCollector","_tokens","_language","_lastTokenType","_lastTokenLanguage","enterMode","startOffset","emit","type","nestedModeTokenize","embeddedModeLine","offsetDelta","nestedModeId","embeddedModeState","nestedModeTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","concat","tokens","endState","finalize","MonarchModernTokensCollector","modeService","theme","_modeService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","getLanguageIdentifier","id","metadata","match","_merge","c","aLen","bLen","cLen","Uint32Array","set","i","tokenize2","MonarchTokenizer","standaloneThemeService","lexer","_this","_standaloneThemeService","_modeId","_lexer","_embeddedModes","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","len","changedLanguages","language","fire","dispose","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","tokenizationSupportPromise","getPromise","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedModeOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","_i","rules_1","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","RegExp","ignoreCase","search","matchOnlyAtLineStart","nestedEndState","nestedModeLine","substring","restOfTheLine","_safeRuleName","name","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedMode","groupEntry","shift","restOfLine","rules_2","rule_1","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","token","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","languageId","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","enteringEmbeddedModeId","getModeIdForLanguageName","embeddedModeData_1","_getNestedEmbeddedModeData","mimetypeOrModeId","_locateMode","isRegisteredMode","getModeId","triggerMode","fixCase","brackets","brackets_1","open","bracketType","close","createTokenizationSupport"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\r\nimport * as modes from '../../../common/modes.js';\r\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\r\nimport * as monarchCommon from './monarchCommon.js';\r\nvar CACHE_STACK_DEPTH = 5;\r\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\r\nvar MonarchStackElementFactory = /** @class */ (function () {\r\n    function MonarchStackElementFactory(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    MonarchStackElementFactory.create = function (parent, state) {\r\n        return this._INSTANCE.create(parent, state);\r\n    };\r\n    MonarchStackElementFactory.prototype.create = function (parent, state) {\r\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchStackElement(parent, state);\r\n        }\r\n        var stackElementId = MonarchStackElement.getStackElementId(parent);\r\n        if (stackElementId.length > 0) {\r\n            stackElementId += '|';\r\n        }\r\n        stackElementId += state;\r\n        var result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchStackElement(parent, state);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    };\r\n    MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\r\n    return MonarchStackElementFactory;\r\n}());\r\nvar MonarchStackElement = /** @class */ (function () {\r\n    function MonarchStackElement(parent, state) {\r\n        this.parent = parent;\r\n        this.state = state;\r\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\r\n    }\r\n    MonarchStackElement.getStackElementId = function (element) {\r\n        var result = '';\r\n        while (element !== null) {\r\n            if (result.length > 0) {\r\n                result += '|';\r\n            }\r\n            result += element.state;\r\n            element = element.parent;\r\n        }\r\n        return result;\r\n    };\r\n    MonarchStackElement._equals = function (a, b) {\r\n        while (a !== null && b !== null) {\r\n            if (a === b) {\r\n                return true;\r\n            }\r\n            if (a.state !== b.state) {\r\n                return false;\r\n            }\r\n            a = a.parent;\r\n            b = b.parent;\r\n        }\r\n        if (a === null && b === null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    MonarchStackElement.prototype.equals = function (other) {\r\n        return MonarchStackElement._equals(this, other);\r\n    };\r\n    MonarchStackElement.prototype.push = function (state) {\r\n        return MonarchStackElementFactory.create(this, state);\r\n    };\r\n    MonarchStackElement.prototype.pop = function () {\r\n        return this.parent;\r\n    };\r\n    MonarchStackElement.prototype.popall = function () {\r\n        var result = this;\r\n        while (result.parent) {\r\n            result = result.parent;\r\n        }\r\n        return result;\r\n    };\r\n    MonarchStackElement.prototype.switchTo = function (state) {\r\n        return MonarchStackElementFactory.create(this.parent, state);\r\n    };\r\n    return MonarchStackElement;\r\n}());\r\nvar EmbeddedModeData = /** @class */ (function () {\r\n    function EmbeddedModeData(modeId, state) {\r\n        this.modeId = modeId;\r\n        this.state = state;\r\n    }\r\n    EmbeddedModeData.prototype.equals = function (other) {\r\n        return (this.modeId === other.modeId\r\n            && this.state.equals(other.state));\r\n    };\r\n    EmbeddedModeData.prototype.clone = function () {\r\n        var stateClone = this.state.clone();\r\n        // save an object\r\n        if (stateClone === this.state) {\r\n            return this;\r\n        }\r\n        return new EmbeddedModeData(this.modeId, this.state);\r\n    };\r\n    return EmbeddedModeData;\r\n}());\r\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\r\nvar MonarchLineStateFactory = /** @class */ (function () {\r\n    function MonarchLineStateFactory(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    MonarchLineStateFactory.create = function (stack, embeddedModeData) {\r\n        return this._INSTANCE.create(stack, embeddedModeData);\r\n    };\r\n    MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {\r\n        if (embeddedModeData !== null) {\r\n            // no caching when embedding\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        var stackElementId = MonarchStackElement.getStackElementId(stack);\r\n        var result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchLineState(stack, null);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    };\r\n    MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\r\n    return MonarchLineStateFactory;\r\n}());\r\nvar MonarchLineState = /** @class */ (function () {\r\n    function MonarchLineState(stack, embeddedModeData) {\r\n        this.stack = stack;\r\n        this.embeddedModeData = embeddedModeData;\r\n    }\r\n    MonarchLineState.prototype.clone = function () {\r\n        var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\r\n        // save an object\r\n        if (embeddedModeDataClone === this.embeddedModeData) {\r\n            return this;\r\n        }\r\n        return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\r\n    };\r\n    MonarchLineState.prototype.equals = function (other) {\r\n        if (!(other instanceof MonarchLineState)) {\r\n            return false;\r\n        }\r\n        if (!this.stack.equals(other.stack)) {\r\n            return false;\r\n        }\r\n        if (this.embeddedModeData === null && other.embeddedModeData === null) {\r\n            return true;\r\n        }\r\n        if (this.embeddedModeData === null || other.embeddedModeData === null) {\r\n            return false;\r\n        }\r\n        return this.embeddedModeData.equals(other.embeddedModeData);\r\n    };\r\n    return MonarchLineState;\r\n}());\r\nvar MonarchClassicTokensCollector = /** @class */ (function () {\r\n    function MonarchClassicTokensCollector() {\r\n        this._tokens = [];\r\n        this._language = null;\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n    }\r\n    MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {\r\n        this._language = modeId;\r\n    };\r\n    MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {\r\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\r\n            return;\r\n        }\r\n        this._lastTokenType = type;\r\n        this._lastTokenLanguage = this._language;\r\n        this._tokens.push(new Token(startOffset, type, this._language));\r\n    };\r\n    MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\r\n        var nestedModeId = embeddedModeData.modeId;\r\n        var embeddedModeState = embeddedModeData.state;\r\n        var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);\r\n        this._tokens = this._tokens.concat(nestedResult.tokens);\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n        this._language = null;\r\n        return nestedResult.endState;\r\n    };\r\n    MonarchClassicTokensCollector.prototype.finalize = function (endState) {\r\n        return new TokenizationResult(this._tokens, endState);\r\n    };\r\n    return MonarchClassicTokensCollector;\r\n}());\r\nvar MonarchModernTokensCollector = /** @class */ (function () {\r\n    function MonarchModernTokensCollector(modeService, theme) {\r\n        this._modeService = modeService;\r\n        this._theme = theme;\r\n        this._prependTokens = null;\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0 /* Null */;\r\n        this._lastTokenMetadata = 0;\r\n    }\r\n    MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {\r\n        this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\r\n    };\r\n    MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {\r\n        var metadata = this._theme.match(this._currentLanguageId, type);\r\n        if (this._lastTokenMetadata === metadata) {\r\n            return;\r\n        }\r\n        this._lastTokenMetadata = metadata;\r\n        this._tokens.push(startOffset);\r\n        this._tokens.push(metadata);\r\n    };\r\n    MonarchModernTokensCollector._merge = function (a, b, c) {\r\n        var aLen = (a !== null ? a.length : 0);\r\n        var bLen = b.length;\r\n        var cLen = (c !== null ? c.length : 0);\r\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\r\n            return new Uint32Array(0);\r\n        }\r\n        if (aLen === 0 && bLen === 0) {\r\n            return c;\r\n        }\r\n        if (bLen === 0 && cLen === 0) {\r\n            return a;\r\n        }\r\n        var result = new Uint32Array(aLen + bLen + cLen);\r\n        if (a !== null) {\r\n            result.set(a);\r\n        }\r\n        for (var i = 0; i < bLen; i++) {\r\n            result[aLen + i] = b[i];\r\n        }\r\n        if (c !== null) {\r\n            result.set(c, aLen + bLen);\r\n        }\r\n        return result;\r\n    };\r\n    MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {\r\n        var nestedModeId = embeddedModeData.modeId;\r\n        var embeddedModeState = embeddedModeData.state;\r\n        var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);\r\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0;\r\n        this._lastTokenMetadata = 0;\r\n        return nestedResult.endState;\r\n    };\r\n    MonarchModernTokensCollector.prototype.finalize = function (endState) {\r\n        return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\r\n    };\r\n    return MonarchModernTokensCollector;\r\n}());\r\nvar MonarchTokenizer = /** @class */ (function () {\r\n    function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {\r\n        var _this = this;\r\n        this._modeService = modeService;\r\n        this._standaloneThemeService = standaloneThemeService;\r\n        this._modeId = modeId;\r\n        this._lexer = lexer;\r\n        this._embeddedModes = Object.create(null);\r\n        this.embeddedLoaded = Promise.resolve(undefined);\r\n        // Set up listening for embedded modes\r\n        var emitting = false;\r\n        this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {\r\n            if (emitting) {\r\n                return;\r\n            }\r\n            var isOneOfMyEmbeddedModes = false;\r\n            for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\r\n                var language = e.changedLanguages[i];\r\n                if (_this._embeddedModes[language]) {\r\n                    isOneOfMyEmbeddedModes = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isOneOfMyEmbeddedModes) {\r\n                emitting = true;\r\n                modes.TokenizationRegistry.fire([_this._modeId]);\r\n                emitting = false;\r\n            }\r\n        });\r\n    }\r\n    MonarchTokenizer.prototype.dispose = function () {\r\n        this._tokenizationRegistryListener.dispose();\r\n    };\r\n    MonarchTokenizer.prototype.getLoadStatus = function () {\r\n        var promises = [];\r\n        for (var nestedModeId in this._embeddedModes) {\r\n            var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                // The nested mode is already loaded\r\n                if (tokenizationSupport instanceof MonarchTokenizer) {\r\n                    var nestedModeStatus = tokenizationSupport.getLoadStatus();\r\n                    if (nestedModeStatus.loaded === false) {\r\n                        promises.push(nestedModeStatus.promise);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            var tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\r\n            if (tokenizationSupportPromise) {\r\n                // The nested mode is in the process of being loaded\r\n                promises.push(tokenizationSupportPromise);\r\n            }\r\n        }\r\n        if (promises.length === 0) {\r\n            return {\r\n                loaded: true\r\n            };\r\n        }\r\n        return {\r\n            loaded: false,\r\n            promise: Promise.all(promises).then(function (_) { return undefined; })\r\n        };\r\n    };\r\n    MonarchTokenizer.prototype.getInitialState = function () {\r\n        var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\r\n        return MonarchLineStateFactory.create(rootState, null);\r\n    };\r\n    MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {\r\n        var tokensCollector = new MonarchClassicTokensCollector();\r\n        var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    };\r\n    MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {\r\n        var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);\r\n        var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    };\r\n    MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {\r\n        if (lineState.embeddedModeData) {\r\n            return this._nestedTokenize(line, lineState, offsetDelta, collector);\r\n        }\r\n        else {\r\n            return this._myTokenize(line, lineState, offsetDelta, collector);\r\n        }\r\n    };\r\n    MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {\r\n        var rules = this._lexer.tokenizer[state.stack.state];\r\n        if (!rules) {\r\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\r\n            if (!rules) {\r\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\r\n            }\r\n        }\r\n        var popOffset = -1;\r\n        var hasEmbeddedPopRule = false;\r\n        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {\r\n            var rule = rules_1[_i];\r\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\r\n                continue;\r\n            }\r\n            hasEmbeddedPopRule = true;\r\n            var regex = rule.regex;\r\n            var regexSource = rule.regex.source;\r\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\r\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');\r\n            }\r\n            var result = line.search(regex);\r\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\r\n                continue;\r\n            }\r\n            if (popOffset === -1 || result < popOffset) {\r\n                popOffset = result;\r\n            }\r\n        }\r\n        if (!hasEmbeddedPopRule) {\r\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\r\n        }\r\n        return popOffset;\r\n    };\r\n    MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {\r\n        var popOffset = this._findLeavingNestedModeOffset(line, lineState);\r\n        if (popOffset === -1) {\r\n            // tokenization will not leave nested mode\r\n            var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);\r\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\r\n        }\r\n        var nestedModeLine = line.substring(0, popOffset);\r\n        if (nestedModeLine.length > 0) {\r\n            // tokenize with the nested mode\r\n            tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);\r\n        }\r\n        var restOfTheLine = line.substring(popOffset);\r\n        return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);\r\n    };\r\n    MonarchTokenizer.prototype._safeRuleName = function (rule) {\r\n        if (rule) {\r\n            return rule.name;\r\n        }\r\n        return '(unknown)';\r\n    };\r\n    MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {\r\n        tokensCollector.enterMode(offsetDelta, this._modeId);\r\n        var lineLength = line.length;\r\n        var embeddedModeData = lineState.embeddedModeData;\r\n        var stack = lineState.stack;\r\n        var pos = 0;\r\n        var groupMatching = null;\r\n        // See https://github.com/Microsoft/monaco-editor/issues/1235:\r\n        // Evaluate rules at least once for an empty line\r\n        var forceEvaluation = true;\r\n        while (forceEvaluation || pos < lineLength) {\r\n            var pos0 = pos;\r\n            var stackLen0 = stack.depth;\r\n            var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\r\n            var state = stack.state;\r\n            var matches = null;\r\n            var matched = null;\r\n            var action = null;\r\n            var rule = null;\r\n            var enteringEmbeddedMode = null;\r\n            // check if we need to process group matches first\r\n            if (groupMatching) {\r\n                matches = groupMatching.matches;\r\n                var groupEntry = groupMatching.groups.shift();\r\n                matched = groupEntry.matched;\r\n                action = groupEntry.action;\r\n                rule = groupMatching.rule;\r\n                // cleanup if necessary\r\n                if (groupMatching.groups.length === 0) {\r\n                    groupMatching = null;\r\n                }\r\n            }\r\n            else {\r\n                // otherwise we match on the token stream\r\n                if (!forceEvaluation && pos >= lineLength) {\r\n                    // nothing to do\r\n                    break;\r\n                }\r\n                forceEvaluation = false;\r\n                // get the rules for this state\r\n                var rules = this._lexer.tokenizer[state];\r\n                if (!rules) {\r\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\r\n                    if (!rules) {\r\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\r\n                    }\r\n                }\r\n                // try each rule until we match\r\n                var restOfLine = line.substr(pos);\r\n                for (var _i = 0, rules_2 = rules; _i < rules_2.length; _i++) {\r\n                    var rule_1 = rules_2[_i];\r\n                    if (pos === 0 || !rule_1.matchOnlyAtLineStart) {\r\n                        matches = restOfLine.match(rule_1.regex);\r\n                        if (matches) {\r\n                            matched = matches[0];\r\n                            action = rule_1.action;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // We matched 'rule' with 'matches' and 'action'\r\n            if (!matches) {\r\n                matches = [''];\r\n                matched = '';\r\n            }\r\n            if (!action) {\r\n                // bad: we didn't match anything, and there is no action to take\r\n                // we need to advance the stream or we get progress trouble\r\n                if (pos < lineLength) {\r\n                    matches = [line.charAt(pos)];\r\n                    matched = matches[0];\r\n                }\r\n                action = this._lexer.defaultToken;\r\n            }\r\n            if (matched === null) {\r\n                // should never happen, needed for strict null checking\r\n                break;\r\n            }\r\n            // advance stream\r\n            pos += matched.length;\r\n            // maybe call action function (used for 'cases')\r\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\r\n                action = action.test(matched, matches, state, pos === lineLength);\r\n            }\r\n            var result = null;\r\n            // set the result: either a string or an array of actions\r\n            if (typeof action === 'string' || Array.isArray(action)) {\r\n                result = action;\r\n            }\r\n            else if (action.group) {\r\n                result = action.group;\r\n            }\r\n            else if (action.token !== null && action.token !== undefined) {\r\n                // do $n replacements?\r\n                if (action.tokenSubst) {\r\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\r\n                }\r\n                else {\r\n                    result = action.token;\r\n                }\r\n                // enter embedded mode?\r\n                if (action.nextEmbedded) {\r\n                    if (action.nextEmbedded === '@pop') {\r\n                        if (!embeddedModeData) {\r\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\r\n                        }\r\n                        embeddedModeData = null;\r\n                    }\r\n                    else if (embeddedModeData) {\r\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\r\n                    }\r\n                    else {\r\n                        enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\r\n                    }\r\n                }\r\n                // state transformations\r\n                if (action.goBack) { // back up the stream..\r\n                    pos = Math.max(0, pos - action.goBack);\r\n                }\r\n                if (action.switchTo && typeof action.switchTo === 'string') {\r\n                    var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\r\n                    if (nextState[0] === '@') {\r\n                        nextState = nextState.substr(1); // peel off starting '@'\r\n                    }\r\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                    else {\r\n                        stack = stack.switchTo(nextState);\r\n                    }\r\n                }\r\n                else if (action.transform && typeof action.transform === 'function') {\r\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\r\n                }\r\n                else if (action.next) {\r\n                    if (action.next === '@push') {\r\n                        if (stack.depth >= this._lexer.maxStack) {\r\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\r\n                                stack.state + ',' + stack.parent.state + ',...]');\r\n                        }\r\n                        else {\r\n                            stack = stack.push(state);\r\n                        }\r\n                    }\r\n                    else if (action.next === '@pop') {\r\n                        if (stack.depth <= 1) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.pop();\r\n                        }\r\n                    }\r\n                    else if (action.next === '@popall') {\r\n                        stack = stack.popall();\r\n                    }\r\n                    else {\r\n                        var nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\r\n                        if (nextState[0] === '@') {\r\n                            nextState = nextState.substr(1); // peel off starting '@'\r\n                        }\r\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.push(nextState);\r\n                        }\r\n                    }\r\n                }\r\n                if (action.log && typeof (action.log) === 'string') {\r\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\r\n                }\r\n            }\r\n            // check result\r\n            if (result === null) {\r\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\r\n            }\r\n            // is the result a group match?\r\n            if (Array.isArray(result)) {\r\n                if (groupMatching && groupMatching.groups.length > 0) {\r\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\r\n                }\r\n                if (matches.length !== result.length + 1) {\r\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                var totalLen = 0;\r\n                for (var i = 1; i < matches.length; i++) {\r\n                    totalLen += matches[i].length;\r\n                }\r\n                if (totalLen !== matched.length) {\r\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                groupMatching = {\r\n                    rule: rule,\r\n                    matches: matches,\r\n                    groups: []\r\n                };\r\n                for (var i = 0; i < result.length; i++) {\r\n                    groupMatching.groups[i] = {\r\n                        action: result[i],\r\n                        matched: matches[i + 1]\r\n                    };\r\n                }\r\n                pos -= matched.length;\r\n                // call recursively to initiate first result match\r\n                continue;\r\n            }\r\n            else {\r\n                // regular result\r\n                // check for '@rematch'\r\n                if (result === '@rematch') {\r\n                    pos -= matched.length;\r\n                    matched = ''; // better set the next state too..\r\n                    matches = null;\r\n                    result = '';\r\n                }\r\n                // check progress\r\n                if (matched.length === 0) {\r\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                }\r\n                // return the result (and check for brace matching)\r\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\r\n                var tokenType = null;\r\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\r\n                    var rest = result.substr('@brackets'.length);\r\n                    var bracket = findBracket(this._lexer, matched);\r\n                    if (!bracket) {\r\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\r\n                    }\r\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\r\n                }\r\n                else {\r\n                    var token = (result === '' ? '' : result + this._lexer.tokenPostfix);\r\n                    tokenType = monarchCommon.sanitize(token);\r\n                }\r\n                tokensCollector.emit(pos0 + offsetDelta, tokenType);\r\n            }\r\n            if (enteringEmbeddedMode !== null) {\r\n                // substitute language alias to known modes to support syntax highlighting\r\n                var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\r\n                if (enteringEmbeddedModeId) {\r\n                    enteringEmbeddedMode = enteringEmbeddedModeId;\r\n                }\r\n                var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\r\n                if (pos < lineLength) {\r\n                    // there is content from the embedded mode on this line\r\n                    var restOfLine = line.substr(pos);\r\n                    return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);\r\n                }\r\n                else {\r\n                    return MonarchLineStateFactory.create(stack, embeddedModeData_1);\r\n                }\r\n            }\r\n        }\r\n        return MonarchLineStateFactory.create(stack, embeddedModeData);\r\n    };\r\n    MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {\r\n        var nestedModeId = this._locateMode(mimetypeOrModeId);\r\n        if (nestedModeId) {\r\n            var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\r\n            }\r\n        }\r\n        return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\r\n    };\r\n    MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {\r\n        if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\r\n            return null;\r\n        }\r\n        if (mimetypeOrModeId === this._modeId) {\r\n            // embedding myself...\r\n            return mimetypeOrModeId;\r\n        }\r\n        var modeId = this._modeService.getModeId(mimetypeOrModeId);\r\n        if (modeId) {\r\n            // Fire mode loading event\r\n            this._modeService.triggerMode(modeId);\r\n            this._embeddedModes[modeId] = true;\r\n        }\r\n        return modeId;\r\n    };\r\n    return MonarchTokenizer;\r\n}());\r\nexport { MonarchTokenizer };\r\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\r\nfunction findBracket(lexer, matched) {\r\n    if (!matched) {\r\n        return null;\r\n    }\r\n    matched = monarchCommon.fixCase(lexer, matched);\r\n    var brackets = lexer.brackets;\r\n    for (var _i = 0, brackets_1 = brackets; _i < brackets_1.length; _i++) {\r\n        var bracket = brackets_1[_i];\r\n        if (bracket.open === matched) {\r\n            return { token: bracket.token, bracketType: 1 /* Open */ };\r\n        }\r\n        else if (bracket.close === matched) {\r\n            return { token: bracket.token, bracketType: -1 /* Close */ };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\r\n    return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}