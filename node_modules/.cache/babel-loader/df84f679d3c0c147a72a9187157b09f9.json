{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, Position } from './../_deps/vscode-languageserver-types/main.js';\nimport { html_beautify } from '../beautify/beautify-html.js';\nimport { repeat } from '../utils/strings.js';\nexport function format(document, range, options) {\n  var value = document.getText();\n  var includesEnd = true;\n  var initialIndentLevel = 0;\n  var tabSize = options.tabSize || 4;\n  if (range) {\n    var startOffset = document.offsetAt(range.start);\n    // include all leading whitespace iff at the beginning of the line\n    var extendedStart = startOffset;\n    while (extendedStart > 0 && isWhitespace(value, extendedStart - 1)) {\n      extendedStart--;\n    }\n    if (extendedStart === 0 || isEOL(value, extendedStart - 1)) {\n      startOffset = extendedStart;\n    } else {\n      // else keep at least one whitespace\n      if (extendedStart < startOffset) {\n        startOffset = extendedStart + 1;\n      }\n    }\n    // include all following whitespace until the end of the line\n    var endOffset = document.offsetAt(range.end);\n    var extendedEnd = endOffset;\n    while (extendedEnd < value.length && isWhitespace(value, extendedEnd)) {\n      extendedEnd++;\n    }\n    if (extendedEnd === value.length || isEOL(value, extendedEnd)) {\n      endOffset = extendedEnd;\n    }\n    range = Range.create(document.positionAt(startOffset), document.positionAt(endOffset));\n    // Do not modify if substring starts in inside an element\n    // Ending inside an element is fine as it doesn't cause formatting errors\n    var firstHalf = value.substring(0, startOffset);\n    if (new RegExp(/.*[<][^>]*$/).test(firstHalf)) {\n      //return without modification\n      value = value.substring(startOffset, endOffset);\n      return [{\n        range: range,\n        newText: value\n      }];\n    }\n    includesEnd = endOffset === value.length;\n    value = value.substring(startOffset, endOffset);\n    if (startOffset !== 0) {\n      var startOfLineOffset = document.offsetAt(Position.create(range.start.line, 0));\n      initialIndentLevel = computeIndentLevel(document.getText(), startOfLineOffset, options);\n    }\n  } else {\n    range = Range.create(Position.create(0, 0), document.positionAt(value.length));\n  }\n  var htmlOptions = {\n    indent_size: tabSize,\n    indent_char: options.insertSpaces ? ' ' : '\\t',\n    indent_empty_lines: getFormatOption(options, 'indentEmptyLines', false),\n    wrap_line_length: getFormatOption(options, 'wrapLineLength', 120),\n    unformatted: getTagsFormatOption(options, 'unformatted', void 0),\n    content_unformatted: getTagsFormatOption(options, 'contentUnformatted', void 0),\n    indent_inner_html: getFormatOption(options, 'indentInnerHtml', false),\n    preserve_newlines: getFormatOption(options, 'preserveNewLines', true),\n    max_preserve_newlines: getFormatOption(options, 'maxPreserveNewLines', 32786),\n    indent_handlebars: getFormatOption(options, 'indentHandlebars', false),\n    end_with_newline: includesEnd && getFormatOption(options, 'endWithNewline', false),\n    extra_liners: getTagsFormatOption(options, 'extraLiners', void 0),\n    wrap_attributes: getFormatOption(options, 'wrapAttributes', 'auto'),\n    wrap_attributes_indent_size: getFormatOption(options, 'wrapAttributesIndentSize', void 0),\n    eol: '\\n'\n  };\n  var result = html_beautify(trimLeft(value), htmlOptions);\n  if (initialIndentLevel > 0) {\n    var indent = options.insertSpaces ? repeat(' ', tabSize * initialIndentLevel) : repeat('\\t', initialIndentLevel);\n    result = result.split('\\n').join('\\n' + indent);\n    if (range.start.character === 0) {\n      result = indent + result; // keep the indent\n    }\n  }\n\n  return [{\n    range: range,\n    newText: result\n  }];\n}\nfunction trimLeft(str) {\n  return str.replace(/^\\s+/, '');\n}\nfunction getFormatOption(options, key, dflt) {\n  if (options && options.hasOwnProperty(key)) {\n    var value = options[key];\n    if (value !== null) {\n      return value;\n    }\n  }\n  return dflt;\n}\nfunction getTagsFormatOption(options, key, dflt) {\n  var list = getFormatOption(options, key, null);\n  if (typeof list === 'string') {\n    if (list.length > 0) {\n      return list.split(',').map(function (t) {\n        return t.trim().toLowerCase();\n      });\n    }\n    return [];\n  }\n  return dflt;\n}\nfunction computeIndentLevel(content, offset, options) {\n  var i = offset;\n  var nChars = 0;\n  var tabSize = options.tabSize || 4;\n  while (i < content.length) {\n    var ch = content.charAt(i);\n    if (ch === ' ') {\n      nChars++;\n    } else if (ch === '\\t') {\n      nChars += tabSize;\n    } else {\n      break;\n    }\n    i++;\n  }\n  return Math.floor(nChars / tabSize);\n}\nfunction getEOL(document) {\n  var text = document.getText();\n  if (document.lineCount > 1) {\n    var to = document.offsetAt(Position.create(1, 0));\n    var from = to;\n    while (from > 0 && isEOL(text, from - 1)) {\n      from--;\n    }\n    return text.substr(from, to - from);\n  }\n  return '\\n';\n}\nfunction isEOL(text, offset) {\n  return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\nfunction isWhitespace(text, offset) {\n  return ' \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"names":["Range","Position","html_beautify","repeat","format","document","range","options","value","getText","includesEnd","initialIndentLevel","tabSize","startOffset","offsetAt","start","extendedStart","isWhitespace","isEOL","endOffset","end","extendedEnd","length","create","positionAt","firstHalf","substring","RegExp","test","newText","startOfLineOffset","line","computeIndentLevel","htmlOptions","indent_size","indent_char","insertSpaces","indent_empty_lines","getFormatOption","wrap_line_length","unformatted","getTagsFormatOption","content_unformatted","indent_inner_html","preserve_newlines","max_preserve_newlines","indent_handlebars","end_with_newline","extra_liners","wrap_attributes","wrap_attributes_indent_size","eol","result","trimLeft","indent","split","join","character","str","replace","key","dflt","hasOwnProperty","list","map","t","trim","toLowerCase","content","offset","i","nChars","ch","charAt","Math","floor","getEOL","text","lineCount","to","from","substr","indexOf"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlFormatter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range, Position } from './../_deps/vscode-languageserver-types/main.js';\nimport { html_beautify } from '../beautify/beautify-html.js';\nimport { repeat } from '../utils/strings.js';\nexport function format(document, range, options) {\n    var value = document.getText();\n    var includesEnd = true;\n    var initialIndentLevel = 0;\n    var tabSize = options.tabSize || 4;\n    if (range) {\n        var startOffset = document.offsetAt(range.start);\n        // include all leading whitespace iff at the beginning of the line\n        var extendedStart = startOffset;\n        while (extendedStart > 0 && isWhitespace(value, extendedStart - 1)) {\n            extendedStart--;\n        }\n        if (extendedStart === 0 || isEOL(value, extendedStart - 1)) {\n            startOffset = extendedStart;\n        }\n        else {\n            // else keep at least one whitespace\n            if (extendedStart < startOffset) {\n                startOffset = extendedStart + 1;\n            }\n        }\n        // include all following whitespace until the end of the line\n        var endOffset = document.offsetAt(range.end);\n        var extendedEnd = endOffset;\n        while (extendedEnd < value.length && isWhitespace(value, extendedEnd)) {\n            extendedEnd++;\n        }\n        if (extendedEnd === value.length || isEOL(value, extendedEnd)) {\n            endOffset = extendedEnd;\n        }\n        range = Range.create(document.positionAt(startOffset), document.positionAt(endOffset));\n        // Do not modify if substring starts in inside an element\n        // Ending inside an element is fine as it doesn't cause formatting errors\n        var firstHalf = value.substring(0, startOffset);\n        if (new RegExp(/.*[<][^>]*$/).test(firstHalf)) {\n            //return without modification\n            value = value.substring(startOffset, endOffset);\n            return [{\n                    range: range,\n                    newText: value\n                }];\n        }\n        includesEnd = endOffset === value.length;\n        value = value.substring(startOffset, endOffset);\n        if (startOffset !== 0) {\n            var startOfLineOffset = document.offsetAt(Position.create(range.start.line, 0));\n            initialIndentLevel = computeIndentLevel(document.getText(), startOfLineOffset, options);\n        }\n    }\n    else {\n        range = Range.create(Position.create(0, 0), document.positionAt(value.length));\n    }\n    var htmlOptions = {\n        indent_size: tabSize,\n        indent_char: options.insertSpaces ? ' ' : '\\t',\n        indent_empty_lines: getFormatOption(options, 'indentEmptyLines', false),\n        wrap_line_length: getFormatOption(options, 'wrapLineLength', 120),\n        unformatted: getTagsFormatOption(options, 'unformatted', void 0),\n        content_unformatted: getTagsFormatOption(options, 'contentUnformatted', void 0),\n        indent_inner_html: getFormatOption(options, 'indentInnerHtml', false),\n        preserve_newlines: getFormatOption(options, 'preserveNewLines', true),\n        max_preserve_newlines: getFormatOption(options, 'maxPreserveNewLines', 32786),\n        indent_handlebars: getFormatOption(options, 'indentHandlebars', false),\n        end_with_newline: includesEnd && getFormatOption(options, 'endWithNewline', false),\n        extra_liners: getTagsFormatOption(options, 'extraLiners', void 0),\n        wrap_attributes: getFormatOption(options, 'wrapAttributes', 'auto'),\n        wrap_attributes_indent_size: getFormatOption(options, 'wrapAttributesIndentSize', void 0),\n        eol: '\\n'\n    };\n    var result = html_beautify(trimLeft(value), htmlOptions);\n    if (initialIndentLevel > 0) {\n        var indent = options.insertSpaces ? repeat(' ', tabSize * initialIndentLevel) : repeat('\\t', initialIndentLevel);\n        result = result.split('\\n').join('\\n' + indent);\n        if (range.start.character === 0) {\n            result = indent + result; // keep the indent\n        }\n    }\n    return [{\n            range: range,\n            newText: result\n        }];\n}\nfunction trimLeft(str) {\n    return str.replace(/^\\s+/, '');\n}\nfunction getFormatOption(options, key, dflt) {\n    if (options && options.hasOwnProperty(key)) {\n        var value = options[key];\n        if (value !== null) {\n            return value;\n        }\n    }\n    return dflt;\n}\nfunction getTagsFormatOption(options, key, dflt) {\n    var list = getFormatOption(options, key, null);\n    if (typeof list === 'string') {\n        if (list.length > 0) {\n            return list.split(',').map(function (t) { return t.trim().toLowerCase(); });\n        }\n        return [];\n    }\n    return dflt;\n}\nfunction computeIndentLevel(content, offset, options) {\n    var i = offset;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(document) {\n    var text = document.getText();\n    if (document.lineCount > 1) {\n        var to = document.offsetAt(Position.create(1, 0));\n        var from = to;\n        while (from > 0 && isEOL(text, from - 1)) {\n            from--;\n        }\n        return text.substr(from, to - from);\n    }\n    return '\\n';\n}\nfunction isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\nfunction isWhitespace(text, offset) {\n    return ' \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}