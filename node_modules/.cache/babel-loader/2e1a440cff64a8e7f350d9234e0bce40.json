{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LineBreakData } from '../../common/viewModel/splitLinesCollection.js';\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nvar DOMLineBreaksComputerFactory = /** @class */function () {\n  function DOMLineBreaksComputerFactory() {}\n  DOMLineBreaksComputerFactory.create = function () {\n    return new DOMLineBreaksComputerFactory();\n  };\n  DOMLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n    tabSize = tabSize | 0; //@perf\n    wrappingColumn = +wrappingColumn; //@perf\n    var requests = [];\n    return {\n      addRequest: function addRequest(lineText, previousLineBreakData) {\n        requests.push(lineText);\n      },\n      finalize: function finalize() {\n        return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\n      }\n    };\n  };\n  return DOMLineBreaksComputerFactory;\n}();\nexport { DOMLineBreaksComputerFactory };\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\n  if (firstLineBreakColumn === -1) {\n    var result_1 = [];\n    for (var i = 0, len = requests.length; i < len; i++) {\n      result_1[i] = null;\n    }\n    return result_1;\n  }\n  var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n  // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\n  // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\n  if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\n    wrappingIndent = 1 /* Same */;\n  }\n\n  var containerDomNode = document.createElement('div');\n  Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n  var sb = createStringBuilder(10000);\n  var firstNonWhitespaceIndices = [];\n  var wrappedTextIndentLengths = [];\n  var renderLineContents = [];\n  var allCharOffsets = [];\n  var allVisibleColumns = [];\n  for (var i = 0; i < requests.length; i++) {\n    var lineContent = requests[i];\n    var firstNonWhitespaceIndex = 0;\n    var wrappedTextIndentLength = 0;\n    var width = overallWidth;\n    if (wrappingIndent !== 0 /* None */) {\n      firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n      if (firstNonWhitespaceIndex === -1) {\n        // all whitespace line\n        firstNonWhitespaceIndex = 0;\n      } else {\n        // Track existing indent\n        for (var i_1 = 0; i_1 < firstNonWhitespaceIndex; i_1++) {\n          var charWidth = lineContent.charCodeAt(i_1) === 9 /* Tab */ ? tabSize - wrappedTextIndentLength % tabSize : 1;\n          wrappedTextIndentLength += charWidth;\n        }\n        var indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n        // Force sticking to beginning of line if no character would fit except for the indentation\n        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n          firstNonWhitespaceIndex = 0;\n          wrappedTextIndentLength = 0;\n        } else {\n          width = overallWidth - indentWidth;\n        }\n      }\n    }\n    var renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    var tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\n    firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n    renderLineContents[i] = renderLineContent;\n    allCharOffsets[i] = tmp[0];\n    allVisibleColumns[i] = tmp[1];\n  }\n  containerDomNode.innerHTML = sb.build();\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  containerDomNode.style.wordWrap = 'break-word';\n  document.body.appendChild(containerDomNode);\n  var range = document.createRange();\n  var lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  var result = [];\n  for (var i = 0; i < requests.length; i++) {\n    var lineDomNode = lineDomNodes[i];\n    var breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n    if (breakOffsets === null) {\n      result[i] = null;\n      continue;\n    }\n    var firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n    var wrappedTextIndentLength = wrappedTextIndentLengths[i];\n    var visibleColumns = allVisibleColumns[i];\n    var breakOffsetsVisibleColumn = [];\n    for (var j = 0, len = breakOffsets.length; j < len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n    if (firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (var j = 0, len = breakOffsets.length; j < len; j++) {\n        breakOffsets[j] += firstNonWhitespaceIndex;\n      }\n    }\n    result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n  }\n  document.body.removeChild(containerDomNode);\n  return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\n  sb.appendASCIIString('<div style=\"width:');\n  sb.appendASCIIString(String(width));\n  sb.appendASCIIString('px;\">');\n  // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n  var len = lineContent.length;\n  var visibleColumn = initialVisibleColumn;\n  var charOffset = 0;\n  var charOffsets = [];\n  var visibleColumns = [];\n  var nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0 /* Null */;\n  for (var charIndex = 0; charIndex < len; charIndex++) {\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    var charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */;\n    var producedCharacters = 1;\n    var charWidth = 1;\n    switch (charCode) {\n      case 9 /* Tab */:\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n        for (var space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n            sb.appendASCII(32 /* Space */);\n          }\n        }\n\n        break;\n      case 32 /* Space */:\n        if (nextCharCode === 32 /* Space */) {\n          sb.write1(0xA0); // &nbsp;\n        } else {\n          sb.appendASCII(32 /* Space */);\n        }\n\n        break;\n      case 60 /* LessThan */:\n        sb.appendASCIIString('&lt;');\n        break;\n      case 62 /* GreaterThan */:\n        sb.appendASCIIString('&gt;');\n        break;\n      case 38 /* Ampersand */:\n        sb.appendASCIIString('&amp;');\n        break;\n      case 0 /* Null */:\n        sb.appendASCIIString('&#00;');\n        break;\n      case 65279 /* UTF8_BOM */:\n      case 8232 /* LINE_SEPARATOR_2028 */:\n        sb.write1(0xFFFD);\n        break;\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        }\n        // if (renderControlCharacters && charCode < 32) {\n        // \tsb.write1(9216 + charCode);\n        // } else {\n        sb.write1(charCode);\n      // }\n    }\n\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendASCIIString('</div>');\n  return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n  var textContentNode = lineDomNode.firstChild;\n  var breakOffsets = [];\n  discoverBreaks(range, textContentNode, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\nfunction discoverBreaks(range, textContentNode, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n  lowRects = lowRects || readClientRect(range, textContentNode, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, textContentNode, charOffsets[high], charOffsets[high + 1]);\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  }\n  // there is at least one line break between these two offsets\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n  var mid = low + (high - low) / 2 | 0;\n  var midRects = readClientRect(range, textContentNode, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, textContentNode, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, textContentNode, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, textContentNode, startOffset, endOffset) {\n  range.setStart(textContentNode, startOffset);\n  range.setEnd(textContentNode, endOffset);\n  return range.getClientRects();\n}","map":{"version":3,"names":["LineBreakData","createStringBuilder","strings","Configuration","DOMLineBreaksComputerFactory","create","prototype","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","addRequest","lineText","previousLineBreakData","push","finalize","createLineBreaks","firstLineBreakColumn","result_1","i","len","length","overallWidth","Math","round","typicalHalfwidthCharacterWidth","containerDomNode","document","createElement","applyFontInfoSlow","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","i_1","charWidth","charCodeAt","indentWidth","ceil","spaceWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","innerHTML","build","style","position","top","wordWrap","body","appendChild","range","createRange","lineDomNodes","Array","slice","call","children","result","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","removeChild","initialVisibleColumn","appendASCIIString","String","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","write1","appendASCII","isFullWidthCharacter","textContentNode","firstChild","discoverBreaks","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","setEnd","getClientRects"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LineBreakData } from '../../common/viewModel/splitLinesCollection.js';\r\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Configuration } from '../config/configuration.js';\r\nvar DOMLineBreaksComputerFactory = /** @class */ (function () {\r\n    function DOMLineBreaksComputerFactory() {\r\n    }\r\n    DOMLineBreaksComputerFactory.create = function () {\r\n        return new DOMLineBreaksComputerFactory();\r\n    };\r\n    DOMLineBreaksComputerFactory.prototype.createLineBreaksComputer = function (fontInfo, tabSize, wrappingColumn, wrappingIndent) {\r\n        tabSize = tabSize | 0; //@perf\r\n        wrappingColumn = +wrappingColumn; //@perf\r\n        var requests = [];\r\n        return {\r\n            addRequest: function (lineText, previousLineBreakData) {\r\n                requests.push(lineText);\r\n            },\r\n            finalize: function () {\r\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\r\n            }\r\n        };\r\n    };\r\n    return DOMLineBreaksComputerFactory;\r\n}());\r\nexport { DOMLineBreaksComputerFactory };\r\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\r\n    if (firstLineBreakColumn === -1) {\r\n        var result_1 = [];\r\n        for (var i = 0, len = requests.length; i < len; i++) {\r\n            result_1[i] = null;\r\n        }\r\n        return result_1;\r\n    }\r\n    var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\r\n    // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\r\n    // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\r\n    if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\r\n        wrappingIndent = 1 /* Same */;\r\n    }\r\n    var containerDomNode = document.createElement('div');\r\n    Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\r\n    var sb = createStringBuilder(10000);\r\n    var firstNonWhitespaceIndices = [];\r\n    var wrappedTextIndentLengths = [];\r\n    var renderLineContents = [];\r\n    var allCharOffsets = [];\r\n    var allVisibleColumns = [];\r\n    for (var i = 0; i < requests.length; i++) {\r\n        var lineContent = requests[i];\r\n        var firstNonWhitespaceIndex = 0;\r\n        var wrappedTextIndentLength = 0;\r\n        var width = overallWidth;\r\n        if (wrappingIndent !== 0 /* None */) {\r\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (firstNonWhitespaceIndex === -1) {\r\n                // all whitespace line\r\n                firstNonWhitespaceIndex = 0;\r\n            }\r\n            else {\r\n                // Track existing indent\r\n                for (var i_1 = 0; i_1 < firstNonWhitespaceIndex; i_1++) {\r\n                    var charWidth = (lineContent.charCodeAt(i_1) === 9 /* Tab */\r\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\r\n                        : 1);\r\n                    wrappedTextIndentLength += charWidth;\r\n                }\r\n                var indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\r\n                // Force sticking to beginning of line if no character would fit except for the indentation\r\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\r\n                    firstNonWhitespaceIndex = 0;\r\n                    wrappedTextIndentLength = 0;\r\n                }\r\n                else {\r\n                    width = overallWidth - indentWidth;\r\n                }\r\n            }\r\n        }\r\n        var renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\r\n        var tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\r\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\r\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\r\n        renderLineContents[i] = renderLineContent;\r\n        allCharOffsets[i] = tmp[0];\r\n        allVisibleColumns[i] = tmp[1];\r\n    }\r\n    containerDomNode.innerHTML = sb.build();\r\n    containerDomNode.style.position = 'absolute';\r\n    containerDomNode.style.top = '10000';\r\n    containerDomNode.style.wordWrap = 'break-word';\r\n    document.body.appendChild(containerDomNode);\r\n    var range = document.createRange();\r\n    var lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\r\n    var result = [];\r\n    for (var i = 0; i < requests.length; i++) {\r\n        var lineDomNode = lineDomNodes[i];\r\n        var breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\r\n        if (breakOffsets === null) {\r\n            result[i] = null;\r\n            continue;\r\n        }\r\n        var firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\r\n        var wrappedTextIndentLength = wrappedTextIndentLengths[i];\r\n        var visibleColumns = allVisibleColumns[i];\r\n        var breakOffsetsVisibleColumn = [];\r\n        for (var j = 0, len = breakOffsets.length; j < len; j++) {\r\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\r\n        }\r\n        if (firstNonWhitespaceIndex !== 0) {\r\n            // All break offsets are relative to the renderLineContent, make them absolute again\r\n            for (var j = 0, len = breakOffsets.length; j < len; j++) {\r\n                breakOffsets[j] += firstNonWhitespaceIndex;\r\n            }\r\n        }\r\n        result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\r\n    }\r\n    document.body.removeChild(containerDomNode);\r\n    return result;\r\n}\r\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\r\n    sb.appendASCIIString('<div style=\"width:');\r\n    sb.appendASCIIString(String(width));\r\n    sb.appendASCIIString('px;\">');\r\n    // if (containsRTL) {\r\n    // \tsb.appendASCIIString('\" dir=\"ltr');\r\n    // }\r\n    var len = lineContent.length;\r\n    var visibleColumn = initialVisibleColumn;\r\n    var charOffset = 0;\r\n    var charOffsets = [];\r\n    var visibleColumns = [];\r\n    var nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\r\n    for (var charIndex = 0; charIndex < len; charIndex++) {\r\n        charOffsets[charIndex] = charOffset;\r\n        visibleColumns[charIndex] = visibleColumn;\r\n        var charCode = nextCharCode;\r\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n        var producedCharacters = 1;\r\n        var charWidth = 1;\r\n        switch (charCode) {\r\n            case 9 /* Tab */:\r\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                charWidth = producedCharacters;\r\n                for (var space = 1; space <= producedCharacters; space++) {\r\n                    if (space < producedCharacters) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                    else {\r\n                        sb.appendASCII(32 /* Space */);\r\n                    }\r\n                }\r\n                break;\r\n            case 32 /* Space */:\r\n                if (nextCharCode === 32 /* Space */) {\r\n                    sb.write1(0xA0); // &nbsp;\r\n                }\r\n                else {\r\n                    sb.appendASCII(32 /* Space */);\r\n                }\r\n                break;\r\n            case 60 /* LessThan */:\r\n                sb.appendASCIIString('&lt;');\r\n                break;\r\n            case 62 /* GreaterThan */:\r\n                sb.appendASCIIString('&gt;');\r\n                break;\r\n            case 38 /* Ampersand */:\r\n                sb.appendASCIIString('&amp;');\r\n                break;\r\n            case 0 /* Null */:\r\n                sb.appendASCIIString('&#00;');\r\n                break;\r\n            case 65279 /* UTF8_BOM */:\r\n            case 8232 /* LINE_SEPARATOR_2028 */:\r\n                sb.write1(0xFFFD);\r\n                break;\r\n            default:\r\n                if (strings.isFullWidthCharacter(charCode)) {\r\n                    charWidth++;\r\n                }\r\n                // if (renderControlCharacters && charCode < 32) {\r\n                // \tsb.write1(9216 + charCode);\r\n                // } else {\r\n                sb.write1(charCode);\r\n            // }\r\n        }\r\n        charOffset += producedCharacters;\r\n        visibleColumn += charWidth;\r\n    }\r\n    charOffsets[lineContent.length] = charOffset;\r\n    visibleColumns[lineContent.length] = visibleColumn;\r\n    sb.appendASCIIString('</div>');\r\n    return [charOffsets, visibleColumns];\r\n}\r\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\r\n    if (lineContent.length <= 1) {\r\n        return null;\r\n    }\r\n    var textContentNode = lineDomNode.firstChild;\r\n    var breakOffsets = [];\r\n    discoverBreaks(range, textContentNode, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\r\n    if (breakOffsets.length === 0) {\r\n        return null;\r\n    }\r\n    breakOffsets.push(lineContent.length);\r\n    return breakOffsets;\r\n}\r\nfunction discoverBreaks(range, textContentNode, charOffsets, low, lowRects, high, highRects, result) {\r\n    if (low === high) {\r\n        return;\r\n    }\r\n    lowRects = lowRects || readClientRect(range, textContentNode, charOffsets[low], charOffsets[low + 1]);\r\n    highRects = highRects || readClientRect(range, textContentNode, charOffsets[high], charOffsets[high + 1]);\r\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\r\n        // same line\r\n        return;\r\n    }\r\n    // there is at least one line break between these two offsets\r\n    if (low + 1 === high) {\r\n        // the two characters are adjacent, so the line break must be exactly between them\r\n        result.push(high);\r\n        return;\r\n    }\r\n    var mid = low + ((high - low) / 2) | 0;\r\n    var midRects = readClientRect(range, textContentNode, charOffsets[mid], charOffsets[mid + 1]);\r\n    discoverBreaks(range, textContentNode, charOffsets, low, lowRects, mid, midRects, result);\r\n    discoverBreaks(range, textContentNode, charOffsets, mid, midRects, high, highRects, result);\r\n}\r\nfunction readClientRect(range, textContentNode, startOffset, endOffset) {\r\n    range.setStart(textContentNode, startOffset);\r\n    range.setEnd(textContentNode, endOffset);\r\n    return range.getClientRects();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}