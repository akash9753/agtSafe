{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\nimport * as strings from './strings.js';\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { LRUCache } from './map.js';\nimport { isThenable } from './async.js';\nvar GLOBSTAR = '**';\nvar GLOB_SPLIT = '/';\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nvar ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n    case 1:\n      return NO_PATH_REGEX + \"*?\";\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return \"(?:\" + PATH_REGEX + \"|\" + NO_PATH_REGEX + \"+\" + PATH_REGEX + \"|\" + PATH_REGEX + NO_PATH_REGEX + \"+)*?\";\n  }\n}\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n  var segments = [];\n  var inBraces = false;\n  var inBrackets = false;\n  var curVal = '';\n  for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n    var char = pattern_1[_i];\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n        break;\n      case '{':\n        inBraces = true;\n        break;\n      case '}':\n        inBraces = false;\n        break;\n      case '[':\n        inBrackets = true;\n        break;\n      case ']':\n        inBrackets = false;\n        break;\n    }\n    curVal += char;\n  }\n  // Tail\n  if (curVal) {\n    segments.push(curVal);\n  }\n  return segments;\n}\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n  var regEx = '';\n  // Split up into segments for each slash found\n  var segments = splitGlobAware(pattern, GLOB_SPLIT);\n  // Special case where we only have globstars\n  if (segments.every(function (s) {\n    return s === GLOBSTAR;\n  })) {\n    regEx = '.*';\n  }\n  // Build regex over segments\n  else {\n    var previousSegmentWasGlobStar_1 = false;\n    segments.forEach(function (segment, index) {\n      // Globstar is special\n      if (segment === GLOBSTAR) {\n        // if we have more than one globstar after another, just ignore it\n        if (!previousSegmentWasGlobStar_1) {\n          regEx += starsToRegExp(2);\n          previousSegmentWasGlobStar_1 = true;\n        }\n        return;\n      }\n      // States\n      var inBraces = false;\n      var braceVal = '';\n      var inBrackets = false;\n      var bracketVal = '';\n      for (var _i = 0, segment_1 = segment; _i < segment_1.length; _i++) {\n        var char = segment_1[_i];\n        // Support brace expansion\n        if (char !== '}' && inBraces) {\n          braceVal += char;\n          continue;\n        }\n        // Support brackets\n        if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n          var res = void 0;\n          // range operator\n          if (char === '-') {\n            res = char;\n          }\n          // negation operator (only valid on first index in bracket)\n          else if ((char === '^' || char === '!') && !bracketVal) {\n            res = '^';\n          }\n          // glob split matching is not allowed within character ranges\n          // see http://man7.org/linux/man-pages/man7/glob.7.html\n          else if (char === GLOB_SPLIT) {\n            res = '';\n          }\n          // anything else gets escaped\n          else {\n            res = strings.escapeRegExpCharacters(char);\n          }\n          bracketVal += res;\n          continue;\n        }\n        switch (char) {\n          case '{':\n            inBraces = true;\n            continue;\n          case '[':\n            inBrackets = true;\n            continue;\n          case '}':\n            var choices = splitGlobAware(braceVal, ',');\n            // Converts {foo,bar} => [foo|bar]\n            var braceRegExp = \"(?:\" + choices.map(function (c) {\n              return parseRegExp(c);\n            }).join('|') + \")\";\n            regEx += braceRegExp;\n            inBraces = false;\n            braceVal = '';\n            break;\n          case ']':\n            regEx += '[' + bracketVal + ']';\n            inBrackets = false;\n            bracketVal = '';\n            break;\n          case '?':\n            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n            continue;\n          case '*':\n            regEx += starsToRegExp(1);\n            continue;\n          default:\n            regEx += strings.escapeRegExpCharacters(char);\n        }\n      }\n      // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n      // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n      // a folder called \"something\" to match as well.\n      // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n      // is to match 0-N segments.\n      if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n        regEx += PATH_REGEX;\n      }\n      // reset state\n      previousSegmentWasGlobStar_1 = false;\n    });\n  }\n  return regEx;\n}\n// regexes to check for trival glob patterns that just check for String#endsWith\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\nvar FALSE = function FALSE() {\n  return false;\n};\nvar NULL = function NULL() {\n  return null;\n};\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  }\n  // Handle IRelativePattern\n  var pattern;\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  }\n  // Whitespace trimming\n  pattern = pattern.trim();\n  // Check cache\n  var patternKey = pattern + \"_\" + !!options.trimForExclusions;\n  var parsedPattern = CACHE.get(patternKey);\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  }\n  // Check for Trivias\n  var match;\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    var base_1 = pattern.substr(4); // '**/*'.length === 4\n    parsedPattern = function parsedPattern(path, basename) {\n      return typeof path === 'string' && strings.endsWith(path, base_1) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  }\n  // Otherwise convert to pattern\n  else {\n    parsedPattern = toRegExp(pattern);\n  }\n  // Cache\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n  return function (path, basename) {\n    if (!extpath.isEqualOrParent(path, arg2.base)) {\n      return null;\n    }\n    return parsedPattern(paths.relative(arg2.base, path), basename);\n  };\n}\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, originalPattern) {\n  var slashBase = \"/\" + base;\n  var backslashBase = \"\\\\\" + base;\n  var parsedPattern = function parsedPattern(path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n    return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\n  };\n  var basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n  var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(function (pattern) {\n    return parsePattern(pattern, options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }), pattern);\n  var n = parsedPatterns.length;\n  if (!n) {\n    return NULL;\n  }\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n  var parsedPattern = function parsedPattern(path, basename) {\n    for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n    return null;\n  };\n  var withBasenames = arrays.first(parsedPatterns, function (pattern) {\n    return !!pattern.allBasenames;\n  });\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n  return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(path, pattern, matchPathEnds) {\n  var nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\n  var nativePathEnd = paths.sep + nativePath;\n  var parsedPattern = matchPathEnds ? function (path, basename) {\n    return typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\n  } : function (path, basename) {\n    return typeof path === 'string' && path === nativePath ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\n  return parsedPattern;\n}\nfunction toRegExp(pattern) {\n  try {\n    var regExp_1 = new RegExp(\"^\" + parseRegExp(pattern) + \"$\");\n    return function (path, basename) {\n      regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n      return typeof path === 'string' && regExp_1.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!arg1) {\n    return FALSE;\n  }\n  // Glob with String\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    var parsedPattern_1 = parsePattern(arg1, options);\n    if (parsedPattern_1 === NULL) {\n      return FALSE;\n    }\n    var resultPattern = function resultPattern(path, basename) {\n      return !!parsedPattern_1(path, basename);\n    };\n    if (parsedPattern_1.allBasenames) {\n      resultPattern.allBasenames = parsedPattern_1.allBasenames;\n    }\n    if (parsedPattern_1.allPaths) {\n      resultPattern.allPaths = parsedPattern_1.allPaths;\n    }\n    return resultPattern;\n  }\n  // Glob with Expression\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  var rp = obj;\n  return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n  var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(function (pattern) {\n    return parseExpressionPattern(pattern, expression[pattern], options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }));\n  var n = parsedPatterns.length;\n  if (!n) {\n    return NULL;\n  }\n  if (!parsedPatterns.some(function (parsedPattern) {\n    return !!parsedPattern.requiresSiblings;\n  })) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n    var resultExpression_1 = function resultExpression_1(path, basename) {\n      for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {\n        // Pattern matches path\n        var result = parsedPatterns[i](path, basename);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    };\n    var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) {\n      return !!pattern.allBasenames;\n    });\n    if (withBasenames_1) {\n      resultExpression_1.allBasenames = withBasenames_1.allBasenames;\n    }\n    var allPaths_1 = parsedPatterns.reduce(function (all, current) {\n      return current.allPaths ? all.concat(current.allPaths) : all;\n    }, []);\n    if (allPaths_1.length) {\n      resultExpression_1.allPaths = allPaths_1;\n    }\n    return resultExpression_1;\n  }\n  var resultExpression = function resultExpression(path, basename, hasSibling) {\n    var name = undefined;\n    for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {\n      // Pattern matches path\n      var parsedPattern = parsedPatterns[i];\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!basename) {\n          basename = paths.basename(path);\n        }\n        if (!name) {\n          name = basename.substr(0, basename.length - paths.extname(path).length);\n        }\n      }\n      var result = parsedPattern(path, basename, name, hasSibling);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  };\n  var withBasenames = arrays.first(parsedPatterns, function (pattern) {\n    return !!pattern.allBasenames;\n  });\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n  return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  var parsedPattern = parsePattern(pattern, options);\n  if (parsedPattern === NULL) {\n    return NULL;\n  }\n  // Expression Pattern is <boolean>\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  }\n  // Expression Pattern is <SiblingClause>\n  if (value) {\n    var when_1 = value.when;\n    if (typeof when_1 === 'string') {\n      var result = function result(path, basename, name, hasSibling) {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n        var clausePattern = when_1.replace('$(basename)', name);\n        var matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(function (m) {\n          return m ? pattern : null;\n        }) : matched ? pattern : null;\n      };\n      result.requiresSiblings = true;\n      return result;\n    }\n  }\n  // Expression is Anything\n  return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  var basenamePatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !!parsedPattern.basenames;\n  });\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n  var basenames = basenamePatterns.reduce(function (all, current) {\n    var basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  var patterns;\n  if (result) {\n    patterns = [];\n    for (var i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce(function (all, current) {\n      var patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n  var aggregate = function aggregate(path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (!basename) {\n      var i = void 0;\n      for (i = path.length; i > 0; i--) {\n        var ch = path.charCodeAt(i - 1);\n        if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\n          break;\n        }\n      }\n      basename = path.substr(i);\n    }\n    var index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !parsedPattern.basenames;\n  });\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":{"version":3,"names":["arrays","strings","extpath","paths","LRUCache","isThenable","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","_i","pattern_1","length","char","push","parseRegExp","regEx","every","s","previousSegmentWasGlobStar_1","forEach","segment","index","braceVal","bracketVal","segment_1","res","escapeRegExpCharacters","choices","braceRegExp","map","c","join","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","base_1","substr","path","basename","endsWith","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","isEqualOrParent","base","relative","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","slice","split","filter","n","i","n_1","withBasenames","first","allPaths","reduce","all","current","concat","matchPathEnds","nativePath","sep","posix","replace","nativePathEnd","regExp_1","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","parsedPattern_1","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression_1","n_2","result","withBasenames_1","allPaths_1","resultExpression","name","n_3","extname","value","when_1","when","clausePattern","matched","then","m","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from './arrays.js';\r\nimport * as strings from './strings.js';\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { LRUCache } from './map.js';\r\nimport { isThenable } from './async.js';\r\nvar GLOBSTAR = '**';\r\nvar GLOB_SPLIT = '/';\r\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\r\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\r\nvar ALL_FORWARD_SLASHES = /\\//g;\r\nfunction starsToRegExp(starCount) {\r\n    switch (starCount) {\r\n        case 0:\r\n            return '';\r\n        case 1:\r\n            return NO_PATH_REGEX + \"*?\"; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\r\n        default:\r\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\r\n            // Group is non capturing because we don't need to capture at all (?:...)\r\n            // Overall we use non-greedy matching because it could be that we match too much\r\n            return \"(?:\" + PATH_REGEX + \"|\" + NO_PATH_REGEX + \"+\" + PATH_REGEX + \"|\" + PATH_REGEX + NO_PATH_REGEX + \"+)*?\";\r\n    }\r\n}\r\nexport function splitGlobAware(pattern, splitChar) {\r\n    if (!pattern) {\r\n        return [];\r\n    }\r\n    var segments = [];\r\n    var inBraces = false;\r\n    var inBrackets = false;\r\n    var curVal = '';\r\n    for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\r\n        var char = pattern_1[_i];\r\n        switch (char) {\r\n            case splitChar:\r\n                if (!inBraces && !inBrackets) {\r\n                    segments.push(curVal);\r\n                    curVal = '';\r\n                    continue;\r\n                }\r\n                break;\r\n            case '{':\r\n                inBraces = true;\r\n                break;\r\n            case '}':\r\n                inBraces = false;\r\n                break;\r\n            case '[':\r\n                inBrackets = true;\r\n                break;\r\n            case ']':\r\n                inBrackets = false;\r\n                break;\r\n        }\r\n        curVal += char;\r\n    }\r\n    // Tail\r\n    if (curVal) {\r\n        segments.push(curVal);\r\n    }\r\n    return segments;\r\n}\r\nfunction parseRegExp(pattern) {\r\n    if (!pattern) {\r\n        return '';\r\n    }\r\n    var regEx = '';\r\n    // Split up into segments for each slash found\r\n    var segments = splitGlobAware(pattern, GLOB_SPLIT);\r\n    // Special case where we only have globstars\r\n    if (segments.every(function (s) { return s === GLOBSTAR; })) {\r\n        regEx = '.*';\r\n    }\r\n    // Build regex over segments\r\n    else {\r\n        var previousSegmentWasGlobStar_1 = false;\r\n        segments.forEach(function (segment, index) {\r\n            // Globstar is special\r\n            if (segment === GLOBSTAR) {\r\n                // if we have more than one globstar after another, just ignore it\r\n                if (!previousSegmentWasGlobStar_1) {\r\n                    regEx += starsToRegExp(2);\r\n                    previousSegmentWasGlobStar_1 = true;\r\n                }\r\n                return;\r\n            }\r\n            // States\r\n            var inBraces = false;\r\n            var braceVal = '';\r\n            var inBrackets = false;\r\n            var bracketVal = '';\r\n            for (var _i = 0, segment_1 = segment; _i < segment_1.length; _i++) {\r\n                var char = segment_1[_i];\r\n                // Support brace expansion\r\n                if (char !== '}' && inBraces) {\r\n                    braceVal += char;\r\n                    continue;\r\n                }\r\n                // Support brackets\r\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\r\n                    var res = void 0;\r\n                    // range operator\r\n                    if (char === '-') {\r\n                        res = char;\r\n                    }\r\n                    // negation operator (only valid on first index in bracket)\r\n                    else if ((char === '^' || char === '!') && !bracketVal) {\r\n                        res = '^';\r\n                    }\r\n                    // glob split matching is not allowed within character ranges\r\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\r\n                    else if (char === GLOB_SPLIT) {\r\n                        res = '';\r\n                    }\r\n                    // anything else gets escaped\r\n                    else {\r\n                        res = strings.escapeRegExpCharacters(char);\r\n                    }\r\n                    bracketVal += res;\r\n                    continue;\r\n                }\r\n                switch (char) {\r\n                    case '{':\r\n                        inBraces = true;\r\n                        continue;\r\n                    case '[':\r\n                        inBrackets = true;\r\n                        continue;\r\n                    case '}':\r\n                        var choices = splitGlobAware(braceVal, ',');\r\n                        // Converts {foo,bar} => [foo|bar]\r\n                        var braceRegExp = \"(?:\" + choices.map(function (c) { return parseRegExp(c); }).join('|') + \")\";\r\n                        regEx += braceRegExp;\r\n                        inBraces = false;\r\n                        braceVal = '';\r\n                        break;\r\n                    case ']':\r\n                        regEx += ('[' + bracketVal + ']');\r\n                        inBrackets = false;\r\n                        bracketVal = '';\r\n                        break;\r\n                    case '?':\r\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\r\n                        continue;\r\n                    case '*':\r\n                        regEx += starsToRegExp(1);\r\n                        continue;\r\n                    default:\r\n                        regEx += strings.escapeRegExpCharacters(char);\r\n                }\r\n            }\r\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\r\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\r\n            // a folder called \"something\" to match as well.\r\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\r\n            // is to match 0-N segments.\r\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\r\n                regEx += PATH_REGEX;\r\n            }\r\n            // reset state\r\n            previousSegmentWasGlobStar_1 = false;\r\n        });\r\n    }\r\n    return regEx;\r\n}\r\n// regexes to check for trival glob patterns that just check for String#endsWith\r\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\r\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\r\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\r\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\r\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\r\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\r\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\r\nvar FALSE = function () {\r\n    return false;\r\n};\r\nvar NULL = function () {\r\n    return null;\r\n};\r\nfunction parsePattern(arg1, options) {\r\n    if (!arg1) {\r\n        return NULL;\r\n    }\r\n    // Handle IRelativePattern\r\n    var pattern;\r\n    if (typeof arg1 !== 'string') {\r\n        pattern = arg1.pattern;\r\n    }\r\n    else {\r\n        pattern = arg1;\r\n    }\r\n    // Whitespace trimming\r\n    pattern = pattern.trim();\r\n    // Check cache\r\n    var patternKey = pattern + \"_\" + !!options.trimForExclusions;\r\n    var parsedPattern = CACHE.get(patternKey);\r\n    if (parsedPattern) {\r\n        return wrapRelativePattern(parsedPattern, arg1);\r\n    }\r\n    // Check for Trivias\r\n    var match;\r\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\r\n        var base_1 = pattern.substr(4); // '**/*'.length === 4\r\n        parsedPattern = function (path, basename) {\r\n            return typeof path === 'string' && strings.endsWith(path, base_1) ? pattern : null;\r\n        };\r\n    }\r\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\r\n        parsedPattern = trivia2(match[1], pattern);\r\n    }\r\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\r\n        parsedPattern = trivia3(pattern, options);\r\n    }\r\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\r\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\r\n    }\r\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\r\n        parsedPattern = trivia4and5(match[1], pattern, false);\r\n    }\r\n    // Otherwise convert to pattern\r\n    else {\r\n        parsedPattern = toRegExp(pattern);\r\n    }\r\n    // Cache\r\n    CACHE.set(patternKey, parsedPattern);\r\n    return wrapRelativePattern(parsedPattern, arg1);\r\n}\r\nfunction wrapRelativePattern(parsedPattern, arg2) {\r\n    if (typeof arg2 === 'string') {\r\n        return parsedPattern;\r\n    }\r\n    return function (path, basename) {\r\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\r\n            return null;\r\n        }\r\n        return parsedPattern(paths.relative(arg2.base, path), basename);\r\n    };\r\n}\r\nfunction trimForExclusions(pattern, options) {\r\n    return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\r\n}\r\n// common pattern: **/some.txt just need basename check\r\nfunction trivia2(base, originalPattern) {\r\n    var slashBase = \"/\" + base;\r\n    var backslashBase = \"\\\\\" + base;\r\n    var parsedPattern = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (basename) {\r\n            return basename === base ? originalPattern : null;\r\n        }\r\n        return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;\r\n    };\r\n    var basenames = [base];\r\n    parsedPattern.basenames = basenames;\r\n    parsedPattern.patterns = [originalPattern];\r\n    parsedPattern.allBasenames = basenames;\r\n    return parsedPattern;\r\n}\r\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\r\nfunction trivia3(pattern, options) {\r\n    var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\r\n        .map(function (pattern) { return parsePattern(pattern, options); })\r\n        .filter(function (pattern) { return pattern !== NULL; }), pattern);\r\n    var n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (n === 1) {\r\n        return parsedPatterns[0];\r\n    }\r\n    var parsedPattern = function (path, basename) {\r\n        for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {\r\n            if (parsedPatterns[i](path, basename)) {\r\n                return pattern;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\r\n    if (withBasenames) {\r\n        parsedPattern.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\r\n    if (allPaths.length) {\r\n        parsedPattern.allPaths = allPaths;\r\n    }\r\n    return parsedPattern;\r\n}\r\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\r\nfunction trivia4and5(path, pattern, matchPathEnds) {\r\n    var nativePath = paths.sep !== paths.posix.sep ? path.replace(ALL_FORWARD_SLASHES, paths.sep) : path;\r\n    var nativePathEnd = paths.sep + nativePath;\r\n    var parsedPattern = matchPathEnds ? function (path, basename) {\r\n        return typeof path === 'string' && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;\r\n    } : function (path, basename) {\r\n        return typeof path === 'string' && path === nativePath ? pattern : null;\r\n    };\r\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];\r\n    return parsedPattern;\r\n}\r\nfunction toRegExp(pattern) {\r\n    try {\r\n        var regExp_1 = new RegExp(\"^\" + parseRegExp(pattern) + \"$\");\r\n        return function (path, basename) {\r\n            regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!\r\n            return typeof path === 'string' && regExp_1.test(path) ? pattern : null;\r\n        };\r\n    }\r\n    catch (error) {\r\n        return NULL;\r\n    }\r\n}\r\nexport function match(arg1, path, hasSibling) {\r\n    if (!arg1 || typeof path !== 'string') {\r\n        return false;\r\n    }\r\n    return parse(arg1)(path, undefined, hasSibling);\r\n}\r\nexport function parse(arg1, options) {\r\n    if (options === void 0) { options = {}; }\r\n    if (!arg1) {\r\n        return FALSE;\r\n    }\r\n    // Glob with String\r\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\r\n        var parsedPattern_1 = parsePattern(arg1, options);\r\n        if (parsedPattern_1 === NULL) {\r\n            return FALSE;\r\n        }\r\n        var resultPattern = function (path, basename) {\r\n            return !!parsedPattern_1(path, basename);\r\n        };\r\n        if (parsedPattern_1.allBasenames) {\r\n            resultPattern.allBasenames = parsedPattern_1.allBasenames;\r\n        }\r\n        if (parsedPattern_1.allPaths) {\r\n            resultPattern.allPaths = parsedPattern_1.allPaths;\r\n        }\r\n        return resultPattern;\r\n    }\r\n    // Glob with Expression\r\n    return parsedExpression(arg1, options);\r\n}\r\nexport function isRelativePattern(obj) {\r\n    var rp = obj;\r\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\r\n}\r\nfunction parsedExpression(expression, options) {\r\n    var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\r\n        .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })\r\n        .filter(function (pattern) { return pattern !== NULL; }));\r\n    var n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (!parsedPatterns.some(function (parsedPattern) { return !!parsedPattern.requiresSiblings; })) {\r\n        if (n === 1) {\r\n            return parsedPatterns[0];\r\n        }\r\n        var resultExpression_1 = function (path, basename) {\r\n            for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {\r\n                // Pattern matches path\r\n                var result = parsedPatterns[i](path, basename);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\r\n        if (withBasenames_1) {\r\n            resultExpression_1.allBasenames = withBasenames_1.allBasenames;\r\n        }\r\n        var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\r\n        if (allPaths_1.length) {\r\n            resultExpression_1.allPaths = allPaths_1;\r\n        }\r\n        return resultExpression_1;\r\n    }\r\n    var resultExpression = function (path, basename, hasSibling) {\r\n        var name = undefined;\r\n        for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {\r\n            // Pattern matches path\r\n            var parsedPattern = parsedPatterns[i];\r\n            if (parsedPattern.requiresSiblings && hasSibling) {\r\n                if (!basename) {\r\n                    basename = paths.basename(path);\r\n                }\r\n                if (!name) {\r\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\r\n                }\r\n            }\r\n            var result = parsedPattern(path, basename, name, hasSibling);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });\r\n    if (withBasenames) {\r\n        resultExpression.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);\r\n    if (allPaths.length) {\r\n        resultExpression.allPaths = allPaths;\r\n    }\r\n    return resultExpression;\r\n}\r\nfunction parseExpressionPattern(pattern, value, options) {\r\n    if (value === false) {\r\n        return NULL; // pattern is disabled\r\n    }\r\n    var parsedPattern = parsePattern(pattern, options);\r\n    if (parsedPattern === NULL) {\r\n        return NULL;\r\n    }\r\n    // Expression Pattern is <boolean>\r\n    if (typeof value === 'boolean') {\r\n        return parsedPattern;\r\n    }\r\n    // Expression Pattern is <SiblingClause>\r\n    if (value) {\r\n        var when_1 = value.when;\r\n        if (typeof when_1 === 'string') {\r\n            var result = function (path, basename, name, hasSibling) {\r\n                if (!hasSibling || !parsedPattern(path, basename)) {\r\n                    return null;\r\n                }\r\n                var clausePattern = when_1.replace('$(basename)', name);\r\n                var matched = hasSibling(clausePattern);\r\n                return isThenable(matched) ?\r\n                    matched.then(function (m) { return m ? pattern : null; }) :\r\n                    matched ? pattern : null;\r\n            };\r\n            result.requiresSiblings = true;\r\n            return result;\r\n        }\r\n    }\r\n    // Expression is Anything\r\n    return parsedPattern;\r\n}\r\nfunction aggregateBasenameMatches(parsedPatterns, result) {\r\n    var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });\r\n    if (basenamePatterns.length < 2) {\r\n        return parsedPatterns;\r\n    }\r\n    var basenames = basenamePatterns.reduce(function (all, current) {\r\n        var basenames = current.basenames;\r\n        return basenames ? all.concat(basenames) : all;\r\n    }, []);\r\n    var patterns;\r\n    if (result) {\r\n        patterns = [];\r\n        for (var i = 0, n = basenames.length; i < n; i++) {\r\n            patterns.push(result);\r\n        }\r\n    }\r\n    else {\r\n        patterns = basenamePatterns.reduce(function (all, current) {\r\n            var patterns = current.patterns;\r\n            return patterns ? all.concat(patterns) : all;\r\n        }, []);\r\n    }\r\n    var aggregate = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (!basename) {\r\n            var i = void 0;\r\n            for (i = path.length; i > 0; i--) {\r\n                var ch = path.charCodeAt(i - 1);\r\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\r\n                    break;\r\n                }\r\n            }\r\n            basename = path.substr(i);\r\n        }\r\n        var index = basenames.indexOf(basename);\r\n        return index !== -1 ? patterns[index] : null;\r\n    };\r\n    aggregate.basenames = basenames;\r\n    aggregate.patterns = patterns;\r\n    aggregate.allBasenames = basenames;\r\n    var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });\r\n    aggregatedPatterns.push(aggregate);\r\n    return aggregatedPatterns;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}