{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position, CompletionItemKind, Range, TextEdit, InsertTextFormat, MarkupKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { ScannerState, TokenType } from '../htmlLanguageTypes.js';\nimport { entities } from '../parser/htmlEntities.js';\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { isLetterOrDigit, endsWith, startsWith } from '../utils/strings.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nimport { isDefined } from '../utils/object.js';\nimport { generateDocumentation } from '../languageFacts/dataProvider.js';\nvar localize = nls.loadMessageBundle();\nvar HTMLCompletion = /** @class */function () {\n  function HTMLCompletion(clientCapabilities) {\n    this.clientCapabilities = clientCapabilities;\n    this.completionParticipants = [];\n  }\n  HTMLCompletion.prototype.setCompletionParticipants = function (registeredCompletionParticipants) {\n    this.completionParticipants = registeredCompletionParticipants || [];\n  };\n  HTMLCompletion.prototype.doComplete = function (document, position, htmlDocument, settings) {\n    var result = this._doComplete(document, position, htmlDocument, settings);\n    return this.convertCompletionList(result);\n  };\n  HTMLCompletion.prototype._doComplete = function (document, position, htmlDocument, settings) {\n    var result = {\n      isIncomplete: false,\n      items: []\n    };\n    var completionParticipants = this.completionParticipants;\n    var dataProviders = getAllDataProviders().filter(function (p) {\n      return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false);\n    });\n    var doesSupportMarkdown = this.doesSupportMarkdown();\n    var text = document.getText();\n    var offset = document.offsetAt(position);\n    var node = htmlDocument.findNodeBefore(offset);\n    if (!node) {\n      return result;\n    }\n    var scanner = createScanner(text, node.start);\n    var currentTag = '';\n    var currentAttributeName;\n    function getReplaceRange(replaceStart, replaceEnd) {\n      if (replaceEnd === void 0) {\n        replaceEnd = offset;\n      }\n      if (replaceStart > offset) {\n        replaceStart = offset;\n      }\n      return {\n        start: document.positionAt(replaceStart),\n        end: document.positionAt(replaceEnd)\n      };\n    }\n    function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {\n      var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n      dataProviders.forEach(function (provider) {\n        provider.provideTags().forEach(function (tag) {\n          result.items.push({\n            label: tag.name,\n            kind: CompletionItemKind.Property,\n            documentation: generateDocumentation(tag, doesSupportMarkdown),\n            textEdit: TextEdit.replace(range, tag.name),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      return result;\n    }\n    function getLineIndent(offset) {\n      var start = offset;\n      while (start > 0) {\n        var ch = text.charAt(start - 1);\n        if (\"\\n\\r\".indexOf(ch) >= 0) {\n          return text.substring(start, offset);\n        }\n        if (!isWhiteSpace(ch)) {\n          return null;\n        }\n        start--;\n      }\n      return text.substring(0, offset);\n    }\n    function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd) {\n      if (tagNameEnd === void 0) {\n        tagNameEnd = offset;\n      }\n      var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n      var closeTag = isFollowedBy(text, tagNameEnd, ScannerState.WithinEndTag, TokenType.EndTagClose) ? '' : '>';\n      var curr = node;\n      if (inOpenTag) {\n        curr = curr.parent; // don't suggest the own tag, it's not yet open\n      }\n\n      while (curr) {\n        var tag = curr.tag;\n        if (tag && (!curr.closed || curr.endTagStart && curr.endTagStart > offset)) {\n          var item = {\n            label: '/' + tag,\n            kind: CompletionItemKind.Property,\n            filterText: '/' + tag,\n            textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n            insertTextFormat: InsertTextFormat.PlainText\n          };\n          var startIndent = getLineIndent(curr.start);\n          var endIndent = getLineIndent(afterOpenBracket - 1);\n          if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {\n            var insertText = startIndent + '</' + tag + closeTag;\n            item.textEdit = TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);\n            item.filterText = endIndent + '</' + tag;\n          }\n          result.items.push(item);\n          return result;\n        }\n        curr = curr.parent;\n      }\n      if (inOpenTag) {\n        return result;\n      }\n      dataProviders.forEach(function (provider) {\n        provider.provideTags().forEach(function (tag) {\n          result.items.push({\n            label: '/' + tag.name,\n            kind: CompletionItemKind.Property,\n            documentation: generateDocumentation(tag, doesSupportMarkdown),\n            filterText: '/' + tag + closeTag,\n            textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      return result;\n    }\n    function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {\n      if (settings && settings.hideAutoCompleteProposals) {\n        return result;\n      }\n      if (!isVoidElement(tag)) {\n        var pos = document.positionAt(tagCloseEnd);\n        result.items.push({\n          label: '</' + tag + '>',\n          kind: CompletionItemKind.Property,\n          filterText: '</' + tag + '>',\n          textEdit: TextEdit.insert(pos, '$0</' + tag + '>'),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n      }\n      return result;\n    }\n    function collectTagSuggestions(tagStart, tagEnd) {\n      collectOpenTagSuggestions(tagStart, tagEnd);\n      collectCloseTagSuggestions(tagStart, true, tagEnd);\n      return result;\n    }\n    function collectAttributeNameSuggestions(nameStart, nameEnd) {\n      if (nameEnd === void 0) {\n        nameEnd = offset;\n      }\n      var replaceEnd = offset;\n      while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {\n        // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.\n        replaceEnd++;\n      }\n      var range = getReplaceRange(nameStart, replaceEnd);\n      var value = isFollowedBy(text, nameEnd, ScannerState.AfterAttributeName, TokenType.DelimiterAssign) ? '' : '=\"$1\"';\n      var tag = currentTag.toLowerCase();\n      var seenAttributes = Object.create(null);\n      dataProviders.forEach(function (provider) {\n        provider.provideAttributes(tag).forEach(function (attr) {\n          if (seenAttributes[attr.name]) {\n            return;\n          }\n          seenAttributes[attr.name] = true;\n          var codeSnippet = attr.name;\n          var command;\n          if (attr.valueSet !== 'v' && value.length) {\n            codeSnippet = codeSnippet + value;\n            if (attr.valueSet || attr.name === 'style') {\n              command = {\n                title: 'Suggest',\n                command: 'editor.action.triggerSuggest'\n              };\n            }\n          }\n          result.items.push({\n            label: attr.name,\n            kind: attr.valueSet === 'handler' ? CompletionItemKind.Function : CompletionItemKind.Value,\n            documentation: generateDocumentation(attr, doesSupportMarkdown),\n            textEdit: TextEdit.replace(range, codeSnippet),\n            insertTextFormat: InsertTextFormat.Snippet,\n            command: command\n          });\n        });\n      });\n      collectDataAttributesSuggestions(range, seenAttributes);\n      return result;\n    }\n    function collectDataAttributesSuggestions(range, seenAttributes) {\n      var dataAttr = 'data-';\n      var dataAttributes = {};\n      dataAttributes[dataAttr] = dataAttr + \"$1=\\\"$2\\\"\";\n      function addNodeDataAttributes(node) {\n        node.attributeNames.forEach(function (attr) {\n          if (startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {\n            dataAttributes[attr] = attr + '=\"$1\"';\n          }\n        });\n        node.children.forEach(function (child) {\n          return addNodeDataAttributes(child);\n        });\n      }\n      if (htmlDocument) {\n        htmlDocument.roots.forEach(function (root) {\n          return addNodeDataAttributes(root);\n        });\n      }\n      Object.keys(dataAttributes).forEach(function (attr) {\n        return result.items.push({\n          label: attr,\n          kind: CompletionItemKind.Value,\n          textEdit: TextEdit.replace(range, dataAttributes[attr]),\n          insertTextFormat: InsertTextFormat.Snippet\n        });\n      });\n    }\n    function collectAttributeValueSuggestions(valueStart, valueEnd) {\n      if (valueEnd === void 0) {\n        valueEnd = offset;\n      }\n      var range;\n      var addQuotes;\n      var valuePrefix;\n      if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {\n        // inside quoted attribute\n        var valueContentStart = valueStart + 1;\n        var valueContentEnd = valueEnd;\n        // valueEnd points to the char after quote, which encloses the replace range\n        if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {\n          valueContentEnd--;\n        }\n        var wsBefore = getWordStart(text, offset, valueContentStart);\n        var wsAfter = getWordEnd(text, offset, valueContentEnd);\n        range = getReplaceRange(wsBefore, wsAfter);\n        valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : '';\n        addQuotes = false;\n      } else {\n        range = getReplaceRange(valueStart, valueEnd);\n        valuePrefix = text.substring(valueStart, offset);\n        addQuotes = true;\n      }\n      var tag = currentTag.toLowerCase();\n      var attribute = currentAttributeName.toLowerCase();\n      if (completionParticipants.length > 0) {\n        var fullRange = getReplaceRange(valueStart, valueEnd);\n        for (var _i = 0, completionParticipants_1 = completionParticipants; _i < completionParticipants_1.length; _i++) {\n          var participant = completionParticipants_1[_i];\n          if (participant.onHtmlAttributeValue) {\n            participant.onHtmlAttributeValue({\n              document: document,\n              position: position,\n              tag: tag,\n              attribute: attribute,\n              value: valuePrefix,\n              range: fullRange\n            });\n          }\n        }\n      }\n      dataProviders.forEach(function (provider) {\n        provider.provideValues(tag, attribute).forEach(function (value) {\n          var insertText = addQuotes ? '\"' + value.name + '\"' : value.name;\n          result.items.push({\n            label: value.name,\n            filterText: insertText,\n            kind: CompletionItemKind.Unit,\n            documentation: generateDocumentation(value, doesSupportMarkdown),\n            textEdit: TextEdit.replace(range, insertText),\n            insertTextFormat: InsertTextFormat.PlainText\n          });\n        });\n      });\n      collectCharacterEntityProposals();\n      return result;\n    }\n    function scanNextForEndPos(nextToken) {\n      if (offset === scanner.getTokenEnd()) {\n        token = scanner.scan();\n        if (token === nextToken && scanner.getTokenOffset() === offset) {\n          return scanner.getTokenEnd();\n        }\n      }\n      return offset;\n    }\n    function collectInsideContent() {\n      for (var _i = 0, completionParticipants_2 = completionParticipants; _i < completionParticipants_2.length; _i++) {\n        var participant = completionParticipants_2[_i];\n        if (participant.onHtmlContent) {\n          participant.onHtmlContent({\n            document: document,\n            position: position\n          });\n        }\n      }\n      return collectCharacterEntityProposals();\n    }\n    function collectCharacterEntityProposals() {\n      // character entities\n      var k = offset - 1;\n      var characterStart = position.character;\n      while (k >= 0 && isLetterOrDigit(text, k)) {\n        k--;\n        characterStart--;\n      }\n      if (k >= 0 && text[k] === '&') {\n        var range = Range.create(Position.create(position.line, characterStart - 1), position);\n        for (var entity in entities) {\n          if (endsWith(entity, ';')) {\n            var label = '&' + entity;\n            result.items.push({\n              label: label,\n              kind: CompletionItemKind.Keyword,\n              documentation: localize('entity.propose', \"Character entity representing '\" + entities[entity] + \"'\"),\n              textEdit: TextEdit.replace(range, label),\n              insertTextFormat: InsertTextFormat.PlainText\n            });\n          }\n        }\n      }\n      return result;\n    }\n    function suggestDoctype(replaceStart, replaceEnd) {\n      var range = getReplaceRange(replaceStart, replaceEnd);\n      result.items.push({\n        label: '!DOCTYPE',\n        kind: CompletionItemKind.Property,\n        documentation: 'A preamble for an HTML document.',\n        textEdit: TextEdit.replace(range, '!DOCTYPE html>'),\n        insertTextFormat: InsertTextFormat.PlainText\n      });\n    }\n    var token = scanner.scan();\n    while (token !== TokenType.EOS && scanner.getTokenOffset() <= offset) {\n      switch (token) {\n        case TokenType.StartTagOpen:\n          if (scanner.getTokenEnd() === offset) {\n            var endPos = scanNextForEndPos(TokenType.StartTag);\n            if (position.line === 0) {\n              suggestDoctype(offset, endPos);\n            }\n            return collectTagSuggestions(offset, endPos);\n          }\n          break;\n        case TokenType.StartTag:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n          currentTag = scanner.getTokenText();\n          break;\n        case TokenType.AttributeName:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n          currentAttributeName = scanner.getTokenText();\n          break;\n        case TokenType.DelimiterAssign:\n          if (scanner.getTokenEnd() === offset) {\n            var endPos = scanNextForEndPos(TokenType.AttributeValue);\n            return collectAttributeValueSuggestions(offset, endPos);\n          }\n          break;\n        case TokenType.AttributeValue:\n          if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n            return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n          }\n          break;\n        case TokenType.Whitespace:\n          if (offset <= scanner.getTokenEnd()) {\n            switch (scanner.getScannerState()) {\n              case ScannerState.AfterOpeningStartTag:\n                var startPos = scanner.getTokenOffset();\n                var endTagPos = scanNextForEndPos(TokenType.StartTag);\n                return collectTagSuggestions(startPos, endTagPos);\n              case ScannerState.WithinTag:\n              case ScannerState.AfterAttributeName:\n                return collectAttributeNameSuggestions(scanner.getTokenEnd());\n              case ScannerState.BeforeAttributeValue:\n                return collectAttributeValueSuggestions(scanner.getTokenEnd());\n              case ScannerState.AfterOpeningEndTag:\n                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);\n              case ScannerState.WithinContent:\n                return collectInsideContent();\n            }\n          }\n          break;\n        case TokenType.EndTagOpen:\n          if (offset <= scanner.getTokenEnd()) {\n            var afterOpenBracket = scanner.getTokenOffset() + 1;\n            var endOffset = scanNextForEndPos(TokenType.EndTag);\n            return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);\n          }\n          break;\n        case TokenType.EndTag:\n          if (offset <= scanner.getTokenEnd()) {\n            var start = scanner.getTokenOffset() - 1;\n            while (start >= 0) {\n              var ch = text.charAt(start);\n              if (ch === '/') {\n                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());\n              } else if (!isWhiteSpace(ch)) {\n                break;\n              }\n              start--;\n            }\n          }\n          break;\n        case TokenType.StartTagClose:\n          if (offset <= scanner.getTokenEnd()) {\n            if (currentTag) {\n              return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);\n            }\n          }\n          break;\n        case TokenType.Content:\n          if (offset <= scanner.getTokenEnd()) {\n            return collectInsideContent();\n          }\n          break;\n        default:\n          if (offset <= scanner.getTokenEnd()) {\n            return result;\n          }\n          break;\n      }\n      token = scanner.scan();\n    }\n    return result;\n  };\n  HTMLCompletion.prototype.doTagComplete = function (document, position, htmlDocument) {\n    var offset = document.offsetAt(position);\n    if (offset <= 0) {\n      return null;\n    }\n    var char = document.getText().charAt(offset - 1);\n    if (char === '>') {\n      var node = htmlDocument.findNodeBefore(offset);\n      if (node && node.tag && !isVoidElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {\n        var scanner = createScanner(document.getText(), node.start);\n        var token = scanner.scan();\n        while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n          if (token === TokenType.StartTagClose && scanner.getTokenEnd() === offset) {\n            return \"$0</\" + node.tag + \">\";\n          }\n          token = scanner.scan();\n        }\n      }\n    } else if (char === '/') {\n      var node = htmlDocument.findNodeBefore(offset);\n      while (node && node.closed) {\n        node = node.parent;\n      }\n      if (node && node.tag) {\n        var scanner = createScanner(document.getText(), node.start);\n        var token = scanner.scan();\n        while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n          if (token === TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {\n            return node.tag + \">\";\n          }\n          token = scanner.scan();\n        }\n      }\n    }\n    return null;\n  };\n  HTMLCompletion.prototype.convertCompletionList = function (list) {\n    if (!this.doesSupportMarkdown()) {\n      list.items.forEach(function (item) {\n        if (item.documentation && typeof item.documentation !== 'string') {\n          item.documentation = {\n            kind: 'plaintext',\n            value: item.documentation.value\n          };\n        }\n      });\n    }\n    return list;\n  };\n  HTMLCompletion.prototype.doesSupportMarkdown = function () {\n    if (!isDefined(this.supportsMarkdown)) {\n      if (!isDefined(this.clientCapabilities)) {\n        this.supportsMarkdown = true;\n        return this.supportsMarkdown;\n      }\n      var hover = this.clientCapabilities && this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;\n      this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;\n    }\n    return this.supportsMarkdown;\n  };\n  return HTMLCompletion;\n}();\nexport { HTMLCompletion };\nfunction isQuote(s) {\n  return /^[\"']*$/.test(s);\n}\nfunction isWhiteSpace(s) {\n  return /^\\s*$/.test(s);\n}\nfunction isFollowedBy(s, offset, intialState, expectedToken) {\n  var scanner = createScanner(s, offset, intialState);\n  var token = scanner.scan();\n  while (token === TokenType.Whitespace) {\n    token = scanner.scan();\n  }\n  return token === expectedToken;\n}\nfunction getWordStart(s, offset, limit) {\n  while (offset > limit && !isWhiteSpace(s[offset - 1])) {\n    offset--;\n  }\n  return offset;\n}\nfunction getWordEnd(s, offset, limit) {\n  while (offset < limit && !isWhiteSpace(s[offset])) {\n    offset++;\n  }\n  return offset;\n}","map":{"version":3,"names":["Position","CompletionItemKind","Range","TextEdit","InsertTextFormat","MarkupKind","createScanner","ScannerState","TokenType","entities","nls","isLetterOrDigit","endsWith","startsWith","getAllDataProviders","isVoidElement","isDefined","generateDocumentation","localize","loadMessageBundle","HTMLCompletion","clientCapabilities","completionParticipants","prototype","setCompletionParticipants","registeredCompletionParticipants","doComplete","document","position","htmlDocument","settings","result","_doComplete","convertCompletionList","isIncomplete","items","dataProviders","filter","p","isApplicable","languageId","getId","doesSupportMarkdown","text","getText","offset","offsetAt","node","findNodeBefore","scanner","start","currentTag","currentAttributeName","getReplaceRange","replaceStart","replaceEnd","positionAt","end","collectOpenTagSuggestions","afterOpenBracket","tagNameEnd","range","forEach","provider","provideTags","tag","push","label","name","kind","Property","documentation","textEdit","replace","insertTextFormat","PlainText","getLineIndent","ch","charAt","indexOf","substring","isWhiteSpace","collectCloseTagSuggestions","inOpenTag","closeTag","isFollowedBy","WithinEndTag","EndTagClose","curr","parent","closed","endTagStart","item","filterText","startIndent","endIndent","insertText","length","collectAutoCloseTagSuggestion","tagCloseEnd","hideAutoCompleteProposals","pos","insert","Snippet","collectTagSuggestions","tagStart","tagEnd","collectAttributeNameSuggestions","nameStart","nameEnd","value","AfterAttributeName","DelimiterAssign","toLowerCase","seenAttributes","Object","create","provideAttributes","attr","codeSnippet","command","valueSet","title","Function","Value","collectDataAttributesSuggestions","dataAttr","dataAttributes","addNodeDataAttributes","attributeNames","children","child","roots","root","keys","collectAttributeValueSuggestions","valueStart","valueEnd","addQuotes","valuePrefix","isQuote","valueContentStart","valueContentEnd","wsBefore","getWordStart","wsAfter","getWordEnd","attribute","fullRange","_i","completionParticipants_1","participant","onHtmlAttributeValue","provideValues","Unit","collectCharacterEntityProposals","scanNextForEndPos","nextToken","getTokenEnd","token","scan","getTokenOffset","collectInsideContent","completionParticipants_2","onHtmlContent","k","characterStart","character","line","entity","Keyword","suggestDoctype","EOS","StartTagOpen","endPos","StartTag","getTokenText","AttributeName","AttributeValue","Whitespace","getScannerState","AfterOpeningStartTag","startPos","endTagPos","WithinTag","BeforeAttributeValue","AfterOpeningEndTag","WithinContent","EndTagOpen","endOffset","EndTag","StartTagClose","Content","doTagComplete","char","list","supportsMarkdown","hover","textDocument","contentFormat","Array","isArray","Markdown","s","test","intialState","expectedToken","limit"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlCompletion.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position, CompletionItemKind, Range, TextEdit, InsertTextFormat, MarkupKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { ScannerState, TokenType } from '../htmlLanguageTypes.js';\nimport { entities } from '../parser/htmlEntities.js';\nimport * as nls from './../../../fillers/vscode-nls.js';\nimport { isLetterOrDigit, endsWith, startsWith } from '../utils/strings.js';\nimport { getAllDataProviders } from '../languageFacts/builtinDataProviders.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nimport { isDefined } from '../utils/object.js';\nimport { generateDocumentation } from '../languageFacts/dataProvider.js';\nvar localize = nls.loadMessageBundle();\nvar HTMLCompletion = /** @class */ (function () {\n    function HTMLCompletion(clientCapabilities) {\n        this.clientCapabilities = clientCapabilities;\n        this.completionParticipants = [];\n    }\n    HTMLCompletion.prototype.setCompletionParticipants = function (registeredCompletionParticipants) {\n        this.completionParticipants = registeredCompletionParticipants || [];\n    };\n    HTMLCompletion.prototype.doComplete = function (document, position, htmlDocument, settings) {\n        var result = this._doComplete(document, position, htmlDocument, settings);\n        return this.convertCompletionList(result);\n    };\n    HTMLCompletion.prototype._doComplete = function (document, position, htmlDocument, settings) {\n        var result = {\n            isIncomplete: false,\n            items: []\n        };\n        var completionParticipants = this.completionParticipants;\n        var dataProviders = getAllDataProviders().filter(function (p) { return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false); });\n        var doesSupportMarkdown = this.doesSupportMarkdown();\n        var text = document.getText();\n        var offset = document.offsetAt(position);\n        var node = htmlDocument.findNodeBefore(offset);\n        if (!node) {\n            return result;\n        }\n        var scanner = createScanner(text, node.start);\n        var currentTag = '';\n        var currentAttributeName;\n        function getReplaceRange(replaceStart, replaceEnd) {\n            if (replaceEnd === void 0) { replaceEnd = offset; }\n            if (replaceStart > offset) {\n                replaceStart = offset;\n            }\n            return { start: document.positionAt(replaceStart), end: document.positionAt(replaceEnd) };\n        }\n        function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {\n            var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n            dataProviders.forEach(function (provider) {\n                provider.provideTags().forEach(function (tag) {\n                    result.items.push({\n                        label: tag.name,\n                        kind: CompletionItemKind.Property,\n                        documentation: generateDocumentation(tag, doesSupportMarkdown),\n                        textEdit: TextEdit.replace(range, tag.name),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    });\n                });\n            });\n            return result;\n        }\n        function getLineIndent(offset) {\n            var start = offset;\n            while (start > 0) {\n                var ch = text.charAt(start - 1);\n                if (\"\\n\\r\".indexOf(ch) >= 0) {\n                    return text.substring(start, offset);\n                }\n                if (!isWhiteSpace(ch)) {\n                    return null;\n                }\n                start--;\n            }\n            return text.substring(0, offset);\n        }\n        function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd) {\n            if (tagNameEnd === void 0) { tagNameEnd = offset; }\n            var range = getReplaceRange(afterOpenBracket, tagNameEnd);\n            var closeTag = isFollowedBy(text, tagNameEnd, ScannerState.WithinEndTag, TokenType.EndTagClose) ? '' : '>';\n            var curr = node;\n            if (inOpenTag) {\n                curr = curr.parent; // don't suggest the own tag, it's not yet open\n            }\n            while (curr) {\n                var tag = curr.tag;\n                if (tag && (!curr.closed || curr.endTagStart && (curr.endTagStart > offset))) {\n                    var item = {\n                        label: '/' + tag,\n                        kind: CompletionItemKind.Property,\n                        filterText: '/' + tag,\n                        textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    };\n                    var startIndent = getLineIndent(curr.start);\n                    var endIndent = getLineIndent(afterOpenBracket - 1);\n                    if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {\n                        var insertText = startIndent + '</' + tag + closeTag;\n                        item.textEdit = TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);\n                        item.filterText = endIndent + '</' + tag;\n                    }\n                    result.items.push(item);\n                    return result;\n                }\n                curr = curr.parent;\n            }\n            if (inOpenTag) {\n                return result;\n            }\n            dataProviders.forEach(function (provider) {\n                provider.provideTags().forEach(function (tag) {\n                    result.items.push({\n                        label: '/' + tag.name,\n                        kind: CompletionItemKind.Property,\n                        documentation: generateDocumentation(tag, doesSupportMarkdown),\n                        filterText: '/' + tag + closeTag,\n                        textEdit: TextEdit.replace(range, '/' + tag + closeTag),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    });\n                });\n            });\n            return result;\n        }\n        function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {\n            if (settings && settings.hideAutoCompleteProposals) {\n                return result;\n            }\n            if (!isVoidElement(tag)) {\n                var pos = document.positionAt(tagCloseEnd);\n                result.items.push({\n                    label: '</' + tag + '>',\n                    kind: CompletionItemKind.Property,\n                    filterText: '</' + tag + '>',\n                    textEdit: TextEdit.insert(pos, '$0</' + tag + '>'),\n                    insertTextFormat: InsertTextFormat.Snippet\n                });\n            }\n            return result;\n        }\n        function collectTagSuggestions(tagStart, tagEnd) {\n            collectOpenTagSuggestions(tagStart, tagEnd);\n            collectCloseTagSuggestions(tagStart, true, tagEnd);\n            return result;\n        }\n        function collectAttributeNameSuggestions(nameStart, nameEnd) {\n            if (nameEnd === void 0) { nameEnd = offset; }\n            var replaceEnd = offset;\n            while (replaceEnd < nameEnd && text[replaceEnd] !== '<') { // < is a valid attribute name character, but we rather assume the attribute name ends. See #23236.\n                replaceEnd++;\n            }\n            var range = getReplaceRange(nameStart, replaceEnd);\n            var value = isFollowedBy(text, nameEnd, ScannerState.AfterAttributeName, TokenType.DelimiterAssign) ? '' : '=\"$1\"';\n            var tag = currentTag.toLowerCase();\n            var seenAttributes = Object.create(null);\n            dataProviders.forEach(function (provider) {\n                provider.provideAttributes(tag).forEach(function (attr) {\n                    if (seenAttributes[attr.name]) {\n                        return;\n                    }\n                    seenAttributes[attr.name] = true;\n                    var codeSnippet = attr.name;\n                    var command;\n                    if (attr.valueSet !== 'v' && value.length) {\n                        codeSnippet = codeSnippet + value;\n                        if (attr.valueSet || attr.name === 'style') {\n                            command = {\n                                title: 'Suggest',\n                                command: 'editor.action.triggerSuggest'\n                            };\n                        }\n                    }\n                    result.items.push({\n                        label: attr.name,\n                        kind: attr.valueSet === 'handler' ? CompletionItemKind.Function : CompletionItemKind.Value,\n                        documentation: generateDocumentation(attr, doesSupportMarkdown),\n                        textEdit: TextEdit.replace(range, codeSnippet),\n                        insertTextFormat: InsertTextFormat.Snippet,\n                        command: command\n                    });\n                });\n            });\n            collectDataAttributesSuggestions(range, seenAttributes);\n            return result;\n        }\n        function collectDataAttributesSuggestions(range, seenAttributes) {\n            var dataAttr = 'data-';\n            var dataAttributes = {};\n            dataAttributes[dataAttr] = dataAttr + \"$1=\\\"$2\\\"\";\n            function addNodeDataAttributes(node) {\n                node.attributeNames.forEach(function (attr) {\n                    if (startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {\n                        dataAttributes[attr] = attr + '=\"$1\"';\n                    }\n                });\n                node.children.forEach(function (child) { return addNodeDataAttributes(child); });\n            }\n            if (htmlDocument) {\n                htmlDocument.roots.forEach(function (root) { return addNodeDataAttributes(root); });\n            }\n            Object.keys(dataAttributes).forEach(function (attr) { return result.items.push({\n                label: attr,\n                kind: CompletionItemKind.Value,\n                textEdit: TextEdit.replace(range, dataAttributes[attr]),\n                insertTextFormat: InsertTextFormat.Snippet\n            }); });\n        }\n        function collectAttributeValueSuggestions(valueStart, valueEnd) {\n            if (valueEnd === void 0) { valueEnd = offset; }\n            var range;\n            var addQuotes;\n            var valuePrefix;\n            if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {\n                // inside quoted attribute\n                var valueContentStart = valueStart + 1;\n                var valueContentEnd = valueEnd;\n                // valueEnd points to the char after quote, which encloses the replace range\n                if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {\n                    valueContentEnd--;\n                }\n                var wsBefore = getWordStart(text, offset, valueContentStart);\n                var wsAfter = getWordEnd(text, offset, valueContentEnd);\n                range = getReplaceRange(wsBefore, wsAfter);\n                valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : '';\n                addQuotes = false;\n            }\n            else {\n                range = getReplaceRange(valueStart, valueEnd);\n                valuePrefix = text.substring(valueStart, offset);\n                addQuotes = true;\n            }\n            var tag = currentTag.toLowerCase();\n            var attribute = currentAttributeName.toLowerCase();\n            if (completionParticipants.length > 0) {\n                var fullRange = getReplaceRange(valueStart, valueEnd);\n                for (var _i = 0, completionParticipants_1 = completionParticipants; _i < completionParticipants_1.length; _i++) {\n                    var participant = completionParticipants_1[_i];\n                    if (participant.onHtmlAttributeValue) {\n                        participant.onHtmlAttributeValue({ document: document, position: position, tag: tag, attribute: attribute, value: valuePrefix, range: fullRange });\n                    }\n                }\n            }\n            dataProviders.forEach(function (provider) {\n                provider.provideValues(tag, attribute).forEach(function (value) {\n                    var insertText = addQuotes ? '\"' + value.name + '\"' : value.name;\n                    result.items.push({\n                        label: value.name,\n                        filterText: insertText,\n                        kind: CompletionItemKind.Unit,\n                        documentation: generateDocumentation(value, doesSupportMarkdown),\n                        textEdit: TextEdit.replace(range, insertText),\n                        insertTextFormat: InsertTextFormat.PlainText\n                    });\n                });\n            });\n            collectCharacterEntityProposals();\n            return result;\n        }\n        function scanNextForEndPos(nextToken) {\n            if (offset === scanner.getTokenEnd()) {\n                token = scanner.scan();\n                if (token === nextToken && scanner.getTokenOffset() === offset) {\n                    return scanner.getTokenEnd();\n                }\n            }\n            return offset;\n        }\n        function collectInsideContent() {\n            for (var _i = 0, completionParticipants_2 = completionParticipants; _i < completionParticipants_2.length; _i++) {\n                var participant = completionParticipants_2[_i];\n                if (participant.onHtmlContent) {\n                    participant.onHtmlContent({ document: document, position: position });\n                }\n            }\n            return collectCharacterEntityProposals();\n        }\n        function collectCharacterEntityProposals() {\n            // character entities\n            var k = offset - 1;\n            var characterStart = position.character;\n            while (k >= 0 && isLetterOrDigit(text, k)) {\n                k--;\n                characterStart--;\n            }\n            if (k >= 0 && text[k] === '&') {\n                var range = Range.create(Position.create(position.line, characterStart - 1), position);\n                for (var entity in entities) {\n                    if (endsWith(entity, ';')) {\n                        var label = '&' + entity;\n                        result.items.push({\n                            label: label,\n                            kind: CompletionItemKind.Keyword,\n                            documentation: localize('entity.propose', \"Character entity representing '\" + entities[entity] + \"'\"),\n                            textEdit: TextEdit.replace(range, label),\n                            insertTextFormat: InsertTextFormat.PlainText\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n        function suggestDoctype(replaceStart, replaceEnd) {\n            var range = getReplaceRange(replaceStart, replaceEnd);\n            result.items.push({\n                label: '!DOCTYPE',\n                kind: CompletionItemKind.Property,\n                documentation: 'A preamble for an HTML document.',\n                textEdit: TextEdit.replace(range, '!DOCTYPE html>'),\n                insertTextFormat: InsertTextFormat.PlainText\n            });\n        }\n        var token = scanner.scan();\n        while (token !== TokenType.EOS && scanner.getTokenOffset() <= offset) {\n            switch (token) {\n                case TokenType.StartTagOpen:\n                    if (scanner.getTokenEnd() === offset) {\n                        var endPos = scanNextForEndPos(TokenType.StartTag);\n                        if (position.line === 0) {\n                            suggestDoctype(offset, endPos);\n                        }\n                        return collectTagSuggestions(offset, endPos);\n                    }\n                    break;\n                case TokenType.StartTag:\n                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n                        return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n                    }\n                    currentTag = scanner.getTokenText();\n                    break;\n                case TokenType.AttributeName:\n                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n                        return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n                    }\n                    currentAttributeName = scanner.getTokenText();\n                    break;\n                case TokenType.DelimiterAssign:\n                    if (scanner.getTokenEnd() === offset) {\n                        var endPos = scanNextForEndPos(TokenType.AttributeValue);\n                        return collectAttributeValueSuggestions(offset, endPos);\n                    }\n                    break;\n                case TokenType.AttributeValue:\n                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {\n                        return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());\n                    }\n                    break;\n                case TokenType.Whitespace:\n                    if (offset <= scanner.getTokenEnd()) {\n                        switch (scanner.getScannerState()) {\n                            case ScannerState.AfterOpeningStartTag:\n                                var startPos = scanner.getTokenOffset();\n                                var endTagPos = scanNextForEndPos(TokenType.StartTag);\n                                return collectTagSuggestions(startPos, endTagPos);\n                            case ScannerState.WithinTag:\n                            case ScannerState.AfterAttributeName:\n                                return collectAttributeNameSuggestions(scanner.getTokenEnd());\n                            case ScannerState.BeforeAttributeValue:\n                                return collectAttributeValueSuggestions(scanner.getTokenEnd());\n                            case ScannerState.AfterOpeningEndTag:\n                                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);\n                            case ScannerState.WithinContent:\n                                return collectInsideContent();\n                        }\n                    }\n                    break;\n                case TokenType.EndTagOpen:\n                    if (offset <= scanner.getTokenEnd()) {\n                        var afterOpenBracket = scanner.getTokenOffset() + 1;\n                        var endOffset = scanNextForEndPos(TokenType.EndTag);\n                        return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);\n                    }\n                    break;\n                case TokenType.EndTag:\n                    if (offset <= scanner.getTokenEnd()) {\n                        var start = scanner.getTokenOffset() - 1;\n                        while (start >= 0) {\n                            var ch = text.charAt(start);\n                            if (ch === '/') {\n                                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());\n                            }\n                            else if (!isWhiteSpace(ch)) {\n                                break;\n                            }\n                            start--;\n                        }\n                    }\n                    break;\n                case TokenType.StartTagClose:\n                    if (offset <= scanner.getTokenEnd()) {\n                        if (currentTag) {\n                            return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);\n                        }\n                    }\n                    break;\n                case TokenType.Content:\n                    if (offset <= scanner.getTokenEnd()) {\n                        return collectInsideContent();\n                    }\n                    break;\n                default:\n                    if (offset <= scanner.getTokenEnd()) {\n                        return result;\n                    }\n                    break;\n            }\n            token = scanner.scan();\n        }\n        return result;\n    };\n    HTMLCompletion.prototype.doTagComplete = function (document, position, htmlDocument) {\n        var offset = document.offsetAt(position);\n        if (offset <= 0) {\n            return null;\n        }\n        var char = document.getText().charAt(offset - 1);\n        if (char === '>') {\n            var node = htmlDocument.findNodeBefore(offset);\n            if (node && node.tag && !isVoidElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {\n                var scanner = createScanner(document.getText(), node.start);\n                var token = scanner.scan();\n                while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n                    if (token === TokenType.StartTagClose && scanner.getTokenEnd() === offset) {\n                        return \"$0</\" + node.tag + \">\";\n                    }\n                    token = scanner.scan();\n                }\n            }\n        }\n        else if (char === '/') {\n            var node = htmlDocument.findNodeBefore(offset);\n            while (node && node.closed) {\n                node = node.parent;\n            }\n            if (node && node.tag) {\n                var scanner = createScanner(document.getText(), node.start);\n                var token = scanner.scan();\n                while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {\n                    if (token === TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {\n                        return node.tag + \">\";\n                    }\n                    token = scanner.scan();\n                }\n            }\n        }\n        return null;\n    };\n    HTMLCompletion.prototype.convertCompletionList = function (list) {\n        if (!this.doesSupportMarkdown()) {\n            list.items.forEach(function (item) {\n                if (item.documentation && typeof item.documentation !== 'string') {\n                    item.documentation = {\n                        kind: 'plaintext',\n                        value: item.documentation.value\n                    };\n                }\n            });\n        }\n        return list;\n    };\n    HTMLCompletion.prototype.doesSupportMarkdown = function () {\n        if (!isDefined(this.supportsMarkdown)) {\n            if (!isDefined(this.clientCapabilities)) {\n                this.supportsMarkdown = true;\n                return this.supportsMarkdown;\n            }\n            var hover = this.clientCapabilities && this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;\n            this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    };\n    return HTMLCompletion;\n}());\nexport { HTMLCompletion };\nfunction isQuote(s) {\n    return /^[\"']*$/.test(s);\n}\nfunction isWhiteSpace(s) {\n    return /^\\s*$/.test(s);\n}\nfunction isFollowedBy(s, offset, intialState, expectedToken) {\n    var scanner = createScanner(s, offset, intialState);\n    var token = scanner.scan();\n    while (token === TokenType.Whitespace) {\n        token = scanner.scan();\n    }\n    return token === expectedToken;\n}\nfunction getWordStart(s, offset, limit) {\n    while (offset > limit && !isWhiteSpace(s[offset - 1])) {\n        offset--;\n    }\n    return offset;\n}\nfunction getWordEnd(s, offset, limit) {\n    while (offset < limit && !isWhiteSpace(s[offset])) {\n        offset++;\n    }\n    return offset;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}