{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRangeKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nfunction limitRanges(ranges, rangeLimit) {\n  ranges = ranges.sort(function (r1, r2) {\n    var diff = r1.startLine - r2.startLine;\n    if (diff === 0) {\n      diff = r1.endLine - r2.endLine;\n    }\n    return diff;\n  });\n  // compute each range's nesting level in 'nestingLevels'.\n  // count the number of ranges for each level in 'nestingLevelCounts'\n  var top = void 0;\n  var previous = [];\n  var nestingLevels = [];\n  var nestingLevelCounts = [];\n  var setNestingLevel = function setNestingLevel(index, level) {\n    nestingLevels[index] = level;\n    if (level < 30) {\n      nestingLevelCounts[level] = (nestingLevelCounts[level] || 0) + 1;\n    }\n  };\n  // compute nesting levels and sanitize\n  for (var i = 0; i < ranges.length; i++) {\n    var entry = ranges[i];\n    if (!top) {\n      top = entry;\n      setNestingLevel(i, 0);\n    } else {\n      if (entry.startLine > top.startLine) {\n        if (entry.endLine <= top.endLine) {\n          previous.push(top);\n          top = entry;\n          setNestingLevel(i, previous.length);\n        } else if (entry.startLine > top.endLine) {\n          do {\n            top = previous.pop();\n          } while (top && entry.startLine > top.endLine);\n          if (top) {\n            previous.push(top);\n          }\n          top = entry;\n          setNestingLevel(i, previous.length);\n        }\n      }\n    }\n  }\n  var entries = 0;\n  var maxLevel = 0;\n  for (var i = 0; i < nestingLevelCounts.length; i++) {\n    var n = nestingLevelCounts[i];\n    if (n) {\n      if (n + entries > rangeLimit) {\n        maxLevel = i;\n        break;\n      }\n      entries += n;\n    }\n  }\n  var result = [];\n  for (var i = 0; i < ranges.length; i++) {\n    var level = nestingLevels[i];\n    if (typeof level === 'number') {\n      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {\n        result.push(ranges[i]);\n      }\n    }\n  }\n  return result;\n}\nexport function getFoldingRanges(document, context) {\n  var scanner = createScanner(document.getText());\n  var token = scanner.scan();\n  var ranges = [];\n  var stack = [];\n  var lastTagName = null;\n  var prevStart = -1;\n  function addRange(range) {\n    ranges.push(range);\n    prevStart = range.startLine;\n  }\n  while (token !== TokenType.EOS) {\n    switch (token) {\n      case TokenType.StartTag:\n        {\n          var tagName = scanner.getTokenText();\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          stack.push({\n            startLine: startLine,\n            tagName: tagName\n          });\n          lastTagName = tagName;\n          break;\n        }\n      case TokenType.EndTag:\n        {\n          lastTagName = scanner.getTokenText();\n          break;\n        }\n      case TokenType.StartTagClose:\n        if (!lastTagName || !isVoidElement(lastTagName)) {\n          break;\n        }\n      // fallthrough\n      case TokenType.EndTagClose:\n      case TokenType.StartTagSelfClose:\n        {\n          var i = stack.length - 1;\n          while (i >= 0 && stack[i].tagName !== lastTagName) {\n            i--;\n          }\n          if (i >= 0) {\n            var stackElement = stack[i];\n            stack.length = i;\n            var line = document.positionAt(scanner.getTokenOffset()).line;\n            var startLine = stackElement.startLine;\n            var endLine = line - 1;\n            if (endLine > startLine && prevStart !== startLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine\n              });\n            }\n          }\n          break;\n        }\n      case TokenType.Comment:\n        {\n          var startLine = document.positionAt(scanner.getTokenOffset()).line;\n          var text = scanner.getTokenText();\n          var m = text.match(/^\\s*#(region\\b)|(endregion\\b)/);\n          if (m) {\n            if (m[1]) {\n              // start pattern match\n              stack.push({\n                startLine: startLine,\n                tagName: ''\n              }); // empty tagName marks region\n            } else {\n              var i = stack.length - 1;\n              while (i >= 0 && stack[i].tagName.length) {\n                i--;\n              }\n              if (i >= 0) {\n                var stackElement = stack[i];\n                stack.length = i;\n                var endLine = startLine;\n                startLine = stackElement.startLine;\n                if (endLine > startLine && prevStart !== startLine) {\n                  addRange({\n                    startLine: startLine,\n                    endLine: endLine,\n                    kind: FoldingRangeKind.Region\n                  });\n                }\n              }\n            }\n          } else {\n            var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n            if (startLine < endLine) {\n              addRange({\n                startLine: startLine,\n                endLine: endLine,\n                kind: FoldingRangeKind.Comment\n              });\n            }\n          }\n          break;\n        }\n    }\n    token = scanner.scan();\n  }\n  var rangeLimit = context && context.rangeLimit || Number.MAX_VALUE;\n  if (ranges.length > rangeLimit) {\n    return limitRanges(ranges, rangeLimit);\n  }\n  return ranges;\n}","map":{"version":3,"names":["FoldingRangeKind","TokenType","createScanner","isVoidElement","limitRanges","ranges","rangeLimit","sort","r1","r2","diff","startLine","endLine","top","previous","nestingLevels","nestingLevelCounts","setNestingLevel","index","level","i","length","entry","push","pop","entries","maxLevel","n","result","getFoldingRanges","document","context","scanner","getText","token","scan","stack","lastTagName","prevStart","addRange","range","EOS","StartTag","tagName","getTokenText","positionAt","getTokenOffset","line","EndTag","StartTagClose","EndTagClose","StartTagSelfClose","stackElement","Comment","text","m","match","kind","Region","getTokenLength","Number","MAX_VALUE"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/language/html/_deps/vscode-html-languageservice/services/htmlFolding.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FoldingRangeKind } from './../_deps/vscode-languageserver-types/main.js';\nimport { TokenType } from '../htmlLanguageTypes.js';\nimport { createScanner } from '../parser/htmlScanner.js';\nimport { isVoidElement } from '../languageFacts/fact.js';\nfunction limitRanges(ranges, rangeLimit) {\n    ranges = ranges.sort(function (r1, r2) {\n        var diff = r1.startLine - r2.startLine;\n        if (diff === 0) {\n            diff = r1.endLine - r2.endLine;\n        }\n        return diff;\n    });\n    // compute each range's nesting level in 'nestingLevels'.\n    // count the number of ranges for each level in 'nestingLevelCounts'\n    var top = void 0;\n    var previous = [];\n    var nestingLevels = [];\n    var nestingLevelCounts = [];\n    var setNestingLevel = function (index, level) {\n        nestingLevels[index] = level;\n        if (level < 30) {\n            nestingLevelCounts[level] = (nestingLevelCounts[level] || 0) + 1;\n        }\n    };\n    // compute nesting levels and sanitize\n    for (var i = 0; i < ranges.length; i++) {\n        var entry = ranges[i];\n        if (!top) {\n            top = entry;\n            setNestingLevel(i, 0);\n        }\n        else {\n            if (entry.startLine > top.startLine) {\n                if (entry.endLine <= top.endLine) {\n                    previous.push(top);\n                    top = entry;\n                    setNestingLevel(i, previous.length);\n                }\n                else if (entry.startLine > top.endLine) {\n                    do {\n                        top = previous.pop();\n                    } while (top && entry.startLine > top.endLine);\n                    if (top) {\n                        previous.push(top);\n                    }\n                    top = entry;\n                    setNestingLevel(i, previous.length);\n                }\n            }\n        }\n    }\n    var entries = 0;\n    var maxLevel = 0;\n    for (var i = 0; i < nestingLevelCounts.length; i++) {\n        var n = nestingLevelCounts[i];\n        if (n) {\n            if (n + entries > rangeLimit) {\n                maxLevel = i;\n                break;\n            }\n            entries += n;\n        }\n    }\n    var result = [];\n    for (var i = 0; i < ranges.length; i++) {\n        var level = nestingLevels[i];\n        if (typeof level === 'number') {\n            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {\n                result.push(ranges[i]);\n            }\n        }\n    }\n    return result;\n}\nexport function getFoldingRanges(document, context) {\n    var scanner = createScanner(document.getText());\n    var token = scanner.scan();\n    var ranges = [];\n    var stack = [];\n    var lastTagName = null;\n    var prevStart = -1;\n    function addRange(range) {\n        ranges.push(range);\n        prevStart = range.startLine;\n    }\n    while (token !== TokenType.EOS) {\n        switch (token) {\n            case TokenType.StartTag: {\n                var tagName = scanner.getTokenText();\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                stack.push({ startLine: startLine, tagName: tagName });\n                lastTagName = tagName;\n                break;\n            }\n            case TokenType.EndTag: {\n                lastTagName = scanner.getTokenText();\n                break;\n            }\n            case TokenType.StartTagClose:\n                if (!lastTagName || !isVoidElement(lastTagName)) {\n                    break;\n                }\n            // fallthrough\n            case TokenType.EndTagClose:\n            case TokenType.StartTagSelfClose: {\n                var i = stack.length - 1;\n                while (i >= 0 && stack[i].tagName !== lastTagName) {\n                    i--;\n                }\n                if (i >= 0) {\n                    var stackElement = stack[i];\n                    stack.length = i;\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    var startLine = stackElement.startLine;\n                    var endLine = line - 1;\n                    if (endLine > startLine && prevStart !== startLine) {\n                        addRange({ startLine: startLine, endLine: endLine });\n                    }\n                }\n                break;\n            }\n            case TokenType.Comment: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var text = scanner.getTokenText();\n                var m = text.match(/^\\s*#(region\\b)|(endregion\\b)/);\n                if (m) {\n                    if (m[1]) { // start pattern match\n                        stack.push({ startLine: startLine, tagName: '' }); // empty tagName marks region\n                    }\n                    else {\n                        var i = stack.length - 1;\n                        while (i >= 0 && stack[i].tagName.length) {\n                            i--;\n                        }\n                        if (i >= 0) {\n                            var stackElement = stack[i];\n                            stack.length = i;\n                            var endLine = startLine;\n                            startLine = stackElement.startLine;\n                            if (endLine > startLine && prevStart !== startLine) {\n                                addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Region });\n                            }\n                        }\n                    }\n                }\n                else {\n                    var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n                    if (startLine < endLine) {\n                        addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Comment });\n                    }\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    var rangeLimit = context && context.rangeLimit || Number.MAX_VALUE;\n    if (ranges.length > rangeLimit) {\n        return limitRanges(ranges, rangeLimit);\n    }\n    return ranges;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}