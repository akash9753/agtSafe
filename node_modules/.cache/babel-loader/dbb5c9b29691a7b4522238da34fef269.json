{"ast":null,"code":"import { ContextKeyOrExpr } from '../../contextkey/common/contextkey.js';\nvar KeybindingResolver = /** @class */function () {\n  function KeybindingResolver(defaultKeybindings, overrides) {\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n    for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\n      var command = defaultKeybindings[i].command;\n      if (command) {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n    for (var i = 0, len = this._keybindings.length; i < len; i++) {\n      var k = this._keybindings[i];\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      }\n      // TODO@chords\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n  KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n    if (defaultKb.command !== command) {\n      return false;\n    }\n    // TODO@chords\n    if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n      return false;\n    }\n    // TODO@chords\n    if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n      return false;\n    }\n    if (when) {\n      if (!defaultKb.when) {\n        return false;\n      }\n      if (!when.equals(defaultKb.when)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\r\n   * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n   */\n  KeybindingResolver.combine = function (defaults, rawOverrides) {\n    defaults = defaults.slice(0);\n    var overrides = [];\n    for (var _i = 0, rawOverrides_1 = rawOverrides; _i < rawOverrides_1.length; _i++) {\n      var override = rawOverrides_1[_i];\n      if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n        overrides.push(override);\n        continue;\n      }\n      var command = override.command.substr(1);\n      // TODO@chords\n      var keypressFirstPart = override.keypressParts[0];\n      var keypressChordPart = override.keypressParts[1];\n      var when = override.when;\n      for (var j = defaults.length - 1; j >= 0; j--) {\n        if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n          defaults.splice(j, 1);\n        }\n      }\n    }\n    return defaults.concat(overrides);\n  };\n  KeybindingResolver.prototype._addKeyPress = function (keypress, item) {\n    var conflicts = this._map.get(keypress);\n    if (typeof conflicts === 'undefined') {\n      // There is no conflict so far\n      this._map.set(keypress, [item]);\n      this._addToLookupMap(item);\n      return;\n    }\n    for (var i = conflicts.length - 1; i >= 0; i--) {\n      var conflict = conflicts[i];\n      if (conflict.command === item.command) {\n        continue;\n      }\n      var conflictIsChord = conflict.keypressParts.length > 1;\n      var itemIsChord = item.keypressParts.length > 1;\n      // TODO@chords\n      if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n        // The conflict only shares the chord start with this command\n        continue;\n      }\n      if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n        // `item` completely overwrites `conflict`\n        // Remove conflict from the lookupMap\n        this._removeFromLookupMap(conflict);\n      }\n    }\n    conflicts.push(item);\n    this._addToLookupMap(item);\n  };\n  KeybindingResolver.prototype._addToLookupMap = function (item) {\n    if (!item.command) {\n      return;\n    }\n    var arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      arr = [item];\n      this._lookupMap.set(item.command, arr);\n    } else {\n      arr.push(item);\n    }\n  };\n  KeybindingResolver.prototype._removeFromLookupMap = function (item) {\n    if (!item.command) {\n      return;\n    }\n    var arr = this._lookupMap.get(item.command);\n    if (typeof arr === 'undefined') {\n      return;\n    }\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === item) {\n        arr.splice(i, 1);\n        return;\n      }\n    }\n  };\n  /**\r\n   * Returns true if it is provable `a` implies `b`.\r\n   */\n  KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {\n    if (!b) {\n      return true;\n    }\n    if (!a) {\n      return false;\n    }\n    return this._implies(a, b);\n  };\n  /**\r\n   * Returns true if it is provable `p` implies `q`.\r\n   */\n  KeybindingResolver._implies = function (p, q) {\n    var notP = p.negate();\n    var terminals = function terminals(node) {\n      if (node instanceof ContextKeyOrExpr) {\n        return node.expr;\n      }\n      return [node];\n    };\n    var expr = terminals(notP).concat(terminals(q));\n    for (var i = 0; i < expr.length; i++) {\n      var a = expr[i];\n      var notA = a.negate();\n      for (var j = i + 1; j < expr.length; j++) {\n        var b = expr[j];\n        if (notA.equals(b)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  KeybindingResolver.prototype.getKeybindings = function () {\n    return this._keybindings;\n  };\n  KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {\n    var items = this._lookupMap.get(commandId);\n    if (typeof items === 'undefined' || items.length === 0) {\n      return null;\n    }\n    return items[items.length - 1];\n  };\n  KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {\n    var lookupMap = null;\n    if (currentChord !== null) {\n      // Fetch all chord bindings for `currentChord`\n      var candidates = this._map.get(currentChord);\n      if (typeof candidates === 'undefined') {\n        // No chords starting with `currentChord`\n        return null;\n      }\n      lookupMap = [];\n      for (var i = 0, len = candidates.length; i < len; i++) {\n        var candidate = candidates[i];\n        // TODO@chords\n        if (candidate.keypressParts[1] === keypress) {\n          lookupMap.push(candidate);\n        }\n      }\n    } else {\n      var candidates = this._map.get(keypress);\n      if (typeof candidates === 'undefined') {\n        // No bindings with `keypress`\n        return null;\n      }\n      lookupMap = candidates;\n    }\n    var result = this._findCommand(context, lookupMap);\n    if (!result) {\n      return null;\n    }\n    // TODO@chords\n    if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n      return {\n        enterChord: true,\n        commandId: null,\n        commandArgs: null,\n        bubble: false\n      };\n    }\n    return {\n      enterChord: false,\n      commandId: result.command,\n      commandArgs: result.commandArgs,\n      bubble: result.bubble\n    };\n  };\n  KeybindingResolver.prototype._findCommand = function (context, matches) {\n    for (var i = matches.length - 1; i >= 0; i--) {\n      var k = matches[i];\n      if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n        continue;\n      }\n      return k;\n    }\n    return null;\n  };\n  KeybindingResolver.contextMatchesRules = function (context, rules) {\n    if (!rules) {\n      return true;\n    }\n    return rules.evaluate(context);\n  };\n  return KeybindingResolver;\n}();\nexport { KeybindingResolver };","map":{"version":3,"names":["ContextKeyOrExpr","KeybindingResolver","defaultKeybindings","overrides","_defaultKeybindings","_defaultBoundCommands","Map","i","len","length","command","set","_map","_lookupMap","_keybindings","combine","k","keypressParts","_addKeyPress","_isTargetedForRemoval","defaultKb","keypressFirstPart","keypressChordPart","when","equals","defaults","rawOverrides","slice","_i","rawOverrides_1","override","charAt","push","substr","j","splice","concat","prototype","keypress","item","conflicts","get","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","arr","a","b","_implies","p","q","notP","negate","terminals","node","expr","notA","getKeybindings","lookupPrimaryKeybinding","commandId","items","resolve","context","currentChord","lookupMap","candidates","candidate","result","_findCommand","enterChord","commandArgs","bubble","matches","contextMatchesRules","rules","evaluate"],"sources":["C:/Users/akash/Desktop/agat project/CLientapp/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"sourcesContent":["import { ContextKeyOrExpr } from '../../contextkey/common/contextkey.js';\r\nvar KeybindingResolver = /** @class */ (function () {\r\n    function KeybindingResolver(defaultKeybindings, overrides) {\r\n        this._defaultKeybindings = defaultKeybindings;\r\n        this._defaultBoundCommands = new Map();\r\n        for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\r\n            var command = defaultKeybindings[i].command;\r\n            if (command) {\r\n                this._defaultBoundCommands.set(command, true);\r\n            }\r\n        }\r\n        this._map = new Map();\r\n        this._lookupMap = new Map();\r\n        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\r\n        for (var i = 0, len = this._keybindings.length; i < len; i++) {\r\n            var k = this._keybindings[i];\r\n            if (k.keypressParts.length === 0) {\r\n                // unbound\r\n                continue;\r\n            }\r\n            // TODO@chords\r\n            this._addKeyPress(k.keypressParts[0], k);\r\n        }\r\n    }\r\n    KeybindingResolver._isTargetedForRemoval = function (defaultKb, keypressFirstPart, keypressChordPart, command, when) {\r\n        if (defaultKb.command !== command) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\r\n            return false;\r\n        }\r\n        if (when) {\r\n            if (!defaultKb.when) {\r\n                return false;\r\n            }\r\n            if (!when.equals(defaultKb.when)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n     */\r\n    KeybindingResolver.combine = function (defaults, rawOverrides) {\r\n        defaults = defaults.slice(0);\r\n        var overrides = [];\r\n        for (var _i = 0, rawOverrides_1 = rawOverrides; _i < rawOverrides_1.length; _i++) {\r\n            var override = rawOverrides_1[_i];\r\n            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\r\n                overrides.push(override);\r\n                continue;\r\n            }\r\n            var command = override.command.substr(1);\r\n            // TODO@chords\r\n            var keypressFirstPart = override.keypressParts[0];\r\n            var keypressChordPart = override.keypressParts[1];\r\n            var when = override.when;\r\n            for (var j = defaults.length - 1; j >= 0; j--) {\r\n                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\r\n                    defaults.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n        return defaults.concat(overrides);\r\n    };\r\n    KeybindingResolver.prototype._addKeyPress = function (keypress, item) {\r\n        var conflicts = this._map.get(keypress);\r\n        if (typeof conflicts === 'undefined') {\r\n            // There is no conflict so far\r\n            this._map.set(keypress, [item]);\r\n            this._addToLookupMap(item);\r\n            return;\r\n        }\r\n        for (var i = conflicts.length - 1; i >= 0; i--) {\r\n            var conflict = conflicts[i];\r\n            if (conflict.command === item.command) {\r\n                continue;\r\n            }\r\n            var conflictIsChord = (conflict.keypressParts.length > 1);\r\n            var itemIsChord = (item.keypressParts.length > 1);\r\n            // TODO@chords\r\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\r\n                // The conflict only shares the chord start with this command\r\n                continue;\r\n            }\r\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\r\n                // `item` completely overwrites `conflict`\r\n                // Remove conflict from the lookupMap\r\n                this._removeFromLookupMap(conflict);\r\n            }\r\n        }\r\n        conflicts.push(item);\r\n        this._addToLookupMap(item);\r\n    };\r\n    KeybindingResolver.prototype._addToLookupMap = function (item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        var arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            arr = [item];\r\n            this._lookupMap.set(item.command, arr);\r\n        }\r\n        else {\r\n            arr.push(item);\r\n        }\r\n    };\r\n    KeybindingResolver.prototype._removeFromLookupMap = function (item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        var arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            return;\r\n        }\r\n        for (var i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === item) {\r\n                arr.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if it is provable `a` implies `b`.\r\n     */\r\n    KeybindingResolver.whenIsEntirelyIncluded = function (a, b) {\r\n        if (!b) {\r\n            return true;\r\n        }\r\n        if (!a) {\r\n            return false;\r\n        }\r\n        return this._implies(a, b);\r\n    };\r\n    /**\r\n     * Returns true if it is provable `p` implies `q`.\r\n     */\r\n    KeybindingResolver._implies = function (p, q) {\r\n        var notP = p.negate();\r\n        var terminals = function (node) {\r\n            if (node instanceof ContextKeyOrExpr) {\r\n                return node.expr;\r\n            }\r\n            return [node];\r\n        };\r\n        var expr = terminals(notP).concat(terminals(q));\r\n        for (var i = 0; i < expr.length; i++) {\r\n            var a = expr[i];\r\n            var notA = a.negate();\r\n            for (var j = i + 1; j < expr.length; j++) {\r\n                var b = expr[j];\r\n                if (notA.equals(b)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    KeybindingResolver.prototype.getKeybindings = function () {\r\n        return this._keybindings;\r\n    };\r\n    KeybindingResolver.prototype.lookupPrimaryKeybinding = function (commandId) {\r\n        var items = this._lookupMap.get(commandId);\r\n        if (typeof items === 'undefined' || items.length === 0) {\r\n            return null;\r\n        }\r\n        return items[items.length - 1];\r\n    };\r\n    KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {\r\n        var lookupMap = null;\r\n        if (currentChord !== null) {\r\n            // Fetch all chord bindings for `currentChord`\r\n            var candidates = this._map.get(currentChord);\r\n            if (typeof candidates === 'undefined') {\r\n                // No chords starting with `currentChord`\r\n                return null;\r\n            }\r\n            lookupMap = [];\r\n            for (var i = 0, len = candidates.length; i < len; i++) {\r\n                var candidate = candidates[i];\r\n                // TODO@chords\r\n                if (candidate.keypressParts[1] === keypress) {\r\n                    lookupMap.push(candidate);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var candidates = this._map.get(keypress);\r\n            if (typeof candidates === 'undefined') {\r\n                // No bindings with `keypress`\r\n                return null;\r\n            }\r\n            lookupMap = candidates;\r\n        }\r\n        var result = this._findCommand(context, lookupMap);\r\n        if (!result) {\r\n            return null;\r\n        }\r\n        // TODO@chords\r\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\r\n            return {\r\n                enterChord: true,\r\n                commandId: null,\r\n                commandArgs: null,\r\n                bubble: false\r\n            };\r\n        }\r\n        return {\r\n            enterChord: false,\r\n            commandId: result.command,\r\n            commandArgs: result.commandArgs,\r\n            bubble: result.bubble\r\n        };\r\n    };\r\n    KeybindingResolver.prototype._findCommand = function (context, matches) {\r\n        for (var i = matches.length - 1; i >= 0; i--) {\r\n            var k = matches[i];\r\n            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\r\n                continue;\r\n            }\r\n            return k;\r\n        }\r\n        return null;\r\n    };\r\n    KeybindingResolver.contextMatchesRules = function (context, rules) {\r\n        if (!rules) {\r\n            return true;\r\n        }\r\n        return rules.evaluate(context);\r\n    };\r\n    return KeybindingResolver;\r\n}());\r\nexport { KeybindingResolver };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}